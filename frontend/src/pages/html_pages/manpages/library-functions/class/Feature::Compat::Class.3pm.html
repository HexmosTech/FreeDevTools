<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>"Feature::Compat::Class" - make "class" syntax available</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libfeature-compat-class-perl">libfeature-compat-class-perl_0.07-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       "Feature::Compat::Class" - make "class" syntax available

</pre><h4><b>SYNOPSIS</b></h4><pre>
          use Feature::Compat::Class;

          class Point {
             field $x :param :reader = 0;
             field $y :param :reader = 0;

             method move_to ($new_x, $new_y) {
                $x = $new_x;
                $y = $new_y;
             }

             method describe {
                say "A point at ($x, $y)";
             }
          }

          Point-&gt;new(x =&gt; 5, y =&gt; 10)-&gt;describe;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module provides the new "class" keyword and related others ("method", "field" and "ADJUST") in a
       forward-compatible way.

       Perl added such syntax at version 5.38.0, which is enabled by

          use feature 'class';

       This syntax was further expanded in 5.40, adding the "__CLASS__" keyword and ":reader" attribute on
       fields.

       On that version of perl or later, this module simply enables the core feature equivalent of using it
       directly. On such perls, this module will install with no non-core dependencies, and requires no C
       compiler.

       On older versions of perl before such syntax is availble in core, it is currently provided instead using
       the Object::Pad module, imported with a special set of options to configure it to only recognise the same
       syntax as the core perl feature, thus ensuring any code using it will still continue to function on that
       newer perl.

       This module is a work-in-progress, because the underlying "feature 'class'" is too. Many of the
       limitations and inabilities listed below are a result of the early-access nature of this branch, and are
       expected to be lifted as work progresses towards a more featureful and complete implementation.

</pre><h4><b>KEYWORDS</b></h4><pre>
       The keywords provided by this module offer a subset of the abilities of those provided by "Object::Pad",
       restricted to specifically only what is commonly supported by the core syntax as well. In general, the
       reader should first consult the documentation for the corresponding "Object::Pad" keyword, but the
       following notes may be of interest:

   <b>class</b>
          class NAME { ... }
          class NAME VERSION { ... }

          class NAME; ...
          class NAME VERSION; ...

       See also "class" in Object::Pad.

       There is no ability to declare any roles with ":does". The legacy subkeywords for these are equally not
       supported.

       The ":repr" attribute is also not supported; the default representation type will always be selected.

       The :strict(params) attribute is not available, but all constructed classes will behave as if the
       attribute had been declared. Every generated constructor will check its parameters for key names left
       unhandled by "ADJUST" blocks, and throw an exception if any remain.

       The following class attributes are supported:

       <u>:isa</u>

          :isa(CLASS)

          :isa(CLASS CLASSVER)

       <u>Since</u> <u>version</u> <u>0.02.</u>

       Declares a superclass that this class extends. At most one superclass is supported.

       If the package providing the superclass does not exist, an attempt is made to load it by code equivalent
       to

          require CLASS ();

       and thus it must either already exist, or be locatable via the usual @INC mechanisms.

       An optional version check can also be supplied; it performs the equivalent of

          BaseClass-&gt;VERSION( $ver )

       Note that "class" blocks <b>do</b> <b>not</b> implicitly enable the "strict" and "warnings" pragmata; either when using
       the core feature or "Object::Pad".  This is to avoid surprises when eventually switching to purely using
       the core perl feature, which will not do that. Remember however that a "use VERSION" of a version "v5.36"
       or above will enable both these pragmata anyway, so that will be sufficient.

   <b>method</b>
          method NAME { ... }
          method NAME;

       See also "method" in Object::Pad.

       Attributes are not supported, other than the usual ones provided by perl itself. Of these, only ":lvalue"
       is particularly useful.

       Lexical methods are not supported.

   <b>field</b>
          field $NAME;
          field @NAME;
          field %NAME;

          field $NAME = EXPR;

          field $NAME :ATTRS... = EXPR;

       See also "field" in Object::Pad.

       Most field attributes are not supported. In particular, rather than using the accessor-generator
       attributes you will have to create accessor methods yourself; such as

          field $var;
          method var { return $var; }
          method set_var ($new_var) { $var = $new_var; }

       <u>Since</u> <u>version</u> <u>0.04</u> fields of any type may take initialising expressions.  Initialiser blocks are not
       supported.

          field $five = 5;

       <u>Since</u> <u>version</u> <u>0.07</u> field initialiser expressions can see earlier fields that have already been declared,
       and use their values:

          field $fullname  :param;
          field $shortname :param = ( split m/ +/, $fullname )[0];

       The following field attributes are supported:

       <u>:param</u>

          field $var :param;

          field $var :param(name)

       <u>Since</u> <u>version</u> <u>0.04.</u>

       Declares that the constructor will take a named parameter to set the value for this field in a new
       instance.

          field $var :param = EXPR;

       Without a defaulting expression, the parameter is mandatory. When combined with a defaulting expression,
       the parameter is optional and the default will only apply if the named parameter was not passed to the
       constructor.

          field $var :param //= EXPR;
          field $var :param ||= EXPR;

       With both the ":param" attribute and a defaulting expression, the operator can also be written as "//="
       or "||=". In this case, the defaulting expression will be used even if the caller passed an undefined
       value (for "//=") or a false value (for "||="). This simplifies many situations where "undef" would not
       be a valid value for a field parameter.

          class C {
             field $timeout :param //= 20;
          }

          C-&gt;new( timeout =&gt; $args{timeout} );
          # default applies if %args has no 'timeout' key, or if its value is undef

       <u>:reader,</u> <u>:reader(NAME)</u>

       <u>Since</u> <u>version</u> <u>0.07.</u>

       Generates a reader method to return the current value of the field. If no name is given, the name of the
       field is used. A single prefix character "_" will be removed if present.

          field $x :reader;

          # equivalent to
          field $x;  method x { return $x }

       These are permitted on an field type, not just scalars. The reader method behaves identically to how a
       lexical variable would behave in the same context; namely returning a list of values from an array or
       key/value pairs from a hash when in list context, or the number of items or keys when in scalar context.

          field @items :reader;

          foreach my $item ( $obj-&gt;items ) { ... }   # iterates the list of items

          my $count = $obj-&gt;items;                   # yields count of items

   <b>ADJUST</b>
          ADJUST { ... }

       See also "ADJUST" in Object::Pad.

       Attributes are not supported; in particular the ":params" attribute of "Object::Pad" v0.70.

   <b>__CLASS__</b>
          my $classname = __CLASS__;

       <u>Since</u> <u>version</u> <u>0.07.</u>

       Only valid within the body (or signature) of a "method", an "ADJUST" block, or the initialising
       expression of a "field". Yields the class name of the instance that the method, block or expression is
       invoked on.

       This is similar to the core perl "__PACKAGE__" constant, except that it cares about the dynamic class of
       the actual instance, not the static class the code belongs to. When invoked by a subclass instance that
       inherited code from its superclass it yields the name of the class of the instance regardless of which
       class defined the code.

       For example,

          class BaseClass {
             ADJUST { say "Constructing an instance of " . __CLASS__; }
          }

          class DerivedClass :isa(BaseClass) { }

          my $obj = DerivedClass-&gt;new;

       Will produce the following output

          Constructing an instance of DerivedClass

       This is particularly useful in field initialisers for invoking (constant) methods on the invoking class
       to provide default values for fields. This way a subclass could provide a different value.

          class Timer {
             use constant DEFAULT_DURATION =&gt; 60;
             field $duration = __CLASS__-&gt;DEFAULT_DURATION;
          }

          class ThreeMinuteTimer :isa(Timer) {
             use constant DEFAULT_DURATION =&gt; 3 * 60;
          }

   <b>Other</b> <b>Keywords</b>
       The following other keywords provided by "Object::Pad" are not supported here at all:

          role

          BUILD, ADJUSTPARAMS

          has

          requires

</pre><h4><b>COMPATIBILITY</b> <b>NOTES</b></h4><pre>
       This module may use either Object::Pad or the perl core "class" feature to implement its syntax. While
       the two behave very similarly and both conform to the description given above, the following differences
       should be noted.

       <u>No</u> <u>known</u> <u>issues</u> <u>at</u> <u>this</u> <u>time</u>

</pre><h4><b>AUTHOR</b></h4><pre>
       Paul Evans &lt;<a href="mailto:leonerd@leonerd.org.uk">leonerd@leonerd.org.uk</a>&gt;

perl v5.38.2                                       2024-08-03                        <u>Feature::Compat::<a href="../man3pm/Class.3pm.html">Class</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>