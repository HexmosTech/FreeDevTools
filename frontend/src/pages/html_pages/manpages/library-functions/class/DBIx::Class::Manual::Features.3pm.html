<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DBIx::Class::Manual::Features - A boatload of DBIx::Class features with links to respective documentation</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdbix-class-perl">libdbix-class-perl_0.082844-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       DBIx::Class::Manual::Features - A boatload of DBIx::Class features with links to respective documentation

</pre><h4><b>META</b></h4><pre>
   <b>Large</b> <b>Community</b>
       There are hundres of DBIC contributors listed in <u>AUTHORS</u>. That ranges from documentation help, to test
       help, to added features, to entire database support.

   <b>Active</b> <b>Community</b>
       Currently (June 9, 2010) 6 active branches (committed to in the last two weeks) in git.  Last release
       (0.08122) had 14 new features, and 16 bug fixes.  Of course that ebbs and flows
       &lt;https://metacpan.org/changes/distribution/DBIx-Class&gt;.)

   <b>Responsive</b> <b>Community</b>
       I needed MSSQL order-by support; the community helped me add support
       generally very welcoming of people willing to help

</pre><h4><b>General</b> <b>ORM</b></h4><pre>
       These are things that are in most other ORMs, but are still reasons to use DBIC over raw SQL.

   <b>Cross</b> <b>DB</b>
       The vast majority of code should run on all databases without needing tweaking

   <b>Basic</b> <b>CRUD</b>
       C - Create
       R - Retrieve
       U - Update
       D - Delete

   <b>SQL:</b> <b>Create</b>
        my $sth = $dbh-&gt;prepare('
           INSERT INTO books
           (title, author_id)
           values (?,?)
        ');

        $sth-&gt;execute( 'A book title', $author_id );

   <b>DBIC:</b> <b>Create</b>
        my $book = $book_rs-&gt;create({
           title     =&gt; 'A book title',
           author_id =&gt; $author_id,
        });

       See "create" in DBIx::Class::ResultSet

       No need to pair placeholders and values
       Automatically gets autoincremented id for you
       Transparently uses INSERT ... RETURNING for databases that support it

   <b>SQL:</b> <b>Read</b>
        my $sth = $dbh-&gt;prepare('
           SELECT title,
           authors.name as author_name
           FROM books, authors
           WHERE books.author = authors.id
        ');

        while ( my $book = $sth-&gt;fetchrow_hashref ) {
          say "Author of $book-&gt;{title} is $book-&gt;{author_name}";
        }

   <b>DBIC:</b> <b>Read</b>
        my $book = $book_rs-&gt;find($book_id);

       or

        my $book = $book_rs-&gt;search({ title =&gt; 'A book title' }, { rows =&gt; 1 })-&gt;next;

       or

        my @books = $book_rs-&gt;search({ author =&gt; $author_id })-&gt;all;

       or

        while( my $book = $books_rs-&gt;next ) {
          printf "Author of %s is %s\n", $book-&gt;title, $book-&gt;author-&gt;name;
        }

       See    "find"    in    DBIx::Class::ResultSet,    "search"    in    DBIx::Class::ResultSet,   "next"   in
       DBIx::Class::ResultSet, and "all" in DBIx::Class::ResultSet

       <b>TMTOWTDI!</b>

   <b>SQL:</b> <b>Update</b>
        my $update = $dbh-&gt;prepare('
           UPDATE books
           SET title = ?
           WHERE id = ?
        ');

        $update-&gt;execute( 'New title', $book_id );

   <b>DBIC:</b> <b>Update</b>
        $book-&gt;update({ title =&gt; 'New title' });

       See "update" in DBIx::Class::Row

       Will not update unless value changes

   <b>SQL:</b> <b>Delete</b>
        my $delete = $dbh-&gt;prepare('DELETE FROM books WHERE id = ?');

        $delete-&gt;execute($book_id);

   <b>DBIC:</b> <b>Delete</b>
        $book-&gt;delete

       See "delete" in DBIx::Class::Row

   <b>SQL:</b> <b>Search</b>
        my $sth = $dbh-&gt;prepare('
          SELECT title,
          authors.name as author_name
          FROM books
          WHERE books.name LIKE "%monte cristo%" AND
          books.topic = "jailbreak"
        ');

   <b>DBIC:</b> <b>Search</b>
        my $book = $book_rs-&gt;search({
           'me.name'  =&gt; { -like =&gt; '%monte cristo%' },
           'me.topic' =&gt; 'jailbreak',
        })-&gt;next;

       See SQL::Abstract::Classic, "next" in DBIx::Class::ResultSet, and "search" in DBIx::Class::ResultSet
       (kinda) introspectible
       Prettier than SQL

   <b>OO</b> <b>Overridability</b>
       Override new if you want to do validation
       Override delete if you want to disable deletion
       and on and on

   <b>Convenience</b> <b>Methods</b>
       "find_or_create" in DBIx::Class::ResultSet
       "update_or_create" in DBIx::Class::ResultSet

   <b>Non-column</b> <b>methods</b>
       Need a method to get a user's gravatar URL?  Add a "gravatar_url" method to the Result class

   <b>RELATIONSHIPS</b>
       "belongs_to" in DBIx::Class::Relationship
       "has_many" in DBIx::Class::Relationship
       "might_have" in DBIx::Class::Relationship
       "has_one" in DBIx::Class::Relationship
       "many_to_many" in DBIx::Class::Relationship
       SET AND FORGET

</pre><h4><b>DBIx::Class</b> <b>Specific</b> <b>Features</b></h4><pre>
       These things may be in other ORM's, but they are very specific, so doubtful

   <b>-&gt;deploy</b>
       Create a database from your DBIx::Class schema.

        my $schema = Frew::Schema-&gt;connect( $dsn, $user, $pass );

        $schema-&gt;deploy

       See "deploy" in DBIx::Class::Schema.

       See also: DBIx::Class::DeploymentHandler

   <b>Schema::Loader</b>
       Create a DBIx::Class schema from your database.

        package Frew::Schema;

        use strict;
        use warnings;

        use base 'DBIx::Class::Schema::Loader';

        __PACKAGE__-&gt;loader_options({
           naming =&gt; 'v7',
           debug  =&gt; $ENV{DBIC_TRACE},
        });

        1;

        # elsewhere...

        my $schema = Frew::Schema-&gt;connect( $dsn, $user, $pass );

       See DBIx::Class::Schema::Loader and "CONSTRUCTOR OPTIONS" in DBIx::Class::Schema::Loader::Base.

   <b>Populate</b>
       Made for inserting lots of rows very quickly into database

        $schema-&gt;populate([ Users =&gt;
           [qw( username password )],
           [qw( frew     &gt;=4char$ )],
           [qw(      ...          )],
           [qw(      ...          )],
        );

       See "populate" in DBIx::Class::Schema

       I use populate here &lt;<a href="http://blog.afoolishmanifesto.com/archives/1255">http://blog.afoolishmanifesto.com/archives/1255</a>&gt; to export our whole (200M~)  db  to
       SQLite

   <b>Multicreate</b>
       Create an object and its related objects all at once

        $schema-&gt;resultset('Author')-&gt;create({
           name =&gt; 'Stephen King',
           books =&gt; [{ title =&gt; 'The Dark Tower' }],
           address =&gt; {
              street =&gt; '123 Turtle Back Lane',
              state  =&gt; { abbreviation =&gt; 'ME' },
              city   =&gt; { name =&gt; 'Lowell'     },
           },
        });

       See "create" in DBIx::Class::ResultSet

       books is a has_many
       address is a belongs_to which in turn belongs to state and city each
       for this to work right state and city must mark abbreviation and name as unique

   <b>Extensible</b>
       DBIx::Class  helped pioneer fast MI in Perl 5 with Class::C3, so it is made to allow extensions to nearly
       every part of it.

   <b>Extensibility</b> <b>example:</b> <b>DBIx::Class::Helpers</b>
       DBIx::Class::Helper::ResultSet::IgnoreWantarray
       DBIx::Class::Helper::ResultSet::Random
       DBIx::Class::Helper::ResultSet::SetOperations
       DBIx::Class::Helper::Row::JoinTable
       DBIx::Class::Helper::Row::NumifyGet
       DBIx::Class::Helper::Row::SubClass
       DBIx::Class::Helper::Row::ToJSON
       DBIx::Class::Helper::Row::StorageValues
       DBIx::Class::Helper::Row::OnColumnChange

   <b>Extensibility</b> <b>example:</b> <b>DBIx::Class::TimeStamp</b>
       See DBIx::Class::TimeStamp
       Cross DB
       set_on_create
       set_on_update

   <b>Extensibility</b> <b>example:</b> <b>Kioku</b>
       See DBIx::Class::Schema::KiokuDB
       Kioku is the new hotness
       Mix RDBMS with Object DB

   <b>Result</b> <b>vs</b> <b>ResultSet</b>
       Result == Row
       ResultSet == Query Plan
        Internal Join Optimizer for all DB's (!!!)
       (less important but...)
       ResultSource == Queryable collection of rows (Table, View, etc)
       Storage == Database
       Schema == associates a set of ResultSources with a Storage

   <b>ResultSet</b> <b>methods</b>
        package MyApp::Schema::ResultSet::Book;

        use strict;
        use warnings;

        use base 'DBIx::Class::ResultSet';

        sub good {
           my $self = shift;
           $self-&gt;search({
              $self-&gt;current_source_alias . '.rating' =&gt; { '&gt;=' =&gt; 4 }
           })
        };

        sub cheap {
           my $self = shift;
           $self-&gt;search({
              $self-&gt;current_source_alias . '.price' =&gt; { '&lt;=' =&gt; 5}
           })
        };

        # ...

        1;

       See "Predefined searches" in DBIx::Class::Manual::Cookbook

       All searches should be ResultSet methods
       Name has obvious meaning
       "current_source_alias" in DBIx::Class::ResultSet helps things to work no matter what

   <b>ResultSet</b> <b>method</b> <b>in</b> <b>Action</b>
        $schema-&gt;resultset('Book')-&gt;good

   <b>ResultSet</b> <b>Chaining</b>
        $schema-&gt;resultset('Book')
           -&gt;good
           -&gt;cheap
           -&gt;recent

   <b>search_related</b>
        my $score = $schema-&gt;resultset('User')
           -&gt;search({'me.userid' =&gt; 'frew'})
           -&gt;related_resultset('access')
           -&gt;related_resultset('mgmt')
           -&gt;related_resultset('orders')
           -&gt;telephone
           -&gt;search_related( shops =&gt; {
              'shops.datecompleted' =&gt; {
                 -between =&gt; ['2009-10-01','2009-10-08']
              }
           })-&gt;completed
           -&gt;related_resultset('rpt_score')
           -&gt;search(undef, { rows =&gt; 1})
           -&gt;get_column('raw_scores')
           -&gt;next;

       The SQL that this produces (with placeholders filled in for clarity's sake) on our system (Microsoft SQL)
       is:

        SELECT raw_scores
          FROM (
            SELECT raw_scores, ROW_NUMBER() OVER (
                ORDER BY (
                    SELECT (1)
                  )
              ) AS rno__row__index
              FROM (
                SELECT rpt_score.raw_scores
                  FROM users me
                  JOIN access access
                    ON access.userid = me.userid
                  JOIN mgmt mgmt
                    ON mgmt.mgmtid = access.mgmtid
                  JOIN [order] orders
                    ON orders.mgmtid = mgmt.mgmtid
                  JOIN shop shops
                    ON shops.orderno = orders.orderno
                  JOIN rpt_scores rpt_score
                    ON rpt_score.shopno = shops.shopno
                WHERE (
                  datecompleted IS NOT NULL AND
                  (
                    (shops.datecompleted BETWEEN '2009-10-01' AND '2009-10-08')  AND
                    (type = '1' AND me.userid = 'frew')
                  )
                )
              ) rpt_score
          ) rpt_score
        WHERE rno__row__index BETWEEN 1 AND 1

       See: "related_resultset"  in  DBIx::Class::ResultSet,  "search_related"  in  DBIx::Class::ResultSet,  and
       "get_column" in DBIx::Class::ResultSet.

   <b>bonus</b> <b>rel</b> <b>methods</b>
        my $book = $author-&gt;create_related(
           books =&gt; {
              title =&gt; 'Another Discworld book',
           }
        );

        my $book2 = $pratchett-&gt;add_to_books({
           title =&gt; 'MOAR Discworld book',
        });

       See      "create_related"      in      DBIx::Class::Relationship::Base      and      "add_to_$rel"     in
       DBIx::Class::Relationship::Base

       Note that it automatically fills in foreign key for you

   <b>Excellent</b> <b>Transaction</b> <b>Support</b>
        $schema-&gt;txn_do(sub {
           ...
        });

        $schema-&gt;txn_begin; # &lt;-- low level
        # ...
        $schema-&gt;txn_commit;

       See  "txn_do"  in  DBIx::Class::Schema,  "txn_begin"  in   DBIx::Class::Schema,   and   "txn_commit"   in
       DBIx::Class::Schema.

   <b>InflateColumn</b>
        package Frew::Schema::Result::Book;

        use strict;
        use warnings;

        use base 'DBIx::Class::Core';

        use DateTime::Format::MySQL;

        # Result code here

        __PACKAGE__-&gt;load_components('InflateColumn');

        __PACKAGE__-&gt;inflate_column(
           date_published =&gt; {
              inflate =&gt; sub { DateTime::Format::MySQL-&gt;parse_date( shift ) },
              deflate =&gt; sub { shift-&gt;ymd },
           },
        );

       See      DBIx::Class::InflateColumn,      "inflate_column"     in     DBIx::Class::InflateColumn,     and
       DBIx::Class::InflateColumn::DateTime.

   <b>InflateColumn:</b> <b>deflation</b>
        $book-&gt;date_published(DateTime-&gt;now);
        $book-&gt;update;

   <b>InflateColumn:</b> <b>inflation</b>
        say $book-&gt;date_published-&gt;month_abbr; # Nov

   <b>FilterColumn</b>
        package Frew::Schema::Result::Book;

        use strict;
        use warnings;

        use base 'DBIx::Class::Core';

        # Result code here

        __PACKAGE__-&gt;load_components('FilterColumn');

        __PACKAGE__-&gt;filter_column(
           length =&gt; {
              to_storage   =&gt; 'to_metric',
              from_storage =&gt; 'to_imperial',
           },
        );

        sub to_metric   { $_[1] * .305 }
        sub to_imperial { $_[1] * 3.28 }

       See DBIx::Class::FilterColumn and "filter_column" in DBIx::Class::FilterColumn

   <b>ResultSetColumn</b>
        my $rsc = $schema-&gt;resultset('Book')-&gt;get_column('price');
        $rsc-&gt;first;
        $rsc-&gt;all;
        $rsc-&gt;min;
        $rsc-&gt;max;
        $rsc-&gt;sum;

       See DBIx::Class::ResultSetColumn

   <b>Aggregates</b>
        my @res = $rs-&gt;search(undef, {
           select   =&gt; [
              'price',
              'genre',
              { max =&gt; price },
              { avg =&gt; price },
           ],
           as       =&gt; [
              qw(price genre max_price avg_price)
           ],
           group_by =&gt; [qw(price genre)],
        });
        for (@res) {
           say $_-&gt;price . ' ' . $_-&gt;genre;
           say $_-&gt;get_column('max_price');
           say $_-&gt;get_column('avg_price');
        }

       See  "select"  in   DBIx::Class::ResultSet,   "as"   in   DBIx::Class::ResultSet,   and   "group_by"   in
       DBIx::Class::ResultSet

       Careful, get_column can basically mean <b>three</b> things
       private in which case you should use an accessor
       public for what there is no accessor for
       public for get resultset column (prev example)

   <b>HRI</b>
        $rs-&gt;search(undef, {
          result_class =&gt; 'DBIx::Class::ResultClass::HashRefInflator',
        });

       See "result_class" in DBIx::Class::ResultSet and DBIx::Class::ResultClass::HashRefInflator.

       Easy on memory
       Mega fast
       Great for quick debugging
       Great for performance tuning (we went from 2m to &lt; 3s)

   <b>Subquery</b> <b>Support</b>
        my $inner_query = $schema-&gt;resultset('Artist')
           -&gt;search({
            name =&gt; [ 'Billy Joel', 'Brittany Spears' ],
        })-&gt;get_column('id')-&gt;as_query;

        my $rs = $schema-&gt;resultset('CD')-&gt;search({
            artist_id =&gt; { -in =&gt; $inner_query },
        });

       See "Subqueries" in DBIx::Class::Manual::Cookbook

   <b>Bare</b> <b>SQL</b> <b>w/</b> <b>Placeholders</b>
        $rs-&gt;update({
           # !!! SQL INJECTION VECTOR
           price =&gt; \"price + $inc", # DON'T DO THIS
        });

       Better:

        $rs-&gt;update({
           price =&gt; \['price + ?', [inc =&gt; $inc]],
        });

       See "Literal SQL with placeholders and bind values (subqueries)" in SQL::Abstract::Classic

</pre><h4><b>FURTHER</b> <b>QUESTIONS?</b></h4><pre>
       Check the list of additional DBIC resources.

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This  module is free software copyright by the DBIx::Class (DBIC) authors. You can redistribute it and/or
       modify it under the same terms as the DBIx::Class library.

perl v5.40.0                                       2025-02-01                 <u>DBIx::Class::Manual::<a href="../man3pm/Features.3pm.html">Features</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>