<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SoDirectionalLightManip — directional light node with 3D interface for editing direction</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/inventor-doc">inventor-doc_2.1.6+ds-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       SoDirectionalLightManip — directional light node with 3D interface for editing direction

</pre><h4><b>INHERITS</b> <b>FROM</b></h4><pre>
       SoBase &gt; SoFieldContainer &gt; SoNode &gt; SoLight &gt; SoDirectionalLight &gt; SoDirectionalLightManip

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;Inventor/manips/SoDirectionalLightManip.h&gt;</b>

          Fields from class SoDirectionalLight:

     <b>SoSFVec3f</b>           <b>direction</b>

          Fields from class SoLight:

     <b>SoSFBool</b>            <b>on</b>
     <b>SoSFFloat</b>           <b>intensity</b>
     <b>SoSFColor</b>           <b>color</b>

          Methods from class SoDirectionalLightManip:

                         <b>SoDirectionalLightManip()</b>
     <b>SoDragger</b> <b>*</b>         <b>getDragger()</b>
     <b>SbBool</b>              <b>replaceNode(SoPath</b> <b>*p</b> <b>)</b>
     <b>SbBool</b>              <b>replaceManip(SoPath</b> <b>*p,</b> <b>SoDirectionalLight</b> <b>*newOne</b> <b>)</b> <b>const</b>
     <b>static</b> <b>SoType</b>       <b>getClassTypeId()</b>

          Methods from class SoNode:

     <b>void</b>                <b>setOverride(SbBool</b> <b>state)</b>
     <b>SbBool</b>              <b>isOverride()</b> <b>const</b>
     <b>SoNode</b> <b>*</b>            <b>copy(SbBool</b> <b>copyConnections</b> <b>=</b> <b>FALSE)</b> <b>const</b>
     <b>virtual</b> <b>SbBool</b>      <b>affectsState()</b> <b>const</b>
     <b>static</b> <b>SoNode</b> <b>*</b>     <b>getByName(const</b> <b>SbName</b> <b>&amp;name)</b>
     <b>static</b> <b>int</b>          <b>getByName(const</b> <b>SbName</b> <b>&amp;name,</b> <b>SoNodeList</b> <b>&amp;list)</b>

          Methods from class SoFieldContainer:

     <b>void</b>                <b>setToDefaults()</b>
     <b>SbBool</b>              <b>hasDefaultValues()</b> <b>const</b>
     <b>SbBool</b>              <b>fieldsAreEqual(const</b> <b>SoFieldContainer</b> <b>*fc)</b> <b>const</b>
     <b>void</b>                <b>copyFieldValues(const</b> <b>SoFieldContainer</b> <b>*fc,</b> <b>SbBool</b> <b>copyConnections</b> <b>=</b> <b>FALSE)</b>
     <b>SbBool</b>              <b>set(const</b> <b>char</b> <b>*fieldDataString)</b>
     <b>void</b>                <b>get(SbString</b> <b>&amp;fieldDataString)</b>
     <b>virtual</b> <b>int</b>         <b>getFields(SoFieldList</b> <b>&amp;resultList)</b> <b>const</b>
     <b>virtual</b> <b>SoField</b> <b>*</b>   <b>getField(const</b> <b>SbName</b> <b>&amp;fieldName)</b> <b>const</b>
     <b>SbBool</b>              <b>getFieldName(const</b> <b>SoField</b> <b>*field,</b> <b>SbName</b> <b>&amp;fieldName)</b> <b>const</b>
     <b>SbBool</b>              <b>isNotifyEnabled()</b> <b>const</b>
     <b>SbBool</b>              <b>enableNotify(SbBool</b> <b>flag)</b>

          Methods from class SoBase:

     <b>void</b>                <b>ref()</b>
     <b>void</b>                <b>unref()</b> <b>const</b>
     <b>void</b>                <b>unrefNoDelete()</b> <b>const</b>
     <b>void</b>                <b>touch()</b>
     <b>virtual</b> <b>SoType</b>      <b>getTypeId()</b> <b>const</b>
     <b>SbBool</b>              <b>isOfType(SoType</b> <b>type)</b> <b>const</b>
     <b>virtual</b> <b>void</b>        <b>setName(const</b> <b>SbName</b> <b>&amp;name)</b>
     <b>virtual</b> <b>SbName</b>      <b>getName()</b> <b>const</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>SoDirectionalLightManip</b>  is  the base class for all <b>SoDirectionalLight</b> nodes that have a built-in 3D user
       interface (this is the only such class provided with the Inventor toolkit).  Since  it  is  derived  from
       <b>SoDirectionalLight</b>,  any changes to its fields result in a change of lighting for nodes that follow it in
       the scene graph. In this case,  the  interface  edits  the  <b>direction</b>  field.  Also,  the  color  of  the
       manipulator's  geometry  will  reflect  the  color of the light (but you cannot edit the color using this
       manipulator).

       Typically, you will want to replace a regular <b>SoDirectionalLight</b> with an <b>SoDirectionalLightManip</b> (as when
       the user selects a light to be edited), or vice versa (as when the user is done moving the light and  the
       interface  should go away). Use the <b>replaceNode()</b> method  to insert a manipulator into a scene graph, and
       the <b>replaceManip()</b> method  to remove it when done.

       The <b>SoDirectionalLightManip</b> utilizes an <b>SoDirectionalLightDragger</b> to provide a 3D interface. However, the
       manipulator  differs  from  the  dragger;  it  lights  other  objects  in  the  scene  because,   as   an
       <b>SoDirectionalLight</b>, it alters the state. The field values and movement of the dragger, on the other hand,
       affect  only  the  dragger itself. To find out more about how the interface works and what each part will
       do, see the reference  page  for  <b>SoDirectionalLightDragger</b>.  The  interfaces  of  the  dragger  and  the
       manipulator are identical.

       The  <b>SoDirectionalLightManip</b>  utilizes  its  dragger  by  adding  it as a hidden child. When an action is
       applied to the manipulator, such as rendering or handling events, the  manipulator  first  traverses  the
       dragger,  and then the manipulator adds its lighting parameters to the state. When you click-drag-release
       over the manipulator, it passes these events down to the dragger, which moves as a result ("I can't  <u>help</u>
       it, I'm a dragger!").

       The manipulator maintains consistency between the fields of the dragger and its own fields. Let's say you
       use  the  mouse  to rotate the <u>dragger</u>. Callbacks ensure that the <b>direction</b> field of the <u>manipulator</u> will
       change by the same amount, thus changing  the  lighting  of  nodes  which  follow  in  the  scene  graph.
       Similarly, if you set the <b>direction</b> field of the <b>SoDirectionalLightManip</b>, the manipulator will orient the
       dragger accordingly.

       Because  the  dragger  is a <u>hidden</u> child, you can see the dragger on screen and interact with it, but the
       dragger does not show up when you write the manipulator to  file.  Also,  any  <b>SoPath</b>  will  end  at  the
       manipulator.  (See  the  Actions  section  of  this reference page for a complete description of when the
       dragger is traversed).

       If you want to get a pointer to the dragger you can get it from the manipulator  using  the  <b>getDragger()</b>
       method.  You will need to do this if you want to change the geometry of a manipulator, since the geometry
       actually belongs to the dragger.

</pre><h4><b>METHODS</b></h4><pre>
                         <b>SoDirectionalLightManip()</b>
          Constructor.

     <b>SoDragger</b> <b>*</b>         <b>getDragger()</b>
          Returns a pointer to the dragger being used by this manipulator. Given this pointer, you can customize
          the dragger just like you would any other dragger. You can change geometry using the <b>setPart()</b> method,
          or add callbacks using the methods found in the <b>SoDragger</b> reference page.

     <b>SbBool</b>              <b>replaceNode(SoPath</b> <b>*p</b> <b>)</b>
          Replaces  the  tail  of  the  path  with  this  manipulator.  The  tail  of  the  path  must   be   an
          <b>SoDirectionalLight</b>  node  (or  subclass  thereof).  If  the  path  has a nodekit, this will try to use
          <b>setPart()</b> to insert the manipulator. Otherwise, the manipulator requires that the next to last node in
          the path chain be a group.

          The field values from the directional light node will be copied to this  manipulator,  and  the  light
          node will be replaced.

          The manipulator will not call <b>ref()</b> on the node it is replacing. The old node will disappear if it has
          no  references  other  than  from  the  input  path  <b>p</b>  and its parent, since this manipulator will be
          replacing it in both of those places. Nor will the manipulator make any changes to  field  connections
          of  the old node. The calling process is thus responsible for keeping track of its own nodes and field
          connections.

     <b>SbBool</b>              <b>replaceManip(SoPath</b> <b>*p,</b> <b>SoDirectionalLight</b> <b>*newOne</b> <b>)</b> <b>const</b>
          Replaces the tail of the path, which must be this manipulator, with the given <b>SoDirectionalLight</b> node.
          If the path has a nodekit, this will try to use <b>setPart()</b> to  insert  the  new  node.  Otherwise,  the
          manipulator requires that the next to last node in the path chain be a group.

          The  field  values  from  the  manipulator  will  be  copied  to  the  directional light node, and the
          manipulator will be replaced.

          The manipulator will not call <b>ref()</b> or <b>unref()</b> on the node which is replacing it, nor will it make any
          changes to field connections. The calling process is thus responsible for keeping  track  of  its  own
          nodes and field connections.

     <b>static</b> <b>SoType</b>       <b>getClassTypeId()</b>
          Returns type identifier for this class.

</pre><h4><b>ACTION</b> <b>BEHAVIOR</b></h4><pre>
       <b>SoGLRenderAction,</b>   <b>SoCallbackAction,</b>   <b>SoGetBoundingBoxAction,</b>  <b>SoGetMatrixAction,</b>  <b>SoHandleEventAction,</b>
       <b>SoRayPickAction</b>
          First, traverses the dragger the way an <b>SoGroup</b> would. All draggers place  themselves  in  space,  but
          leave  the  current  transformation  unchanged  when finished. Then the <b>SoDirectionalLightManip</b> adds a
          directional light to the state just like its base class, <b>SoDirectionalLight</b>.

     <b>SoSearchAction</b>
          Searches just like an <b>SoDirectionalLight</b>. Does not search the dragger, which is a hidden child.

     <b>SoWriteAction</b>
          Writes out just like an <b>SoDirectionalLight</b>. Does not write the dragger, which is a  hidden  child.  If
          you  really need to write valuable information about the dragger, such as customized geometry, you can
          retrieve the dragger with the <b>getDragger()</b> method and then write it out separately.

</pre><h4><b>FILE</b> <b>FORMAT/DEFAULTS</b></h4><pre>
       <b>DirectionalLightManip</b> <b>{</b>
          <b>on</b>         <b>TRUE</b>
          <b>intensity</b>  <b>1</b>
          <b>color</b>      <b>1</b> <b>1</b> <b>1</b>
          <b>direction</b>  <b>0</b> <b>0</b> <b>-1</b>
     <b>}</b>

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b>SoDragger,</b> <b>SoDirectionalLight,</b> <b>SoDirectionalLightDragger,</b> <b>SoPointLightManip,</b> <b>SoSpotLightManip</b>

                                                                                  <u><a href="../man3IV/SoDirectionalLightManip.3IV.html">SoDirectionalLightManip</a>(3IV)</u>()
</pre>
 </div>
</div></section>
</div>
</body>
</html>