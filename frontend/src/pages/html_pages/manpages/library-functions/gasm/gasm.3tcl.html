<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>grammar::me::cpu::gasm - ME assembler</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcllib">tcllib_2.0+dfsg-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       grammar::me::cpu::gasm - ME assembler

</pre><h4><b>SYNOPSIS</b></h4><pre>
       package require <b>grammar::me::cpu::gasm</b> <b>?0.2?</b>

       <b>::grammar::me::cpu::gasm::begin</b> <u>g</u> <u>n</u> ?<u>mode</u>? ?<u>note</u>?

       <b>::grammar::me::cpu::gasm::done</b> <b>--&gt;</b> <u>t</u>

       <b>::grammar::me::cpu::gasm::state</b>

       <b>::grammar::me::cpu::gasm::state!</b> <u>s</u>

       <b>::grammar::me::cpu::gasm::lift</b> <u>t</u> <u>dst</u> <b>=</b> <u>src</u>

       <b>::grammar::me::cpu::gasm::Inline</b> <u>t</u> <u>node</u> <u>label</u>

       <b>::grammar::me::cpu::gasm::Cmd</b> <u>cmd</u> ?<u>arg</u>...?

       <b>::grammar::me::cpu::gasm::Bra</b>

       <b>::grammar::me::cpu::gasm::Nop</b> <u>text</u>

       <b>::grammar::me::cpu::gasm::Note</b> <u>text</u>

       <b>::grammar::me::cpu::gasm::Jmp</b> <u>label</u>

       <b>::grammar::me::cpu::gasm::Exit</b>

       <b>::grammar::me::cpu::gasm::Who</b> <u>label</u>

       <b>::grammar::me::cpu::gasm::/Label</b> <u>name</u>

       <b>::grammar::me::cpu::gasm::/Clear</b>

       <b>::grammar::me::cpu::gasm::/Ok</b>

       <b>::grammar::me::cpu::gasm::/Fail</b>

       <b>::grammar::me::cpu::gasm::/At</b> <u>name</u>

       <b>::grammar::me::cpu::gasm::/CloseLoop</b>

________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  package  provides  a simple in-memory assembler. Its origin is that of a support package for use by
       packages converting PEG and other grammars into a corresponding matcher based on the ME virtual  machine,
       like  <b>page::compiler::peg::mecpu</b>. Despite that it is actually mostly agnostic regarding the instructions,
       users can choose any instruction set they like.

       The program under construction is held in a graph structure (See package <b>struct::graph</b>)  during  assembly
       and  subsequent  manipulation,  with instructions represented by nodes, and the flow of execution between
       instructions explicitly encoded in the arcs between them.

       In this model jumps are not encoded explicitly, they are implicit in the arcs. The generation of explicit
       jumps is left to any code converting the graph structure into a  more  conventional  representation.  The
       same  goes  for  branches.  They are implicitly encoded by all instructions which have two outgoing arcs,
       whereas all other instructions have only one outgoing arc. Their  conditonality  is  handled  by  tagging
       their outgoing arcs with information about the conditions under which they are taken.

       While  the  graph  the  assembler operates on is supplied from the outside, i.e. external, it does manage
       some internal state, namely:

       [1]    The handle of the graph node most assembler operations will work on, the <u>anchor</u>.

       [2]    A mapping from arbitrary strings to instructions. I.e. it is  possible  to  <u>label</u>  an  instruction
              during assembly, and later recall that instruction by its label.

       [3]    The condition code to use when creating arcs between instructions, which is one of <b>always</b>, <b>ok</b>, and
              <b>fail</b>.

       [4]    The current operation mode, one of <b>halt</b>, <b>okfail</b>, and <b>!okfail</b>.

       [5]    The  name  of  a  node  in  a  tree. This, and the operation mode above are the parts most heavily
              influenced by the needs of a grammar compiler,  as  they  assume  some  basic  program  structures
              (selected  through the operation mode), and intertwine the graph with a tree, like the AST for the
              grammar to be compiled.

</pre><h4><b>DEFINITIONS</b></h4><pre>
       As the graph the assembler is operating on, and the tree it is intertwined  with,  are  supplied  to  the
       assembler  from  the  outside  it is necessary to specify the API expected from them, and to describe the
       structures expected and/or generated by the assembler in either.

       [1]    Any graph object command used by the assembler  has  to  provide  the  API  as  specified  in  the
              documentation for the package <b>struct::graph</b>.

       [2]    Any  tree  object  command  used  by  the  assembler  has  to  provide the API as specified in the
              documentation for the package <b>struct::tree</b>.

       [3]    Any instruction (node) generated by the assembler in a graph will have at least two, and  at  most
              three attributes:

              <b>instruction</b>
                     The  value  of  this  attribute  is  the  name of the instruction. The only names currently
                     defined by the assembler are the three pseudo-instructions

                     <b>NOP</b>    This instruction does nothing. Useful for fixed  framework  nodes,  unchanging  jump
                            destinations, and the like. No arguments.

                     <b>C</b>      A  .NOP  to  allow  the insertion of arbitrary comments into the instruction stream,
                            i.e. a comment node. One argument, the text of the comment.

                     <b>BRA</b>    A .NOP serving as explicitly coded conditional branch. No arguments.

                     However we reserve the space of all instructions whose names begin with  a  "."  (dot)  for
                     future use by the assembler.

              <b>arguments</b>
                     The  value  of  this  attribute is a list of strings, the arguments of the instruction. The
                     contents are dependent on the actual instruction and the assembler  doesn't  know  or  care
                     about  them. This means for example that it has no builtin knowledge about what instruction
                     need which arguments and thus doesn't perform any type of checking.

              <b>expr</b>   This attribute is optional. When it is present its value is the name of a node in the  tree
                     intertwined with the graph.

       [4]    Any arc between two instructions will have one attribute:

              <b>condition</b>
                     The  value of this attribute determines under which condition execution will take this arc.
                     It is one of <b>always</b>, <b>ok</b>, and <b>fail</b>. The first condition is used for all arcs which  are  the
                     single  outgoing arc of an instruction. The other two are used for the two outgoing arcs of
                     an instruction which implicitly encode a branch.

       [5]    A tree node given to the assembler  for  cross-referencing  will  be  written  to  and  given  the
              following  attributes,  some  fixed,  some  dependent  on  the  operation mode. All values will be
              references to nodes in the instruction graph. Some of the instruction will expect some or specific
              sets of these attributes.

              <b>gas::entry</b>
                     Always written.

              <b>gas::exit</b>
                     Written for all modes but <b>okfail</b>.

              <b>gas::exit::ok</b>
                     Written for mode <b>okfail</b>.

              <b>gas::exit::fail</b>
                     Written for mode <b>okfail</b>.

</pre><h4><b>API</b></h4><pre>
       <b>::grammar::me::cpu::gasm::begin</b> <u>g</u> <u>n</u> ?<u>mode</u>? ?<u>note</u>?
              This command starts the assembly of an instruction sequence, and (re)initializes the state of  the
              assembler.  After  completion  of  the  instruction sequence use <b>::grammar::me::cpu::gasm::done</b> to
              finalize the assembler.

              It will operate on the graph <u>g</u> in  the  specified  <u>mode</u>  (Default  is  <b>okfail</b>).  As  part  of  the
              initialization  it  will  always  create  a  standard  .NOP  instruction and label it "entry". The
              creation of the remaining standard instructions is <u>mode</u>-dependent:

              <b>halt</b>   An "icf_halt" instruction labeled "exit/return".

              <b>!okfail</b>
                     An "icf_ntreturn" instruction labeled "exit/return".

              <b>okfail</b> Two .NOP instructions labeled "exit/ok" and "exit/fail" respectively.

              The <u>note</u>, if specified (default is not), is given to the "entry" .NOP instruction.

              The node reference <u>n</u> is simply stored for use by <b>::grammar::me::cpu::gasm::done</b>. It has  to  refer
              to a node in the tree <u>t</u> argument of that command.

              After  the  initialization  is  done the "entry" instruction will be the <u>anchor</u>, and the condition
              code will be set to <b>always</b>.

              The command returns the empy string as its result.

       <b>::grammar::me::cpu::gasm::done</b> <b>--&gt;</b> <u>t</u>
              This command finalizes the creation of an instruction sequence and then clears the  state  of  the
              assembler.   <u>NOTE</u>  that  this  <u>does</u>  <u>not</u>  delete any of the created instructions. They can be made
              available  to  future  begin/done  cycles.   Further  assembly  will  be   possible   only   after
              reinitialization of the system via <b>::grammar::me::cpu::gasm::begin</b>.

              Before  the  state  is  cleared  selected  references  to selected instructions will be written to
              attributes of the node <u>n</u> in the tree <u>t</u>.  Which instructions are saved is <u>mode</u>-dependent. Both <u>mode</u>
              and the destination node <u>n</u> were specified during invokation of <b>::grammar::me::cpu::gasm::begin</b>.

              Independent of the mode a reference to the instruction  labeled  "entry"  will  be  saved  to  the
              attribute  <b>gas::entry</b>  of  <u>n</u>. The reference to the node <u>n</u> will further be saved into the attribute
              "expr" of the "entry" instruction. Beyond that

              <b>halt</b>   A reference to the instruction  labeled  "exit/return"  will  be  saved  to  the  attribute
                     <b>gas::exit</b> of <u>n</u>.

              <b>okfail</b> See <b>halt</b>.

              <b>!okfail</b>
                     Reference  to  the  two instructions labeled "exit/ok" and "exit/fail" will be saved to the
                     attributes <b>gas::exit::ok</b> and <b>gas::exit::fail</b> of <u>n</u> respectively.

       The command returns the empy string as its result.

       <b>::grammar::me::cpu::gasm::state</b>
              This command returns the current state  of  the  assembler.  Its  format  is  not  documented  and
              considered to be internal to the package.

       <b>::grammar::me::cpu::gasm::state!</b> <u>s</u>
              This  command  takes a serialized assembler state <u>s</u> as returned by <b>::grammar::me::cpu::gasm::state</b>
              and makes it the current state of the assembler.

              <u>Note</u> that this may overwrite label definitions, however all non-conflicting label  definitions  in
              the state before are not touched and merged with <u>s</u>.

              The command returns the empty string as its result.

       <b>::grammar::me::cpu::gasm::lift</b> <u>t</u> <u>dst</u> <b>=</b> <u>src</u>
              This  command  operates  on  the  tree  <u>t</u>.  It  copies  the contents of the attributes <b>gas::entry</b>,
              <b>gas::exit::ok</b> and <b>gas::exit::fail</b> from the node <u>src</u> to the node <u>dst</u>.  It returns the empty  string
              as its result.

       <b>::grammar::me::cpu::gasm::Inline</b> <u>t</u> <u>node</u> <u>label</u>
              This  command links an instruction sequence created by an earlier begin/done pair into the current
              instruction sequence.

              To this end it

              [1]    reads the  instruction  references  from  the  attributes  <b>gas::entry</b>,  <b>gas::exit::ok</b>,  and
                     <b>gas::exit::fail</b> from the node <u>n</u> of the tree <u>t</u> and makes them available to assembler und the
                     labels <u>label</u>/entry, <u>label</u>/exit::ok, and <u>label</u>/exit::fail respectively.

              [2]    Creates  an  arc  from  the  <u>anchor</u>  to  the node labeled <u>label</u>/entry, and tags it with the
                     current condition code.

              [3]    Makes the node labeled <u>label</u>/exit/ok the new <u>anchor</u>.

              The command returns the empty string as its result.

       <b>::grammar::me::cpu::gasm::Cmd</b> <u>cmd</u> ?<u>arg</u>...?
              This is the basic command to add instructions to the graph.  It creates a new instruction of  type
              <u>cmd</u> with the given arguments <u>arg</u>...  If the <u>anchor</u> was defined it will also create an arc from the
              <u>anchor</u>  to  the  new  instruction  using  the  current  condition  code.   After  the call the new
              instruction will be the <u>anchor</u> and the current condition code will be set to <b>always</b>.

              The command returns the empty string as its result.

       <b>::grammar::me::cpu::gasm::Bra</b>
              This   is   a   convenience   command   to   create   a   .BRA   pseudo-instruction.    It    uses
              <b>::grammar::me::cpu::gasm::Cmd</b> to actually create the instruction and inherits its behaviour.

       <b>::grammar::me::cpu::gasm::Nop</b> <u>text</u>
              This    is    a   convenience   command   to   create   a   .NOP   pseudo-instruction.   It   uses
              <b>::grammar::me::cpu::gasm::Cmd</b> to actually create the instruction and inherits its behaviour.   The
              <u>text</u> will be saved as the first and only argument of the new instruction.

       <b>::grammar::me::cpu::gasm::Note</b> <u>text</u>
              This  is  a  convenience  command  to  create  a  .C  pseudo-instruction,  i.e. a comment. It uses
              <b>::grammar::me::cpu::gasm::Cmd</b> to actually create the instruction and inherits its behaviour.   The
              <u>text</u> will be saved as the first and only argument of the new instruction.

       <b>::grammar::me::cpu::gasm::Jmp</b> <u>label</u>
              This  command  creates an arc from the <u>anchor</u> to the instruction labeled with <u>label</u>, and tags with
              the the current condition code.

              The command returns the empty string as its result.

       <b>::grammar::me::cpu::gasm::Exit</b>
              This command creates an arc from the <u>anchor</u>  to  one  of  the  exit  instructions,  based  on  the
              operation mode (see <b>::grammar::me::cpu::gasm::begin</b>), and tags it with current condition code.

              For  mode <b>okfail</b> it links to the instruction labeled either "exit/ok" or "exit/fail", depending on
              the current condition code, and tagging it with the current condition code For the other two modes
              it links to the instruction labeled "exit/return", tagging it condition code  <b>always</b>,  independent
              the current condition code.

              The command returns the empty string as its result.

       <b>::grammar::me::cpu::gasm::Who</b> <u>label</u>
              This command returns a reference to the instruction labeled with <u>label</u>.

       <b>::grammar::me::cpu::gasm::/Label</b> <u>name</u>
              This command labels the <u>anchor</u> with <u>name</u>.  <u>Note</u> that an instruction can have more than one label.

              The command returns the empty string as its result.

       <b>::grammar::me::cpu::gasm::/Clear</b>
              This  command  clears  the  <u>anchor</u>, leaving it undefined, and further resets the current condition
              code to <b>always</b>.

              The command returns the empty string as its result.

       <b>::grammar::me::cpu::gasm::/Ok</b>
              This command sets the current condition code to <b>ok</b>.

              The command returns the empty string as its result.

       <b>::grammar::me::cpu::gasm::/Fail</b>
              This command sets the current condition code to <b>fail</b>.

              The command returns the empty string as its result.

       <b>::grammar::me::cpu::gasm::/At</b> <u>name</u>
              This command sets the <u>anchor</u> to the instruction labeled with <u>name</u>, and further resets the  current
              condition code to <b>always</b>.

              The command returns the empty string as its result.

       <b>::grammar::me::cpu::gasm::/CloseLoop</b>
              This  command  marks  the <u>anchor</u> as the last instruction in a loop body, by creating the attribute
              <b>LOOP</b>.

              The command returns the empty string as its result.

</pre><h4><b>BUGS,</b> <b>IDEAS,</b> <b>FEEDBACK</b></h4><pre>
       This document, and the package it describes, will undoubtedly contain bugs and  other  problems.   Please
       report  such  in  the  category <u>grammar_me</u> of the <u>Tcllib</u> <u>Trackers</u> [<a href="http://core.tcl.tk/tcllib/reportlist">http://core.tcl.tk/tcllib/reportlist</a>].
       Please also report any ideas for enhancements you may have for either package and/or documentation.

       When proposing code changes, please provide <u>unified</u> <u>diffs</u>, i.e the output of <b>diff</b> <b>-u</b>.

       Note further that <u>attachments</u> are strongly preferred over inlined patches. Attachments  can  be  made  by
       going  to the <b>Edit</b> form of the ticket immediately after its creation, and then using the left-most button
       in the secondary navigation bar.

</pre><h4><b>KEYWORDS</b></h4><pre>
       assembler, grammar, graph, parsing, tree, virtual machine

</pre><h4><b>CATEGORY</b></h4><pre>
       Grammars and finite automata

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2005 Andreas Kupries &lt;<a href="mailto:andreas_kupries@users.sourceforge.net">andreas_kupries@users.sourceforge.net</a>&gt;

tcllib                                                 0.2                          <u>grammar::me::cpu::<a href="../man3tcl/gasm.3tcl.html">gasm</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>