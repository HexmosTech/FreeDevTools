<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>slave - Functions for starting and controlling slave nodes.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       slave - Functions for starting and controlling slave nodes.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  module  provides  functions  for starting Erlang slave nodes. All slave nodes that are started by a
       master terminate automatically when the master terminates. All terminal output produced at the  slave  is
       sent back to the master node. File I/O is done through the master.

       Slave  nodes  on  other  hosts  than  the  current one are started with the <u>ssh</u> program. The user must be
       allowed to <u>ssh</u> to the remote hosts without being prompted for a password.  This  can  be  arranged  in  a
       number  of  ways  (for  details, see the <u>ssh</u> documentation). A slave node started on the same host as the
       master inherits certain environment values from the  master,  such  as  the  current  directory  and  the
       environment  variables.  For what can be assumed about the environment when a slave is started on another
       host, see the documentation for the <u>ssh</u> program.

       An alternative to the <u>ssh</u> program can be specified on the command line to <u><a href="../man1/erl.1.html">erl</a>(1)</u> as follows:

       -rsh Program

       Note that the command specified with the <u>-rsh</u> flag is treated as a file name which may contain spaces. It
       is thus not possible to include any command line options. The remote node  will  be  launched  as  <u>"$RSH"</u>
       <u>"$REMOTE_HOSTNAME"</u> <u>erl</u> <u>-detached</u> <u>-noinput</u> <u>...</u>, so the <u>erl</u> command must be found in the path on the remote
       host.

       The  slave  node is to use the same file system at the master. At least, Erlang/OTP is to be installed in
       the same place on both computers and the same version of Erlang is to be used.

       A node running on Windows can only start slave nodes on the host on which it is running.

       The master node must be alive.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>pseudo([Master</b> <b>|</b> <b>ServerList])</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Master = node()
                 ServerList = [atom()]

              Calls <u>pseudo(Master,</u> <u>ServerList)</u>. If you want to start a node from the command line and set  up  a
              number of pseudo servers, an Erlang runtime system can be started as follows:

              % erl -name abc -s slave pseudo klacke@super x --

       <b>pseudo(Master,</b> <b>ServerList)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Master = node()
                 ServerList = [atom()]

              Starts  a  number  of pseudo servers. A pseudo server is a server with a registered name that does
              nothing but pass on all message to the real server that executes at a master node. A pseudo server
              is an intermediary that only has the same registered name as the real server.

              For example, if you have started a slave node <u>N</u> and want to execute  <u>pxw</u>  graphics  code  on  this
              node, you can start server <u>pxw_server</u> as a pseudo server at the slave node. This is illustrated as
              follows:

              rpc:call(N, slave, pseudo, [node(), [pxw_server]]).

       <b>relay(Pid)</b> <b>-&gt;</b> <b>no_return()</b>

              Types:

                 Pid = pid()

              Runs  a  pseudo  server.  This  function never returns any value and the process that executes the
              function receives messages. All messages received are simply passed on to <u>Pid</u>.

       <b>start(Host)</b> <b>-&gt;</b> <b>{ok,</b> <b>Node}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

       <b>start(Host,</b> <b>Name)</b> <b>-&gt;</b> <b>{ok,</b> <b>Node}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

       <b>start(Host,</b> <b>Name,</b> <b>Args)</b> <b>-&gt;</b> <b>{ok,</b> <b>Node}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Host = inet:hostname()
                 Name = atom() | string()
                 Args = string()
                 Node = node()
                 Reason = timeout | no_rsh | {already_running, Node}

              Starts a slave node on host <u>Host</u>. Host names need not necessarily be specified as fully  qualified
              names;  short  names  can  also  be  used.  This  is  the  same condition that applies to names of
              distributed Erlang nodes.

              The name of the started node becomes <u>Name@Host</u>. If no name is provided, the name becomes the  same
              as the node that executes the call (except the host name part of the node name).

              The  slave  node resets its <u>user</u> process so that all terminal I/O that is produced at the slave is
              automatically relayed to the master. Also, the file process is relayed to the master.

              Argument <u>Args</u> is used to set <u>erl</u> command-line arguments. If provided, it is passed to the new node
              and can be used for a variety of purposes; see <u><a href="../man1/erl.1.html">erl</a>(1)</u>.

              As an example, suppose that you want to start a slave node at host <u>H</u> with  node  name  <u>Name@H</u>  and
              want the slave node to have the following properties:

                * Directory <u>Dir</u> is to be added to the code path.

                * The Mnesia directory is to be set to <u>M</u>.

                * The Unix <u>DISPLAY</u> environment variable is to be set to the display of the master node.

              The following code is executed to achieve this:

              E = " -env DISPLAY " ++ net_adm:localhost() ++ ":0 ",
              Arg = "-mnesia_dir " ++ M ++ " -pa " ++ Dir ++ E,
              slave:start(H, Name, Arg).

              The  function  returns  <u>{ok,</u>  <u>Node}</u>,  where  <u>Node</u>  is  the name of the new node, otherwise <u>{error,</u>
              <u>Reason}</u>, where <u>Reason</u> can be one of:

                <u>timeout</u>:
                  The master node failed to get in contact with the slave node. This can occur in  a  number  of
                  circumstances:

                  * Erlang/OTP is not installed on the remote host.

                  * The file system on the other host has a different structure to the the master.

                  * The Erlang nodes have different cookies.

                <u>no_rsh</u>:
                  No  remote shell program was found on the computer. Note that <u>ssh</u> is used by default, but this
                  can be overridden with the <u>-rsh</u> flag.

                <u>{already_running,</u> <u>Node}</u>:
                  A node with name <u>Name@Host</u> already exists.

       <b>start_link(Host)</b> <b>-&gt;</b> <b>{ok,</b> <b>Node}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

       <b>start_link(Host,</b> <b>Name)</b> <b>-&gt;</b> <b>{ok,</b> <b>Node}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

       <b>start_link(Host,</b> <b>Name,</b> <b>Args)</b> <b>-&gt;</b> <b>{ok,</b> <b>Node}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Host = inet:hostname()
                 Name = atom() | string()
                 Args = string()
                 Node = node()
                 Reason = timeout | no_rsh | {already_running, Node}

              Starts a slave node in the same way as <u>start/1,2,3</u>, except that the slave node is  linked  to  the
              currently executing process. If that process terminates, the slave node also terminates.

              For a description of arguments and return values, see <u>start/1,2,3</u>.

       <b>stop(Node)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Node = node()

              Stops (kills) a node.

Ericsson AB                                        stdlib 3.17                                       <u><a href="../man3erl/slave.3erl.html">slave</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>