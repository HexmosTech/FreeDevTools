<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Template::Plugin::Gettext - Gettext Support For the Template Toolkit Version 2</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtemplate-plugin-gettext-perl">libtemplate-plugin-gettext-perl_1.0-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Template::Plugin::Gettext - Gettext Support For the Template Toolkit Version 2

</pre><h4><b>SYNOPSIS</b></h4><pre>
       Load the plug-in in templates:

           [% USE Gettext('com.textdomain.my', 'fr', 'utf-8', 'DIRECTORIES'...) %]
           [% Gettext.gettext('Hello, world!') %]

           [% 'Hello, world!' | gettext %]

       Or alias "Gettext":

           [% USE gtx = Gettext('com.textdomain.my', 'fr', 'utf-8', 'DIRECTORIES'...) %]
           [% gtx.gettext('Hello, world!') %]

       Use method invocations:

           [% Gettext.gettext("Hello, world!") %]
           [% Gettext.xgettext("Hello, {name}!", name =&gt; 'John Doe') %]

       Or filters (without the prefix):

           [% FILTER gettext %]
           Hello, world!
           [% END %]

           [% 'Hello, world!' | gettext %]

           [% FILTER xgettext(name =&gt; 'John Doe') %]
           Hello, {name}!
           [% END %]

       You have a multitude of methods available:

           [% gtx.gettext("Hello, user!") %]
           [% gtx.xgettext("Hello, {user}!", user =&gt; 'John Doe') %]
           [% gtx.ngettext("One document deleted.",
                           "Multiple documents deleted."),
                           42) %]
           [% gtx.nxgettext("One document deleted.",
                            "{num} documents deleted."),
                            42,
                            num =&gt; 42) %]
           [% gtx.npgettext("context..."
                            "One document deleted.",
                            "Multiple documents deleted."),
                            42) %]
           [% gtx.npxgettext("context...",
                             "One document deleted.",
                             "{num} documents deleted."),
                             42,
                             num =&gt; 42) %]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <b>Template::Plugin::Gettext</b> plug-in makes the GNU gettext API &lt;https://www.gnu.org/software/gettext/&gt;
       available for documents using the Template Toolkit version 2 &lt;<a href="http://template-toolkit.org/">http://template-toolkit.org/</a>&gt;.  See
       &lt;https://github.com/gflohr/Template-Plugin-Gettext&gt; for an overall picture and the recommended tool-
       chain.

</pre><h4><b>FUNCTIONS</b></h4><pre>
       The following methods produce translatable content:

       <b>[%</b> <b>gtx.gettext(STRING)</b> <b>%]</b>
           Retrieves the translation for <b>STRING</b>.

       <b>[%</b> <b>gtx.xgettext(STRING,</b> <b>PLACEHOLDER1</b> <b>=&gt;</b> <b>VALUE1,</b> <b>PLACEHOLDER2</b> <b>=&gt;</b> <b>VALUE2,</b> <b>...)</b> <b>%]</b>
           Gets  the  translation  for a string with placeholders and interpolates values into it.  Placeholders
           have the format &lt;{PLACEHOLDER}&gt;.  For a literal left curly brace you can use this hack:

               [% gtx.xgettext("String with {LBRACE}PLACEHOLDERS{RBRACE}",
                               LBRACE =&gt; "{", RBRACE =&gt; "}") %]

       <b>[%</b> <b>gtx.pgettext(CONTEXT,</b> <b>STRING)</b> <b>%]</b>
           Retrieves the translation for  <b>STRING</b>  in  context  <b>CONTEXT</b>.   You  should  use  message  context  to
           disambiguate  identical  strings  that  require different translations depending on the context.  See
           this example for an explanation:

               [% gtx.gettext("State: ") %]
                   [% gtx.gettext("Open")] | [% gtx.gettext("Close") %]

               [% gtx.gettext("Menu:") %]
                   [% gtx.pgettext("menu", "Open")]
                   [% gtx.gettext("Save")]
                   [% gtx.gettext("Save As")]
                   [% gtx.pgettext("menu", "Close")]

           The strings "Open" and "Close" in line 2 are adjectives. As
            menu entries they are verb forms and will have a different
            translation in many languages.

            In doubt: Only use contexts if one of your translators complains
            about a message having multiple meanings.

       <b>[%</b> <b>gtx.pxgettext(CONTEXT,</b> <b>STRING,</b> <b>PLACEHOLDER1</b> <b>=&gt;</b> <b>VALUE1,</b> <b>PLACEHOLDER2</b> <b>=&gt;</b> <b>VALUE2)</b> <b>%]</b>
           Get the translation for  <b>STRING</b>  with  placeholders  in  context  <b>CONTEXT</b>.   This  is  a  mixture  of
           "xgettext()" and "pgettext()" above.

       <b>[%</b> <b>gtx.nxgettext(SINGULAR,</b> <b>PLURAL,</b> <b>COUNT,</b> <b>PLACEHOLDER1</b> <b>=&gt;</b> <b>VALUE1,</b> <b>PLACEHOLDER2</b> <b>=&gt;</b> <b>VALUE2)</b> <b>%]</b>
           Retrieves  the translation for the string with the singular form <b>SINGULAR</b> and the plural from <b>PLURAL</b>,
           both possibly containing placeholders.  The correct form is picked  based  upon  the  third  argument
           <b>COUNT</b>.

           Example:

               [% gtx.nxgettext("One document deleted",
                                "{num} documents deleted"),
                                count,
                                num =&gt; count) %]

           In  English this will produce "42 documents deleted" if the variable count has the value 42.  It will
           produce "One document deleted" if the variable count has the value 1.

           In other languages, the rules for plural forms may be a lot simpler (for example Chinese,  which  has
           no  plural)  or  a lot more complicated (for example Russian with two or Slovenian with even 3 plural
           forms).  Using <b>ngettext()</b>  gives  your  translators  the  chance  to  provide  syntactically  correct
           translations for these cases.

       <b>[%</b> <b>gtx.npxgettext(CONTEXT,</b> <b>SINGULAR,</b> <b>PLURAL,</b> <b>COUNT,</b> <b>PLACEHOLDER1</b> <b>=&gt;</b> <b>VALUE1,</b> <b>PLACEHOLDER2</b> <b>=&gt;</b> <b>VALUE2)</b> <b>%]</b>
           Putting  it  all together:  For message context <b>CONTEXT</b> the translation for a message in <b>SINGULAR</b> and
           <b>PLURAL</b> is retrieved based on the argument <b>COUNT</b>.  Possible placeholders are expanded.

           The function is a mixture of <b>xgettext()</b>, <b>ngettext()</b>, and <b>pgettext()</b>, see above!

       <b>[%</b> <b>gtx.ngettext(SINGULAR,</b> <b>PLURAL,</b> <b>COUNT)</b> <b>%]</b>
           Useless function, provided for completeness.  Use <b>nxgettext()</b> instead, so that  you  can  interpolate
           the value of <b>COUNT</b>!

       <b>[%</b> <b>gtx.npgettext(CONTEXT,</b> <b>SINGULAR,</b> <b>PLURAL,</b> <b>COUNT)</b> <b>%]</b>
           Useless  function,  provided for completeness.  Use <b>npxgettext()</b> instead, so that you can interpolate
           the value of <b>COUNT</b>!

       In fact, you have also all the keywords used for "FILTERS" available but those not listed here have  such
       an odd ordering of arguments that they are not listed here.

   <b>FILTERS</b>
       The entire gettext API is also exposed as a filter.  There are two things to note here:

       •   When  used  as  filters, you don't prefix the method names.  It' s "gettext" not "Gettext.gettext" or
           "gtx.<b>gettext()</b>".

       •   The filters with message contexts have rather strange names, for example:

               [% FILTER gettextp("greeting") %]
               Hello, world!
               [% END %]

               or 100 % equivalent:

               [% 'Hello, world!' | gettextp("greeting") %]

           Why? The text between <b>FILTER</b> and <b>END</b> resp. the text in front of the pipe symbol <b>|</b> is always the first
           argument.  This plug-in therefore tries to make the first argument the most significant one.   Nobody
           stops you from writing the following:

               [% FILTER pgettext("Hello, world!") %]
               greeting
               [% END %]

               or again 100 % equivalent:

               [% 'greeting' | pgettext("Hello, world!") %]

           It produces exactly the same results as above but it looks a little bit odd, doesn't it?

           It  would  have been arguably better understandable to silently reorder the arguments, when using the
           plug-in  as  a  filter.   But  it  would  break  extraction  of  your   strings   with   xgettext-tt2
           (Locale::XGettext::TT2) because the string extractor would then confuse the arguments.

           But  stay  relaxed! Message contexts are rarely needed, and when you need them, you have to live with
           this little weirdness.

           In order to avoid confusion, those filters that would  not  have  the  translatable  string  (in  the
           singular form) where one would expect it, are not documented here.

       You can use the following filters:

       <b>[%</b> <b>STRING</b> <b>|</b> <b>gettext</b> <b>%]</b>
       <b>[%</b> <b>FILTER</b> <b>gettext</b> <b>%]STRING[%</b> <b>FILTER</b> <b>%]</b>
           Retrieves the translation for <b>STRING</b>.

       <b>[%</b> <b>STRING</b> <b>|</b> <b>xgettext(PLACEHOLDER1</b> <b>=&gt;</b> <b>VALUE1,</b> <b>PLACEHOLDER2</b> <b>=&gt;</b> <b>VALUE2,</b> <b>...)</b> <b>%]</b>
       <b>[%</b> <b>FILTER</b> <b>xgettext(PLACEHOLDER1</b> <b>=&gt;</b> <b>VALUE1,</b> <b>PLACEHOLDER2</b> <b>=&gt;</b> <b>VALUE2,</b> <b>...)</b> <b>%]STRING[%</b> <b>END</b> <b>%]</b>
           Gets  the  translation  for a string with placeholders and interpolates values into it.  Placeholders
           have the format &lt;{PLACEHOLDER}&gt;.  For a literal left curly brace you can use this hack:

               [% "String with {LBRACE}PLACEHOLDERS{RBRACE}" | xgettext(LBRACE =&gt; "{", RBRACE =&gt; "}") %]

       <b>[%</b> <b>STRING</b> <b>|</b> <b>gettextp(CONTEXT)</b> <b>%]</b>
       <b>[%</b> <b>FILTER</b> <b>gettextp(CONTEXT)</b> <b>%]STRING[%</b> <b>END</b> <b>%]</b>
           Retrieves the translation for  <b>STRING</b>  in  context  <b>CONTEXT</b>.   You  should  use  message  context  to
           disambiguate  identical strings that require different translations depending on the context. See the
           docuemntation for <b>pgettext()</b> in "FUNCTIONS" above for more details!

       <b>[%</b> <b>STRING</b> <b>|</b> <b>xgettextp(CONTEXT,</b> <b>STRING,</b> <b>PLACEHOLDER1</b> <b>=&gt;</b> <b>VALUE1,</b> <b>PLACEHOLDER2</b> <b>=&gt;</b> <b>VALUE2)</b> <b>%]</b>
       <b>[%</b> <b>FILTER</b> <b>xgettextp(CONTEXT,</b> <b>STRING,</b> <b>PLACEHOLDER1</b> <b>=&gt;</b> <b>VALUE1,</b> <b>PLACEHOLDER2</b> <b>=&gt;</b> <b>VALUE2)</b> <b>%]STRING[%</b> <b>END</b> <b>%]</b>
           Get the translation for  <b>STRING</b>  with  placeholders  in  context  <b>CONTEXT</b>.   This  is  a  mixture  of
           "xgettext()" and "pgettext()" above.

       <b>[%</b> <b>SINGULAR</b> <b>|</b> <b>nxgettext(PLURAL,</b> <b>COUNT,</b> <b>PLACEHOLDER1</b> <b>=&gt;</b> <b>VALUE1,</b> <b>PLACEHOLDER2</b> <b>=&gt;</b> <b>VALUE2)</b> <b>%]</b>
       <b>[%</b> <b>FILTER</b> <b>nxgettext(PLURAL,</b> <b>COUNT,</b> <b>PLACEHOLDER1</b> <b>=&gt;</b> <b>VALUE1,</b> <b>PLACEHOLDER2</b> <b>=&gt;</b> <b>VALUE2)</b> <b>%]SINGULAR[%</b> <b>END</b> <b>%]</b>
           Retrieves  the translation for the string with the singular form <b>SINGULAR</b> and the plural from <b>PLURAL</b>,
           both possibly containing placeholders.  The correct form is picked  based  upon  the  third  argument
           <b>COUNT</b>.

           Example:

               [% "One document deleted" | nxgettext("{num} documents deleted"),
                                                     count,
                                                     num =&gt; count) %]

           In  English this will produce "42 documents deleted" if the variable count has the value 42.  It will
           produce "One document deleted" if the variable count has the value 1.

           In other languages, the rules for plural forms may be a lot simpler (for example Chinese,  which  has
           no  plural)  or  a lot more complicated (for example Russian with two or Slovenian with even 3 plural
           forms).  Using <b>ngettext()</b>  gives  your  translators  the  chance  to  provide  syntactically  correct
           translations for these cases.

       <b>[%</b> <b>SINGULAR</b> <b>|</b> <b>nxgettextp(PLURAL,</b> <b>COUNT,</b> <b>CONTEXT,</b> <b>PLACEHOLDER1</b> <b>=&gt;</b> <b>VALUE1,</b> <b>PLACEHOLDER2</b> <b>=&gt;</b> <b>VALUE2)</b> <b>%]</b>
       <b>[%</b> <b>FILTER</b> <b>nxgettextp(PLURAL,</b> <b>COUNT,</b> <b>CONTEXT,</b> <b>PLACEHOLDER1</b> <b>=&gt;</b> <b>VALUE1,</b> <b>PLACEHOLDER2</b> <b>=&gt;</b> <b>VALUE2)</b> <b>%]SINGULAR[%</b>
       <b>END</b> <b>%]</b>
           Putting  it  all together:  For message context <b>CONTEXT</b> the translation for a message in <b>SINGULAR</b> and
           <b>PLURAL</b> is retrieved based on the argument <b>COUNT</b>.  Possible placeholders are expanded.

           The filter is a mixture of <b>xgettext()</b>, <b>ngettext()</b>, and <b>pgettext()</b>, see above!

       <b>[%</b> <b>SINGULAR</b> <b>|</b> <b>ngettext(PLURAL,</b> <b>COUNT)</b> <b>%]</b>
       <b>[%</b> <b>FILTER</b> <b>ngettext(PLURAL,</b> <b>COUNT)</b> <b>%]SINGULAR[%</b> <b>END</b> <b>%]</b>
           Useless filter, provided for completeness.  Use <b>nxgettext()</b> instead, so that you can interpolate  the
           value of <b>COUNT</b>!

       <b>[%</b> <b>SINGULAR</b> <b>|</b> <b>ngettextp[(PLURAL,</b> <b>COUNT,</b> <b>CONTEXT)</b> <b>%]</b>
       <b>[%</b> <b>FILTER</b> <b>|</b> <b>ngettextp[(PLURAL,</b> <b>COUNT,</b> <b>CONTEXT)</b> <b>%]SINGULAR[%</b> <b>END</b> <b>%]</b>
           Useless filter, provided for completeness.  Use <b>nxgettextp()</b> instead, so that you can interpolate the
           value of <b>COUNT</b>!

       <b>[%</b> <b>debug_locale</b> <b>%]</b>
           The  plug-in  implicitly calls <b>web_set_locale()</b> (see Locale::Util) if a language was specified in the
           <b>USE</b> statement.  The function <b>debug_locale()</b> gives you the return value  of  the  call  for  debugging
           purposes.  Example:

               [% USE gtx = Gettext('com.mydomain.www', de') %]

               Using locale [% debug_locale() %].

           This way, you can determine whether setting the specified locale actually worked.

</pre><h4><b>CLASS</b> <b>METHODS</b></h4><pre>
       <b>textdomains</b>
           Returns  a  hash  where the keys are the textdomains found in templates that invoked the plug-in, and
           the values are the corresponding template file names.

           The purpose of this method is to allow harvesting files that should be processed by xgettext-tt2.

           If  the  template  is  either  "input  text"  or  "input  file   handle",   the   template   variable
           "gettext_filename"  -  if  existing  -  is assumed as the template name.  Rationale: "input text" and
           "input file handle" are used by the Template Toolkit as aliases, when reading from a scalar or a file
           handle.

       <b>resetTextdomains</b>
           Resets the hash described above for <b>textdomain()</b> to its initial, empty state.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (C) 2016-2018 Guido Flohr (<a href="http://www.guido-flohr.net/">http://www.guido-flohr.net/</a>).  License LGPLv3+: GNU  General  Public
       License  version  3 or later &lt;<a href="http://gnu.org/licenses/lgpl.html">http://gnu.org/licenses/lgpl.html</a>&gt;.  This is free software: you are free to
       change and redistribute it.  There is NO WARRANTY,  to  the  extent  permitted  by  law.   Copyright  (C)
       2016-2018 Guido Flohr &lt;<a href="mailto:guido.flohr@cantanea.com">guido.flohr@cantanea.com</a>&gt;, all rights reserved.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Template, Template::Manual::Filters, xgettext-tt2, perl

perl v5.36.0                                       2023-07-21                     <u>Template::Plugin::<a href="../man3pm/Gettext.3pm.html">Gettext</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>