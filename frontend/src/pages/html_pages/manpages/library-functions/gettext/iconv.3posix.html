<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-posix-dev">manpages-posix-dev_2017a-2_all</a> <br><br><pre>
</pre><h4><b>PROLOG</b></h4><pre>
       This  manual  page  is part of the POSIX Programmer's Manual.  The Linux implementation of this interface
       may differ (consult the corresponding Linux manual page for details of Linux behavior), or the  interface
       may not be implemented on Linux.

</pre><h4><b>NAME</b></h4><pre>
       iconv — codeset conversion function

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;<a href="file:/usr/include/iconv.h">iconv.h</a>&gt;

       size_t iconv(iconv_t <u>cd</u>, char **restrict <u>inbuf</u>,
           size_t *restrict <u>inbytesleft</u>, char **restrict <u>outbuf</u>,
           size_t *restrict <u>outbytesleft</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <u>iconv</u>() function shall convert the sequence of characters from one codeset, in the array specified by
       <u>inbuf</u>,  into a sequence of corresponding characters in another codeset, in the array specified by <u>outbuf</u>.
       The codesets are those specified in the <u>iconv_open</u>() call that returned the  conversion  descriptor,  <u>cd</u>.
       The  <u>inbuf</u>  argument  points  to  a  variable  that points to the first character in the input buffer and
       <u>inbytesleft</u> indicates the number of bytes to the end of the buffer to be converted. The  <u>outbuf</u>  argument
       points  to  a  variable  that  points  to  the first available byte in the output buffer and <u>outbytesleft</u>
       indicates the number of the available bytes to the end of the buffer.

       For state-dependent encodings, the conversion descriptor <u>cd</u> is placed into its initial shift state  by  a
       call  for  which  <u>inbuf</u>  is  a null pointer, or for which <u>inbuf</u> points to a null pointer. When <u>iconv</u>() is
       called in this way, and if <u>outbuf</u> is not a null pointer or a pointer to a null pointer, and  <u>outbytesleft</u>
       points  to a positive value, <u>iconv</u>() shall place, into the output buffer, the byte sequence to change the
       output buffer to its initial shift state. If the output buffer is not large enough  to  hold  the  entire
       reset sequence, <u>iconv</u>() shall fail and set <u>errno</u> to <b>[E2BIG]</b>.  Subsequent calls with <u>inbuf</u> as other than a
       null  pointer or a pointer to a null pointer cause the conversion to take place from the current state of
       the conversion descriptor.

       If a sequence of input bytes does not form a valid character in the specified codeset,  conversion  shall
       stop  after  the  previous  successfully converted character. If the input buffer ends with an incomplete
       character or shift sequence, conversion shall stop after the previous successfully  converted  bytes.  If
       the  output  buffer  is  not  large enough to hold the entire converted input, conversion shall stop just
       prior to the input bytes that would cause the output buffer to overflow. The variable pointed to by <u>inbuf</u>
       shall be updated to point to the byte following the last byte successfully used in  the  conversion.  The
       value  pointed  to by <u>inbytesleft</u> shall be decremented to reflect the number of bytes still not converted
       in the input buffer. The variable pointed to by <u>outbuf</u> shall be updated to point to  the  byte  following
       the  last  byte  of  converted  output data. The value pointed to by <u>outbytesleft</u> shall be decremented to
       reflect the number of bytes still available in the output  buffer.  For  state-dependent  encodings,  the
       conversion  descriptor  shall  be  updated  to  reflect  the shift state in effect at the end of the last
       successfully converted byte sequence.

       If <u>iconv</u>() encounters a character in the input buffer that is valid, but for which an identical character
       does not exist in the target codeset, <u>iconv</u>() shall perform an implementation-defined conversion on  this
       character.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       The  <u>iconv</u>() function shall update the variables pointed to by the arguments to reflect the extent of the
       conversion and return the number of non-identical conversions performed. If  the  entire  string  in  the
       input  buffer  is  converted,  the value pointed to by <u>inbytesleft</u> shall be 0. If the input conversion is
       stopped due to any conditions mentioned above, the value pointed to by <u>inbytesleft</u> shall be non-zero  and
       <u>errno</u> shall be set to indicate the condition. If an error occurs, <u>iconv</u>() shall return (<b>size_t</b>)-1 and set
       <u>errno</u> to indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       The <u>iconv</u>() function shall fail if:

       <b>EILSEQ</b> Input conversion stopped due to an input byte that does not belong to the input codeset.

       <b>E2BIG</b>  Input conversion stopped due to lack of space in the output buffer.

       <b>EINVAL</b> Input  conversion stopped due to an incomplete character or shift sequence at the end of the input
              buffer.

       The <u>iconv</u>() function may fail if:

       <b>EBADF</b>  The <u>cd</u> argument is not a valid open conversion descriptor.

       <u>The</u> <u>following</u> <u>sections</u> <u>are</u> <u>informative.</u>

</pre><h4><b>EXAMPLES</b></h4><pre>
       None.

</pre><h4><b>APPLICATION</b> <b>USAGE</b></h4><pre>
       The <u>inbuf</u> argument indirectly points to the memory area which contains the  conversion  input  data.  The
       <u>outbuf</u>  argument  indirectly  points to the memory area which is to contain the result of the conversion.
       The objects indirectly pointed to by <u>inbuf</u> and <u>outbuf</u> are not  restricted  to  containing  data  that  is
       directly  representable in the ISO C standard language <b>char</b> data type. The type of <u>inbuf</u> and <u>outbuf</u>, <b>char</b>
       <b>**</b>, does not imply that the objects pointed to are interpreted as null-terminated C strings or arrays  of
       characters.  Any  interpretation  of a byte sequence that represents a character in a given character set
       encoding scheme is done internally within the codeset  converters.  For  example,  the  area  pointed  to
       indirectly  by  <u>inbuf</u>  and/or  <u>outbuf</u>  can  contain  all  zero  octets that are not interpreted as string
       terminators but as coded character data according to the respective codeset encoding scheme. The type  of
       the  data  (<b>char</b>,  <b>short</b>,  <b>long</b>,  and  so  on) read or stored in the objects is not specified, but may be
       inferred for both the input and output data by the converters  determined  by  the  <u>fromcode</u>  and  <u>tocode</u>
       arguments of <u>iconv_open</u>().

       Regardless  of the data type inferred by the converter, the size of the remaining space in both input and
       output objects (the <u>intbytesleft</u> and <u>outbytesleft</u> arguments) is always measured in bytes.

       For implementations that support the conversion of state-dependent encodings, the  conversion  descriptor
       must  be  able  to  accurately  reflect  the  shift-state  in  effect  at  the end of the last successful
       conversion. It is not required that the conversion descriptor itself be updated, which would  require  it
       to  be a pointer type. Thus, implementations are free to implement the descriptor as a handle (other than
       a pointer type) by which the conversion information can be accessed and updated.

</pre><h4><b>RATIONALE</b></h4><pre>
       None.

</pre><h4><b>FUTURE</b> <b>DIRECTIONS</b></h4><pre>
       None.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u>iconv_open</u>(), <u>iconv_close</u>(), <u>mbsrtowcs</u>()

       The Base Definitions volume of POSIX.1‐2017, <b>&lt;iconv.h&gt;</b>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Portions of this text are reprinted and reproduced in electronic form from IEEE Std 1003.1-2017, Standard
       for Information  Technology  --  Portable  Operating  System  Interface  (POSIX),  The  Open  Group  Base
       Specifications  Issue  7, 2018 Edition, Copyright (C) 2018 by the Institute of Electrical and Electronics
       Engineers, Inc and The Open Group.  In the event of any discrepancy between this version and the original
       IEEE and The Open Group Standard, the original IEEE and The Open Group Standard is the referee  document.
       The original Standard can be obtained online at <a href="http://www.opengroup.org/unix/online.html">http://www.opengroup.org/unix/online.html</a> .

       Any  typographical  or formatting errors that appear in this page are most likely to have been introduced
       during  the  conversion  of  the  source  files  to  man  page  format.  To  report  such   errors,   see
       https://www.kernel.org/doc/man-pages/reporting_bugs.html .

IEEE/The Open Group                                   2017                                         <u><a href="../man3POSIX/ICONV.3POSIX.html">ICONV</a></u>(3POSIX)
</pre>
 </div>
</div></section>
</div>
</body>
</html>