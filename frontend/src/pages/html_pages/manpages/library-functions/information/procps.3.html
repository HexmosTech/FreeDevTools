<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>procps - API to access system level information in the /proc filesystem</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/procps">procps_4.0.4-8ubuntu2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       procps - API to access system level information in the <a href="file:/proc">/proc</a> filesystem

</pre><h4><b>SYNOPSIS</b></h4><pre>
       Five  distinct  interfaces  are represented in this synopsis and named after the files they access in the
       <a href="file:/proc">/proc</a> pseudo filesystem: <b>diskstats</b>, <b>meminfo</b>, <b>slabinfo</b>, <b>stat</b> and <b>vmstat</b>.

           #include &lt;libproc2/<b>named_interface</b>.h&gt;

           int <b>procps_new</b>   (struct info **<u>info</u>);
           int <b>procps_ref</b>   (struct info  *<u>info</u>);
           int <b>procps_unref</b> (struct info **<u>info</u>);

           struct result *<b>procps_get</b> (
               struct info *<u>info</u>,
           [   const char *<u>name</u>,      ]   <b>diskstats</b> api only
               enum item <u>item</u>);

           struct stack *<b>procps_select</b> (
               struct info *<u>info</u>,
           [   const char *<u>name</u>,      ]   <b>diskstats</b> api only
               enum item *<u>items</u>,
               int <u>numitems</u>);

           struct reaped *<b>procps_reap</b> (
               struct info *<u>info</u>,
           [   enum reap_type <u>what</u>,   ]   <b>stat</b> api only
               enum item *<u>items</u>,
               int <u>numitems</u>);

           struct stack **<b>procps_sort</b> (
               struct info *<u>info</u>,
               struct stack *<u>stacks</u>[],
               int <u>numstacked</u>,
               enum item <u>sortitem</u>,
               enum sort_order <u>order</u>);

           The above functions and structures are generic but the specific <b>named_interface</b> would also be part of
           any identifiers.  For example, `procps_new' would actually be `procps_<b>meminfo</b>_new' and  `info'  would
           really be `<b>diskstats</b>_info', etc.

           The same <b>named_interface</b> is used in each header file name with an appended `.h' suffix.

           Link with <u>-lproc2</u>.

</pre><h4><b>DESCRIPTION</b></h4><pre>
   <b>Overview</b>
       Central  to  these  interfaces  is  a simple `result' structure reflecting an `item' plus its value (in a
       union with standard C language types as members).  All `result' structures  are  automatically  allocated
       and provided by the library.

       By  specifying  an array of `items', these structures can be organized as a `stack', potentially yielding
       many results with a single function call.  Thus, a `stack' can be viewed  as  a  variable  length  record
       whose content and order is determined solely by the user.

       As  part  of each interface there are two unique enumerators.  The `noop' and `extra' items exist to hold
       user values.  They are never set by the library, but the `extra' result will be zeroed with each  library
       interaction.

       The <b>named_interface</b> header file will be an essential document during user program development.  There you
       will  find  available  items, their return type (the `result' struct member name) and the source for such
       values.  Additional enumerators and structures are also documented there.

   <b>Usage</b>
       The following would be a typical sequence of calls to these interfaces.

       1. <b>procps_new()</b>
       2. <b>procps_get()</b>, <b>procps_select()</b> or <b>procps_reap()</b>
       3. <b>procps_unref()</b>

       The <b>get</b> function is used to retrieve a `result' structure for a  single  `item'.   Alternatively,  a  <b>GET</b>
       macro is available when only the return value is of interest.

       The <b>select</b> function can retrieve multiple `result' structures in a single `stack'.

       For  unpredictable variable outcomes, the <b>diskstats</b>, <b>slabinfo</b> and <b>stat</b> interfaces export a <b>reap</b> function.
       It is used to retrieve multiple `stacks' each containing multiple  `result'  structures.   Optionally,  a
       user may choose to <b>sort</b> those results.

       To  exploit  any `stack', and access individual `result' structures, a <u>relative_enum</u> is required as shown
       in the <b>VAL</b> macro defined in the header file.  Such values could be hard coded as: 0  through  numitems-1.
       However,  this need is typically satisfied by creating your own enumerators corresponding to the order of
       the `items' array.

   <b>Caveats</b>
       The <b>new</b>, <b>ref</b>, <b>unref</b>, <b>get</b> and <b>select</b> functions are available in all five interfaces.

       For the <b>new</b> and <b>unref</b> functions, the address of an <u>info</u> struct pointer must be  supplied.   With  <b>new</b>  it
       must  have  been initialized to NULL.  With <b>unref</b> it will be reset to NULL if the reference count reaches
       zero.

       In the case of the <b>diskstats</b> interface, a <u>name</u> parameter on the <b>get</b> and  <b>select</b>  functions  identifies  a
       disk or partition name

       For  the  <b>stat</b>  interface, a <u>what</u> parameter on the <b>reap</b> function identifies whether data for just CPUs or
       both CPUs and NUMA nodes is to be gathered.

       When using the <b>sort</b> function, the parameters <u>stacks</u> and <u>numstacked</u> would normally be  those  returned  in
       the `reaped' structure.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
   <b>Functions</b> <b>Returning</b> <b>an</b> <b>`int'</b>
       An  error  will  be  indicated by a negative number that is always the inverse of some well known errno.h
       value.

       Success is indicated by a zero return value.  However, the <b>ref</b> and <b>unref</b>  functions  return  the  current
       <u>info</u> structure reference count.

   <b>Functions</b> <b>Returning</b> <b>an</b> <b>`address'</b>
       An error will be indicated by a NULL return pointer with the reason found in the formal errno value.

       Success is indicated by a pointer to the named structure.

</pre><h4><b>DEBUGGING</b></h4><pre>
       To aid in program development, there is a provision that can help ensure `result' member references agree
       with  library  expectations.   It  assumes that a supplied macro in the header file is used to access the
       `result' value.

       This feature can be activated through either of the following  methods  and  any  discrepancies  will  be
       written to <b>stderr</b>.

       1) Add CFLAGS='-DXTRA_PROCPS_DEBUG' to any other ./configure options employed.

       2) Add #include &lt;procps/xtra-procps-debug.h&gt; to any program <u>after</u> the named interface includes.

       This  verification  feature  incurs  substantial  overhead.   Therefore,  it  is important that it <u>not</u> be
       activated for a production/release build.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/procps_misc.3.html">procps_misc</a></b>(3), <b><a href="../man3/procps_pids.3.html">procps_pids</a></b>(3), <b><a href="../man5/proc.5.html">proc</a></b>(5).

libproc2                                           August 2022                                         <u><a href="../man3/PROCPS.3.html">PROCPS</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>