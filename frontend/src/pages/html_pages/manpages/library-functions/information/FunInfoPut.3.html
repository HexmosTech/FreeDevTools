<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FunInfoPut - put information into a Funtools struct</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libfuntools-dev">libfuntools-dev_1.4.8-1.1build2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       FunInfoPut - put information into a Funtools struct

</pre><h4><b>SYNOPSIS</b></h4><pre>
         #include &lt;funtools.h&gt;

         int FunInfoPut(Fun fun, int type, char *addr, ...)

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <u><b>FunInfoPut()</b></u>  routine  puts  information  into  a Funtools structure.  The first argument is the Fun
       handle from which information is to be retrieved.  After this first required argument  comes  a  variable
       length  list of pairs of arguments. Each pair consists of an integer representing the type of information
       to store and the address of the new information to store in the struct. The variable list  is  terminated
       by a 0.  The routine returns the number of put actions performed.

       The  full list of available information is described above with the <u>FunInfoPut()</u> routine. Although use of
       this routine is expected to be uncommon, there is one important situation in which it plays an  essential
       part: writing multiple extensions to a single output file.

       For  input, multiple extensions are handled by calling <u>FunOpen()</u> for each extension to be processed. When
       opening multiple inputs, it sometimes is the case that you will want to process them and then write  them
       (including  their  header  parameters)  to a single output file.  To accomplish this, you open successive
       input extensions using <u>FunOpen()</u> and then call <u><b>FunInfoPut()</b></u> to set the Funtools reference handle  of  the
       output file to that of the newly opened input extension:

         /* open a new input extension */
         ifun=FunOpen(tbuf, "r", NULL)) )
         /* make the new extension the reference handle for the output file */
         FunInfoPut(ofun, FUN_IFUN, &amp;ifun, 0);

       Resetting  FUN_IFUN  has  same  effect  as  when  a  funtools  handle  is passed as the final argument to
       <u>FunOpen()</u>.  The state of the output file is reset so that a new extension is ready to be written.   Thus,
       the next I/O call on the output extension will output the header, as expected.

       For  example,  in  a binary table, after resetting FUN_IFUN you can then call <u>FunColumnSelect()</u> to select
       the     columns     for     output.     When     you     then     call      <u>FunImagePut()</u>      or      &lt;A
       HREF="./library.html#funtablerowput"&gt;<u>FunTableRowPut()</u>,  a new extension will be written that contains the
       header parameters from the reference extension. Remember to call <u>FunFlush()</u> to complete output of a given
       extension.

       A complete example of this capability is given in the evcol example code.  The central algorithm is:

       •   open the output file without a reference handle

       •   loop: open each input extension in turn

           •   set the reference handle for output to the newly opened input extension

           •   read the input rows or image and perform processing

           •   write new rows or image to the output file

           •   flush the output

           •   close input extension

       •   close output file

       Note that <u>FunFlush()</u> is called after processing each input extension in order to ensure that  the  proper
       padding  is  written  to the output file.  A call to <u>FunFlush()</u> also ensures that the extension header is
       written to the output file in the case where there are no rows to output.

       If you wish to output  a  new  extension  without  using  a  Funtools  reference  handle,  you  can  call
       <u>FunInfoPut()</u>   to  reset  the  FUN_OPS  value  directly.   For  a  binary  table,  you  would  then  call
       <u>FunColumnSelect()</u> to set up the columns for this new extension.

         /* reset the operations performed on this handle */
         int ops=0;
         FunInfoPut(ofun, FUN_OPS, &amp;ops, 0);
         FunColumnSelect(fun, sizeof(EvRec), NULL,
                         "MYCOL", "J", "w", FUN_OFFSET(Ev, mycol),
                         NULL);

       Once the FUN_OPS variable has been reset, the next I/O call on  the  output  extension  will  output  the
       header, as expected.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       See <a href="../man7/funtools.7.html">funtools</a>(7) for a list of Funtools help pages

version 1.4.5                                    April 14, 2011                                    <u><a href="../man3/funinfoput.3.html">funinfoput</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>