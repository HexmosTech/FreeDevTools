<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>dlinfo - obtain information about a dynamically loaded object</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       dlinfo - obtain information about a dynamically loaded object

</pre><h4><b>LIBRARY</b></h4><pre>
       Dynamic linking library (<u>libdl</u>, <u>-ldl</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#define</b> <b>_GNU_SOURCE</b>
       <b>#include</b> <b>&lt;<a href="file:/usr/include/link.h">link.h</a>&gt;</b>
       <b>#include</b> <b>&lt;<a href="file:/usr/include/dlfcn.h">dlfcn.h</a>&gt;</b>

       <b>int</b> <b>dlinfo(void</b> <b>*restrict</b> handle<b>,</b> <b>int</b> request<b>,</b> <b>void</b> <b>*restrict</b> info<b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>dlinfo</b>()  function  obtains  information  about  the dynamically loaded object referred to by <u>handle</u>
       (typically obtained by an earlier call to <b><a href="../man3/dlopen.3.html">dlopen</a></b>(3) or <b><a href="../man3/dlmopen.3.html">dlmopen</a></b>(3)).  The <u>request</u> argument specifies which
       information is to be returned.  The <u>info</u> argument is a pointer to a  buffer  used  to  store  information
       returned by the call; the type of this argument depends on <u>request</u>.

       The  following  values  are  supported  for  <u>request</u>  (with  the  corresponding  type  for  <u>info</u> shown in
       parentheses):

       <b>RTLD_DI_LMID</b> (<u>Lmid_t</u> <u>*</u>)
              Obtain the ID of the link-map list (namespace) in which <u>handle</u> is loaded.

       <b>RTLD_DI_LINKMAP</b> (<u>struct</u> <u>link_map</u> <u>**</u>)
              Obtain a pointer to the <u>link_map</u> structure corresponding to <u>handle</u>.  The <u>info</u> argument points to a
              pointer to a <u>link_map</u> structure, defined in <u>&lt;link.h&gt;</u> as:

                  struct link_map {
                      ElfW(Addr) l_addr;  /* Difference between the
                                             address in the ELF file and
                                             the address in memory */
                      char      *l_name;  /* Absolute pathname where
                                             object was found */
                      ElfW(Dyn) *l_ld;    /* Dynamic section of the
                                             shared object */
                      struct link_map *l_next, *l_prev;
                                          /* Chain of loaded objects */

                      /* Plus additional fields private to the
                         implementation */
                  };

       <b>RTLD_DI_ORIGIN</b> (<u>char</u> <u>*</u>)
              Copy the pathname of the origin of the shared object  corresponding  to  <u>handle</u>  to  the  location
              pointed to by <u>info</u>.

       <b>RTLD_DI_SERINFO</b> (<u>Dl_serinfo</u> <u>*</u>)
              Obtain the library search paths for the shared object referred to by <u>handle</u>.  The <u>info</u> argument is
              a  pointer to a <u>Dl_serinfo</u> that contains the search paths.  Because the number of search paths may
              vary, the size of the structure pointed to by <u>info</u>  can  vary.   The  <b>RTLD_DI_SERINFOSIZE</b>  request
              described  below  allows  applications  to  size the buffer suitably.  The caller must perform the
              following steps:

              (1)  Use a <b>RTLD_DI_SERINFOSIZE</b> request to populate a <u>Dl_serinfo</u> structure with the size (<u>dls_size</u>)
                   of the structure needed for the subsequent <b>RTLD_DI_SERINFO</b> request.

              (2)  Allocate a <u>Dl_serinfo</u> buffer of the correct size (<u>dls_size</u>).

              (3)  Use a further <b>RTLD_DI_SERINFOSIZE</b> request to populate the <u>dls_size</u> and <u>dls_cnt</u> fields of  the
                   buffer allocated in the previous step.

              (4)  Use a <b>RTLD_DI_SERINFO</b> to obtain the library search paths.

              The <u>Dl_serinfo</u> structure is defined as follows:

                  typedef struct {
                      size_t dls_size;           /* Size in bytes of
                                                    the whole buffer */
                      unsigned int dls_cnt;      /* Number of elements
                                                    in 'dls_serpath' */
                      Dl_serpath dls_serpath[1]; /* Actually longer,
                                                    'dls_cnt' elements */
                  } Dl_serinfo;

              Each of the <u>dls_serpath</u> elements in the above structure is a structure of the following form:

                  typedef struct {
                      char *dls_name;            /* Name of library search
                                                    path directory */
                      unsigned int dls_flags;    /* Indicates where this
                                                    directory came from */
                  } Dl_serpath;

              The <u>dls_flags</u> field is currently unused, and always contains zero.

       <b>RTLD_DI_SERINFOSIZE</b> (<u>Dl_serinfo</u> <u>*</u>)
              Populate  the  <u>dls_size</u>  and  <u>dls_cnt</u>  fields  of the <u>Dl_serinfo</u> structure pointed to by <u>info</u> with
              values suitable for allocating a buffer for use in a subsequent <b>RTLD_DI_SERINFO</b> request.

       <b>RTLD_DI_TLS_MODID</b> (<u>size_t</u> <u>*</u>, since glibc 2.4)
              Obtain the module ID of this shared object's TLS (thread-local storage) segment, as  used  in  TLS
              relocations.  If this object does not define a TLS segment, zero is placed in <u>*info</u>.

       <b>RTLD_DI_TLS_DATA</b> (<u>void</u> <u>**</u>, since glibc 2.4)
              Obtain  a  pointer  to  the  calling  thread's TLS block corresponding to this shared object's TLS
              segment.  If this object does not define a PT_TLS segment,  or  if  the  calling  thread  has  not
              allocated a block for it, NULL is placed in <u>*info</u>.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On success, <b>dlinfo</b>() returns 0.  On failure, it returns -1; the cause of the error can be diagnosed using
       <b><a href="../man3/dlerror.3.html">dlerror</a></b>(3).

</pre><h4><b>ATTRIBUTES</b></h4><pre>
       For an explanation of the terms used in this section, see <b><a href="../man7/attributes.7.html">attributes</a></b>(7).
       ┌─────────────────────────────────────────────────────────────────────────────┬───────────────┬─────────┐
       │ <b>Interface</b>                                                                   │ <b>Attribute</b>     │ <b>Value</b>   │
       ├─────────────────────────────────────────────────────────────────────────────┼───────────────┼─────────┤
       │ <b>dlinfo</b>()                                                                    │ Thread safety │ MT-Safe │
       └─────────────────────────────────────────────────────────────────────────────┴───────────────┴─────────┘

</pre><h4><b>VERSIONS</b></h4><pre>
       The sets of requests supported by the various implementations overlaps only partially.

</pre><h4><b>STANDARDS</b></h4><pre>
       GNU.

</pre><h4><b>HISTORY</b></h4><pre>
       glibc 2.3.3.  Solaris.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The  program  below  opens  a  shared  objects  using <b><a href="../man3/dlopen.3.html">dlopen</a></b>(3) and then uses the <b>RTLD_DI_SERINFOSIZE</b> and
       <b>RTLD_DI_SERINFO</b> requests to obtain the library search path list for the library.  Here is an  example  of
       what we might see when running the program:

           $ <b>./a.out</b> <b>/lib64/libm.so.6</b>
           dls_serpath[0].dls_name = <a href="file:/lib64">/lib64</a>
           dls_serpath[1].dls_name = <a href="file:/usr/lib64">/usr/lib64</a>

   <b>Program</b> <b>source</b>

       #define _GNU_SOURCE
       #include &lt;<a href="file:/usr/include/dlfcn.h">dlfcn.h</a>&gt;
       #include &lt;<a href="file:/usr/include/link.h">link.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;

       int
       main(int argc, char *argv[])
       {
           void *handle;
           Dl_serinfo serinfo;
           Dl_serinfo *sip;

           if (argc != 2) {
               fprintf(stderr, "Usage: %s &lt;libpath&gt;\n", argv[0]);
               exit(EXIT_FAILURE);
           }

           /* Obtain a handle for shared object specified on command line. */

           handle = dlopen(argv[1], RTLD_NOW);
           if (handle == NULL) {
               fprintf(stderr, "dlopen() failed: %s\n", dlerror());
               exit(EXIT_FAILURE);
           }

           /* Discover the size of the buffer that we must pass to
              RTLD_DI_SERINFO. */

           if (dlinfo(handle, RTLD_DI_SERINFOSIZE, &amp;serinfo) == -1) {
               fprintf(stderr, "RTLD_DI_SERINFOSIZE failed: %s\n", dlerror());
               exit(EXIT_FAILURE);
           }

           /* Allocate the buffer for use with RTLD_DI_SERINFO. */

           sip = malloc(serinfo.dls_size);
           if (sip == NULL) {
               perror("malloc");
               exit(EXIT_FAILURE);
           }

           /* Initialize the 'dls_size' and 'dls_cnt' fields in the newly
              allocated buffer. */

           if (dlinfo(handle, RTLD_DI_SERINFOSIZE, sip) == -1) {
               fprintf(stderr, "RTLD_DI_SERINFOSIZE failed: %s\n", dlerror());
               exit(EXIT_FAILURE);
           }

           /* Fetch and print library search list. */

           if (dlinfo(handle, RTLD_DI_SERINFO, sip) == -1) {
               fprintf(stderr, "RTLD_DI_SERINFO failed: %s\n", dlerror());
               exit(EXIT_FAILURE);
           }

           for (size_t j = 0; j &lt; serinfo.dls_cnt; j++)
               printf("dls_serpath[%zu].dls_name = %s\n",
                      j, sip-&gt;dls_serpath[j].dls_name);

           exit(EXIT_SUCCESS);
       }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/dl_iterate_phdr.3.html">dl_iterate_phdr</a></b>(3), <b><a href="../man3/dladdr.3.html">dladdr</a></b>(3), <b><a href="../man3/dlerror.3.html">dlerror</a></b>(3), <b><a href="../man3/dlopen.3.html">dlopen</a></b>(3), <b><a href="../man3/dlsym.3.html">dlsym</a></b>(3), <b><a href="../man8/ld.so.8.html">ld.so</a></b>(8)

Linux man-pages 6.9.1                              2024-06-15                                          <u><a href="../man3/dlinfo.3.html">dlinfo</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>