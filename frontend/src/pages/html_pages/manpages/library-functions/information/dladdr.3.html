<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>dladdr, dladdr1 - translate address to symbolic information</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       dladdr, dladdr1 - translate address to symbolic information

</pre><h4><b>LIBRARY</b></h4><pre>
       Dynamic linking library (<u>libdl</u>, <u>-ldl</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#define</b> <b>_GNU_SOURCE</b>
       <b>#include</b> <b>&lt;<a href="file:/usr/include/dlfcn.h">dlfcn.h</a>&gt;</b>

       <b>int</b> <b>dladdr(const</b> <b>void</b> <b>*</b><u>addr</u><b>,</b> <b>Dl_info</b> <b>*</b><u>info</u><b>);</b>
       <b>int</b> <b>dladdr1(const</b> <b>void</b> <b>*</b><u>addr</u><b>,</b> <b>Dl_info</b> <b>*</b><u>info</u><b>,</b> <b>void</b> <b>**</b><u>extra_info</u><b>,</b>
                   <b>int</b> <u>flags</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  function  <b>dladdr</b>()  determines whether the address specified in <u>addr</u> is located in one of the shared
       objects loaded by the calling application.  If it is, then <b>dladdr</b>() returns information about the  shared
       object and symbol that overlaps <u>addr</u>.  This information is returned in a <u>Dl_info</u> structure:

           typedef struct {
               const char *dli_fname;  /* Pathname of shared object that
                                          contains address */
               void       *dli_fbase;  /* Base address at which shared
                                          object is loaded */
               const char *dli_sname;  /* Name of symbol whose definition
                                          overlaps <u>addr</u> */
               void       *dli_saddr;  /* Exact address of symbol named
                                          in <u>dli_sname</u> */
           } Dl_info;

       If no symbol matching <u>addr</u> could be found, then <u>dli_sname</u> and <u>dli_saddr</u> are set to NULL.

       The  function <b>dladdr1</b>() is like <b>dladdr</b>(), but returns additional information via the argument <u>extra_info</u>.
       The information returned depends on the value specified in <u>flags</u>, which can have  one  of  the  following
       values:

       <b>RTLD_DL_LINKMAP</b>
              Obtain  a  pointer  to  the  link  map  for the matched file.  The <u>extra_info</u> argument points to a
              pointer to a <u>link_map</u> structure (i.e., <u>struct</u> <u>link_map</u> <u>**</u>), defined in <u>&lt;link.h&gt;</u> as:

                  struct link_map {
                      ElfW(Addr) l_addr;  /* Difference between the
                                             address in the ELF file and
                                             the address in memory */
                      char      *l_name;  /* Absolute pathname where
                                             object was found */
                      ElfW(Dyn) *l_ld;    /* Dynamic section of the
                                             shared object */
                      struct link_map *l_next, *l_prev;
                                          /* Chain of loaded objects */

                      /* Plus additional fields private to the
                         implementation */
                  };

       <b>RTLD_DL_SYMENT</b>
              Obtain a pointer to the ELF symbol table entry of the matching symbol.  The <u>extra_info</u> argument is
              a pointer to a symbol pointer: <u>const</u> <u>ElfW(Sym)</u> <u>**</u>.  The <u>ElfW</u>() macro definition turns its argument
              into the name of an ELF data type suitable for the  hardware  architecture.   For  example,  on  a
              64-bit platform, <u>ElfW(Sym)</u> yields the data type name <u>Elf64_Sym</u>, which is defined in <u>&lt;elf.h&gt;</u> as:

                  typedef struct  {
                      Elf64_Word    st_name;     /* Symbol name */
                      unsigned char st_info;     /* Symbol type and binding */
                      unsigned char st_other;    /* Symbol visibility */
                      Elf64_Section st_shndx;    /* Section index */
                      Elf64_Addr    st_value;    /* Symbol value */
                      Elf64_Xword   st_size;     /* Symbol size */
                  } Elf64_Sym;

              The <u>st_name</u> field is an index into the string table.

              The  <u>st_info</u>  field  encodes  the  symbol's type and binding.  The type can be extracted using the
              macro <b>ELF64_ST_TYPE(st_info)</b> (or <b>ELF32_ST_TYPE()</b> on 32-bit platforms), which  yields  one  of  the
              following values:
                  <b>Value</b>           <b>Description</b>
                  <b>STT_NOTYPE</b>      Symbol type is unspecified
                  <b>STT_OBJECT</b>      Symbol is a data object
                  <b>STT_FUNC</b>        Symbol is a code object
                  <b>STT_SECTION</b>     Symbol associated with a section
                  <b>STT_FILE</b>        Symbol's name is filename
                  <b>STT_COMMON</b>      Symbol is a common data object
                  <b>STT_TLS</b>         Symbol is thread-local data object
                  <b>STT_GNU_IFUNC</b>   Symbol is indirect code object

              The  symbol binding can be extracted from the <u>st_info</u> field using the macro <b>ELF64_ST_BIND(st_info)</b>
              (or <b>ELF32_ST_BIND()</b> on 32-bit platforms), which yields one of the following values:
                  <b>Value</b>            <b>Description</b>
                  <b>STB_LOCAL</b>        Local symbol
                  <b>STB_GLOBAL</b>       Global symbol
                  <b>STB_WEAK</b>         Weak symbol
                  <b>STB_GNU_UNIQUE</b>   Unique symbol

              The <u>st_other</u> field contains the symbol's visibility,  which  can  be  extracted  using  the  macro
              <b>ELF64_ST_VISIBILITY(st_info)</b>  (or  <b>ELF32_ST_VISIBILITY()</b> on 32-bit platforms), which yields one of
              the following values:
                  <b>Value</b>           <b>Description</b>
                  <b>STV_DEFAULT</b>     Default symbol visibility rules
                  <b>STV_INTERNAL</b>    Processor-specific hidden class
                  <b>STV_HIDDEN</b>      Symbol unavailable in other modules
                  <b>STV_PROTECTED</b>   Not preemptible, not exported

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On success, these functions return a nonzero value.  If the address specified in <u>addr</u> could be matched to
       a shared object, but not to a symbol in the shared object, then the <u>info-&gt;dli_sname</u>  and  <u>info-&gt;dli_saddr</u>
       fields are set to NULL.

       If  the address specified in <u>addr</u> could not be matched to a shared object, then these functions return 0.
       In this case, an error message is <u>not</u> available via <b><a href="../man3/dlerror.3.html">dlerror</a></b>(3).

</pre><h4><b>ATTRIBUTES</b></h4><pre>
       For an explanation of the terms used in this section, see <b><a href="../man7/attributes.7.html">attributes</a></b>(7).
       ┌─────────────────────────────────────────────────────────────────────────────┬───────────────┬─────────┐
       │ <b>Interface</b>                                                                   │ <b>Attribute</b>     │ <b>Value</b>   │
       ├─────────────────────────────────────────────────────────────────────────────┼───────────────┼─────────┤
       │ <b>dladdr</b>(), <b>dladdr1</b>()                                                         │ Thread safety │ MT-Safe │
       └─────────────────────────────────────────────────────────────────────────────┴───────────────┴─────────┘

</pre><h4><b>STANDARDS</b></h4><pre>
       GNU.

</pre><h4><b>HISTORY</b></h4><pre>
       <b>dladdr</b>()
              glibc 2.0.

       <b>dladdr1</b>()
              glibc 2.3.3.

       Solaris.

</pre><h4><b>BUGS</b></h4><pre>
       Sometimes, the function pointers you pass to <b>dladdr</b>() may surprise you.  On some  architectures  (notably
       i386  and  x86-64),  <u>dli_fname</u> and <u>dli_fbase</u> may end up pointing back at the object from which you called
       <b>dladdr</b>(), even if the function used as an argument should come from a dynamically linked library.

       The problem is that the function pointer will still be resolved at compile time, but merely point to  the
       <u>plt</u>  (Procedure Linkage Table) section of the original object (which dispatches the call after asking the
       dynamic linker to resolve the symbol).  To work around this, you can  try  to  compile  the  code  to  be
       position-independent:  then,  the compiler cannot prepare the pointer at compile time any more and <b><a href="../man1/gcc.1.html">gcc</a></b>(1)
       will generate code that just loads the final symbol address from the <u>got</u> (Global  Offset  Table)  at  run
       time before passing it to <b>dladdr</b>().

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/dl_iterate_phdr.3.html">dl_iterate_phdr</a></b>(3), <b><a href="../man3/dlinfo.3.html">dlinfo</a></b>(3), <b><a href="../man3/dlopen.3.html">dlopen</a></b>(3), <b><a href="../man3/dlsym.3.html">dlsym</a></b>(3), <b><a href="../man8/ld.so.8.html">ld.so</a></b>(8)

Linux man-pages 6.9.1                              2024-05-02                                          <u><a href="../man3/dladdr.3.html">dladdr</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>