<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>App::Info::Util - Utility class for App::Info subclasses</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libapp-info-perl">libapp-info-perl_0.57-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       App::Info::Util - Utility class for App::Info subclasses

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use App::Info::Util;

         my $util = App::Info::Util-&gt;new;

         # Subclasses File::Spec.
         my @paths = $util-&gt;paths;

         # First directory that exists in a list.
         my $dir = $util-&gt;first_dir(@paths);

         # First directory that exists in a path.
         $dir = $util-&gt;first_path($ENV{PATH});

         # First file that exists in a list.
         my $file = $util-&gt;first_file('this.txt', '/that.txt', 'C:\\foo.txt');

         # First file found among file base names and directories.
         my $files = ['this.txt', 'that.txt'];
         $file = $util-&gt;first_cat_file($files, @paths);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This class subclasses File::Spec and adds its own methods in order to offer utility methods to App::Info
       classes. Although intended to be used by App::Info subclasses, in truth App::Info::Util's utility may be
       considered more general, so feel free to use it elsewhere.

       The methods added in addition to the usual File::Spec suspects are designed to facilitate locating files
       and directories on the file system, as well as searching those files. The assumption is that, in order to
       provide useful meta data about a given software package, an App::Info subclass must find relevant files
       and directories and parse them with regular expressions. This class offers methods that simplify those
       tasks.

</pre><h4><b>CONSTRUCTOR</b></h4><pre>
   <b>new</b>
         my $util = App::Info::Util-&gt;new;

       This is a very simple constructor that merely returns an App::Info::Util object. Since, like its
       File::Spec super class, App::Info::Util manages no internal data itself, all methods may be used as class
       methods, if one prefers to. The constructor here is provided merely as a convenience.

</pre><h4><b>OBJECT</b> <b>METHODS</b></h4><pre>
       In addition to all of the methods offered by its super class, File::Spec, App::Info::Util offers the
       following methods.

   <b>first_dir</b>
         my @paths = $util-&gt;paths;
         my $dir = $util-&gt;first_dir(@dirs);

       Returns the first file system directory in @paths that exists on the local file system. Only the first
       item in @paths that exists as a directory will be returned; any other paths leading to non-directories
       will be ignored.

   <b>first_path</b>
         my $path = $ENV{PATH};
         $dir = $util-&gt;first_path($path);

       Takes the $path string and splits it into a list of directory paths, based on the path delimiter on the
       local file system. Then calls "first_dir()" to return the first directory in the path list that exists on
       the local file system. The path delimiter is specified for the following file systems:

       •   MacOS: ","

       •   MSWin32: ";"

       •   os2: ";"

       •   VMS: undef

           This method always returns undef on VMS. Patches welcome.

       •   epoc: undef

           This method always returns undef on epoch. Patches welcome.

       •   Unix: ":"

           All other operating systems are assumed to be Unix-based.

   <b>first_file</b>
         my $file = $util-&gt;first_file(@filelist);

       Examines  each  of  the  files in @filelist and returns the first one that exists on the file system. The
       file must be a regular file -- directories will be ignored.

   <b>first_exe</b>
         my $exe = $util-&gt;first_exe(@exelist);

       Examines each of the files in @exelist and returns the first one that exists on the  file  system  as  an
       executable file. Directories will be ignored.

   <b>first_cat_path</b>
         my $file = $util-&gt;first_cat_path('ick.txt', @paths);
         $file = $util-&gt;first_cat_path(['this.txt', 'that.txt'], @paths);

       The  first  argument  to  this  method  may  be  either a file or directory base name (that is, a file or
       directory name without a full path specification), or a reference to an array of file or  directory  base
       names. The remaining arguments constitute a list of directory paths. "first_cat_path()" processes each of
       these directory paths, concatenates (by the method native to the local operating system) each of the file
       or directory base names, and returns the first one that exists on the file system.

       For example, let us say that we were looking for a file called either <u>httpd</u> or <u>apache</u>, and it could be in
       any of the following paths: <u><a href="file:/usr/local/bin">/usr/local/bin</a></u>, <u><a href="file:/usr/bin/">/usr/bin/</a></u>, <u><a href="file:/bin">/bin</a></u>. The method call looks like this:

         my $httpd = $util-&gt;first_cat_path(['httpd', 'apache'], '<a href="file:/usr/local/bin">/usr/local/bin</a>',
                                           '<a href="file:/usr/bin/">/usr/bin/</a>', '<a href="file:/bin">/bin</a>');

       If  the  OS  is  a Unix variant, "first_cat_path()" will then look for the first file that exists in this
       order:

       /usr/local/bin/httpd
       /usr/local/bin/apache
       /usr/bin/httpd
       /usr/bin/apache
       /bin/httpd
       /bin/apache

       The first of these complete paths to be found will be returned. If none are found,  then  undef  will  be
       returned.

   <b>first_cat_dir</b>
         my $dir = $util-&gt;first_cat_dir('ick.txt', @paths);
         $dir = $util-&gt;first_cat_dir(['this.txt', 'that.txt'], @paths);

       Functionally  identical  to  "first_cat_path()",  except  that it returns the directory path in which the
       first file was found, rather than the full concatenated path. Thus, in the above  example,  if  the  file
       found  was  <u>/usr/bin/httpd</u>,  while  "first_cat_path()"  would  return that value, "first_cat_dir()" would
       return <u><a href="file:/usr/bin">/usr/bin</a></u> instead.

   <b>first_cat_exe</b>
         my $exe = $util-&gt;first_cat_exe('ick.exe', @paths);
         $exe = $util-&gt;first_cat_exe(['this.exe', 'that.exe'], @paths);

       Functionally identical to "first_cat_path()",  except  that  it  returns  the  full  path  to  the  first
       executable file found, rather than simply the first file found.

   <b>search_file</b>
         my $file = 'foo.txt';
         my $regex = qr/(text\s+to\s+find)/;
         my $value = $util-&gt;search_file($file, $regex);

       Opens  $file  and  executes  the  $regex  regular expression against each line in the file. Once the line
       matches and one or more values is returned by the match, the file is  closed  and  the  value  or  values
       returned.

       For example, say <u>foo.txt</u> contains the line "Version 6.5, patch level 8", and you need to grab each of the
       three version parts. All three parts can be grabbed like this:

         my $regex = qr/Version\s+(\d+)\.(\d+),[^\d]*(\d+)/;
         my @nums = $util-&gt;search_file($file, $regex);

       Now  @nums  will  contain  the  values "(6, 5, 8)". Note that in a scalar context, the above search would
       yield an array reference:

         my $regex = qr/Version\s+(\d+)\.(\d+),[^\d]*(\d+)/;
         my $nums = $util-&gt;search_file($file, $regex);

       So now $nums contains "[6, 5, 8]". The same does not hold true if  the  match  returns  only  one  value,
       however.  Say <u>foo.txt</u> contains the line "king of the who?", and you wish to know who the king is king of.
       Either of the following two calls would get you the data you need:

         my $minions = $util-&gt;search_file($file, qr/King\s+of\s+(.*)/);
         my @minions = $util-&gt;search_file($file, qr/King\s+of\s+(.*)/);

       In the first case, because the regular expression contains only one set of  parentheses,  "search_file()"
       will  simply  return that value: $minions contains the string "the who?". In the latter case, @minions of
       course contains a single element: "("the who?")".

       Note that a regular expression without parentheses -- that is, one that doesn't grab values and put  them
       into  $1,  $2,  etc.,  will never successfully match a line in this method. You must include something to
       parenthetically match. If you just want to know the value of what was  matched,  parenthesize  the  whole
       thing  and  if the value returns, you have a match. Also, if you need to match patterns across lines, try
       using multiple regular expressions with "multi_search_file()", instead.

   <b>files_in_dir</b>
         my @files = $util-&gt;files_in_dir($dir);
            @files = $util-&gt;files_in_dir($dir, $filter);
         my $files = $util-&gt;files_in_dir($dir);
            $files = $util-&gt;files_in_dir($dir, $filter);

       Returns an list or array reference of all of the files and directories in the file system directory $dir.
       An optional second argument is a code reference that filters the files. The code reference should examine
       the $_ for a file name and return true if it's a file that you're interested and false if it's not.

   <b>multi_search_file</b>
         my @regexen = (qr/(one)/, qr/(two)\s+(three)/);
         my @matches = $util-&gt;multi_search_file($file, @regexen);

       Like "search_file()", this method opens $file and parses it for regular expression matches. This  method,
       however,  can take a list of regular expressions to look for, and will return the values found for all of
       them.  Regular expressions that match and return multiple values will be returned  as  array  references,
       while those that match and return a single value will return just that single value.

       For example, say you are parsing a file with lines like the following:

         #define XML_MAJOR_VERSION 1
         #define XML_MINOR_VERSION 95
         #define XML_MICRO_VERSION 2

       You need to get each of these numbers, but calling "search_file()" for each of them would be wasteful, as
       each call to "search_file()" opens the file and parses it. With "multi_search_file()", on the other hand,
       the  file  will  be opened only once, and, once all of the regular expressions have returned matches, the
       file will be closed and the matches returned.

       Thus the above values can be collected like this:

         my @regexen = ( qr/XML_MAJOR_VERSION\s+(\d+)$/,
                         qr/XML_MINOR_VERSION\s+(\d+)$/,
                         qr/XML_MICRO_VERSION\s+(\d+)$/ );

         my @nums = $file-&gt;multi_search_file($file, @regexen);

       The result will be that @nums contains "(1, 95, 2)". Note that  "multi_file_search()"  tries  to  do  the
       right  thing  by  only  parsing  the file until all of the regular expressions have been matched. Thus, a
       large file with the values you need near the top can be parsed very quickly.

       As with "search_file()", "multi_search_file()" can take regular expressions that match  multiple  values.
       These will be returned as array references. For example, say the file you're parsing has files like this:

         FooApp Version 4
         Subversion 2, Microversion 6

       To  get  all  of  the  version  numbers, you can either use three regular expressions, as in the previous
       example:

         my @regexen = ( qr/FooApp\s+Version\s+(\d+)$/,
                         qr/Subversion\s+(\d+),/,
                         qr/Microversion\s+(\d$)$/ );

         my @nums = $file-&gt;multi_search_file($file, @regexen);

       In which case @nums will contain "(4, 2, 6)". Or, you can use just two regular expressions:

         my @regexen = ( qr/FooApp\s+Version\s+(\d+)$/,
                         qr/Subversion\s+(\d+),\s+Microversion\s+(\d$)$/ );

         my @nums = $file-&gt;multi_search_file($file, @regexen);

       In which case @nums will contain "(4, [2, 6])". Note that the two parentheses that return values  in  the
       second regular expression cause the matches to be returned as an array reference.

   <b>lib_dirs</b>
         my @dirs = $util-&gt;lib_dirs;

       Returns a list of possible library directories to be searched. These are gathered from the "libsdirs" and
       "loclibpth"  Config  settings.  These  are  useful  for  passing  to  "first_cat_dir()" to search typical
       directories for library files.

</pre><h4><b>SUPPORT</b></h4><pre>
       This module is stored in an open GitHub repository  &lt;<a href="http://github.com/theory/app-info/">http://github.com/theory/app-info/</a>&gt;.  Feel  free  to
       fork and contribute!

       Please  file bug reports via GitHub Issues &lt;<a href="http://github.com/theory/app-info/issues/">http://github.com/theory/app-info/issues/</a>&gt; or by sending mail
       to <a href="mailto:bug-App-Info@rt.cpan.org">bug-App-Info@rt.cpan.org</a> &lt;<a href="mailto:bug-App-Info@rt.cpan.org">mailto:bug-App-Info@rt.cpan.org</a>&gt;.

</pre><h4><b>AUTHOR</b></h4><pre>
       David E. Wheeler &lt;<a href="mailto:david@justatheory.com">david@justatheory.com</a>&gt;

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       App::Info, File::Spec, App::Info::HTTPD::Apache App::Info::RDBMS::PostgreSQL

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright (c) 2002-2011, David E. Wheeler. Some Rights Reserved.

       This module is free software; you can redistribute it and/or modify it  under  the  same  terms  as  Perl
       itself.

perl v5.36.0                                       2022-12-06                               <u>App::Info::<a href="../man3pm/Util.3pm.html">Util</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>