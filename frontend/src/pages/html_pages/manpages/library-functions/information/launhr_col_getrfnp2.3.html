<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>launhr_col_getrfnp2 - la{un,or}hr_col_getrfnp2: LU factor without pivoting, level 2</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/liblapack-doc">liblapack-doc_3.12.1-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       launhr_col_getrfnp2 - la{un,or}hr_col_getrfnp2: LU factor without pivoting, level 2

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Functions</b>
       recursive subroutine <b>claunhr_col_getrfnp2</b> (m, n, a, lda, d, info)
           <b>CLAUNHR_COL_GETRFNP2</b>
       recursive subroutine <b>dlaorhr_col_getrfnp2</b> (m, n, a, lda, d, info)
           <b>DLAORHR_COL_GETRFNP2</b>
       recursive subroutine <b>slaorhr_col_getrfnp2</b> (m, n, a, lda, d, info)
           <b>SLAORHR_COL_GETRFNP2</b>
       recursive subroutine <b>zlaunhr_col_getrfnp2</b> (m, n, a, lda, d, info)
           <b>ZLAUNHR_COL_GETRFNP2</b>

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>recursive</b> <b>subroutine</b> <b>claunhr_col_getrfnp2</b> <b>(integer</b> <b>m,</b> <b>integer</b> <b>n,</b> <b>complex,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>a,</b> <b>integer</b> <b>lda,</b>
       <b>complex,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>d,</b> <b>integer</b> <b>info)</b>
       <b>CLAUNHR_COL_GETRFNP2</b>

       <b>Purpose:</b>

            CLAUNHR_COL_GETRFNP2 computes the modified LU factorization without
            pivoting of a complex general M-by-N matrix A. The factorization has
            the form:

                A - S = L * U,

            where:
               S is a m-by-n diagonal sign matrix with the diagonal D, so that
               D(i) = S(i,i), 1 &lt;= i &lt;= min(M,N). The diagonal D is constructed
               as D(i)=-SIGN(A(i,i)), where A(i,i) is the value after performing
               i-1 steps of Gaussian elimination. This means that the diagonal
               element at each step of 'modified' Gaussian elimination is at
               least one in absolute value (so that division-by-zero not
               possible during the division by the diagonal element);

               L is a M-by-N lower triangular matrix with unit diagonal elements
               (lower trapezoidal if M &gt; N);

               and U is a M-by-N upper triangular matrix
               (upper trapezoidal if M &lt; N).

            This routine is an auxiliary routine used in the Householder
            reconstruction routine CUNHR_COL. In CUNHR_COL, this routine is
            applied to an M-by-N matrix A with orthonormal columns, where each
            element is bounded by one in absolute value. With the choice of
            the matrix S above, one can show that the diagonal element at each
            step of Gaussian elimination is the largest (in absolute value) in
            the column on or below the diagonal, so that no pivoting is required
            for numerical stability [1].

            For more details on the Householder reconstruction algorithm,
            including the modified LU factorization, see [1].

            This is the recursive version of the LU factorization algorithm.
            Denote A - S by B. The algorithm divides the matrix B into four
            submatrices:

                   [  B11 | B12  ]  where B11 is n1 by n1,
               B = [ -----|----- ]        B21 is (m-n1) by n1,
                   [  B21 | B22  ]        B12 is n1 by n2,
                                          B22 is (m-n1) by n2,
                                          with n1 = min(m,n)/2, n2 = n-n1.

            The subroutine calls itself to factor B11, solves for B21,
            solves for B12, updates B22, then calls itself to factor B22.

            For more details on the recursive LU algorithm, see [2].

            CLAUNHR_COL_GETRFNP2 is called to factorize a block by the blocked
            routine CLAUNHR_COL_GETRFNP, which uses blocked code calling
            Level 3 BLAS to update the submatrix. However, CLAUNHR_COL_GETRFNP2
            is self-sufficient and can be used without CLAUNHR_COL_GETRFNP.

            [1] 'Reconstructing Householder vectors from tall-skinny QR',
                G. Ballard, J. Demmel, L. Grigori, M. Jacquelin, H.D. Nguyen,
                E. Solomonik, J. Parallel Distrib. Comput.,
                vol. 85, pp. 3-31, 2015.

            [2] 'Recursion leads to automatic variable blocking for dense linear
                algebra algorithms', F. Gustavson, IBM J. of Res. and Dev.,
                vol. 41, no. 6, pp. 737-755, 1997.

       <b>Parameters</b>
           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix A.  M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix A.  N &gt;= 0.

           <u>A</u>

                     A is COMPLEX array, dimension (LDA,N)
                     On entry, the M-by-N matrix to be factored.
                     On exit, the factors L and U from the factorization
                     A-S=L*U; the unit diagonal elements of L are not stored.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,M).

           <u>D</u>

                     D is COMPLEX array, dimension min(M,N)
                     The diagonal elements of the diagonal M-by-N sign matrix S,
                     D(i) = S(i,i), where 1 &lt;= i &lt;= min(M,N). The elements can be
                     only ( +1.0, 0.0 ) or (-1.0, 0.0 ).

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>

            November 2019, Igor Kozachenko,
                           Computer Science Division,
                           University of California, Berkeley

   <b>recursive</b> <b>subroutine</b> <b>dlaorhr_col_getrfnp2</b> <b>(integer</b> <b>m,</b> <b>integer</b> <b>n,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>a,</b>
       <b>integer</b> <b>lda,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>d,</b> <b>integer</b> <b>info)</b>
       <b>DLAORHR_COL_GETRFNP2</b>

       <b>Purpose:</b>

            DLAORHR_COL_GETRFNP2 computes the modified LU factorization without
            pivoting of a real general M-by-N matrix A. The factorization has
            the form:

                A - S = L * U,

            where:
               S is a m-by-n diagonal sign matrix with the diagonal D, so that
               D(i) = S(i,i), 1 &lt;= i &lt;= min(M,N). The diagonal D is constructed
               as D(i)=-SIGN(A(i,i)), where A(i,i) is the value after performing
               i-1 steps of Gaussian elimination. This means that the diagonal
               element at each step of 'modified' Gaussian elimination is at
               least one in absolute value (so that division-by-zero not
               possible during the division by the diagonal element);

               L is a M-by-N lower triangular matrix with unit diagonal elements
               (lower trapezoidal if M &gt; N);

               and U is a M-by-N upper triangular matrix
               (upper trapezoidal if M &lt; N).

            This routine is an auxiliary routine used in the Householder
            reconstruction routine DORHR_COL. In DORHR_COL, this routine is
            applied to an M-by-N matrix A with orthonormal columns, where each
            element is bounded by one in absolute value. With the choice of
            the matrix S above, one can show that the diagonal element at each
            step of Gaussian elimination is the largest (in absolute value) in
            the column on or below the diagonal, so that no pivoting is required
            for numerical stability [1].

            For more details on the Householder reconstruction algorithm,
            including the modified LU factorization, see [1].

            This is the recursive version of the LU factorization algorithm.
            Denote A - S by B. The algorithm divides the matrix B into four
            submatrices:

                   [  B11 | B12  ]  where B11 is n1 by n1,
               B = [ -----|----- ]        B21 is (m-n1) by n1,
                   [  B21 | B22  ]        B12 is n1 by n2,
                                          B22 is (m-n1) by n2,
                                          with n1 = min(m,n)/2, n2 = n-n1.

            The subroutine calls itself to factor B11, solves for B21,
            solves for B12, updates B22, then calls itself to factor B22.

            For more details on the recursive LU algorithm, see [2].

            DLAORHR_COL_GETRFNP2 is called to factorize a block by the blocked
            routine DLAORHR_COL_GETRFNP, which uses blocked code calling
            Level 3 BLAS to update the submatrix. However, DLAORHR_COL_GETRFNP2
            is self-sufficient and can be used without DLAORHR_COL_GETRFNP.

            [1] 'Reconstructing Householder vectors from tall-skinny QR',
                G. Ballard, J. Demmel, L. Grigori, M. Jacquelin, H.D. Nguyen,
                E. Solomonik, J. Parallel Distrib. Comput.,
                vol. 85, pp. 3-31, 2015.

            [2] 'Recursion leads to automatic variable blocking for dense linear
                algebra algorithms', F. Gustavson, IBM J. of Res. and Dev.,
                vol. 41, no. 6, pp. 737-755, 1997.

       <b>Parameters</b>
           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix A.  M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix A.  N &gt;= 0.

           <u>A</u>

                     A is DOUBLE PRECISION array, dimension (LDA,N)
                     On entry, the M-by-N matrix to be factored.
                     On exit, the factors L and U from the factorization
                     A-S=L*U; the unit diagonal elements of L are not stored.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,M).

           <u>D</u>

                     D is DOUBLE PRECISION array, dimension min(M,N)
                     The diagonal elements of the diagonal M-by-N sign matrix S,
                     D(i) = S(i,i), where 1 &lt;= i &lt;= min(M,N). The elements can
                     be only plus or minus one.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>

            November 2019, Igor Kozachenko,
                           Computer Science Division,
                           University of California, Berkeley

   <b>recursive</b> <b>subroutine</b> <b>slaorhr_col_getrfnp2</b> <b>(integer</b> <b>m,</b> <b>integer</b> <b>n,</b> <b>real,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>a,</b> <b>integer</b> <b>lda,</b>
       <b>real,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>d,</b> <b>integer</b> <b>info)</b>
       <b>SLAORHR_COL_GETRFNP2</b>

       <b>Purpose:</b>

            SLAORHR_COL_GETRFNP2 computes the modified LU factorization without
            pivoting of a real general M-by-N matrix A. The factorization has
            the form:

                A - S = L * U,

            where:
               S is a m-by-n diagonal sign matrix with the diagonal D, so that
               D(i) = S(i,i), 1 &lt;= i &lt;= min(M,N). The diagonal D is constructed
               as D(i)=-SIGN(A(i,i)), where A(i,i) is the value after performing
               i-1 steps of Gaussian elimination. This means that the diagonal
               element at each step of 'modified' Gaussian elimination is at
               least one in absolute value (so that division-by-zero not
               possible during the division by the diagonal element);

               L is a M-by-N lower triangular matrix with unit diagonal elements
               (lower trapezoidal if M &gt; N);

               and U is a M-by-N upper triangular matrix
               (upper trapezoidal if M &lt; N).

            This routine is an auxiliary routine used in the Householder
            reconstruction routine SORHR_COL. In SORHR_COL, this routine is
            applied to an M-by-N matrix A with orthonormal columns, where each
            element is bounded by one in absolute value. With the choice of
            the matrix S above, one can show that the diagonal element at each
            step of Gaussian elimination is the largest (in absolute value) in
            the column on or below the diagonal, so that no pivoting is required
            for numerical stability [1].

            For more details on the Householder reconstruction algorithm,
            including the modified LU factorization, see [1].

            This is the recursive version of the LU factorization algorithm.
            Denote A - S by B. The algorithm divides the matrix B into four
            submatrices:

                   [  B11 | B12  ]  where B11 is n1 by n1,
               B = [ -----|----- ]        B21 is (m-n1) by n1,
                   [  B21 | B22  ]        B12 is n1 by n2,
                                          B22 is (m-n1) by n2,
                                          with n1 = min(m,n)/2, n2 = n-n1.

            The subroutine calls itself to factor B11, solves for B21,
            solves for B12, updates B22, then calls itself to factor B22.

            For more details on the recursive LU algorithm, see [2].

            SLAORHR_COL_GETRFNP2 is called to factorize a block by the blocked
            routine SLAORHR_COL_GETRFNP, which uses blocked code calling
            Level 3 BLAS to update the submatrix. However, SLAORHR_COL_GETRFNP2
            is self-sufficient and can be used without SLAORHR_COL_GETRFNP.

            [1] 'Reconstructing Householder vectors from tall-skinny QR',
                G. Ballard, J. Demmel, L. Grigori, M. Jacquelin, H.D. Nguyen,
                E. Solomonik, J. Parallel Distrib. Comput.,
                vol. 85, pp. 3-31, 2015.

            [2] 'Recursion leads to automatic variable blocking for dense linear
                algebra algorithms', F. Gustavson, IBM J. of Res. and Dev.,
                vol. 41, no. 6, pp. 737-755, 1997.

       <b>Parameters</b>
           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix A.  M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix A.  N &gt;= 0.

           <u>A</u>

                     A is REAL array, dimension (LDA,N)
                     On entry, the M-by-N matrix to be factored.
                     On exit, the factors L and U from the factorization
                     A-S=L*U; the unit diagonal elements of L are not stored.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,M).

           <u>D</u>

                     D is REAL array, dimension min(M,N)
                     The diagonal elements of the diagonal M-by-N sign matrix S,
                     D(i) = S(i,i), where 1 &lt;= i &lt;= min(M,N). The elements can
                     be only plus or minus one.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>

            November 2019, Igor Kozachenko,
                           Computer Science Division,
                           University of California, Berkeley

   <b>recursive</b> <b>subroutine</b> <b>zlaunhr_col_getrfnp2</b> <b>(integer</b> <b>m,</b> <b>integer</b> <b>n,</b> <b>complex*16,</b> <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>a,</b> <b>integer</b>
       <b>lda,</b> <b>complex*16,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>d,</b> <b>integer</b> <b>info)</b>
       <b>ZLAUNHR_COL_GETRFNP2</b>

       <b>Purpose:</b>

            ZLAUNHR_COL_GETRFNP2 computes the modified LU factorization without
            pivoting of a complex general M-by-N matrix A. The factorization has
            the form:

                A - S = L * U,

            where:
               S is a m-by-n diagonal sign matrix with the diagonal D, so that
               D(i) = S(i,i), 1 &lt;= i &lt;= min(M,N). The diagonal D is constructed
               as D(i)=-SIGN(A(i,i)), where A(i,i) is the value after performing
               i-1 steps of Gaussian elimination. This means that the diagonal
               element at each step of 'modified' Gaussian elimination is at
               least one in absolute value (so that division-by-zero not
               possible during the division by the diagonal element);

               L is a M-by-N lower triangular matrix with unit diagonal elements
               (lower trapezoidal if M &gt; N);

               and U is a M-by-N upper triangular matrix
               (upper trapezoidal if M &lt; N).

            This routine is an auxiliary routine used in the Householder
            reconstruction routine ZUNHR_COL. In ZUNHR_COL, this routine is
            applied to an M-by-N matrix A with orthonormal columns, where each
            element is bounded by one in absolute value. With the choice of
            the matrix S above, one can show that the diagonal element at each
            step of Gaussian elimination is the largest (in absolute value) in
            the column on or below the diagonal, so that no pivoting is required
            for numerical stability [1].

            For more details on the Householder reconstruction algorithm,
            including the modified LU factorization, see [1].

            This is the recursive version of the LU factorization algorithm.
            Denote A - S by B. The algorithm divides the matrix B into four
            submatrices:

                   [  B11 | B12  ]  where B11 is n1 by n1,
               B = [ -----|----- ]        B21 is (m-n1) by n1,
                   [  B21 | B22  ]        B12 is n1 by n2,
                                          B22 is (m-n1) by n2,
                                          with n1 = min(m,n)/2, n2 = n-n1.

            The subroutine calls itself to factor B11, solves for B21,
            solves for B12, updates B22, then calls itself to factor B22.

            For more details on the recursive LU algorithm, see [2].

            ZLAUNHR_COL_GETRFNP2 is called to factorize a block by the blocked
            routine ZLAUNHR_COL_GETRFNP, which uses blocked code calling
            Level 3 BLAS to update the submatrix. However, ZLAUNHR_COL_GETRFNP2
            is self-sufficient and can be used without ZLAUNHR_COL_GETRFNP.

            [1] 'Reconstructing Householder vectors from tall-skinny QR',
                G. Ballard, J. Demmel, L. Grigori, M. Jacquelin, H.D. Nguyen,
                E. Solomonik, J. Parallel Distrib. Comput.,
                vol. 85, pp. 3-31, 2015.

            [2] 'Recursion leads to automatic variable blocking for dense linear
                algebra algorithms', F. Gustavson, IBM J. of Res. and Dev.,
                vol. 41, no. 6, pp. 737-755, 1997.

       <b>Parameters</b>
           <u>M</u>

                     M is INTEGER
                     The number of rows of the matrix A.  M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The number of columns of the matrix A.  N &gt;= 0.

           <u>A</u>

                     A is COMPLEX*16 array, dimension (LDA,N)
                     On entry, the M-by-N matrix to be factored.
                     On exit, the factors L and U from the factorization
                     A-S=L*U; the unit diagonal elements of L are not stored.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A.  LDA &gt;= max(1,M).

           <u>D</u>

                     D is COMPLEX*16 array, dimension min(M,N)
                     The diagonal elements of the diagonal M-by-N sign matrix S,
                     D(i) = S(i,i), where 1 &lt;= i &lt;= min(M,N). The elements can be
                     only ( +1.0, 0.0 ) or (-1.0, 0.0 ).

           <u>INFO</u>

                     INFO is INTEGER
                     = 0:  successful exit
                     &lt; 0:  if INFO = -i, the i-th argument had an illegal value

       <b>Author</b>
           Univ. of Tennessee

           Univ. of California Berkeley

           Univ. of Colorado Denver

           NAG Ltd.

       <b>Contributors:</b>

            November 2019, Igor Kozachenko,
                           Computer Science Division,
                           University of California, Berkeley

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for LAPACK from the source code.

Version 3.12.0                              Sun Jul 20 2025 01:40:05                      <u><a href="../man3/launhr_col_getrfnp2.3.html">launhr_col_getrfnp2</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>