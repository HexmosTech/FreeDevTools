<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MIME::Lite - low-calorie MIME generator</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmime-lite-perl">libmime-lite-perl_3.033-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       MIME::Lite - low-calorie MIME generator

</pre><h4><b>WAIT!</b></h4><pre>
       MIME::Lite is not recommended by its current maintainer.  There are a number of alternatives, like
       Email::MIME or MIME::Entity and Email::Sender, which you should probably use instead.  MIME::Lite
       continues to accrue weird bug reports, and it is not receiving a large amount of refactoring due to the
       availability of better alternatives.  Please consider using something else.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       Create and send using the default send method for your OS a single-part message:

           use MIME::Lite;
           ### Create a new single-part message, to send a GIF file:
           $msg = MIME::Lite-&gt;new(
               From     =&gt; '<a href="mailto:me@myhost.com">me@myhost.com</a>',
               To       =&gt; '<a href="mailto:you@yourhost.com">you@yourhost.com</a>',
               Cc       =&gt; '<a href="mailto:some@other.com">some@other.com</a>, <a href="mailto:some@more.com">some@more.com</a>',
               Subject  =&gt; 'Helloooooo, nurse!',
               Type     =&gt; 'image/gif',
               Encoding =&gt; 'base64',
               Path     =&gt; 'hellonurse.gif'
           );
           $msg-&gt;send; # send via default

       Create a multipart message (i.e., one with attachments) and send it via SMTP

           ### Create a new multipart message:
           $msg = MIME::Lite-&gt;new(
               From    =&gt; '<a href="mailto:me@myhost.com">me@myhost.com</a>',
               To      =&gt; '<a href="mailto:you@yourhost.com">you@yourhost.com</a>',
               Cc      =&gt; '<a href="mailto:some@other.com">some@other.com</a>, <a href="mailto:some@more.com">some@more.com</a>',
               Subject =&gt; 'A message with 2 parts...',
               Type    =&gt; 'multipart/mixed'
           );

           ### Add parts (each "attach" has same arguments as "new"):
           $msg-&gt;attach(
               Type     =&gt; 'TEXT',
               Data     =&gt; "Here's the GIF file you wanted"
           );
           $msg-&gt;attach(
               Type     =&gt; 'image/gif',
               Path     =&gt; 'aaa000123.gif',
               Filename =&gt; 'logo.gif',
               Disposition =&gt; 'attachment'
           );
           ### use Net::SMTP to do the sending
           $msg-&gt;send('smtp','some.host', Debug=&gt;1 );

       Output a message:

           ### Format as a string:
           $str = $msg-&gt;as_string;

           ### Print to a filehandle (say, a "sendmail" stream):
           $msg-&gt;print(\*SENDMAIL);

       Send a message:

           ### Send in the "best" way (the default is to use "sendmail"):
           $msg-&gt;send;
           ### Send a specific way:
           $msg-&gt;send('type',@args);

       Specify default send method:

           MIME::Lite-&gt;send('smtp','some.host',Debug=&gt;0);

       with authentication

           MIME::Lite-&gt;send('smtp','some.host', AuthUser=&gt;$user, AuthPass=&gt;$pass);

       using SSL

           MIME::Lite-&gt;send('smtp','some.host', SSL =&gt; 1, Port =&gt; 465 );

</pre><h4><b>DESCRIPTION</b></h4><pre>
       In the never-ending quest for great taste with fewer calories, we proudly present: <u>MIME::Lite</u>.

       MIME::Lite is intended as a simple, standalone module for generating (not parsing!) MIME messages...
       specifically, it allows you to output a simple, decent single- or multi-part message with text or binary
       attachments.  It does not require that you have the Mail:: or MIME:: modules installed, but will work
       with them if they are.

       You can specify each message part as either the literal data itself (in a scalar or array), or as a
       string which can be given to <b>open()</b> to get a readable filehandle (e.g., "&lt;filename" or "somecommand|").

       You don't need to worry about encoding your message data: this module will do that for you.  It handles
       the 5 standard MIME encodings.

</pre><h4><b>EXAMPLES</b></h4><pre>
   <b>Create</b> <b>a</b> <b>simple</b> <b>message</b> <b>containing</b> <b>just</b> <b>text</b>
           $msg = MIME::Lite-&gt;new(
               From     =&gt;'<a href="mailto:me@myhost.com">me@myhost.com</a>',
               To       =&gt;'<a href="mailto:you@yourhost.com">you@yourhost.com</a>',
               Cc       =&gt;'<a href="mailto:some@other.com">some@other.com</a>, <a href="mailto:some@more.com">some@more.com</a>',
               Subject  =&gt;'Helloooooo, nurse!',
               Data     =&gt;"How's it goin', eh?"
           );

   <b>Create</b> <b>a</b> <b>simple</b> <b>message</b> <b>containing</b> <b>just</b> <b>an</b> <b>image</b>
           $msg = MIME::Lite-&gt;new(
               From     =&gt;'<a href="mailto:me@myhost.com">me@myhost.com</a>',
               To       =&gt;'<a href="mailto:you@yourhost.com">you@yourhost.com</a>',
               Cc       =&gt;'<a href="mailto:some@other.com">some@other.com</a>, <a href="mailto:some@more.com">some@more.com</a>',
               Subject  =&gt;'Helloooooo, nurse!',
               Type     =&gt;'image/gif',
               Encoding =&gt;'base64',
               Path     =&gt;'hellonurse.gif'
           );

   <b>Create</b> <b>a</b> <b>multipart</b> <b>message</b>
           ### Create the multipart "container":
           $msg = MIME::Lite-&gt;new(
               From    =&gt;'<a href="mailto:me@myhost.com">me@myhost.com</a>',
               To      =&gt;'<a href="mailto:you@yourhost.com">you@yourhost.com</a>',
               Cc      =&gt;'<a href="mailto:some@other.com">some@other.com</a>, <a href="mailto:some@more.com">some@more.com</a>',
               Subject =&gt;'A message with 2 parts...',
               Type    =&gt;'multipart/mixed'
           );

           ### Add the text message part:
           ### (Note that "attach" has same arguments as "new"):
           $msg-&gt;attach(
               Type     =&gt;'TEXT',
               Data     =&gt;"Here's the GIF file you wanted"
           );

           ### Add the image part:
           $msg-&gt;attach(
               Type        =&gt;'image/gif',
               Path        =&gt;'aaa000123.gif',
               Filename    =&gt;'logo.gif',
               Disposition =&gt; 'attachment'
           );

   <b>Attach</b> <b>a</b> <b>GIF</b> <b>to</b> <b>a</b> <b>text</b> <b>message</b>
       This will create a multipart message exactly as above, but using the "attach to singlepart" hack:

           ### Start with a simple text message:
           $msg = MIME::Lite-&gt;new(
               From    =&gt;'<a href="mailto:me@myhost.com">me@myhost.com</a>',
               To      =&gt;'<a href="mailto:you@yourhost.com">you@yourhost.com</a>',
               Cc      =&gt;'<a href="mailto:some@other.com">some@other.com</a>, <a href="mailto:some@more.com">some@more.com</a>',
               Subject =&gt;'A message with 2 parts...',
               Type    =&gt;'TEXT',
               Data    =&gt;"Here's the GIF file you wanted"
           );

           ### Attach a part... the make the message a multipart automatically:
           $msg-&gt;attach(
               Type     =&gt;'image/gif',
               Path     =&gt;'aaa000123.gif',
               Filename =&gt;'logo.gif'
           );

   <b>Attach</b> <b>a</b> <b>pre-prepared</b> <b>part</b> <b>to</b> <b>a</b> <b>message</b>
           ### Create a standalone part:
           $part = MIME::Lite-&gt;new(
               Top      =&gt; 0,
               Type     =&gt;'text/html',
               Data     =&gt;'&lt;H1&gt;Hello&lt;/H1&gt;',
           );
           $part-&gt;attr('content-type.charset' =&gt; 'UTF-8');
           $part-&gt;add('X-Comment' =&gt; 'A message for you');

           ### Attach it to any message:
           $msg-&gt;attach($part);

   <b>Print</b> <b>a</b> <b>message</b> <b>to</b> <b>a</b> <b>filehandle</b>
           ### Write it to a filehandle:
           $msg-&gt;print(\*STDOUT);

           ### Write just the header:
           $msg-&gt;print_header(\*STDOUT);

           ### Write just the encoded body:
           $msg-&gt;print_body(\*STDOUT);

   <b>Print</b> <b>a</b> <b>message</b> <b>into</b> <b>a</b> <b>string</b>
           ### Get entire message as a string:
           $str = $msg-&gt;as_string;

           ### Get just the header:
           $str = $msg-&gt;header_as_string;

           ### Get just the encoded body:
           $str = $msg-&gt;body_as_string;

   <b>Send</b> <b>a</b> <b>message</b>
           ### Send in the "best" way (the default is to use "sendmail"):
           $msg-&gt;send;

   <b>Send</b> <b>an</b> <b>HTML</b> <b>document...</b> <b>with</b> <b>images</b> <b>included!</b>
           $msg = MIME::Lite-&gt;new(
                To      =&gt;'<a href="mailto:you@yourhost.com">you@yourhost.com</a>',
                Subject =&gt;'HTML with in-line images!',
                Type    =&gt;'multipart/related'
           );
           $msg-&gt;attach(
               Type =&gt; 'text/html',
               Data =&gt; qq{
                   &lt;body&gt;
                       Here's &lt;i&gt;my&lt;/i&gt; image:
                       &lt;img src="cid:myimage.gif"&gt;
                   &lt;/body&gt;
               },
           );
           $msg-&gt;attach(
               Type =&gt; 'image/gif',
               Id   =&gt; 'myimage.gif',
               Path =&gt; '/path/to/somefile.gif',
           );
           $msg-&gt;send();

   <b>Change</b> <b>how</b> <b>messages</b> <b>are</b> <b>sent</b>
           ### Do something like this in your 'main':
           if ($I_DONT_HAVE_SENDMAIL) {
              MIME::Lite-&gt;send('smtp', $host, Timeout=&gt;60,
                  AuthUser=&gt;$user, AuthPass=&gt;$pass);
           }

           ### Now this will do the right thing:
           $msg-&gt;send;         ### will now use Net::SMTP as shown above

</pre><h4><b>PUBLIC</b> <b>INTERFACE</b></h4><pre>
   <b>Global</b> <b>configuration</b>
       To alter the way the entire module behaves, you have the following methods/options:

       MIME::Lite-&gt;<b>field_order()</b>
           When  used  as  a  classmethod,  this  changes  the default order in which headers are output for <u>all</u>
           messages.  However, please consider using the instance method variant instead, so you won't stomp  on
           other message senders in the same application.

       MIME::Lite-&gt;<b>quiet()</b>
           This classmethod can be used to suppress/unsuppress all warnings coming from this module.

       MIME::Lite-&gt;<b>send()</b>
           When  used  as  a  classmethod, this can be used to specify a different default mechanism for sending
           message.  The initial default is:

               MIME::Lite-&gt;send("sendmail", "/usr/lib/sendmail -t -oi -oem");

           However, you should consider the similar but smarter and taint-safe variant:

               MIME::Lite-&gt;send("sendmail");

           Or, for non-Unix users:

               MIME::Lite-&gt;send("smtp");

       $MIME::Lite::AUTO_CC
           If true, automatically send to the Cc/Bcc addresses for <b>send_by_smtp()</b>.  Default is <b>true</b>.

       $MIME::Lite::AUTO_CONTENT_TYPE
           If true, try to automatically choose the content type from the file name in new()/build().  In  other
           words, setting this true changes the default "Type" from "TEXT" to "AUTO".

           Default  is  <b>false</b>,  since  we  must  maintain  backwards-compatibility  with prior behavior.  <b>Please</b>
           consider keeping it false, and just using Type 'AUTO' when you <b>build()</b> or <b>attach()</b>.

       $MIME::Lite::AUTO_ENCODE
           If true, automatically choose the encoding from the content type.  Default is <b>true</b>.

       $MIME::Lite::AUTO_VERIFY
           If true, check paths to attachments right before printing,  raising  an  exception  if  any  path  is
           unreadable.  Default is <b>true</b>.

       $MIME::Lite::PARANOID
           If  true,  we  won't  attempt to use MIME::Base64, MIME::QuotedPrint, or MIME::Types, even if they're
           available.  Default is <b>false</b>.  Please consider keeping it false, and trusting these other packages to
           do the right thing.

   <b>Construction</b>
       new [PARAMHASH]
           <u>Class</u> <u>method,</u> <u>constructor.</u>  Create a new message object.

           If any arguments are given, they are passed  into  build();  otherwise,  just  the  empty  object  is
           created.

       attach PART
       attach PARAMHASH...
           <u>Instance</u> <u>method.</u>  Add a new part to this message, and return the new part.

           If  you  supply  a  single  PART argument, it will be regarded as a MIME::Lite object to be attached.
           Otherwise, this method assumes that you are giving in the pairs of a PARAMHASH  which  will  be  sent
           into new() to create the new part.

           One  of  the  possibly-quite-useful hacks thrown into this is the "attach-to-singlepart" hack: if you
           attempt to attach a part (let's call it "part 1") to a message that doesn't have  a  content-type  of
           "multipart" or "message", the following happens:

           •   A new part (call it "part 0") is made.

           •   The  MIME  attributes  and  data (but <u>not</u> the other headers) are cut from the "self" message, and
               pasted into "part 0".

           •   The "self" is turned into a "multipart/mixed" message.

           •   The new "part 0" is added to the "self", and <u>then</u> "part 1" is added.

           One of the nice side-effects is that you can create  a  text  message  and  then  add  zero  or  more
           attachments to it, much in the same way that a user agent like Netscape allows you to do.

       build [PARAMHASH]
           <u>Class/instance</u>  <u>method,</u> <u>initializer.</u>  Create (or initialize) a MIME message object.  Normally, you'll
           use the following keys in PARAMHASH:

              * Data, FH, or Path      (either one of these, or none if multipart)
              * Type                   (e.g., "image/jpeg")
              * From, To, and Subject  (if this is the "top level" of a message)

           The PARAMHASH can contain the following keys:

           (fieldname)
               Any field you want placed in the message header, taken from the standard list  of  header  fields
               (you don't need to worry about case):

                   Approved      Encrypted     Received      Sender
                   Bcc           From          References    Subject
                   Cc            Keywords      Reply-To      To
                   Comments      Message-ID    Resent-*      X-*
                   Content-*     MIME-Version  Return-Path
                   Date                        Organization

               To give experienced users some veto power, these fields will be set <u>after</u> the ones I set... so be
               careful: <u>don't</u> <u>set</u> <u>any</u> <u>MIME</u> <u>fields</u> (like "Content-type") unless you know what you're doing!

               To  specify  a  fieldname  that's  <u>not</u>  in the above list, even one that's identical to an option
               below, just give it with a trailing ":", like "My-field:".  When in doubt, that <u>always</u> signals  a
               mail field (and it sort of looks like one too).

           Data
               <u>Alternative</u>  <u>to</u>  <u>"Path"</u>  <u>or</u>  <u>"FH".</u>  The actual message data.  This may be a scalar or a ref to an
               array of strings; if the latter, the message consists  of  a  simple  concatenation  of  all  the
               strings in the array.

           Datestamp
               <u>Optional.</u>   If given true (or omitted), we force the creation of a "Date:" field stamped with the
               current date/time if this is a top-level message.  You may want this if using <b>send_by_smtp()</b>.  If
               you don't want this to be done, either provide your own Date or explicitly set this to false.

           Disposition
               <u>Optional.</u>  The content disposition, "inline" or "attachment".  The default is "inline".

           Encoding
               <u>Optional.</u>  The content transfer encoding that should be used to encode your data:

                  Use encoding:     | If your message contains:
                  ------------------------------------------------------------
                  7bit              | Only 7-bit text, all lines &lt;1000 characters
                  8bit              | 8-bit text, all lines &lt;1000 characters
                  quoted-printable  | 8-bit text or long lines (more reliable than "8bit")
                  base64            | Largely non-textual data: a GIF, a tar file, etc.

               The default is taken from the Type; generally it is "binary" (no encoding) for text/*, message/*,
               and multipart/*, and "base64" for everything else.  A value of "binary" is generally <u>not</u> suitable
               for sending anything but ASCII text files with lines under 1000 characters, so consider using one
               of the other values instead.

               In the case of "7bit"/"8bit", long lines are automatically chopped to legal length; in  the  case
               of  "7bit",  all  8-bit  characters are automatically <u>removed</u>.  This may not be what you want, so
               pick your encoding well!  For more info, see "A MIME PRIMER".

           FH  <u>Alternative</u> <u>to</u> <u>"Data"</u> <u>or</u> <u>"Path".</u>  Filehandle  containing  the  data,  opened  for  reading.   See
               "ReadNow" also.

           Filename
               <u>Optional.</u>  The name of the attachment.  You can use this to supply a recommended filename for the
               end-user  who is saving the attachment to disk.  You only need this if the filename at the end of
               the "Path" is inadequate, or if you're using "Data" instead of "Path".  You should <u>not</u>  put  path
               information in here (e.g., no "/" or "\" or ":" characters should be used).

           Id  <u>Optional.</u>  Same as setting "content-id".

           Length
               <u>Optional.</u>   Set  the content length explicitly.  Normally, this header is automatically computed,
               but only under certain circumstances (see "Benign limitations").

           Path
               <u>Alternative</u> <u>to</u> <u>"Data"</u> <u>or</u> <u>"FH".</u>  Path to a file containing the data... actually,  it  can  be  any
               <b>open()</b>able  expression.   If it looks like a path, the last element will automatically be treated
               as the filename.  See "ReadNow" also.

           ReadNow
               <u>Optional,</u> <u>for</u> <u>use</u> <u>with</u> <u>"Path".</u>  If true, will open the path and slurp the contents into core now.
               This is useful if the Path points to a command and you don't want to run  the  command  over  and
               over if outputting the message several times.  <b>Fatal</b> <b>exception</b> raised if the open fails.

           Top <u>Optional.</u>  If defined, indicates whether or not this is a "top-level" MIME message.  The parts of
               a multipart message are <u>not</u> top-level.  Default is true.

           Type
               <u>Optional.</u>  The MIME content type, or one of these special values (case-sensitive):

                    "TEXT"   means "text/plain"
                    "BINARY" means "application/octet-stream"
                    "AUTO"   means attempt to guess from the filename, falling back
                             to 'application/octet-stream'.  This is good if you have
                             MIME::Types on your system and you have no idea what
                             file might be used for the attachment.

               The  default  is  "TEXT", but it will be "AUTO" if you set $AUTO_CONTENT_TYPE to true (sorry, but
               you have to enable it explicitly, since we don't want to break code  which  depends  on  the  old
               behavior).

           A  picture  being worth 1000 words (which is of course 2000 bytes, so it's probably more of an "icon"
           than a "picture", but I digress...), here are some examples:

               $msg = MIME::Lite-&gt;build(
                   From     =&gt; '<a href="mailto:yelling@inter.com">yelling@inter.com</a>',
                   To       =&gt; '<a href="mailto:stocking@fish.net">stocking@fish.net</a>',
                   Subject  =&gt; "Hi there!",
                   Type     =&gt; 'TEXT',
                   Encoding =&gt; '7bit',
                   Data     =&gt; "Just a quick note to say hi!"
               );

               $msg = MIME::Lite-&gt;build(
                   From     =&gt; '<a href="mailto:dorothy@emerald-city.oz">dorothy@emerald-city.oz</a>',
                   To       =&gt; '<a href="mailto:gesundheit@edu.edu.edu">gesundheit@edu.edu.edu</a>',
                   Subject  =&gt; "A gif for U"
                   Type     =&gt; 'image/gif',
                   Path     =&gt; "/home/httpd/logo.gif"
               );

               $msg = MIME::Lite-&gt;build(
                   From     =&gt; '<a href="mailto:laughing@all.of.us">laughing@all.of.us</a>',
                   To       =&gt; '<a href="mailto:scarlett@fiddle.dee.de">scarlett@fiddle.dee.de</a>',
                   Subject  =&gt; "A gzipp'ed tar file",
                   Type     =&gt; 'x-gzip',
                   Path     =&gt; "gzip &lt; /usr/inc/somefile.tar |",
                   ReadNow  =&gt; 1,
                   Filename =&gt; "somefile.tgz"
               );

           To show you what's really going on, that last example could also have been written:

               $msg = new MIME::Lite;
               $msg-&gt;build(
                   Type     =&gt; 'x-gzip',
                   Path     =&gt; "gzip &lt; /usr/inc/somefile.tar |",
                   ReadNow  =&gt; 1,
                   Filename =&gt; "somefile.tgz"
               );
               $msg-&gt;add(From    =&gt; "<a href="mailto:laughing@all.of.us">laughing@all.of.us</a>");
               $msg-&gt;add(To      =&gt; "<a href="mailto:scarlett@fiddle.dee.de">scarlett@fiddle.dee.de</a>");
               $msg-&gt;add(Subject =&gt; "A gzipp'ed tar file");

   <b>Setting/getting</b> <b>headers</b> <b>and</b> <b>attributes</b>
       add TAG,VALUE
           <u>Instance</u> <u>method.</u>  Add field TAG with the given VALUE to the end of  the  header.   The  TAG  will  be
           converted  to  all-lowercase,  and  the  VALUE  will be made "safe" (returns will be given a trailing
           space).

           <b>Beware:</b> any MIME fields you "add" will override any MIME attributes I have  when  it  comes  time  to
           output those fields.  Normally, you will use this method to add <u>non-MIME</u> fields:

               $msg-&gt;add("Subject" =&gt; "Hi there!");

           Giving VALUE as an arrayref will cause all those values to be added.  This is only useful for special
           multiple-valued fields like "Received":

               $msg-&gt;add("Received" =&gt; ["here", "there", "everywhere"]

           Giving  VALUE  as  the empty string adds an invisible placeholder to the header, which can be used to
           suppress the output of the "Content-*" fields or the special  "MIME-Version" field.  When suppressing
           fields, you should use <b>replace()</b> instead of <b>add()</b>:

               $msg-&gt;replace("Content-disposition" =&gt; "");

           <u>Note:</u> <b>add()</b> is probably going to be more efficient than replace(), so you're better off using it  for
           most applications if you are certain that you don't need to <b>delete()</b> the field first.

           <u>Note:</u> the name comes from Mail::Header.

       attr ATTR,[VALUE]
           <u>Instance</u>  <u>method.</u>   Set MIME attribute ATTR to the string VALUE.  ATTR is converted to all-lowercase.
           This method is normally used to set/get MIME attributes:

               $msg-&gt;attr("content-type"         =&gt; "text/html");
               $msg-&gt;attr("content-type.charset" =&gt; "US-ASCII");
               $msg-&gt;attr("content-type.name"    =&gt; "homepage.html");

           This would cause the final output to look something like this:

               Content-type: text/html; charset=US-ASCII; name="homepage.html"

           Note that the special empty sub-field tag indicates the anonymous first sub-field.

           Giving VALUE as undefined will cause the contents of the named subfield to be deleted.

           Supplying no VALUE argument just returns the attribute's value:

               $type = $msg-&gt;attr("content-type");        ### returns "text/html"
               $name = $msg-&gt;attr("content-type.name");   ### returns "homepage.html"

       delete TAG
           <u>Instance</u> <u>method.</u>  Delete field TAG with the given VALUE to the end of the header.  The  TAG  will  be
           converted to all-lowercase.

               $msg-&gt;delete("Subject");

           <u>Note:</u> the name comes from Mail::Header.

       field_order FIELD,...FIELD
           <u>Class/instance</u> <u>method.</u>  Change the order in which header fields are output for this object:

               $msg-&gt;field_order('from', 'to', 'content-type', 'subject');

           When used as a class method, changes the default settings for all objects:

               MIME::Lite-&gt;field_order('from', 'to', 'content-type', 'subject');

           Case does not matter: all field names will be coerced to lowercase.  In either case, supply the empty
           array to restore the default ordering.

       fields
           <u>Instance</u>  <u>method.</u>   Return  the  full  header  for the object, as a ref to an array of "[TAG, VALUE]"
           pairs, where each TAG is all-lowercase.  Note that any  fields  the  user  has  explicitly  set  will
           override the corresponding MIME fields that we would otherwise generate.  So, don't say...

               $msg-&gt;set("Content-type" =&gt; "text/html; charset=US-ASCII");

           unless  you  want  the  above  value to override the "Content-type" MIME field that we would normally
           generate.

           <u>Note:</u> I called this "fields" because the <b>header()</b> method of Mail::Header returns something different,
           but similar enough to be confusing.

           You can change the order of the fields: see "field_order".  You really shouldn't need to do this, but
           some people have to deal with broken mailers.

       filename [FILENAME]
           <u>Instance</u> <u>method.</u>  Set the filename which this data will be reported  as.   This  actually  sets  both
           "standard" attributes.

           With no argument, returns the filename as dictated by the content-disposition.

       get TAG,[INDEX]
           <u>Instance</u>  <u>method.</u>   Get the contents of field TAG, which might have been set with <b>set()</b> or <b>replace()</b>.
           Returns the text of the field.

               $ml-&gt;get('Subject', 0);

           If the optional 0-based INDEX is given,  then  we  return  the  INDEX'th  occurrence  of  field  TAG.
           Otherwise,  we look at the context: In a scalar context, only the first (0th) occurrence of the field
           is returned; in an array context, <u>all</u> occurrences are returned.

           <u>Warning:</u> this should only be used with non-MIME fields.  Behavior with MIME fields is TBD,  and  will
           raise an exception for now.

       get_length
           <u>Instance</u> <u>method.</u>  Recompute the content length for the message <u>if</u> <u>the</u> <u>process</u> <u>is</u> <u>trivial</u>, setting the
           "content-length" attribute as a side-effect:

               $msg-&gt;get_length;

           Returns the length, or undefined if not set.

           <u>Note:</u> the content length can be difficult to compute, since it involves assembling the entire encoded
           body  and  taking  the length of it (which, in the case of multipart messages, means freezing all the
           sub-parts, etc.).

           This method only sets the content length to a defined value if  the  message  is  a  singlepart  with
           "binary"  encoding,  <u>and</u>  the  body  is available either in-core or as a simple file.  Otherwise, the
           content length is set to the undefined value.

           Since content-length is not a standard MIME field anyway (that's right, kids: it's not  in  the  MIME
           RFCs, it's an HTTP thing), this seems pretty fair.

       parts
           <u>Instance</u> <u>method.</u>  Return the parts of this entity, and this entity only.  Returns empty array if this
           entity has no parts.

           This is <b>not</b> recursive!  Parts can have sub-parts; use <b>parts_DFS()</b> to get everything.

       parts_DFS
           <u>Instance</u> <u>method.</u>  Return the list of all MIME::Lite objects included in the entity, starting with the
           entity itself, in depth-first-search order.  If this object has no parts, it alone will be returned.

       preamble [TEXT]
           <u>Instance</u>  <u>method.</u>   Get/set  the  preamble string, assuming that this object has subparts.  Set it to
           undef for the default string.

       replace TAG,VALUE
           <u>Instance</u> <u>method.</u>  Delete all occurrences of fields named TAG, and add a  new  field  with  the  given
           VALUE.  TAG is converted to all-lowercase.

           <b>Beware</b>  the  special  MIME  fields  (MIME-version,  Content-*):  if  you  "replace" a MIME field, the
           replacement text will override the <u>actual</u> MIME attributes when it comes time to  output  that  field.
           So normally you use <b>attr()</b> to change MIME fields and <b>add()</b>/<b>replace()</b> to change <u>non-MIME</u> fields:

               $msg-&gt;replace("Subject" =&gt; "Hi there!");

           Giving  VALUE as the <u>empty</u> <u>string</u> will effectively <u>prevent</u> that field from being output.  This is the
           correct way to suppress the special MIME fields:

               $msg-&gt;replace("Content-disposition" =&gt; "");

           Giving VALUE as <u>undefined</u> will just cause all explicit values for TAG to be deleted,  without  having
           any new values added.

           <u>Note:</u> the name of this method  comes from Mail::Header.

       scrub
           <u>Instance</u>  <u>method.</u>   <b>This</b>  <b>is</b> <b>Alpha</b> <b>code.</b>  <b>If</b> <b>you</b> <b>use</b> <b>it,</b> <b>please</b> <b>let</b> <b>me</b> <b>know</b> <b>how</b> <b>it</b> <b>goes.</b>  Recursively
           goes through the "parts" tree of this message and tries to find MIME attributes that can be  removed.
           With an array argument, removes exactly those attributes; e.g.:

               $msg-&gt;scrub(['content-disposition', 'content-length']);

           Is the same as recursively doing:

               $msg-&gt;replace('Content-disposition' =&gt; '');
               $msg-&gt;replace('Content-length'      =&gt; '');

   <b>Setting/getting</b> <b>message</b> <b>data</b>
       binmode [OVERRIDE]
           <u>Instance</u>  <u>method.</u>   With no argument, returns whether or not it thinks that the data (as given by the
           "Path" argument of build()) should be read using <b>binmode()</b> (for example, when read_now() is invoked).

           The default behavior is that any content type other than "text/*" or "message/*" is  binmode'd;  this
           should in general work fine.

           With a defined argument, this method sets an explicit "override" value.  An undefined argument unsets
           the override.  The new current value is returned.

       data [DATA]
           <u>Instance</u>  <u>method.</u>   Get/set  the  literal DATA of the message.  The DATA may be either a scalar, or a
           reference to an array of scalars (which will simply be joined).

           <u>Warning:</u> setting the data causes  the  "content-length"  attribute  to  be  recomputed  (possibly  to
           nothing).

       fh [FILEHANDLE]
           <u>Instance</u> <u>method.</u>  Get/set the FILEHANDLE which contains the message data.

           Takes  a  filehandle as an input and stores it in the object.  This routine is similar to <b>path()</b>; one
           important difference is that no attempt is made to set the content length.

       path [PATH]
           <u>Instance</u> <u>method.</u>  Get/set the PATH to the message data.

           <u>Warning:</u> setting the path recomputes any existing "content-length" field, and re-sets the  "filename"
           (to the last element of the path if it looks like a simple path, and to nothing if not).

       resetfh [FILEHANDLE]
           <u>Instance</u>  <u>method.</u>  Set the current position of the filehandle back to the beginning.  Only applies if
           you used "FH" in <b>build()</b> or <b>attach()</b> for this message.

           Returns false if unable to reset the filehandle (since not all filehandles are seekable).

       read_now
           <u>Instance</u> <u>method.</u>  Forces data from the path/filehandle (as specified by build()) to be read into core
           immediately, just as though you had given it literally with the "Data" keyword.

           Note that the in-core data will always be used if available.

           Be aware that everything is slurped into a giant scalar: you may not want to use this if sending  tar
           files!  The benefit of <u>not</u> reading in the data is that very large files can be handled by this module
           if left on disk until the message is output via print() or print_body().

       sign PARAMHASH
           <u>Instance</u>  <u>method.</u>   Sign  the message.  This forces the message to be read into core, after which the
           signature is appended to it.

           Data
               As in build(): the literal signature data.  Can be either a scalar  or  a  ref  to  an  array  of
               scalars.

           Path
               As in build(): the path to the file.

           If no arguments are given, the default is:

               Path =&gt; "$ENV{HOME}/.signature"

           The content-length is recomputed.

       verify_data
           <u>Instance</u>  <u>method.</u>   Verify  that all "paths" to attached data exist, recursively.  It might be a good
           idea for you to do this before a <b>print()</b>, to prevent accidental partial output if  a  file  might  be
           missing.  Raises exception if any path is not readable.

   <b>Output</b>
       print [OUTHANDLE]
           <u>Instance</u>  <u>method.</u>   Print  the  message  to  the  given  output  handle, or to the currently-selected
           filehandle if none was given.

           All OUTHANDLE has to be is a filehandle (possibly a glob ref), or  any  object  that  responds  to  a
           <b>print()</b> message.

       print_body [OUTHANDLE] [IS_SMTP]
           <u>Instance</u>  <u>method.</u>   Print  the  body  of  a  message to the given output handle, or to the currently-
           selected filehandle if none was given.

           All OUTHANDLE has to be is a filehandle (possibly a glob ref), or  any  object  that  responds  to  a
           <b>print()</b> message.

           <b>Fatal</b> <b>exception</b> raised if unable to open any of the input files, or if a part contains no data, or if
           an unsupported encoding is encountered.

           IS_SMPT  is  a  special  option  to  handle  SMTP  mails  a little more intelligently than other send
           mechanisms may require. Specifically this ensures that the last byte sent is NOT '\n' (octal \012) if
           the last two bytes are not '\r\n' (\015\012) as this will cause some SMTP servers to hang.

       print_header [OUTHANDLE]
           <u>Instance</u> <u>method.</u>  Print the header of the message to the given output handle, or  to  the  currently-
           selected filehandle if none was given.

           All  OUTHANDLE  has  to  be  is  a filehandle (possibly a glob ref), or any object that responds to a
           <b>print()</b> message.

       as_string
           <u>Instance</u> <u>method.</u>  Return the entire message as a string, with a header and an encoded body.

       body_as_string
           <u>Instance</u> <u>method.</u>  Return the encoded body as a string.  This is the portion after the header and  the
           blank line.

           <u>Note:</u>  actually  prepares the body by "printing" to a scalar.  Proof that you can hand the "print*()"
           methods any blessed object that responds to a print() message.

       header_as_string
           <u>Instance</u> <u>method.</u>  Return the header as a string.

   <b>Sending</b>
       send
       send HOW, HOWARGS...
           <u>Class/instance</u> <u>method.</u>  This is the principal method for sending mail, and for configuring  how  mail
           will be sent.

           <u>As</u>  <u>a</u>  <u>class</u>  <u>method</u>  with a HOW argument and optional HOWARGS, it sets the default sending mechanism
           that the no-argument instance method will use.  The HOW is a  facility  name  (<b>see</b>  <b>below</b>),  and  the
           HOWARGS  is interpreted by the facility.  The class method returns the previous HOW and HOWARGS as an
           array.

               MIME::Lite-&gt;send('sendmail', "d:\\programs\\sendmail.exe");
               ...
               $msg = MIME::Lite-&gt;new(...);
               $msg-&gt;send;

           <u>As</u> <u>an</u> <u>instance</u> <u>method</u> <u>with</u> <u>arguments</u> (a HOW argument and optional HOWARGS), sends the message in  the
           requested manner; e.g.:

               $msg-&gt;send('sendmail', "d:\\programs\\sendmail.exe");

           <u>As</u>  <u>an</u>  <u>instance</u>  <u>method</u>  <u>with</u> <u>no</u> <u>arguments,</u> sends the message by the default mechanism set up by the
           class method.  Returns whatever the mail-handling routine returns: this should be  true  on  success,
           false/exception on error:

               $msg = MIME::Lite-&gt;new(From=&gt;...);
               $msg-&gt;send || die "you DON'T have mail!";

           On Unix systems (or rather non-Win32 systems), the default setting is equivalent to:

               MIME::Lite-&gt;send("sendmail", "/usr/lib/sendmail -t -oi -oem");

           On Win32 systems the default setting is equivalent to:

               MIME::Lite-&gt;send("smtp");

           The  assumption  is  that on Win32 your site/lib/Net/libnet.cfg file will be preconfigured to use the
           appropriate SMTP server. See below for configuring for authentication.

           There are three facilities:

           "sendmail", ARGS...
               Send a message by piping it into the "sendmail" command.   Uses  the  <b>send_by_sendmail()</b>  method,
               giving it the ARGS.  This usage implements (and deprecates) the sendmail() method.

           "smtp", [HOSTNAME, [NAMEDPARMS] ]
               Send  a  message  by  SMTP,  using  optional  HOSTNAME  as  SMTP-sending host.  Net::SMTP will be
               required.  Uses the <b>send_by_smtp()</b> method. Any additional arguments passed in will also be passed
               through to send_by_smtp.  This is useful for things like mail  servers  requiring  authentication
               where you can say something like the following

                 MIME::Lite-&gt;send('smtp', $host, AuthUser=&gt;$user, AuthPass=&gt;$pass);

               which will configure things so future uses of

                 $msg-&gt;send();

               do the right thing.

           "sub", \&amp;SUBREF, ARGS...
               Sends  a  message  MSG  by invoking the subroutine SUBREF of your choosing, with MSG as the first
               argument, and ARGS following.

           <u>For</u> <u>example:</u> let's say you're on an OS which lacks the usual Unix  "sendmail"  facility,  but  you've
           installed  something  a  lot  like  it,  and  you  need  to  configure  your  Perl script to use this
           "sendmail.exe" program.  Do this following in your script's setup:

               MIME::Lite-&gt;send('sendmail', "d:\\programs\\sendmail.exe");

           Then, whenever you need to send a message $msg, just say:

               $msg-&gt;send;

           That's it.  Now, if you ever move your script to a Unix box, all you need to do is change  that  line
           in the setup and you're done.  All of your $msg-&gt;send invocations will work as expected.

           After  sending, the method <b>last_send_successful()</b> can be used to determine if the send was successful
           or not.

       send_by_sendmail SENDMAILCMD
       send_by_sendmail PARAM=&gt;VALUE, ARRAY, HASH...
           <u>Instance</u> <u>method.</u>  Send message via an external "sendmail" program (this will probably only work  out-
           of-the-box on Unix systems).

           Returns true on success, false or exception on error.

           You  can  specify  the program and all its arguments by giving a single string, SENDMAILCMD.  Nothing
           fancy is done; the message is simply piped in.

           However, if your needs are a little more advanced, you can specify zero  or  more  of  the  following
           PARAM/VALUE  pairs  (or  a  reference  to  hash or array of such arguments as well as any combination
           thereof); a Unix-style, taint-safe "sendmail" command will be constructed for you:

           Sendmail
               Full path to the program to use.  Default is "/usr/lib/sendmail".

           BaseArgs
               Ref to the basic array of arguments we start with.  Default is "["-t", "-oi", "-oem"]".

           SetSender
               Unless this is <u>explicitly</u> given as false, we attempt to automatically set the  "-f"  argument  to
               the first address that can be extracted from the "From:" field of the message (if there is one).

               <u>What</u>  <u>is</u>  <u>the</u>  <u>-f,</u>  <u>and</u>  <u>why</u> <u>do</u> <u>we</u> <u>use</u> <u>it?</u>  Suppose we did <u>not</u> use "-f", and you gave an explicit
               "From:" field in your message: in this case, the sendmail "envelope" would indicate the <u>real</u> user
               your process was running under, as a way of preventing  mail  forgery.   Using  the  "-f"  switch
               causes the sender to be set in the envelope as well.

               <u>So</u>  <u>when</u> <u>would</u> <u>I</u> <u>NOT</u> <u>want</u> <u>to</u> <u>use</u> <u>it?</u>  If sendmail doesn't regard you as a "trusted" user, it will
               permit the "-f" but also add an "X-Authentication-Warning" header to the message  to  indicate  a
               forged envelope.  To avoid this, you can either (1) have SetSender be false, or (2) make yourself
               a trusted user by adding a "T" configuration
                   command to your <u>sendmail.cf</u> file
                   (e.g.: "Teryq" if the script is running as user "eryq").

           FromSender
               If defined, this is identical to setting SetSender to true, except that instead of looking at the
               "From:" field we use the address given by this option.  Thus:

                   FromSender =&gt; '<a href="mailto:me@myhost.com">me@myhost.com</a>'

           After  sending, the method <b>last_send_successful()</b> can be used to determine if the send was successful
           or not.

       send_by_smtp HOST, ARGS...
       send_by_smtp REF, HOST, ARGS
           <u>Instance</u> <u>method.</u>  Send message via SMTP, using Net::SMTP -- which will be required for this feature.

           HOST is the name of SMTP server to connect to, or  undef  to  have  Net::SMTP  use  the  defaults  in
           Libnet.cfg.

           ARGS  are a list of key value pairs which may be selected from the list below. Many of these are just
           passed through to specific Net::SMTP commands and you should review that module for details.

           Please see Good-vs-bad email addresses with <b>send_by_smtp()</b>

           Hello
           LocalAddr
           LocalPort
           Timeout
           Port
           ExactAddresses
           Debug
               See <b>Net::SMTP::new()</b> for details.

           Size
           Return
           Bits
           Transaction
           Envelope
               See <b>Net::SMTP::mail()</b> for details.

           SkipBad
               If true doesn't throw an error when multiple email addresses are provided and some are not valid.
               See <b>Net::SMTP::recipient()</b> for details.

           AuthUser
               Authenticate with <b>Net::SMTP::auth()</b> using this username.

           AuthPass
               Authenticate with <b>Net::SMTP::auth()</b> using this password.

           NoAuth
               Normally if AuthUser and AuthPass are defined MIME::Lite  will  attempt  to  use  them  with  the
               <b>Net::SMTP::auth()</b>  command  to authenticate the connection, however if this value is true then no
               authentication occurs.

           To  Sets the addresses to send to. Can be a string or a reference to an array  of  strings.  Normally
               this is extracted from the To: (and Cc: and Bcc: fields if $AUTO_CC is true).

               This value overrides that.

           From
               Sets  the  email  address to send from. Normally this value is extracted from the Return-Path: or
               From: field of the mail itself (in that order).

               This value overrides that.

           <u>Returns:</u> True on success, croaks with an error message on failure.

           After sending, the method <b>last_send_successful()</b> can be used to determine if the send was  successful
           or not.

       send_by_testfile FILENAME
           <u>Instance</u> <u>method.</u>  Print message to a file (namely FILENAME), which will default to mailer.testfile If
           file exists, message will be appended.

       last_send_successful
           This  method will return TRUE if the last <b>send()</b> or <b>send_by_XXX()</b> method call was successful. It will
           return defined but false if it was not successful, and undefined if the object had not been  used  to
           send yet.

       sendmail COMMAND...
           <u>Class</u>  <u>method,</u>  <u>DEPRECATED.</u>   Declare the sender to be "sendmail", and set up the "sendmail" command.
           <u>You</u> <u>should</u> <u>use</u> <u><b>send()</b></u> <u>instead.</u>

   <b>Miscellaneous</b>
       quiet ONOFF
           <u>Class</u> <u>method.</u>  Suppress/unsuppress all warnings coming from this module.

               MIME::Lite-&gt;<a href="../man1/quiet.1.html">quiet</a>(1);       ### I know what I'm doing

           I recommend that you include that comment as well.  And while you type it, say it  out  loud:  if  it
           doesn't feel right, then maybe you should reconsider the whole line.  ";-)"

</pre><h4><b>NOTES</b></h4><pre>
   <b>How</b> <b>do</b> <b>I</b> <b>prevent</b> <b>"Content"</b> <b>headers</b> <b>from</b> <b>showing</b> <b>up</b> <b>in</b> <b>my</b> <b>mail</b> <b>reader?</b>
       Apparently, some people are using mail readers which display the MIME headers like "Content-disposition",
       and they want MIME::Lite not to generate them "because they look ugly".

       Sigh.

       Y'know,  kids,  those headers aren't just there for cosmetic purposes.  They help ensure that the message
       is <u>understood</u> correctly by mail readers.  But okay, you asked for it, you got it...  here's how  you  can
       suppress the standard MIME headers.  Before you send the message, do this:

           $msg-&gt;scrub;

       You  can  <b>scrub()</b> any part of a multipart message independently; just be aware that it works recursively.
       Before you scrub, note the rules that I follow:

       Content-type
           You can safely scrub the "content-type" attribute if, and only if, the part is of  type  "text/plain"
           with charset "us-ascii".

       Content-transfer-encoding
           You can safely scrub the "content-transfer-encoding" attribute if, and only if, the part uses "7bit",
           "8bit",  or  "binary"  encoding.   You  are  far  better  off doing this if your lines are under 1000
           characters.  Generally, that means you <u>can</u> scrub it for plain text, and you can <u>not</u>  scrub  this  for
           images, etc.

       Content-disposition
           You can safely scrub the "content-disposition" attribute if you trust the mail reader to do the right
           thing  when  it  decides  whether to show an attachment inline or as a link.  Be aware that scrubbing
           both the content-disposition and the content-type means  that  there  is  no  way  to  "recommend"  a
           filename for the attachment!

           <b>Note:</b>  there  are  reports  of  brain-dead  MUAs out there that do the wrong thing if you <u>provide</u> the
           content-disposition.  If your attachments keep showing up inline or vice-versa,  try  scrubbing  this
           attribute.

       Content-length
           You can always scrub "content-length" safely.

   <b>How</b> <b>do</b> <b>I</b> <b>give</b> <b>my</b> <b>attachment</b> <b>a</b> <b>[different]</b> <b>recommended</b> <b>filename?</b>
       By using the Filename option (which is different from Path!):

           $msg-&gt;attach(Type =&gt; "image/gif",
                        Path =&gt; "/here/is/the/real/file.GIF",
                        Filename =&gt; "logo.gif");

       You should <u>not</u> put path information in the Filename.

   <b>Working</b> <b>with</b> <b>UTF-8</b> <b>and</b> <b>other</b> <b>character</b> <b>sets</b>
       All  text  that is added to your mail message should be properly encoded.  MIME::Lite doesn't do this for
       you. For instance, if you want to send your mail in UTF-8, where  $to,  $subject  and  $text  have  these
       values:

       •   To: "Ramón Nuñez &lt;<a href="mailto:foo@bar.com">foo@bar.com</a>&gt;"

       •   Subject: "¡Aquí está!"

       •   Text: "¿Quieres ganar muchos €'s?"

           use MIME::Lite;
           use Encode qw(encode encode_utf8 );

           my $to      = "Ram\363n Nu\361ez &lt;foo\@bar.com&gt;";
           my $subject = "\241Aqu\355 est\341!";
           my $text    = "\277Quieres ganar muchos \x{20ac}'s?";

           ### Create a new message encoded in UTF-8:
           my $msg = MIME::Lite-&gt;new(
               From    =&gt; '<a href="mailto:me@myhost.com">me@myhost.com</a>',
               To      =&gt; encode( 'MIME-Header', $to ),
               Subject =&gt; encode( 'MIME-Header', $subject ),
               Data    =&gt; encode_utf8($text)
           );
           $msg-&gt;attr( 'content-type' =&gt; 'text/plain; charset=utf-8' );
           $msg-&gt;send;

       <b>Note:</b>

       •   The  above example assumes that the values you want to encode are in Perl's "internal" form, i.e. the
           strings contain decoded UTF-8 characters, not the bytes that represent those characters.

           See perlunitut, perluniintro, perlunifaq and Encode for more.

       •   If, for the body of the email,  you want to use a character set other than  UTF-8,  then  you  should
           encode appropriately, and set the correct "content-type", eg:

               ...
               Data =&gt; encode('iso-8859-15',$text)
               ...

               $msg-&gt;attr( 'content-type' =&gt; 'text/plain; charset=iso-8859-15' );

       •   For the message headers, Encode::MIME::Header only support UTF-8, but most modern mail clients should
           be  able  to  handle this.  It is not a problem to have your headers in a different encoding from the
           message body.

   <b>Benign</b> <b>limitations</b>
       This is "lite", after all...

       •   There's no parsing.  Get MIME-tools if you need to parse MIME messages.

       •   MIME::Lite messages are currently <u>not</u> interchangeable  with  either  Mail::Internet  or  MIME::Entity
           objects.  This is a completely separate module.

       •   A  content-length  field is only inserted if the encoding is binary, the message is a singlepart, and
           all the document data is available at build() time by virtue of residing in a  simple  path,  or  in-
           core.   Since content-length is not a standard MIME field anyway (that's right, kids: it's not in the
           MIME RFCs, it's an HTTP thing), this seems pretty fair.

       •   MIME::Lite alone cannot help you lose weight.  You must supplement your  use  of  MIME::Lite  with  a
           healthy diet and exercise.

   <b>Cheap</b> <b>and</b> <b>easy</b> <b>mailing</b>
       I  thought  putting in a default "sendmail" invocation wasn't too bad an idea, since a lot of Perlers are
       on UNIX systems. (As of version 3.02 this is default only on Non-Win32 boxen. On Win32 boxen the  default
       is to use SMTP and the defaults specified in the site/lib/Net/libnet.cfg)

       The out-of-the-box configuration is:

            MIME::Lite-&gt;send('sendmail', "/usr/lib/sendmail -t -oi -oem");

       By the way, these arguments to sendmail are:

            -t      Scan message for To:, Cc:, Bcc:, etc.

            -oi     Do NOT treat a single "." on a line as a message terminator.
                    As in, "-oi vey, it truncated my message... why?!"

            -oem    On error, mail back the message (I assume to the
                    appropriate address, given in the header).
                    When mail returns, circle is complete.  Jai Guru Deva -oem.

       Note that these are the same arguments you get if you configure to use the smarter, taint-safe mailing:

            MIME::Lite-&gt;send('sendmail');

       If  you  get  "X-Authentication-Warning"  headers  from this, you can forgo diddling with the envelope by
       instead specifying:

            MIME::Lite-&gt;send('sendmail', SetSender=&gt;0);

       And, if you're not on a Unix system, or if you'd just rather send mail some  other  way,  there's  always
       SMTP, which these days probably requires authentication so you probably need to say

            MIME::Lite-&gt;send('smtp', "smtp.myisp.net",
               AuthUser=&gt;"YourName",AuthPass=&gt;"YourPass" );

       Or you can set up your own subroutine to call.  In any case, check out the <b>send()</b> method.

</pre><h4><b>WARNINGS</b></h4><pre>
   <b>Good-vs-bad</b> <b>email</b> <b>addresses</b> <b>with</b> <b>send_by_smtp()</b>
       If  using  <b>send_by_smtp()</b>, be aware that unless you explicitly provide the email addresses to send to and
       from you will be forcing MIME::Lite to extract email addresses out of a possible  list  provided  in  the
       "To:", "Cc:", and "Bcc:" fields.  This is tricky stuff, and as such only the following sorts of addresses
       will work reliably:

           username
           <a href="mailto:full.name@some.host.com">full.name@some.host.com</a>
           "Name, Full" &lt;<a href="mailto:full.name@some.host.com">full.name@some.host.com</a>&gt;

       <b>Disclaimer:</b>  MIME::Lite  was  never  intended  to  be  a  Mail  User Agent, so please don't expect a full
       implementation of RFC-822.  Restrict yourself to the common forms of Internet addresses described herein,
       and you should be fine.  If this is not feasible, then consider using MIME::Lite to <u>prepare</u> your  message
       only, and using Net::SMTP explicitly to <u>send</u> your message.

       <b>Note:</b>  As  of  MIME::Lite  v3.02  the  mail  name  extraction  routines have been beefed up considerably.
       Furthermore if Mail::Address is provided then name extraction is done using that. Accordingly  the  above
       advice  is  now  less  true  than  it  once  was. Funky email names <u>should</u> work properly now. However the
       disclaimer remains. Patches welcome. :-)

   <b>Formatting</b> <b>of</b> <b>headers</b> <b>delayed</b> <b>until</b> <b>print()</b>
       This class treats a MIME header in  the  most  abstract  sense,  as  being  a  collection  of  high-level
       attributes.  The actual RFC-822-style header fields are not constructed until it's time to actually print
       the darn thing.

   <b>Encoding</b> <b>of</b> <b>data</b> <b>delayed</b> <b>until</b> <b>print()</b>
       When  you  specify  message  bodies (in <b>build()</b> or <b>attach()</b>) -- whether by <b>FH</b>, <b>Data</b>, or <b>Path</b> -- be warned
       that we don't attempt to open files, read filehandles, or encode the data until <b>print()</b> is invoked.

       In the past, this created some confusion for users of sendmail who gave the wrong path to  an  attachment
       body,  since  enough  of the <b>print()</b> would succeed to get the initial part of the message out.  Nowadays,
       $AUTO_VERIFY is used to spot-check the Paths given before the  mail  facility  is  employed.   A  whisker
       slower, but tons safer.

       Note  that if you give a message body via FH, and try to <b>print()</b> a message twice, the second <b>print()</b> will
       not do the right thing unless you  explicitly rewind the filehandle.

       You can get past these difficulties by using the <b>ReadNow</b> option, provided that you have enough memory  to
       handle your messages.

   <b>MIME</b> <b>attributes</b> <b>are</b> <b>separate</b> <b>from</b> <b>header</b> <b>fields!</b>
       <b>Important:</b> the MIME attributes are stored and manipulated separately from the message header fields; when
       it comes time to print the header out, <u>any</u> <u>explicitly-given</u> <u>header</u> <u>fields</u> <u>override</u> <u>the</u> <u>ones</u> <u>that</u> <u>would</u> <u>be</u>
       <u>created</u> <u>from</u> <u>the</u> <u>MIME</u> <u>attributes.</u>  That means that this:

           ### DANGER ### DANGER ### DANGER ### DANGER ### DANGER ###
           $msg-&gt;add("Content-type", "text/html; charset=US-ASCII");

       will  set  the  exact  "Content-type"  field  in  the  header I write, <u>regardless</u> <u>of</u> <u>what</u> <u>the</u> <u>actual</u> <u>MIME</u>
       <u>attributes</u> <u>are.</u>

       <u>This</u> <u>feature</u> <u>is</u> <u>for</u> <u>experienced</u> <u>users</u> <u>only,</u> as an escape hatch in case the  code  that  normally  formats
       MIME  header  fields  isn't  doing  what  you need.  And, like any escape hatch, it's got an alarm on it:
       MIME::Lite will warn you if you attempt to set() or replace() any MIME header field.  Use attr() instead.

   <b>Beware</b> <b>of</b> <b>lines</b> <b>consisting</b> <b>of</b> <b>a</b> <b>single</b> <b>dot</b>
       Julian Haight noted that MIME::Lite allows you to compose messages with lines in the body consisting of a
       single ".".  This is true: it should be completely harmless so long as "sendmail" is used  with  the  -oi
       option (see "Cheap and easy mailing").

       However,  I  don't  know  if  using  Net::SMTP  to  transfer such a message is equally safe.  Feedback is
       welcomed.

       My perspective: I don't want to magically diddle with  a  user's  message  unless  absolutely  positively
       necessary.   Some  users may want to send files with "." alone on a line; my well-meaning tinkering could
       seriously harm them.

   <b>Infinite</b> <b>loops</b> <b>may</b> <b>mean</b> <b>tainted</b> <b>data!</b>
       Stefan Sautter noticed a bug in 2.106 where a m//gc match was failing due to tainted data, leading to  an
       infinite loop inside MIME::Lite.

       I am attempting to correct for this, but be advised that my fix will silently untaint the data (given the
       context  in  which  the problem occurs, this should be benign: I've labelled the source code with UNTAINT
       comments for the curious).

       So: don't depend on taint-checking to save you from outputting tainted data in a message.

   <b>Don't</b> <b>tweak</b> <b>the</b> <b>global</b> <b>configuration</b>
       Global configuration variables are bad, and should go away.  Until they do, please follow the hints  with
       each setting on how <u>not</u> to change it.

</pre><h4><b>A</b> <b>MIME</b> <b>PRIMER</b></h4><pre>
   <b>Content</b> <b>types</b>
       The  "Type"  parameter  of  build()  is a <u>content</u> <u>type</u>.  This is the actual type of data you are sending.
       Generally this is a string of the form "majortype/minortype".

       Here are the major MIME types.  A more-comprehensive listing may be found in RFC-2046.

       application
           Data which does not fit in any of the other categories, particularly data to  be  processed  by  some
           type      of      application      program.       "application/octet-stream",     "application/gzip",
           "application/postscript"...

       audio
           Audio data.  "audio/basic"...

       image
           Graphics data.  "image/gif", "image/jpeg"...

       message
           A message, usually another mail or MIME message.  "message/rfc822"...

       multipart
           A message containing other messages.  "multipart/mixed", "multipart/alternative"...

       text
           Textual data, meant for humans to read.  "text/plain", "text/html"...

       video
           Video or video+audio data.  "video/mpeg"...

   <b>Content</b> <b>transfer</b> <b>encodings</b>
       The "Encoding" parameter of build().  This is how the message body is packaged up for safe transit.

       Here are the 5 major MIME encodings.  A more-comprehensive listing may be found in RFC-2045.

       7bit
           Basically, no <u>real</u> encoding is done.  However, this label guarantees that  no  8-bit  characters  are
           present, and that lines do not exceed 1000 characters in length.

       8bit
           Basically,  no  <u>real</u> encoding is done.  The message might contain 8-bit characters, but this encoding
           guarantees that lines do not exceed 1000 characters in length.

       binary
           No encoding is done at all.  Message might contain 8-bit characters, and lines might be  longer  than
           1000 characters long.

           The  most liberal, and the least likely to get through mail gateways.  Use sparingly, or (better yet)
           not at all.

       base64
           Like "uuencode", but very well-defined.  This is how you should send essentially  binary  information
           (tar files, GIFs, JPEGs, etc.).

       quoted-printable
           Useful  for  encoding  messages  which  are textual in nature, yet which contain non-ASCII characters
           (e.g., Latin-1, Latin-2, or any other 8-bit alphabet).

</pre><h4><b>HELPER</b> <b>MODULES</b></h4><pre>
       MIME::Lite works nicely with other certain other modules if they are present.  Good to have installed are
       the   latest   MIME::Types,    Mail::Address,    MIME::Base64,    MIME::QuotedPrint,    and    Net::SMTP.
       Email::Date::Format is strictly required.

       If they aren't present then some functionality won't work, and other features won't be as efficient or up
       to date as they could be. Nevertheless they are optional extras.

</pre><h4><b>BUNDLED</b> <b>GOODIES</b></h4><pre>
       MIME::Lite  comes  with  a number of extra files in the distribution bundle.  This includes examples, and
       utility modules that you can use to get yourself started with the module.

       The ./examples directory contains a number of snippets in prepared form, generally they  are  documented,
       but they should be easy to understand.

       The  ./contrib  directory contains a companion/tool modules that come bundled with MIME::Lite, they don't
       get installed by default. Please review the POD they come with.

</pre><h4><b>BUGS</b></h4><pre>
       The whole reason that version 3.0 was released was to ensure that MIME::Lite is up to date  and  patched.
       If you find an issue please report it.

       As  far  as  I  know  MIME::Lite  doesn't  currently  have  any  serious  bugs,  but  my  usage is hardly
       comprehensive.

       Having said that there are a number of open issues for me, mostly caused by the progress in the community
       as whole since Eryq last released. The tests are based  around  an  interesting  but  non  standard  test
       framework. I'd like to change it over to using Test::More.

       Should tests fail please review the ./testout directory, and in any bug reports please include the output
       of the relevant file. This is the only redeeming feature of not using Test::More that I can see.

       Bug fixes / Patches / Contribution are welcome, however I probably won't apply them unless they also have
       an  associated  test.  This  means  that  if  I don't have the time to write the test the patch won't get
       applied, so please, include tests for any patches you provide.

</pre><h4><b>VERSION</b></h4><pre>
       Version: 3.033

</pre><h4><b>CHANGE</b> <b>LOG</b></h4><pre>
       Moved to ./changes.pod

       NOTE: Users of the "advanced features" of 3.01_0x smtp sending should take care: These features have been
       REMOVED as they never really fit the purpose of the module. Redundant SMTP delivery is a task that should
       be handled by another module.

</pre><h4><b>TERMS</b> <b>AND</b> <b>CONDITIONS</b></h4><pre>
         Copyright (c) 1997 by Eryq.
         Copyright (c) 1998 by ZeeGee Software Inc.
         Copyright (c) 2003,2005 Yves Orton. (demerphq)

       All rights reserved.  This program is free software; you can redistribute it and/or modify it  under  the
       same terms as Perl itself.

       This software comes with <b>NO</b> <b>WARRANTY</b> of any kind.  See the COPYING file in the distribution for details.

</pre><h4><b>NUTRITIONAL</b> <b>INFORMATION</b></h4><pre>
       For  some  reason,  the  US  FDA says that this is now required by law on any products that bear the name
       "Lite"...

       Version 3.0 is now new and improved! The distribution is now 30% smaller!

           MIME::Lite                |
           ------------------------------------------------------------
           Serving size:             | 1 module
           Servings per container:   | 1
           Calories:                 | 0
           Fat:                      | 0g
             Saturated Fat:          | 0g

       Warning: for consumption by hardware only!  May produce indigestion in humans if taken internally.

</pre><h4><b>AUTHOR</b></h4><pre>
       Eryq (<u><a href="mailto:eryq@zeegee.com">eryq@zeegee.com</a></u>).  President, ZeeGee Software Inc. (<u><a href="http://www.zeegee.com">http://www.zeegee.com</a></u>).

       Go to <u><a href="http://www.cpan.org">http://www.cpan.org</a></u> for the latest downloads and on-line documentation for this module.  Enjoy.

       Patches And Maintenance by Yves Orton and many others.  Consult ./changes.pod

perl v5.38.2                                       2024-03-07                                    <u>MIME::<a href="../man3pm/Lite.3pm.html">Lite</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>