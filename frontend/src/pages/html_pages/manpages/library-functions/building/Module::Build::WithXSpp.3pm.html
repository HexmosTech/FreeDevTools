<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module::Build::WithXSpp - XS++ enhanced flavour of Module::Build</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmodule-build-withxspp-perl">libmodule-build-withxspp-perl_0.14-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Module::Build::WithXSpp - XS++ enhanced flavour of Module::Build

</pre><h4><b>SYNOPSIS</b></h4><pre>
       In <u>Build.PL</u>:

         use strict;
         use warnings;
         use 5.006001;

         use Module::Build::WithXSpp;

         my $build = Module::Build::WithXSpp-&gt;new(
           # normal Module::Build arguments...
           # optional: mix in some extra C typemaps:
           extra_typemap_modules =&gt; {
             'ExtUtils::Typemaps::ObjectMap' =&gt; '0',
           },
         );
         $build-&gt;create_build_script;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This subclass of Module::Build adds some tools and processes to make it easier to use for wrapping C++
       using XS++ (ExtUtils::XSpp).

       There are a few minor differences from using "Module::Build" for an ordinary XS module and a few
       conventions that you should be aware of as an XS++ module author. They are documented in the "FEATURES
       AND CONVENTIONS" section below. But if you can't be bothered to read all that, you may choose skip it and
       blindly follow the advice in "JUMP START FOR THE IMPATIENT".

       An example of a full distribution based on this build tool can be found in the ExtUtils::XSpp
       distribution under <u>examples/XSpp-Example</u>. Using that example as the basis for your
       "Module::Build::WithXSpp"-based distribution is probably a good idea.

</pre><h4><b>FEATURES</b> <b>AND</b> <b>CONVENTIONS</b></h4><pre>
   <b>XS</b> <b>files</b>
       By default, "Module::Build::WithXSpp" will automatically generate a main XS file for your module which
       includes all XS++ files and does the correct incantations to support C++.

       If "Module::Build::WithXSpp" detects any XS files in your module, it will skip the generation of this
       default file and assume that you wrote a custom main XS file. If that is not what you want, and wish to
       simply include plain XS code, then you should put the XS in a verbatim block of an <u>.xsp</u> file. In case you
       need to use the plain-C part of an XS file for "#include" directives and other code, then put your code
       into a header file and "#include" it from an <u>.xsp</u> file:

       In <u>src/mystuff.h</u>:

         #include &lt;something&gt;
         using namespace some::thing;

       In <u>xsp/MyClass.xsp</u>

         #include "mystuff.h"

         %{
           ... verbatim XS here ...
         %}

       Note that there is no guarantee about the order in which the XS++ files are picked up.

   <b>Build</b> <b>directory</b>
       When building your XS++ based extension, a temporary build directory <u>buildtmp</u> is created for the
       byproducts.  It is automatically cleaned up by "./Build clean".

   <b>Source</b> <b>directories</b>
       A Perl module distribution typically has the module ".pm" files in its <u>lib</u> subdirectory. In a
       "Module::Build::WithXSpp" based distribution, there are two more such conventions about source
       directories:

       If any C++ source files are present in the <u>src</u> directory, they will be compiled to object files and
       linked automatically.

       Any ".xs", ".xsp", and ".xspt" files in an <u>xs</u> or <u>xsp</u> subdirectory will be automatically picked up and
       included by the build system.

       For backwards compatibility, files of the above types are also recognized in <u>lib</u>.

   <b>Typemaps</b>
       In XS++, there are two types of typemaps: The ordinary XS typemaps which conventionally put in a file
       called <u>typemap</u>, and XS++ typemaps.

       The ordinary XS typemaps will be found in the main directory, under <u>lib</u>, and in the XS directories (<u>xs</u>
       and <u>xsp</u>). They are required to carry the ".map" extension or to be called <u>typemap</u>.  You may use multiple
       <u>.map</u> files if the entries do not collide. They will be merged at build time into a complete <u>typemap</u> file
       in the temporary build directory.

       The "extra_typemap_modules" option is the preferred way to do XS typemapping.  It works like any other
       "Module::Build" argument that declares dependencies except that it loads the listed modules at build time
       and includes their typemaps into the build.

       The XS++ typemaps are required to carry the ".xspt" extension or (for backwards compatibility) to be
       called "typemap.xsp".

   <b>Detecting</b> <b>the</b> <b>C++</b> <b>compiler</b>
       "Module::Build::WithXSpp" uses ExtUtils::CppGuess to detect a C++ compiler on your system that is
       compatible with the C compiler that was used to compile your perl binary. It sets some additional
       compiler/linker options.

       This is known to work on GCC (Linux, MacOS, Windows, and ?) as well as the MS VC toolchain. Patches to
       enable other compilers are <b>very</b> welcome.

   <b>Automatic</b> <b>dependencies</b>
       "Module::Build::WithXSpp" automatically adds several dependencies (on the currently running versions) to
       your distribution.  You can disable this by setting "auto_configure_requires =&gt; 0" in <u>Build.PL</u>.

       These are at configure time: "Module::Build", "Module::Build::WithXSpp" itself, and "ExtUtils::CppGuess".
       Additionally there will be a build-time dependency on "ExtUtils::XSpp".

       You do not have to set these dependencies yourself unless you need to set the required versions manually.

   <b>Include</b> <b>files</b>
       Unfortunately, including the perl headers produces quite some pollution and redefinition of common
       symbols. Therefore, it may be necessary to include some of your headers before including the perl
       headers. Specifically, this is the case for MSVC compilers and the standard library headers.

       Therefore, if you care about that platform in the least, you should use the "early_includes" option when
       creating a "Module::Build::WithXSpp" object to list headers to include before the perl headers. If such a
       supplied header file starts with a double quote, "#include "..."" is used, otherwise "#include &lt;...&gt;" is
       the default. Example:

         Module::Build::WithXSpp-&gt;new(
           early_includes =&gt; [qw(
             "mylocalheader.h"
             &lt;mysystemheader.h&gt;
           )]
         )

</pre><h4><b>JUMP</b> <b>START</b> <b>FOR</b> <b>THE</b> <b>IMPATIENT</b></h4><pre>
       There are as many ways to start a new CPAN distribution as there are CPAN distributions. Choose your
       favourite (I just do "h2xs -An My::Module"), then apply a few changes to your setup:

       • Obliterate any <u>Makefile.PL</u>.

         This is what your <u>Build.PL</u> should look like:

           use strict;
           use warnings;
           use 5.006001;
           use Module::Build::WithXSpp;

           my $build = Module::Build::WithXSpp-&gt;new(
             module_name         =&gt; 'My::Module',
             license             =&gt; 'perl',
             dist_author         =&gt; q{John Doe &lt;john_does_mail_address&gt;},
             dist_version_from   =&gt; 'lib/My/Module.pm',
             build_requires =&gt; { 'Test::More' =&gt; 0, },
             extra_typemap_modules =&gt; {
               'ExtUtils::Typemaps::ObjectMap' =&gt; '0',
               # ...
             },
           );
           $build-&gt;create_build_script;

         If you need to link against some library "libfoo", add this to the options:

             extra_linker_flags =&gt; [qw(-lfoo)],

         There is "extra_compiler_flags", too, if you need it.

       • You create two folders in the main distribution folder: <u>src</u> and <u>xsp</u>.

       • You  put any C++ code that you want to build and include in the module into <u>src/</u>. All the typical C(++)
         file extensions are recognized and will be compiled to object files and linked  into  the  module.  And
         headers in that folder will be accessible for "#include &lt;myheader.h&gt;".

         For good measure, move a copy of <u>ppport.h</u> to that directory.  See Devel::PPPort.

       • You do not write normal XS files. Instead, you write XS++ and put it into the <u>xsp/</u> folder in files with
         the  ".xsp"  extension.  Do not worry, you can include verbatim XS blocks in XS++. For details on XS++,
         see ExtUtils::XSpp.

       • If you need to do any XS type mapping, put your typemaps into a  <u>.map</u>  file  in  the  "xsp"  directory.
         Alternatively,  search  CPAN for an appropriate typemap module (cf.  ExtUtils::Typemaps::Default for an
         explanation).  XS++ typemaps belong into <u>.xspt</u> files in the same directory.

       • In this scheme, <u>lib/</u> only contains Perl module files (and  POD).   If  you  started  from  a  pure-Perl
         distribution, don't forget to add these magic two lines to your main module:

           require XSLoader;
           XSLoader::load('My::Module', $VERSION);

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Module::Build upon which this module is based.

       ExtUtils::XSpp  implements  XS++. The "ExtUtils::XSpp" distribution contains an <u>examples</u> directory with a
       usage example of this module.

       ExtUtils::Typemaps implements progammatic modification (merging) of C/XS  typemaps.  "ExtUtils::Typemaps"
       was  renamed  from  "ExtUtils::Typemap"  since the original name conflicted with the core <u>typemap</u> file on
       case-insensitive file systems.

       ExtUtils::Typemaps::Default explains the concept of having typemaps shipped as modules.

       ExtUtils::Typemaps::ObjectMap is such a typemap module and probably very useful for any XS++ module.

       ExtUtils::Typemaps::STL::String implements simple typemapping for STL "std::string"s.

</pre><h4><b>AUTHOR</b></h4><pre>
       Steffen Mueller &lt;<a href="mailto:smueller@cpan.org">smueller@cpan.org</a>&gt;

       With input and bug fixes from:

       Mattia Barbon

       Shmuel Fomberg

       Florian Schlichting

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright 2010, 2011, 2012, 2013 Steffen Mueller.

       This program is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.

perl v5.34.0                                       2022-06-15                       <u>Module::Build::<a href="../man3pm/WithXSpp.3pm.html">WithXSpp</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>