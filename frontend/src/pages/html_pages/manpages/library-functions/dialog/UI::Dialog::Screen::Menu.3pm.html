<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UI::Dialog::Screen::Menu - wrapper to screen dialogs.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libui-dialog-perl">libui-dialog-perl_1.21-0.1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       UI::Dialog::Screen::Menu - wrapper to screen dialogs.

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use UI::Dialog::Screen::Menu;

         # $d is an existing instance of UI::Dialog

         my $screen = new UI::Dialog::Screen::Menu ( dialog =&gt; $d );
         $screen-&gt;add_menu_item("This is the label", sub { print "Hello\n"; });

         # $rv is 0 if the user canceled, 1 if any menu item was selected.
         my $rv = $screen-&gt;run();

</pre><h4><b>ABSTRACT</b></h4><pre>
       UI::Dialog::Screen::Menu is a helper class which enables a clean and modular code flow for menu driven
       applications using UI::Dialog. Using callbacks assigned to menu items, a reactionary model to scripting
       with UI::Dialog becomes rapidly easy.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       UI::Dialog::Screen::Menu is actually "external" to the UI::Dialog core usage. The class simply wraps
       around an existing UI::Dialog instance for rendering a menu-driven flow of screens.

       Using this class, you define a number of screen instances and assign callbacks to each of the menu items.
       Once defined, simply call <b>run()</b> (or <b>loop()</b> to execute <b>run()</b> indefinitely). When a user selects one of the
       menu items, the assigned function will be executed. From within those functions, simply call other
       UI::Dialog::Screen::Menu instances and that's how you branch your user's experience from one screen to
       the next. See the <b>EXAMPLES</b>

</pre><h4><b>EXPORT</b></h4><pre>
         None

</pre><h4><b>INHERITS</b></h4><pre>
         None

</pre><h4><b>CONSTRUCTOR</b></h4><pre>
   <b>new(</b> <b>%options</b> <b>)</b>
       EXAMPLE
            # Have UI::Dialog::Screen::Menu use an existing UI::Dialog instance
            # to render the user interface.
            my $s = new( dialog =&gt; $d );

            # Also accepts UI::Dialog constructor arguments, so that it can create
            # it's own instance of UI::Dialog if none is provided.
            my $s = new( title =&gt; 'Default Title', backtitle =&gt; 'Backtitle',
                         width =&gt; 65, height =&gt; 20, listheight =&gt; 5,
                         order =&gt; [ 'zenity', 'xdialog', 'gdialog' ] );

       DESCRIPTION
                 This  is the Class Constructor method. It accepts a list of key =&gt; value pairs and uses them as
                 the defaults when interacting with the various widgets.

       RETURNS
                 A blessed object reference of the UI::Dialog::Screen::Menu class.

       OPTIONS
           The (...)'s after each option indicate the default for the option. An * denotes support  by  all  the
           widget methods on a per-use policy defaulting to the values decided during object creation.

           <b>dialog</b> <b>=</b> <b>UI::Dialog</b> (undef)
           <b>debug</b> <b>=</b> <b>0,1,2</b> (0)
           <b>order</b> <b>=</b> <b>[</b> <b>zenity,</b> <b>xdialog,</b> <b>gdialog,</b> <b>kdialog,</b> <b>cdialog,</b> <b>whiptail,</b> <b>ascii</b> <b>]</b> (as indicated)
           <b>PATH</b> <b>=</b> <b>[</b> <b><a href="file:/bin">/bin</a>,</b> <b><a href="file:/usr/bin">/usr/bin</a>,</b> <b><a href="file:/usr/local/bin">/usr/local/bin</a>,</b> <b>/opt/bin</b> <b>]</b> (as indicated)
           <b>backtitle</b> <b>=</b> <b>"backtitle"</b> ('') *
           <b>title</b> <b>=</b> <b>"title"</b> ('') *
           <b>beepbefore</b> <b>=</b> <b>0,1</b> (0) *
           <b>beepafter</b> <b>=</b> <b>0,1</b> (0) *
           <b>height</b> <b>=</b> <b>\d+</b> (20) *
           <b>width</b> <b>=</b> <b>\d+</b> (65) *
           <b>listheight</b> <b>=</b> <b>\d+</b> (5) *

</pre><h4><b>STATE</b> <b>METHODS</b></h4><pre>
   <b>run(</b> <b>)</b>
       EXAMPLE
            my $rv = $s-&gt;run();

       DESCRIPTION
                 Render  the  screen menu immediately. This method blocks until the user input has been received
                 and acted upon.

       RETURNS
                 TRUE if the user selected an item from the menu, FALSE otherwise.

   <b>loop(</b> <b>)</b>
       EXAMPLE
            $s-&gt;loop();

       DESCRIPTION
                 Calls the <b>run()</b> method immediately. Once <b>run()</b> completes it's  execution,  the  <b>loop()</b>  decides
                 whether  or  not  to  display  again.  If  the  return  value of <b>run()</b> is TRUE, the <b>loop()</b> will
                 continue. If the use pressed Cancel (or Escape) or any other action other than one of the  menu
                 items; the <b>loop()</b> will end. The <b>loop()</b> will also end if the <b>break_loop()</b> method is called.

       RETURNS
                 TRUE if the user selected an item from the menu, FALSE otherwise.

   <b>is_looping(</b> <b>)</b>
       EXAMPLE
            if ($s-&gt;is_looping()) {
                print "Currently in a UI::Dialog::Screen::Menu loop\n";
            }

       DESCRIPTION
                 Returns TRUE if the given screen is in a menu <b>loop()</b>, FALSE otherwise.

       RETURNS
                 a single SCALAR.

   <b>break_loop(</b> <b>)</b>
       EXAMPLE
            $s-&gt;break_loop();

       DESCRIPTION
                 Flags  the screen menu to stop looping. This does not close or otherwise clear the screen. This
                 simply flags the loop to exit at the end of it's current run.

       RETURNS
                 None.

</pre><h4><b>SCREEN</b> <b>METHODS</b></h4><pre>
   <b>add_menu_item(</b> <b>)</b>
       EXAMPLE
            my $index = $s-&gt;add_menu_item( "Menu Item Label", \%some_function );

       DESCRIPTION
                 Append a new item to the menu list.

       RETURNS
                 Returns the list index (starting from 0) of the item that was just appended to the list.

   <b>get_menu_items(</b> <b>)</b>
       EXAMPLE
            my @items = $s-&gt;get_menu_items();

       DESCRIPTION
                 Returns an array of hashrefs. Each hash contains a "label" and "func" key/value pairs.

       RETURNS
                 An ARRAY.

   <b>del_menu_item(</b> <b>)</b>
       EXAMPLE
            my $old_item = $d-&gt;del_menu_item( $index );

       DESCRIPTION
                 Remove a specific item from the menu, addressed by it's  list  index  (starting  from  0),  and
                 return the menu item as a hashref.

       RETURNS
                 A  HASH  containing the 'label' and 'func' of the menu item that was just removed from the menu
                 list.

   <b>set_menu_item(</b> <b>)</b>
       EXAMPLE
            # Modify the 'label' and 'func' for a specific menu item
            my $original_item = $s-&gt;set_menu_item( $index, $label, $func );

            # Modify just the label of a menu item
            my $original_item = $s-&gt;set_menu_item( $index, $label, undef );

            # Modify just the func of a menu item
            my $original_item = $s-&gt;set_menu_item( $index, undef, $func );

            # Effectively do nothing
            my $original_item = $s-&gt;set_menu_item( $index, undef, undef );

       DESCRIPTION
                 Modify the menu item addressed by the given index (starting from 0).   If  the  'label'  and/or
                 'func' arguments are undef then the previous value is kept.

       RETURNS
                 A HASH of the original values for the modified menu item.

</pre><h4><b>EXAMPLE</b> <b>USAGE</b></h4><pre>
       The below example assumed that $d is an instances of UI::Dialog.

        # Create our first screen
        my $s1 = new UI::Dialog::Screen::Menu ( dialog =&gt; $d );
        $s1-&gt;add_menu_item( "Just an option", \&amp;some_function );

        # Add a menu item that updates it's own label every time
        # it is selected.
        our $counter = 0;
        $s1-&gt;add_menu_item
         ( "Counter: ".$counter,
           sub {
             my ($self,$dialog,$index) = @_;
             $counter++;
             $self-&gt;set_menu_item($index,"Counter: ".$counter, undef);
           }
         );

        # Create a second screen
        my $s2 = new UI::Dialog::Screen::Menu ( dialog =&gt; $d );
        $s2-&gt;add_menu_item( "Another item", \&amp;another_function );

        # Link the second screen to an option of the first
        $s1-&gt;add_menu_item( "Goto Screen 2", sub { $s2-&gt;loop(); } );

        # Start a menu loop and actually display the first screen
        $s1-&gt;loop();

       Users  can get to second menu from selecting the third item on the first menu screen. As long as the user
       continues to select items from the second menu, it will continue to loop. If the user cancels the  second
       screen, the will return to the first which will itself continue to loop.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       PERLDOC
          UI::Dialog
          UI::Dialog::GNOME
          UI::Dialog::KDE
          UI::Dialog::Console
          UI::Dialog::Screen::Druid
          UI::Dialog::Backend
          UI::Dialog::Backend::ASCII
          UI::Dialog::Backend::CDialog
          UI::Dialog::Backend::GDialog
          UI::Dialog::Backend::KDialog
          UI::Dialog::Backend::Nautilus
          UI::Dialog::Backend::Whiptail
          UI::Dialog::Backend::XDialog
          UI::Dialog::Backend::XOSD
          UI::Dialog::Backend::Zenity

       MAN FILES
          <a href="../man1/dialog.1.html">dialog</a>(1), <a href="../man1/whiptail.1.html">whiptail</a>(1), <a href="../man1/zenity.1.html">zenity</a>(1), <a href="../man1/gdialog.1.html">gdialog</a>(1), <a href="../man1/Xdialog.1.html">Xdialog</a>(1),
          <a href="../man1/osd_cat.1.html">osd_cat</a>(1), <a href="../man1/kdialog.1.html">kdialog</a>(1) and <a href="../man1/nautilus.1.html">nautilus</a>(1)

</pre><h4><b>BUGS</b></h4><pre>
       Please email the author with any bug reports. Include the name of the module in the subject line.

</pre><h4><b>AUTHOR</b></h4><pre>
       Kevin C. Krinke, &lt;<a href="mailto:kevin@krinke.ca">kevin@krinke.ca</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
        Copyright (C) 2004-2016  Kevin C. Krinke &lt;<a href="mailto:kevin@krinke.ca">kevin@krinke.ca</a>&gt;

        This library is free software; you can redistribute it and/or
        modify it under the terms of the GNU Lesser General Public
        License as published by the Free Software Foundation; either
        version 2.1 of the License, or (at your option) any later version.

        This library is distributed in the hope that it will be useful,
        but WITHOUT ANY WARRANTY; without even the implied warranty of
        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
        Lesser General Public License for more details.

        You should have received a copy of the GNU Lesser General Public
        License along with this library; if not, write to the Free Software
        Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA

perl v5.28.0                                       2018-10-27                      <u>UI::Dialog::Screen::<a href="../man3pm/Menu.3pm.html">Menu</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>