<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>flask-httpauth - Flask-HTTPAuth Documentation</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/python3-flask-httpauth">python3-flask-httpauth_4.8.0-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       flask-httpauth - Flask-HTTPAuth Documentation

       <b>Flask-HTTPAuth</b> is a Flask extension that simplifies the use of HTTP authentication with Flask routes.

</pre><h4><b>BASIC</b> <b>AUTHENTICATION</b> <b>EXAMPLES</b></h4><pre>
       The following example application uses HTTP Basic authentication to protect route <b>'/'</b>:

          from flask import Flask
          from flask_httpauth import HTTPBasicAuth
          from werkzeug.security import generate_password_hash, check_password_hash

          app = Flask(__name__)
          auth = HTTPBasicAuth()

          users = {
              "john": generate_password_hash("hello"),
              "susan": generate_password_hash("bye")
          }

          @auth.verify_password
          def verify_password(username, password):
              if username in users and \
                      check_password_hash(users.get(username), password):
                  return username

          @app.route('/')
          @auth.login_required
          def index():
              return "Hello, {}!".format(auth.current_user())

          if __name__ == '__main__':
              app.run()

       The  function decorated with the <b>verify_password</b> decorator receives the username and password sent by the
       client. If the credentials belong to a user, then the function should return  the  user  object.  If  the
       credentials  are  invalid the function can return <b>None</b> or <b>False</b>. The user object can then be queried from
       the <b>current_user()</b> method of the authentication instance.

</pre><h4><b>DIGEST</b> <b>AUTHENTICATION</b> <b>EXAMPLE</b></h4><pre>
       The following example uses HTTP Digest authentication:

          from flask import Flask
          from flask_httpauth import HTTPDigestAuth

          app = Flask(__name__)
          app.config['SECRET_KEY'] = 'secret key here'
          auth = HTTPDigestAuth()

          users = {
              "john": "hello",
              "susan": "bye"
          }

          @auth.get_password
          def get_pw(username):
              if username in users:
                  return users.get(username)
              return None

          @app.route('/')
          @auth.login_required
          def index():
              return "Hello, {}!".format(auth.username())

          if __name__ == '__main__':
              app.run()

</pre><h4><b>TOKEN</b> <b>AUTHENTICATION</b> <b>EXAMPLE</b></h4><pre>
       The following example application uses a custom HTTP authentication scheme to protect route  <b>'/'</b>  with  a
       token:

          from flask import Flask
          from flask_httpauth import HTTPTokenAuth

          app = Flask(__name__)
          auth = HTTPTokenAuth(scheme='Bearer')

          tokens = {
              "secret-token-1": "john",
              "secret-token-2": "susan"
          }

          @auth.verify_token
          def verify_token(token):
              if token in tokens:
                  return tokens[token]

          @app.route('/')
          @auth.login_required
          def index():
              return "Hello, {}!".format(auth.current_user())

          if __name__ == '__main__':
              app.run()

       The  <b>HTTPTokenAuth</b>  is a generic authentication handler that can be used with non-standard authentication
       schemes, with the scheme name given as an  argument  in  the  constructor.  In  the  above  example,  the
       <b>WWW-Authenticate</b> header provided by the server will use <b>Bearer</b> as scheme:

          WWW-Authenticate: Bearer realm="Authentication Required"

       The  <b>verify_token</b>  callback  receives  the  authentication  credentials  provided  by  the  client on the
       <b>Authorization</b> header. This can be a simple token, or can contain multiple arguments, which  the  function
       will  have  to parse and extract from the string. As with the <b>verify_password</b>, the function should return
       the user object if the token is valid.

       In the examples directory you can find a complete example that uses JWS tokens. JWS tokens are similar to
       JWT tokens. However using JWT tokens would require an external dependency.

</pre><h4><b>USING</b> <b>MULTIPLE</b> <b>AUTHENTICATION</b> <b>SCHEMES</b></h4><pre>
       Applications sometimes need to support a combination  of  authentication  methods.  For  example,  a  web
       application could be authenticated by sending client id and secret over basic authentication, while third
       party  API  clients use a JWS or JWT bearer token. The <u>MultiAuth</u> class allows you to protect a route with
       more than one authentication object. To grant access to the endpoint, one of the  authentication  methods
       must validate.

       In the examples directory you can find a complete example that uses basic and token authentication.

</pre><h4><b>USER</b> <b>ROLES</b></h4><pre>
       Flask-HTTPAuth includes a simple role-based authentication system that can optionally be added to provide
       an  additional  layer  of  granularity  in  filtering accesses to routes. To enable role support, write a
       function that returns the list of roles for  a  given  user  and  decorate  it  with  the  <b>get_user_roles</b>
       decorator:

          @auth.get_user_roles
          def get_user_roles(user):
              return user.get_roles()

       To  restrict  access to a route to users having a given role, add the <b>role</b> argument to the <b>login_required</b>
       decorator:

          @app.route('/admin')
          @auth.login_required(role='admin')
          def admins_only():
              return "Hello {}, you are an admin!".format(auth.current_user())

       The <b>role</b> argument can take a list of roles, in which case users who have any of the given roles  will  be
       granted access:

          @app.route('/admin')
          @auth.login_required(role=['admin', 'moderator'])
          def admins_only():
              return "Hello {}, you are an admin or a moderator!".format(auth.current_user())

       In the most advanced usage, users can be filtered by having multiple roles:

          @app.route('/admin')
          @auth.login_required(role=['user', ['moderator', 'contributor']])
          def admins_only():
              return "Hello {}, you are a user or a moderator/contributor!".format(auth.current_user())

</pre><h4><b>DEPLOYMENT</b> <b>CONSIDERATIONS</b></h4><pre>
       Be  aware that some web servers do not pass the <b>Authorization</b> headers to the WSGI application by default.
       For example, if you use Apache with  mod_wsgi,  you  have  to  set  option  <b>WSGIPassAuthorization</b>  <b>On</b>  as
       <u>documented</u> <u>here</u>.

</pre><h4><b>DEPRECATED</b> <b>BASIC</b> <b>AUTHENTICATION</b> <b>OPTIONS</b></h4><pre>
       Before  the  <b>verify_password</b> described above existed there were other simpler mechanisms for implementing
       basic authentication. While these are deprecated they are still maintained. However, the  <b>verify_password</b>
       callback should be preferred as it provides greater security and flexibility.

       The  <b>get_password</b>  callback  needs to return the password associated with the username given as argument.
       Flask-HTTPAuth will allow access only if <b>get_password(username)</b> <b>==</b> <b>password</b>. Example:

          @auth.get_password
          def get_password(username):
              return get_password_for_username(username)

       Using this callback alone is in general not a good idea because it requires passwords to be available  in
       plaintext  in  the  server.  In  the  more likely scenario that the passwords are stored hashed in a user
       database, then an additional callback is needed to define how to hash a password:

          @auth.hash_password
          def hash_pw(password):
              return hash_password(password)

       In this example, you have to replace <b>hash_password()</b> with the specific  hashing  function  used  in  your
       application.   When   the   <b>hash_password</b>   callback   is   provided,   access   will   be  granted  when
       <b>get_password(username)</b> <b>==</b> <b>hash_password(password)</b>.

       If the hashing algorithm requires the username to be known then  the  callback  can  take  two  arguments
       instead of one:

          @auth.hash_password
          def hash_pw(username, password):
              salt = get_salt(username)
              return hash_password(password, salt)

</pre><h4><b>API</b> <b>DOCUMENTATION</b></h4><pre>
       <b>class</b> <b>flask_httpauth.HTTPBasicAuth</b>
              This class handles HTTP Basic authentication for Flask routes.

              <b>__init__(scheme=None,</b> <b>realm=None)</b>
                     Create a basic authentication object.

                     If  the  optional  <b>scheme</b>  argument  is  provided,  it will be used instead of the standard
                     "Basic" scheme in the <b>WWW-Authenticate</b> response. A fairly  common  practice  is  to  use  a
                     custom scheme to prevent browsers from prompting the user to login.

                     The  <b>realm</b>  argument  can  be  used  to  provide  an  application  defined  realm  with the
                     <b>WWW-Authenticate</b> header.

              <b>verify_password(verify_password_callback)</b>
                     If defined, this callback function will be called by  the  framework  to  verify  that  the
                     username  and  password combination provided by the client are valid. The callback function
                     takes two arguments, the username and the password. It  must  return  the  user  object  if
                     credentials  are  valid,  or  <b>True</b>  if  a  user  object is not available. In case of failed
                     authentication, it should return <b>None</b> or <b>False</b>. Example usage:

                        @auth.verify_password
                        def verify_password(username, password):
                            user = User.query.filter_by(username).first()
                            if user and passlib.hash.sha256_crypt.verify(password, user.password_hash):
                                return user

                     If this callback is defined, it is  also  invoked  when  the  request  does  not  have  the
                     <b>Authorization</b> header with user credentials, and in this case both the <b>username</b> and <b>password</b>
                     arguments are set to empty strings. The application can opt to return <b>True</b> in this case and
                     that  will  allow  anonymous  users access to the route. The callback function can indicate
                     that the user is anonymous by writing a  state  variable  to  <b>flask.g</b>  or  by  checking  if
                     <b>auth.current_user()</b> is <b>None</b>.

                     Note  that  when  a <b>verify_password</b> callback is provided the <b>get_password</b> and <b>hash_password</b>
                     callbacks are not used.

              <b>get_user_roles(roles_callback)</b>
                     If defined, this callback function will be called by the  framework  to  obtain  the  roles
                     assigned to a given user. The callback function takes a single argument, the user for which
                     roles  are  requested.  The user object passed to this function will be the one returned by
                     the "verify" callback. If the verify callback returned <b>True</b> instead of a user object,  then
                     the  <b>Authorization</b>  object  provided by Flask will be passed to this function. The function
                     should return the role or list of roles that belong to the user. Example:

                        @auth.get_user_roles
                        def get_user_roles(user):
                            return user.get_roles()

              <b>get_password(password_callback)</b>
                     <u>Deprecated</u> This callback function will be called by the framework to  obtain  the  password
                     for a given user. Example:

                        @auth.get_password
                        def get_password(username):
                            return db.get_user_password(username)

              <b>hash_password(hash_password_callback)</b>
                     <u>Deprecated</u>  If  defined,  this callback function will be called by the framework to apply a
                     custom hashing algorithm to the password provided by the client.  If  this  callback  isn't
                     provided  the  password  will  be  checked  unchanged.  The  callback  can  take one or two
                     arguments. The one argument version receives the password to hash, while the  two  argument
                     version  receives  the  username  and  the  password in that order. Example single argument
                     callback:

                        @auth.hash_password
                        def hash_password(password):
                            return md5(password).hexdigest()

                     Example two argument callback:

                        @auth.hash_password
                        def hash_pw(username, password):
                            salt = get_salt(username)
                            return hash(password, salt)

              <b>error_handler(error_callback)</b>
                     If defined, this callback function will be called by the framework when it is necessary  to
                     send  an  authentication  error back to the client. The function can take one argument, the
                     status code of the error, which can be 401 (incorrect credentials)  or  403  (correct,  but
                     insufficient  credentials).  To preserve compatiiblity with older releases of this package,
                     the function can also be defined without arguments. The return  value  from  this  function
                     must  by  any  accepted  response  type  in Flask routes. If this callback isn't provided a
                     default error response is generated. Example:

                        @auth.error_handler
                        def auth_error(status):
                            return "Access Denied", status

              <b>login_required(view_function_callback)</b>
                     This callback function  will  be  called  when  authentication  is  successful.  This  will
                     typically be a Flask view function. Example:

                        @app.route('/private')
                        @auth.login_required
                        def private_page():
                            return "Only for authorized people!"

                     An optional <b>role</b> argument can be given to further restrict access by roles. Example:

                        @app.route('/private')
                        @auth.login_required(role='admin')
                        def private_page():
                            return "Only for admins!"

                     An  optional  <b>optional</b>  argument can be set to <b>True</b> to allow the route to execute also when
                     authentication is not included with the request, in which case <b>auth.current_user()</b> will  be
                     set to <b>None</b>. Example:

                        @app.route('/private')
                        @auth.login_required(optional=True)
                        def private_page():
                            user = auth.current_user()
                            return "Hello {}!".format(user.name if user is not None else 'anonymous')

              <b>current_user()</b>
                     The  user  object returned by the <b>verify_password</b> callback on successful authentication. If
                     no user is returned by the callback, this is set to the  username  passed  by  the  client.
                     Example:

                        @app.route('/')
                        @auth.login_required
                        def index():
                            user = auth.current_user()
                            return "Hello, {}!".format(user.name)

              <b>username()</b>
                     <u>Deprecated</u> A view function that is protected with this class can access the logged username
                     through this method. Example:

                        @app.route('/')
                        @auth.login_required
                        def index():
                            return "Hello, {}!".format(auth.username())

       <b>class</b> <b>flask_httpauth.HTTPDigestAuth</b>
              This  class handles HTTP Digest authentication for Flask routes. The <b>SECRET_KEY</b> configuration must
              be set in the Flask application to enable the session  to  work.  Flask  by  default  stores  user
              sessions in the client as secure cookies, so the client must be able to handle cookies.

              <b>__init__(self,</b> <b>scheme=None,</b> <b>realm=None,</b> <b>use_ha1_pw=False,</b> <b>qop='auth',</b> <b>algorithm='MD5')</b>
                     Create a digest authentication object.

                     If the optional <b>scheme</b> argument is provided, it will be used instead of the "Digest" scheme
                     in  the  <b>WWW-Authenticate</b>  response.  A fairly common practice is to use a custom scheme to
                     prevent browsers from prompting the user to login.

                     The <b>realm</b>  argument  can  be  used  to  provide  an  application  defined  realm  with  the
                     <b>WWW-Authenticate</b> header.

                     If  <b>use_ha1_pw</b>  is  False,  then  the  <b>get_password</b> callback needs to return the plain text
                     password for the given user. If <b>use_ha1_pw</b> is True,  the  <b>get_password</b>  callback  needs  to
                     return  the  HA1  value  for the given user. The advantage of setting <b>use_ha1_pw</b> to <b>True</b> is
                     that it allows the application to store the HA1 hash of the password in the user database.

                     The <b>qop</b> option configures a  list  of  accepted  quality  of  protection  extensions.  This
                     argument  can  be given as a comma-separated string, a list of strings, or <b>None</b> to disable.
                     The default is <b>auth</b>. The <b>auth-int</b> option is currently not implemented.

                     The <b>algorithm</b> option configures the hash generation algorithm to use. The default  is  <b>MD5</b>.
                     The two algorithms that are implemented are <b>MD5</b> and <b>MD5-Sess</b>.

              <b>generate_ha1(username,</b> <b>password)</b>
                     Generate  the  HA1  hash  that can be stored in the user database when <b>use_ha1_pw</b> is set to
                     True in the constructor.

              <b>generate_nonce(nonce_making_callback)</b>
                     If defined, this callback function will be called by the framework to generate a nonce.  If
                     this is defined, <b>verify_nonce</b> should also be defined.

                     This can be used to use a state storage mechanism other than the session.

              <b>verify_nonce(nonce_verify_callback)</b>
                     If defined, this callback function will be called by the framework to verify that  a  nonce
                     is valid.  It will be called with a single argument: the nonce to be verified.

                     This can be used to use a state storage mechanism other than the session.

              <b>generate_opaque(opaque_making_callback)</b>
                     If  defined,  this  callback function will be called by the framework to generate an opaque
                     value.  If this is defined, <b>verify_opaque</b> should also be defined.

                     This can be used to use a state storage mechanism other than the session.

              <b>verify_opaque(opaque_verify_callback)</b>
                     If defined, this callback function will be called by the framework to verify that an opaque
                     value is valid.  It will be called with a single argument: the opaque value to be verified.

                     This can be used to use a state storage mechanism other than the session.

              <b>get_password(password_callback)</b>
                     See basic authentication for documentation and examples.

              <b>get_user_roles(roles_callback)</b>
                     See basic authentication for documentation and examples.

              <b>error_handler(error_callback)</b>
                     See basic authentication for documentation and examples.

              <b>login_required(view_function_callback)</b>
                     See basic authentication for documentation and examples.

              <b>current_user()</b>
                     See basic authentication for documentation and examples.

              <b>username()</b>
                     See basic authentication for documentation and examples.

       <b>class</b> <b>flask_httpauth.HTTPTokenAuth</b>
              This class handles HTTP authentication with custom schemes for Flask routes.

              <b>__init__(scheme='Bearer',</b> <b>realm=None,</b> <b>header=None)</b>
                     Create a token authentication object.

                     The <b>scheme</b> argument can be use to specify the scheme to be  used  in  the  <b>WWW-Authenticate</b>
                     response.  The <b>Authorization</b> header sent by the client must include this scheme followed by
                     the token. Example:

                        Authorization: Bearer this-is-my-token

                     The <b>realm</b>  argument  can  be  used  to  provide  an  application  defined  realm  with  the
                     <b>WWW-Authenticate</b> header.

                     The  <b>header</b>  argument  can be used to specify a custom header instead of <b>Authorization</b> from
                     where to obtain the token. If a custom header is used, the <b>scheme</b> should not  be  included.
                     Example:

                        X-API-Key: this-is-my-token

              <b>verify_token(verify_token_callback)</b>
                     This  callback function will be called by the framework to verify that the credentials sent
                     by the client with the <b>Authorization</b> header are valid.  The  callback  function  takes  one
                     argument, the token provided by the client. The function must return the user object if the
                     token  is  valid,  or  <b>True</b>  if  a  user  object  is  not  available.  In  case of a failed
                     authentication, the function should return <b>None</b> or <b>False</b>. Example usage:

                        @auth.verify_token
                        def verify_token(token):
                            return User.query.filter_by(token=token).first()

                     Note that a <b>verify_token</b> callback is required when using this class.

              <b>get_user_roles(roles_callback)</b>
                     See basic authentication for documentation and examples.

              <b>error_handler(error_callback)</b>
                     See basic authentication for documentation and examples.

              <b>login_required(view_function_callback)</b>
                     See basic authentication for documentation and examples.

              <b>current_user()</b>
                     See basic authentication for documentation and examples.

       <b>class</b> <b>flask_httpauth.HTTPMultiAuth</b>
              This class handles HTTP authentication with custom schemes for Flask routes.

              <b>__init__(auth_object,</b> <b>...)</b>
                     Create a multiple authentication object.

                     The arguments are one or more instances of <b>HTTPBasicAuth</b>, <b>HTTPDigestAuth</b> or  <b>HTTPTokenAuth</b>.
                     A  route  protected  with  this authentication method will try all the given authentication
                     objects until one succeeds.

              <b>login_required(view_function_callback)</b>
                     See basic authentication for documentation and examples.

              <b>current_user()</b>
                     See basic authentication for documentation and examples.

</pre><h4><b>AUTHOR</b></h4><pre>
       Miguel Grinberg

</pre><h4><b>COPYRIGHT</b></h4><pre>
       2024, Miguel Grinberg

                                                  May 03, 2024                                 <u><a href="../man3/FLASK-HTTPAUTH.3.html">FLASK-HTTPAUTH</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>