<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>wip - Word Interpreter</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcllib">tcllib_2.0+dfsg-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       wip - Word Interpreter

</pre><h4><b>SYNOPSIS</b></h4><pre>
       package require <b>Tcl</b> <b>8.5</b> <b>9</b>

       package require <b>wip</b> <b>?2.3?</b>

       package require <b>snit</b> <b>?1.4?</b>

       package require <b>struct::set</b>

       <b>::wip</b> <u>wipName</u> <u>engine</u> <u>arg</u>...

       <b>def</b> <u>name</u>

       <b>def</b> <u>name</u> <u>method_prefix</u>

       <b>wipName</b> <u>option</u> ?<u>arg</u> <u>arg</u> <u>...</u>?

       <b>wip::dsl</b> ?<u>suffix</u>?

       <u>wipName</u> <b>def</b> <u>name</u> ?<u>method_prefix</u>?

       <u>wipName</u> <b>defl</b> <u>names</u>

       <u>wipName</u> <b>defd</b> <u>dict</u>

       <u>wipName</u> <b>deflva</b> <u>name</u>...

       <u>wipName</u> <b>defdva</b> (<u>name</u> <u>method_prefix</u>)...

       <u>wipName</u> <b>undefl</b> <u>names</u>

       <u>wipName</u> <b>undefva</b> <u>name</u>...

       <u>wipName</u> <b>unknown</b> <u>cmdprefix</u>

       <u>wipName</u> <b>runl</b> <u>wordlist</u>

       <u>wipName</u> <b>run</b> <u>word</u>...

       <u>wipName</u> <b>run_next</b>

       <u>wipName</u> <b>run_next_while</b> <u>acceptable</u>

       <u>wipName</u> <b>run_next_until</b> <u>rejected</u>

       <u>wipName</u> <b>run_next_if</b> <u>acceptable</u>

       <u>wipName</u> <b>run_next_ifnot</b> <u>rejected</u>

       <u>wipName</u> <b>next</b>

       <u>wipName</u> <b>peek</b>

       <u>wipName</u> <b>peekall</b>

       <u>wipName</u> <b>insertl</b> <u>at</u> <u>wordlist</u>

       <u>wipName</u> <b>replacel</b> <u>wordlist</u>

       <u>wipName</u> <b>pushl</b> <u>wordlist</u>

       <u>wipName</u> <b>addl</b> <u>wordlist</u>

       <u>wipName</u> <b>insert</b> <u>at</u> <u>word</u>...

       <u>wipName</u> <b>replace</b> <u>word</u>...

       <u>wipName</u> <b>push</b> <u>word</u>...

       <u>wipName</u> <b>add</b> <u>word</u>...

________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  package  provides  a  micro interpreter for lists of words. Domain specific languages based on this
       will have a bit of a Forth feel, with the input stream segmented into words  and  any  other  structuring
       left to whatever the language desired. Note that we have here in essence only the core dispatch loop, and
       no actual commands whatsoever, making this definitely only a Forth feel and not an actual Forth.

       The idea is derived from Colin McCormack's <b>treeql</b> processor, modified to require less boiler plate within
       the  command  implementations,  at  the  expense  of,  likely, execution speed. In addition the interface
       between processor core and commands is more complex too.

</pre><h4><b>GENERAL</b> <b>BEHAVIOUR</b></h4><pre>
       Word interpreters have a mappping from the names of the language commands they  shall  recognize  to  the
       methods in the engine to invoke for them, and possibly fixed arguments for these methods. This mapping is
       largely static, however it is possible to change it during the execution of a word list (= program).

       At the time a language command is defined the word interpreter will use <b>snit</b>'s introspection capabilities
       to  determine  the number of arguments expected by the method of the egnine, and together with the number
       of fixed arguments supplied in the method prefix of the mapping it then  knows  how  many  arguments  the
       language command is expecting. This is the command's <u>arity</u>. Variable-argument methods (i.e. with the last
       argument  named <u>args</u>) are <u>not</u> allowed and will cause the word interpreter to throw an error at definition
       time.

       Note that while I said <b>snit</b>'s abilities the engine object can be written  in  any  way,  as  long  as  it
       understands  the  method  <b>info</b> <b>args</b>, which takes a method name and returns the list of arguments for that
       method.

       When executing a list of words (aka program) the first word is always taken as the  name  of  a  language
       command,  and  the  next words as its arguments, per the <u>arity</u> of the command. Command and argument words
       are removed from the list and then associated method of the engine is executed with the  argument  words.
       The process then repeats using the then-first word of the list.

       Note  that  the  methods implementing the language commands may have full access to the list of words and
       are allowed to manipulate as they see fit.

       [1]    This means, for example, that while we cannot specify variable-argument methods directly they  can
              consume  words  after  their  fixed  arguments before returning to the execution loop. This may be
              under the control of their fixed arguments.

       [2]    Another possibility is the use of method <b>run_next</b> and its  variants  to  execute  commands  coming
              after the current command, changing the order of execution.

       [3]    Execution  can  be  further  changed  by use of the program accessor methods which allow a command
              implementation to modify the remaining list of words  (insert,  replace,  prepend,  append  words)
              without executing them immediately.

       [4]    At  last  the  basic  <b>run</b>  methods  save and restore an existing list of words when used, enabling
              recursive use from within command implementations.

</pre><h4><b>CLASS</b> <b>API</b></h4><pre>
       The main command of the package is:

       <b>::wip</b> <u>wipName</u> <u>engine</u> <u>arg</u>...
              The command creates a new word interpreter object with an associated global Tcl command whose name
              is <u>wipName</u>. If however the string <b>%AUTO%</b> was used as object name the package will generate its own
              unique name for the object.

              The <u>engine</u> is the object the word interpreter will dispatch all recognized commands  to,  and  the
              <u>arg</u>uments are a word list which defines an initial mapping from language words to engine methods.

              The recognized language of this word list is

              <b>def</b> <u>name</u>
                     Defines  <u>name</u> as command of the language, to be mapped to a method of the <u>engine</u> having the
                     same name.

              <b>def</b> <u>name</u> <u>method_prefix</u>
                     Defines <u>name</u> as command of the language, to be mapped to the method of the <u>engine</u> named  in
                     the <u>method_prefix</u>.

       The  returned  command  may  be  used  to  invoke various operations on the object.  It has the following
       general form:

              <b>wipName</b> <u>option</u> ?<u>arg</u> <u>arg</u> <u>...</u>?
                     <u>Option</u> and the <u>arg</u>s determine the exact behavior of the command.

       The package additionally exports the command:

       <b>wip::dsl</b> ?<u>suffix</u>?
              This command is for use within snit types which wish to use one or  more  wip  interpreters  as  a
              component. Use within the type definition installs most of the boilerplate needed to setup and use
              a word interpreter.

              It  installs a component named <u>wip</u>, and a method <b>wip_setup</b> for initializing it. This method has to
              be called from within the constructor of the type using the word interpreter.  If further installs
              a series of procedures which make the object API of the word interpreter directly available to the
              type's methods, without having to specify the component.

              <u>Note</u> that this does and cannot install the language to interpret, i.e. the mapping from  words  to
              engine methods.

              It  is  possible  to  instantiate  multiple  word  interpreter  components  within a type by using
              different suffices as arguments to the command.  In that case the name of the component changes to
              ´wip_<b>$suffix</b>', the setup command becomes ´wip_<b>$suffix</b>_setup' and all the procedures also  get  the
              suffix ´_<b>$suffix</b>'.

</pre><h4><b>OBJECT</b> <b>API</b></h4><pre>
       The following commands are possible for word interpreter objects:

       <u>wipName</u> <b>def</b> <u>name</u> ?<u>method_prefix</u>?
              Defines  a language command <u>name</u> and maps it to the method named in the engine's <u>method_prefix</u>. If
              the <u>method_prefix</u> name is not specified it is simply the name of the language command.

       <u>wipName</u> <b>defl</b> <u>names</u>
              Defines a series of language commands, specified through the list  of  <u>names</u>,  all  of  which  are
              mapped to engine methods of the same name.

       <u>wipName</u> <b>defd</b> <u>dict</u>
              Defines  a  series of language commands, specified through the dictionary <u>dict</u> of names and method
              prefixes.

       <u>wipName</u> <b>deflva</b> <u>name</u>...
              As method <b>defl</b>, however the list of names is specified through multiple arguments.

       <u>wipName</u> <b>defdva</b> (<u>name</u> <u>method_prefix</u>)...
              As method <b>defd</b>, however the dictionary of names and method prefixes is specified through  multiple
              arguments.

       <u>wipName</u> <b>undefl</b> <u>names</u>
              Removes the named series of language commands from the mapping.

       <u>wipName</u> <b>undefva</b> <u>name</u>...
              As method <b>undefl</b>, however the list of names is specified through multiple arguments.

       <u>wipName</u> <b>unknown</b> <u>cmdprefix</u>
              Sets  the  handler  for  unknown  words  to <u>cmdprefix</u>. This command prefix takes one argument, the
              current word, and either throws some error, or returns  the  result  of  executing  the  word,  as
              defined by the handler. The default handler simply throws an error.

       <u>wipName</u> <b>runl</b> <u>wordlist</u>
              Treats  the  list of words in <u>wordlist</u> as a program and executes the contained command one by one.
              The result of the command executed last is returned as the result of this command.

              The <u>wordlist</u> is stored in the object for access by the other <u>run</u>-methods, and the general  program
              accessor  methods  (see below). A previously stored wordlist is saved during the execution of this
              method and restored before it returns. This enables the recursive execution of word  lists  within
              word lists.

       <u>wipName</u> <b>run</b> <u>word</u>...
              As method <b>runl</b>, however the list of words to execute is specified through multiple arguments.

       <u>wipName</u> <b>run_next</b>
              Low-level  method.  Determines  the  next  word  in the list of words, and its arguments, and then
              executes it. The result of the executed word is the result of this method.

              Exposed for use within command implementations.  The methods <b>run</b> and <b>runl</b> use it to execute  words
              until their word list is exhausted.

       <u>wipName</u> <b>run_next_while</b> <u>acceptable</u>
              Low-level method. Invokes the method <b>run_next</b> as long as the next word is in the set of <u>acceptable</u>
              words,  and  the  program is not empty. The result of the command executed last is returned as the
              result of this command.

              Exposed for use within command implementations to change the order of execution.

       <u>wipName</u> <b>run_next_until</b> <u>rejected</u>
              Low-level method. Invokes the method <b>run_next</b> until the next word is in the set of <u>rejected</u> words,
              and the program is not empty. The result of the command executed last is returned as the result of
              this command.

              Exposed for use within command implementations to change the order of execution.

       <u>wipName</u> <b>run_next_if</b> <u>acceptable</u>
              Low-level method. Invokes the method <b>run_next</b> if the next word is in the set of <u>acceptable</u>  words,
              and the program is not empty. The result of the command executed last is returned as the result of
              this command.

              Exposed for use within command implementations to change the order of execution.

       <u>wipName</u> <b>run_next_ifnot</b> <u>rejected</u>
              Low-level  method.  Invokes  the  method  <b>run_next</b>  if the next word is not in the set of <u>rejected</u>
              words, and the program is not empty. The result of the command executed last is  returned  as  the
              result of this command.

              Exposed for use within command implementations to change the order of execution.

       <u>wipName</u> <b>next</b>
              Returns the next word in the programm. The word is also removed.

       <u>wipName</u> <b>peek</b>
              Returns the next word in the programm without removing it

       <u>wipName</u> <b>peekall</b>
              Returns the remaining programm in toto.

       <u>wipName</u> <b>insertl</b> <u>at</u> <u>wordlist</u>
              Basic  programm  accessor method. Inserts the specified <u>wordlist</u> into the program, just before the
              word at position <u>at</u>. Positions are counted from <b>zero</b>.

       <u>wipName</u> <b>replacel</b> <u>wordlist</u>
              Basic programm accessor method. Replaces the whole stored program with the specified <u>wordlist</u>.

       <u>wipName</u> <b>pushl</b> <u>wordlist</u>
              Program accessor method. The specified <u>wordlist</u> is added to the front of  the  remaining  program.
              Equivalent to

              $wip insertl 0 $wordlist

       <u>wipName</u> <b>addl</b> <u>wordlist</u>
              Program  accessor  method. The specified <u>wordlist</u> is appended at the end of the remaining program.
              Equivalent to

              $wip insertl end $wordlist

       <u>wipName</u> <b>insert</b> <u>at</u> <u>word</u>...
              Like method <b>insertl</b>, except the words are specified through multiple arguments.

       <u>wipName</u> <b>replace</b> <u>word</u>...
              Like method <b>setl</b>, except the words are specified through multiple arguments.

       <u>wipName</u> <b>push</b> <u>word</u>...
              Like method <b>pushl</b>, except the words are specified through multiple arguments.

       <u>wipName</u> <b>add</b> <u>word</u>...
              Like method <b>addl</b>, except the words are specified through multiple arguments.

</pre><h4><b>EXAMPLES</b></h4><pre>
       No examples yet.

</pre><h4><b>BUGS,</b> <b>IDEAS,</b> <b>FEEDBACK</b></h4><pre>
       This document, and the package it describes, will undoubtedly contain bugs and  other  problems.   Please
       report  such  in  the category <u>wip</u> of the <u>Tcllib</u> <u>Trackers</u> [<a href="http://core.tcl.tk/tcllib/reportlist">http://core.tcl.tk/tcllib/reportlist</a>].  Please
       also report any ideas for enhancements you may have for either package and/or documentation.

       When proposing code changes, please provide <u>unified</u> <u>diffs</u>, i.e the output of <b>diff</b> <b>-u</b>.

       Note further that <u>attachments</u> are strongly preferred over inlined patches. Attachments  can  be  made  by
       going  to the <b>Edit</b> form of the ticket immediately after its creation, and then using the left-most button
       in the secondary navigation bar.

</pre><h4><b>KEYWORDS</b></h4><pre>
       interpreter, list, word

</pre><h4><b>CATEGORY</b></h4><pre>
       Programming tools

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2007-2010 Andreas Kupries &lt;<a href="mailto:andreas_kupries@users.sourceforge.net">andreas_kupries@users.sourceforge.net</a>&gt;

tcllib                                                 2.3                                             <u><a href="../man3tcl/wip.3tcl.html">wip</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>