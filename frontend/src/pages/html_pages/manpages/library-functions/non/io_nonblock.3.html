<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>io_nonblock - switch to non-blocking I/O</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libowfat-dev">libowfat-dev_0.32-5_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       io_nonblock - switch to non-blocking I/O

</pre><h4><b>SYNTAX</b></h4><pre>
       <b>#include</b> <b>&lt;libowfat/io.h&gt;</b>

       void <b>io_nonblock</b>(int64 fd);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       io_nonblock  puts UNIX descriptor fd into ``non-blocking mode.'' Calling io_nonblock(<u>fd</u>) before io_fd(<u>fd</u>)
       makes io_tryread and io_trywrite faster and more efficient.

       Actually, current UNIX kernels do not support non-blocking descriptors; they  support  non-blocking  open
       files.  Furthermore,  many  programs  will break if they encounter non-blocking mode. This means that you
       must not use io_nonblock for a descriptor inherited from another program.

       io_nonblock has no return value; it always succeeds. If d  is  not  the  number  of  a  UNIX  descriptor,
       io_nonblock has no effect.

       If  io_fd  is  given  a  descriptor in blocking mode, io_tryread and io_trywrite go through the following
       contortions to avoid blocking:

       1  Stop if poll says that the descriptor is not ready.  Otherwise  there's  a  good  chance,  but  not  a
          guarantee:  even  if  poll  says  the  descriptor is ready, the descriptor might not be ready a moment
          later. (Furthermore, poll can fail on some systems.)

       2  Catch SIGALRM. SIGALRM must not be blocked, and must not be used elsewhere in the program.

       3  Set an interval timer so that any blocking call will be interrupted by SIGALRM within 10 milliseconds.
          (Current UNIX kernels do  not  allow  any  shorter  interval.)  Of  course,  this  may  still  mean  a
          10-millisecond delay.

       If io_fd is given a descriptor in non-blocking mode (or a descriptor for a regular disk file), io_tryread
       and io_trywrite avoid these contortions.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3/io_wait.3.html">io_wait</a>(3), <a href="../man3/io_canwrite.3.html">io_canwrite</a>(3)

                                                                                                  <u><a href="../man3/io_nonblock.3.html">io_nonblock</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>