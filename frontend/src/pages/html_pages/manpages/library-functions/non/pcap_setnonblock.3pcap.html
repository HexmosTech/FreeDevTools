<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pcap_setnonblock, pcap_getnonblock - set or get the state of non-blocking mode on a capture device</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libpcap0.8-dev">libpcap0.8-dev_1.10.5-2ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       pcap_setnonblock, pcap_getnonblock - set or get the state of non-blocking mode on a capture device

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;pcap/pcap.h&gt;</b>

       <b>char</b> <b>errbuf[PCAP_ERRBUF_SIZE];</b>

       <b>int</b> <b>pcap_setnonblock(pcap_t</b> <b>*p,</b> <b>int</b> <b>nonblock,</b> <b>char</b> <b>*errbuf);</b>
       <b>int</b> <b>pcap_getnonblock(pcap_t</b> <b>*p,</b> <b>char</b> <b>*errbuf);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>pcap_setnonblock</b>()  puts a capture handle into ``non-blocking'' mode, or takes it out of ``non-blocking''
       mode, depending on whether the <u>nonblock</u> argument is non-zero or zero.  It has no effect on ``savefiles''.
       <u>errbuf</u> is a buffer large enough to hold at least <b>PCAP_ERRBUF_SIZE</b> chars.

       In ``non-blocking'' mode, an attempt to read from the capture descriptor  with  <b><a href="../man3PCAP/pcap_dispatch.3PCAP.html">pcap_dispatch</a></b>(3PCAP)  and
       <b><a href="../man3PCAP/pcap_next_ex.3PCAP.html">pcap_next_ex</a></b>(3PCAP)  will,  if no packets are currently available to be read, return <b>0</b> immediately rather
       than blocking waiting for packets to arrive.

       <b><a href="../man3PCAP/pcap_loop.3PCAP.html">pcap_loop</a></b>(3PCAP) will loop  forever,  consuming  CPU  time  when  no  packets  are  currently  available;
       <b>pcap_dispatch</b>()  should  be  used  instead.   <b><a href="../man3PCAP/pcap_next.3PCAP.html">pcap_next</a></b>(3PCAP)  will  return <b>NULL</b> if there are no packets
       currently available to read; this is indistinguishable from an error, so <b>pcap_next_ex</b>()  should  be  used
       instead.

       When  first activated with <b><a href="../man3PCAP/pcap_activate.3PCAP.html">pcap_activate</a></b>(3PCAP) or opened with <b><a href="../man3PCAP/pcap_open_live.3PCAP.html">pcap_open_live</a></b>(3PCAP), a capture handle is
       not in ``non-blocking mode''; a call to <b>pcap_setnonblock</b>() is required in order to  put  it  into  ``non-
       blocking'' mode.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       <b>pcap_setnonblock()</b>  return  0 on success, <b>PCAP_ERROR_NOT_ACTIVATED</b> if called on a capture handle that has
       been created but not activated, and <b>PCAP_ERROR</b> for other errors.  <b>pcap_getnonblock</b>() returns the  current
       ``non-blocking''  state  of  the capture descriptor on success; it always returns <b>0</b> on ``savefiles''.  It
       returns <b>PCAP_ERROR_NOT_ACTIVATED</b> if called on a capture handle that has been created but  not  activated,
       and  <b>PCAP_ERROR</b>  for  other  errors.   If <b>PCAP_ERROR</b> is returned, <u>errbuf</u> is filled in with an appropriate
       error message.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3PCAP/pcap.3PCAP.html">pcap</a></b>(3PCAP), <b><a href="../man3PCAP/pcap_next_ex.3PCAP.html">pcap_next_ex</a></b>(3PCAP), <b><a href="../man3PCAP/pcap_geterr.3PCAP.html">pcap_geterr</a></b>(3PCAP)

                                                30 November 2023                         <u><a href="../man3PCAP/PCAP_SETNONBLOCK.3PCAP.html">PCAP_SETNONBLOCK</a></u>(3PCAP)
</pre>
 </div>
</div></section>
</div>
</body>
</html>