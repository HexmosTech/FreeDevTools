<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>dbminit, fetch, store, dbmclose - somewhat dbm-compatible database routines</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/inn">inn_1.7.2q-52_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       dbminit, fetch, store, dbmclose - somewhat dbm-compatible database routines
       dbzfresh, dbzagain, dbzfetch, dbzstore - database routines
       dbzsync, dbzsize, dbzincore, dbzcancel, dbzdebug - database routines

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;dbz.h&gt;</b>

       <b>dbminit(base)</b>
       <b>char</b> <b>*base;</b>

       <b>datum</b>
       <b>fetch(key)</b>
       <b>datum</b> <b>key;</b>

       <b>store(key,</b> <b>value)</b>
       <b>datum</b> <b>key;</b>
       <b>datum</b> <b>value;</b>

       <b>dbmclose()</b>

       <b>dbzfresh(base,</b> <b>size,</b> <b>fieldsep,</b> <b>cmap,</b> <b>tagmask)</b>
       <b>char</b> <b>*base;</b>
       <b>long</b> <b>size;</b>
       <b>int</b> <b>fieldsep;</b>
       <b>int</b> <b>cmap;</b>
       <b>long</b> <b>tagmask;</b>

       <b>dbzagain(base,</b> <b>oldbase)</b>
       <b>char</b> <b>*base;</b>
       <b>char</b> <b>*oldbase;</b>

       <b>datum</b>
       <b>dbzfetch(key)</b>
       <b>datum</b> <b>key;</b>

       <b>dbzstore(key,</b> <b>value)</b>
       <b>datum</b> <b>key;</b>
       <b>datum</b> <b>value;</b>

       <b>dbzsync()</b>

       <b>long</b>
       <b>dbzsize(nentries)</b>
       <b>long</b> <b>nentries;</b>

       <b>dbzincore(newvalue)</b>

       <b>dbzcancel()</b>

       <b>dbzdebug(newvalue)</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       These  functions  provide  an  indexing  system  for  rapid random access to a text file (the <u>base</u> <u>file</u>).
       Subject to certain constraints, they are call-compatible with <u><a href="../man3/dbm.3.html">dbm</a></u>(3), although  they  also  provide  some
       extensions.  (Note that they are <u>not</u> file-compatible with <u>dbm</u> or any variant thereof.)

       In  principle,  <u>dbz</u>  stores  key-value  pairs, where both key and value are arbitrary sequences of bytes,
       specified to the functions by values of type <u>datum</u>, typedefed in the header file to be a  structure  with
       members <u>dptr</u> (a value of type <u>char</u> <u>*</u> pointing to the bytes) and <u>dsize</u> (a value of type <u>int</u> indicating how
       long the byte sequence is).

       In practice, <u>dbz</u> is more restricted than <u>dbm</u>.  A <u>dbz</u> database must be an index into a base file, with the
       database  <u>value</u>s being <u><a href="../man3/fseek.3.html">fseek</a></u>(3) offsets into the base file.  Each such <u>value</u> must ``point to'' a place in
       the base file where the corresponding <u>key</u> sequence is found.  A key can be no longer  than  DBZMAXKEY  (a
       constant  defined  in  the header file) bytes.  No key can be an initial subsequence of another, which in
       most applications requires that keys be either bracketed or terminated in some way (see the discussion of
       the <u>fieldsep</u> parameter of <u>dbzfresh</u>, below, for a fine point on terminators).

       <u>Dbminit</u> opens a database, an index into the base file <u>base</u>, consisting of  files  <u>base</u><b>.dir</b>  and  <u>base</u><b>.pag</b>
       which  must  already  exist.   (If  the  database  is new, they should be zero-length files.)  Subsequent
       accesses go to that database until <u>dbmclose</u> is called to close the database.   The  base  file  need  not
       exist at the time of the <u>dbminit</u>, but it must exist before accesses are attempted.

       <u>Fetch</u>  searches  the  database  for  the  specified <u>key</u>, returning the corresponding <u>value</u> if any.  <u>Store</u>
       stores the <u>key</u>-<u>value</u> pair in the database.  <u>Store</u> will fail unless the database files are writeable.  See
       below for a complication arising from case mapping.

       <u>Dbzfresh</u> is a variant of <u>dbminit</u> for creating a new database with more control over details.  Unlike  for
       <u>dbminit</u>, the database files need not exist: they will be created if necessary, and truncated in any case.

       <u>Dbzfresh</u>'s  <u>size</u>  parameter  specifies the size of the first hash table within the database, in key-value
       pairs.  Performance will be best if <u>size</u> is a prime number and the number of key-value  pairs  stored  in
       the database does not exceed about 2/3 of <u>size</u>.  (The <u>dbzsize</u> function, given the expected number of key-
       value pairs, will suggest a database size that meets these criteria.)  Assuming that an <u>fseek</u> offset is 4
       bytes,  the <b>.pag</b> file will be 4*<u>size</u> bytes (the <b>.dir</b> file is tiny and roughly constant in size) until the
       number of key-value pairs exceeds about 80% of <u>size</u>.  (Nothing awful will happen if  the  database  grows
       beyond 100% of <u>size</u>, but accesses will slow down somewhat and the <b>.pag</b> file will grow somewhat.)

       <u>Dbzfresh</u>'s  <u>fieldsep</u>  parameter  specifies the field separator in the base file.  If this is not NUL (0),
       and the last character of a <u>key</u> argument is NUL, that NUL compares equal to either a NUL or a <u>fieldsep</u> in
       the base file.  This permits use of NUL to terminate key strings without requiring that  NULs  appear  in
       the base file.  The <u>fieldsep</u> of a database created with <u>dbminit</u> is the horizontal-tab character.

       For  use  in  news  systems,  various  forms  of  case  mapping (e.g. uppercase to lowercase) in keys are
       available.  The <u>cmap</u> parameter to <u>dbzfresh</u> is a single character  specifying  which  of  several  mapping
       algorithms to use.  Available algorithms are:

              <b>0</b>      case-sensitive:  no case mapping

              <b>B</b>      same as <b>0</b>

              <b>NUL</b>    same as <b>0</b>

              <b>=</b>      case-insensitive:  uppercase and lowercase equivalent

              <b>b</b>      same as <b>=</b>

              <b>C</b>      RFC822  message-ID  rules,  case-sensitive  before  `@' (with certain exceptions) and case-
                     insensitive after

              <b>?</b>      whatever the local default is, normally <b>C</b>

       Mapping algorithm <b>0</b> (no mapping) is faster than the others and is overwhelmingly the correct  choice  for
       most applications.  Unless compatibility constraints interfere, it is more efficient to pre-map the keys,
       storing mapped keys in the base file, than to have <u>dbz</u> do the mapping on every search.

       For  historical reasons, <u>fetch</u> and <u>store</u> expect their <u>key</u> arguments to be pre-mapped, but expect unmapped
       keys in the base file.  <u>Dbzfetch</u> and <u>dbzstore</u> do the same jobs but handle all case mapping internally, so
       the customer need not worry about it.

       <u>Dbz</u> stores only the database <u>value</u>s in its files, relying on reference to the base file to confirm a  hit
       on a key.  References to the base file can be minimized, greatly speeding up searches, if a little bit of
       information  about  the  keys  can be stored in the <u>dbz</u> files.  This is ``free'' if there are some unused
       bits in an <u>fseek</u> offset, so that the offset can be <u>tagged</u> with  some  information  about  the  key.   The
       <u>tagmask</u>  parameter  of  <u>dbzfresh</u> allows specifying the location of unused bits.  <u>Tagmask</u> should be a mask
       with one group of contiguous <b>1</b> bits.  The bits in the mask should be unused (0) in <u>most</u> offsets.  The bit
       immediately above the mask (the <u>flag</u> bit) should be unused (0) in <u>all</u>  offsets;  <u>(dbz)store</u>  will  reject
       attempts  to store a key-value pair in which the <u>value</u> has the flag bit on.  Apart from this restriction,
       tagging is invisible to the user.  As a special case, a <u>tagmask</u> of 1 means ``no tagging'', for  use  with
       enormous base files or on systems with unusual offset representations.

       A  <u>size</u>  of  0 given to <u>dbzfresh</u> is synonymous with the local default; the normal default is suitable for
       tables of 90-100,000 key-value pairs.  A <u>cmap</u> of 0 (NUL) is synonymous with the character  <b>0</b>,  signifying
       no  case mapping (note that the character <b>?</b>  specifies the local default mapping, normally <b>C</b>).  A <u>tagmask</u>
       of 0 is synonymous with the local default tag mask, normally 0x7f000000 (specifying  the  top  bit  in  a
       32-bit  offset  as  the flag bit, and the next 7 bits as the mask, which is suitable for base files up to
       circa  24MB).   Calling  <u>dbminit(name)</u>  with  the  database  files  empty  is   equivalent   to   calling
       <u>dbzfresh(name,0,'\t','?',0)</u>.

       When  databases are regenerated periodically, as in news, it is simplest to pick the parameters for a new
       database based on the old one.  This also permits some memory of past sizes of the old database, so  that
       a  new  database size can be chosen to cover expected fluctuations.  <u>Dbzagain</u> is a variant of <u>dbminit</u> for
       creating a new database as a new generation of an old database.  The  database  files  for  <u>oldbase</u>  must
       exist.   <u>Dbzagain</u>  is equivalent to calling <u>dbzfresh</u> with the same field separator, case mapping, and tag
       mask as the old database, and a <u>size</u> equal to the result of applying <u>dbzsize</u> to  the  largest  number  of
       entries in the <u>oldbase</u> database and its previous 10 generations.

       When many accesses are being done by the same program, <u>dbz</u> is massively faster if its first hash table is
       in  memory.   If  an  internal  flag  is  1, an attempt is made to read the table in when the database is
       opened, and <u>dbmclose</u> writes it out to disk again (if it was read successfully  and  has  been  modified).
       <u>Dbzincore</u>  sets  the  flag to <u>newvalue</u> (which should be 0 or 1) and returns the previous value; this does
       not affect the status of a database that has already been opened.  The default is 0.  The attempt to read
       the table in may fail due to memory shortage; in  this  case  <u>dbz</u>  quietly  falls  back  on  its  default
       behavior.  <u>Store</u>s to an in-memory database are not (in general) written out to the file until <u>dbmclose</u> or
       <u>dbzsync</u>,  so  if  robustness  in  the  presence  of  crashes or concurrent accesses is crucial, in-memory
       databases should probably be avoided.

       <u>Dbzsync</u> causes all buffers etc. to be flushed out to the files.  It is typically  used  as  a  precaution
       against crashes or concurrent accesses when a <u>dbz</u>-using process will be running for a long time.  It is a
       somewhat expensive operation, especially for an in-memory database.

       <u>Dbzcancel</u>  cancels any pending writes from buffers.  This is typically useful only for in-core databases,
       since writes are otherwise done immediately.  Its main purpose is to let a child process, in the wake  of
       a <u>fork</u>, do a <u>dbmclose</u> without writing its parent's data to disk.

       If  <u>dbz</u>  has  been compiled with debugging facilities available (which makes it bigger and a bit slower),
       <u>dbzdebug</u> alters the value (and returns the previous value) of an internal flag which (when 1; default  is
       0) causes verbose and cryptic debugging output on standard output.

       Concurrent reading of databases is fairly safe, but there is no (inter)locking, so concurrent updating is
       not.

       The  database  files  include  a  record  of  the  byte order of the processor creating the database, and
       accesses by processors with different byte order will work, although they will be slightly slower.   Byte
       order is preserved by <u>dbzagain</u>.  However, agreement on the size and internal structure of an <u>fseek</u> offset
       is necessary, as is consensus on the character set.

       An  open  database  occupies  three  <u>stdio</u>  streams and their corresponding file descriptors; a fourth is
       needed for an in-memory database.  Memory consumption is negligible (except for <u>stdio</u> buffers) except for
       in-memory databases.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man1/dbz.1.html">dbz</a>(1), <a href="../man3/dbm.3.html">dbm</a>(3)

</pre><h4><b>DIAGNOSTICS</b></h4><pre>
       Functions returning <u>int</u> values return 0 for success, -1 for failure.  Functions  returning  <u>datum</u>  values
       return  a  value  with  <u>dptr</u>  set  to  NULL for failure.  <u>Dbminit</u> attempts to have <u>errno</u> set plausibly on
       return, but otherwise this is not guaranteed.  An <u>errno</u> of <b>EDOM</b> from <u>dbminit</u> indicates that the  database
       did not appear to be in <u>dbz</u> format.

</pre><h4><b>HISTORY</b></h4><pre>
       The  original  <u>dbz</u> was written by Jon Zeeff (<a href="mailto:zeeff@b-tech.ann-arbor.mi.us">zeeff@b-tech.ann-arbor.mi.us</a>).  Later contributions by David
       Butler  and  Mark  Moraes.   Extensive  reworking,  including  this  documentation,  by   Henry   Spencer
       (<a href="mailto:henry@zoo.toronto.edu">henry@zoo.toronto.edu</a>) as part of the C News project.  Hashing function by Peter Honeyman.

</pre><h4><b>BUGS</b></h4><pre>
       The <u>dptr</u> members of returned <u>datum</u> values point to static storage which is overwritten by later calls.

       Unlike  <u>dbm</u>,  <u>dbz</u>  will misbehave if an existing key-value pair is `overwritten' by a new <u>(dbz)store</u> with
       the same key.  The user is responsible  for  avoiding  this  by  using  <u>(dbz)fetch</u>  first  to  check  for
       duplicates;  an  internal  optimization  remembers  the  result  of  the first search so there is minimal
       overhead in this.

       Waiting until after <u>dbminit</u> to bring the base file into existence will fail if  <u><a href="../man2/chdir.2.html">chdir</a></u>(2)  has  been  used
       meanwhile.

       The RFC822 case mapper implements only a first approximation to the hideously-complex RFC822 case rules.

       The prime finder in <u>dbzsize</u> is not particularly quick.

       Should implement the <u>dbm</u> functions <u>delete</u>, <u>firstkey</u>, and <u>nextkey</u>.

       On  C implementations which trap integer overflow, <u>dbz</u> will refuse to <u>(dbz)store</u> an <u>fseek</u> offset equal to
       the greatest representable positive number, as this would cause overflow  in  the  biased  representation
       used.

       <u>Dbzagain</u>  perhaps  ought  to  notice  when many offsets in the old database were too big for tagging, and
       shrink the tag mask to match.

       Marking <u>dbz</u>'s file descriptors close-on-<u>exec</u> would be a better approach to the problem <u>dbzcancel</u> tries to
       address, but that's harder to do portably.

C News                                             3 Feb 1991                                             <u><a href="../man3/DBZ.3.html">DBZ</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>