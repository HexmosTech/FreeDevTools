<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pxlib - Library to read and write Paradox databases</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/pxlib-dev">pxlib-dev_0.6.9-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       pxlib - Library to read and write Paradox databases

</pre><h4><b>DESCRIPTION</b></h4><pre>
       pxlib  is a library to read and write Paradox databases. It is far from being complete but should be very
       helpful for those working on unix and having the need to handle paradox databases,  blob  files,  primary
       and secondary indexes.

       pxlib  is a C-library with bindings for Python and PHP.  The later is part of PECL (<a href="http://pecl.php.net">http://pecl.php.net</a>).
       This documentation will only describe the functions of the C-library, though most of what  is  said  here
       can  be  applied  to  the other language bindings.  The PHP extension of pxlib is documented in PEAR. The
       extension is called Paradox.

       This library is the base for a gnumeric plugin which has been officially added  to  gnumeric  in  version
       1.4.0.  pxlib  is  also  used  by  hk_classes  which  itself  is  the  database  access utilized by knoda
       (<a href="http://www.knoda.org">http://www.knoda.org</a>).

</pre><h4><b>GETTING</b> <b>STARTED</b></h4><pre>
       Programs which want to use pxlib will have to include the header file paradox.h and link  against  libpx.
       If  the  libgsf  file access is to be used paradox-gsf.h has to be included instead of paradox.h. The gsf
       library cannot be used currently for writing because pxlib requires read access on the database as  well,
       which is not supported by libgsf.  In such a case you will have to create a temporary file first and copy
       it the gsf stream afterwards.

       Before  reading or writing a database file the library should be initialized with <b><a href="../man3/PX_boot.3.html">PX_boot</a>(3)</b>. It will set
       the locale and selects the messages in your language as defined by the environment variable  LC_ALL.  The
       library should be finalized by <b><a href="../man3/PX_shutdown.3.html">PX_shutdown</a>(3)</b>.

       A  Paradox  database is represented by a pointer to pxdoc_t. Such an object can be created with <b><a href="../man3/PX_new.3.html">PX_new</a>(3)</b>
       and destroyed with <b><a href="../man3/PX_delete.3.html">PX_delete</a>(3)</b>.  You can  easily  handle  several  documents  at  the  same  time,  each
       represented by its own pointer to pxdoc_t.

       pxdoc_t  is  a  faily large structure with various information about the paradox file. Most of the needed
       information is stored in a substructure called px_head.  px_head is defined as the following:

       typedef struct px_head pxhead_t;
       struct px_head {
         char *px_tablename;
         int px_recordsize;
         char px_filetype;
         int px_fileversion;
         int px_numrecords;
         int px_theonumrecords;
         int px_numfields;
         int px_maxtablesize;
         int px_headersize;
         int px_fileblocks;
         int px_firstblock;
         int px_lastblock;
         int px_indexfieldnumber;
         int px_indexroot;
         int px_numindexlevels;
         int px_writeprotected;
         int px_doscodepage;
         int px_primarykeyfields;
         char px_modifiedflags1;
         char px_modifiedflags2;
         char px_sortorder;
         int px_autoinc;
         int px_fileupdatetime;
         char px_refintegrity;
         struct px_field *px_fields;
       };

       The structure is defined in paradox.h and can be accessed directly, thought it is not encouraged at  all,
       because  the  structure  will  disappear  in  the  future.  Most  header  values can already be read with
       <b><a href="../man3/PX_get_value.3.html">PX_get_value</a>(3)</b> or <b><a href="../man3/PX_get_parameter.3.html">PX_get_parameter</a>(3)</b> and set by <b><a href="../man3/PX_set_value.3.html">PX_set_value</a>(3)</b> respectively <b><a href="../man3/PX_set_parameter.3.html">PX_set_parameter</a>(3)</b>

       The following example will do the basic preparation without creating nor opening a document on the disk.

       ...
       #include &lt;paradox.h&gt;

       main(int argc, char *argv[]) {
            pxdoc_t *pxdoc;

            PX_boot();
            pxdoc = PX_new();
            PX_delete(pxdoc);
            PX_shutdown();
       }

       In order to actually read a Paradox database from disk you will have to call

       <b>int</b> <b>PX_open_file</b> <b>(pxdoc_t</b> <b>*</b><u>pxdoc</u><b>,</b> <b>const</b> <b>char</b> <b>*</b><u>filename</u><b>);</b>

       or

       <b>int</b> <b>PX_open_fp</b> <b>(pxdoc_t</b> <b>*</b><u>pxdoc</u><b>,</b> <b>FILE</b> <b>*</b><u>fp</u><b>);</b>

       <b><a href="../man3/PX_open_file.3.html">PX_open_file</a>(3)</b> will open an existing file with the given file name,  while  <b><a href="../man3/PX_open_fp.3.html">PX_open_fp</a>(3)</b>  will  use  an
       already open file. Both require a pointer to pxdoc_t.

       Extending  the  previous  example with one of the former two functions to open a database is just another
       small step as illustrated in the next example.

       ...
       #include &lt;paradox.h&gt;

       main(int argc, char *argv[]) {
            pxdoc_t *pxdoc;

            PX_boot();
            pxdoc = PX_new();
            PX_open_file(pxdoc, "test.db");
            PX_close(pxdoc);
            PX_delete(pxdoc);
            PX_shutdown();
       }

       The database has to be closed with <b><a href="../man3/PX_close.3.html">PX_close</a>(3)</b>.  <b><a href="../man3/PX_close.3.html">PX_close</a>(3)</b> will only close the file if it was opened by
       <b><a href="../man3/PX_open_file.3.html">PX_open_file</a>(3)</b>.  <b><a href="../man3/PX_close.3.html">PX_close</a>(3)</b> is crucial because it also flushes unwritten blocks to disk.

       There are more sophisticated functions to create the handle for the Paradox database.  They are used when
       error handling and memory management shall be controlled by the calling  application.  Check  the  manual
       pages  <b><a href="../man3/PX_new2.3.html">PX_new2</a>(3)</b>  and  <b><a href="../man3/PX_new3.3.html">PX_new3</a>(3)</b> for a detailed description or read the section about memory management
       and error handler below.

       If you rather like to create a new Paradox database the above example must call

       <b>int</b> <b>PX_create_file</b> <b>(pxdoc_t</b> <b>*</b><u>pxdoc</u><b>,</b> <b>pxfield_t</b> <b>*</b><u>fields</u><b>,</b> <b>int</b> <u>numfields</u><b>,</b> <b>const</b> <b>char</b> <b>*</b><u>filename</u><b>,</b> <b>int</b> <u>type</u><b>);</b>

       instead of <b><a href="../man3/PX_open_file.3.html">PX_open_file</a>(3)</b>. Creating a Paradox file requires three  further  parameters  to  specify  the
       database  layout  and  the  file type, e.g. pxfFileTypNonIndexDB. The function can be used to create both
       databases and primary index files. Secondary index files are not supported before version &lt;= 0.6.0 due to
       several bugs in pxlib.  Since the format of a secondary index file is identical to a database file  there
       is  actually  no  need for special support of secondary indexes.  It is left to the application to create
       them itself.  pxlib &gt;= 0.6.0 can open databases for reading and writing and provide  four  new  functions
       for this purpose. They will be described in the section `Modifying a database'.

       Each field of the database is described by a structure:

       typedef struct px_field pxfield_t;
       struct px_field {
         char *px_fname;
         char px_ftype;
         int px_flen;
         int px_fdc;
       };

       The  memory  for  the  field  array  must  be  allocated  by the calling application using pxlibs' memory
       management functions, but will be freed by pxlib. For a list of available file types see the man page  of
       <b><a href="../man3/PX_create_fp.3.html">PX_create_fp</a>(3)</b>.

</pre><h4><b>READING</b> <b>RECORDS</b> <b>FROM</b> <b>A</b> <b>DATABASE</b></h4><pre>
       Data  in  a  Paradox  database  is  organized  in  records containing fields.  This is much like in other
       formats, e.g. dBase or a relational database system. Fields can be of 17 different data types  as  listed
       below.   Field values are stored in sequential order in a record. A complete record is read by one of the
       functions

       <b>int</b> <b>PX_get_record</b> <b>(pxdoc_t</b> <b>*</b><u>pxdoc</u><b>,</b> <b>int</b> <u>recno</u><b>,</b> <b>char</b> <b>*</b><u>data</u><b>,</b> <b>int</b> <u>deleted</u><b>);</b>

       or

       <b>int</b> <b>PX_get_record2</b> <b>(pxdoc_t</b> <b>*</b><u>pxdoc</u><b>,</b> <b>int</b> <u>recno</u><b>,</b> <b>char</b> <b>*</b><u>data</u><b>,</b> <b>int</b> <u>deleted</u><b>,</b> <b>pxdatablockinfo_t</b> <b>*</b><u>pxdbinfo</u><b>);</b>

       The second function returns additional data about the internal location of the record  within  the  file,
       which  is  mostly  valueable  for  debugging  or creating a seconday index.  Both functions need a record
       number starting at 0 for the first record and a memory area large enough for the record. The size of that
       area can be determined by the function <b><a href="../man3/PX_get_value.3.html">PX_get_value</a>(3)</b> when `recordsize' is passed as the value name. The
       record will read into that piece of memory straight from the database file without modifications.

       Paradox files can be encrypted. pxlib will automatically decrypt a file while reading without the need to
       supply a password. This is possible because of a very weak encryption algorithmn and the  password  being
       stored in the database file itself.

       Once  the  record data has been read it can be accessed with a number of different functions depending on
       the field type. The following list contains the field type and the function needed to retrieve the value.
       Nothing can prevent you from accessing the record data in a different way if you know what you are doing.

       <b>pxfAlpha</b>

              <b>int</b> <b>PX_get_data_alpha</b> <b>(pxdoc_t</b> <b>*</b><u>pxdoc</u><b>,</b> <b>char</b> <b>*</b><u>data</u><b>,</b> <b>int</b> <u>len</u><b>,</b> <b>char</b> <b>**</b><u>value</u><b>);</b>

              The field value will be automatically converted from the encoding used in the database file to the
              encoding set by <b><a href="../man3/PX_set_parameter.3.html">PX_set_parameter</a>(3)</b> with parameter name set to 'targetencoding`. The  string  will
              be null terminated.

              This  function  allocates  memory  for  the field data which must be freed by the application. The
              chunk of memory can be different from len when encoding involves conversion from  a  1-byte  to  a
              2-byte  character  representaion.  This  is  also  the  reason why the application cannot precisly
              allocate the memory for the data and it must be left to pxlib.  Read  the  section  about  `Memory
              allocation' for more details.

       <b>pxfDate</b>

              <b>int</b> <b>PX_get_data_long</b> <b>(pxdoc_t</b> <b>*</b><u>pxdoc</u><b>,</b> <b>char</b> <b>*</b><u>data</u><b>,</b> <b>int</b> <u>len</u><b>,</b> <b>long</b> <b>*</b><u>value</u><b>);</b>

              Fields  of  type date are actually 4 byte integer values counting days since jan-00-0000. In order
              to convert it into 3 single integers for year, month and day, you will have to add 1721425 to  the
              value and call the function

              <b>void</b> <b>PX_SdnToGregorian</b> <b>(long</b> <b>int</b> <b>*</b><u>value</u><b>,</b> <b>int</b> <b>*</b><u>year</u><b>,</b> <b>int</b> <b>*</b><u>month</u><b>,</b> <b>int</b> <b>*</b><u>day</u><b>);</b>

              in  order  to  get  a valid date. The value 1721425 is the number of days between the start of the
              julian calendar (4714 BC) and jan-00-0000.  <u>len</u> must be set to 4.

       <b>pxfShort</b>

              <b>int</b> <b>PX_get_data_short</b> <b>(pxdoc_t</b> <b>*</b><u>pxdoc</u><b>,</b> <b>char</b> <b>*</b><u>data</u><b>,</b> <b>int</b> <u>len</u><b>,</b> <b>short</b> <b>int</b> <b>*</b><u>value</u><b>);</b>

              This type is a short integer which is 2 bytes long.  <u>len</u> must be set to 2.

       <b>pxfLong,</b> <b>pxfAutoInc</b>

              <b>int</b> <b>PX_get_data_long</b> <b>(pxdoc_t</b> <b>*</b><u>pxdoc</u><b>,</b> <b>char</b> <b>*</b><u>data</u><b>,</b> <b>int</b> <u>len</u><b>,</b> <b>long</b> <b>*</b><u>value</u><b>);</b>

              This type is a integer which is 4 bytes long.  <u>len</u> must be set to 4.

       <b>pxfNumber,</b> <b>pxfCurrency</b>

              <b>int</b> <b>PX_get_data_double</b> <b>(pxdoc_t</b> <b>*</b><u>pxdoc</u><b>,</b> <b>char</b> <b>*</b><u>data</u><b>,</b> <b>int</b> <u>len</u><b>,</b> <b>double</b> <b>*</b><u>value</u><b>);</b>

              These types are floating poing numbers.  <u>len</u> must be set to 8.

       <b>pxfLogical</b>

              <b>int</b> <b>PX_get_data_byte</b> <b>(pxdoc_t</b> <b>*</b><u>pxdoc</u><b>,</b> <b>char</b> <b>*</b><u>data</u><b>,</b> <b>int</b> <u>len</u><b>,</b> <b>char</b> <b>*</b><u>value</u><b>);</b>

              The extracted value is either 0 (false) or &lt;0 (true).  <u>len</u> must be set to 1.

       <b>pxfBLOb,</b> <b>pxfMemoBLOb,</b> <b>pxfFmtMemoBLOb</b>

              <b>int</b> <b>PX_get_data_blob</b> <b>(pxdoc_t</b> <b>*</b><u>pxdoc</u><b>,</b> <b>char</b>  <b>*</b><u>data</u><b>,</b>  <b>int</b>  <u>len</u><b>,</b>  <b>int</b>  <b>*</b><u>modnr</u><b>,</b>  <b>int</b>  <b>*</b><u>blobsize</u><b>,</b>  <b>char</b>
              <b>**</b><u>value</u><b>);</b>

              This  function may not in any case succed. You should call <b><a href="../man3/PX_set_blob_file.3.html">PX_set_blob_file</a>(3)</b> before to make sure
              even blobs in a separate blob file can be retrieved. See the section about reading blobs for  more
              information.

       <b>pxfOLE</b> This  type  is  not supported because there is too little known about it. Accessing fields of type
              pxfOLE like fields of type pxfBLOb may work.

       <b>pxfGraphic</b>

              <b>int</b> <b>PX_get_data_graphic</b> <b>(pxdoc_t</b> <b>*</b><u>pxdoc</u><b>,</b> <b>char</b> <b>*</b><u>data</u><b>,</b> <b>int</b> <u>len</u><b>,</b>  <b>int</b>  <b>*</b><u>modnr</u><b>,</b>  <b>int</b>  <b>*</b><u>blobsize</u><b>,</b>  <b>char</b>
              <b>**</b><u>value</u><b>);</b>

              This function has not been tested very well.

       <b>pxfTime</b>
              Use  <b><a href="../man3/PX_get_data_long.3.html">PX_get_data_long</a>(3)</b>  as  documented  at  field type pxfDate. The value is the number of milli
              seconds since midnight.

       <b>pxfTimestamp</b>
              Use <b><a href="../man3/PX_get_data_double.3.html">PX_get_data_double</a>(3)</b> and convert the timestamp into a string with

              <b>char</b> <b>*PX_timestamp2string</b> <b>(pxdoc_t</b> <b>*</b><u>pxdoc</u><b>,</b> <b>double</b> <b>*</b><u>value</u><b>,</b> <b>const</b> <b>char</b> <b>*</b><u>format</u><b>);</b>

              <b><a href="../man3/PX_timestamp2string.3.html">PX_timestamp2string</a>(3)</b> takes a format string as described in the manual page of the  function  and
              returns  a  string.   Alternatively  you can process the value itself. It represents the number of
              seconds since jan-00-0000. Dividing it by 86400 and converting it to an integer produces  a  value
              as stored in fields of type pxfTime.

       <b>pxfBCD</b>

              <b>int</b> <b>PX_get_data_bcd</b> <b>(pxdoc_t</b> <b>*</b><u>pxdoc</u><b>,</b> <b>char</b> <b>*</b><u>data</u><b>,</b> <b>int</b> <u>len</u><b>,</b> <b>char</b> <b>**</b><u>value</u><b>);</b>

              This function allocates memory for the field data which must be freed by the application.

       <b>pxfBytes</b>

              <b>int</b> <b>PX_get_data_bytes</b> <b>(pxdoc_t</b> <b>*</b><u>pxdoc</u><b>,</b> <b>char</b> <b>*</b><u>data</u><b>,</b> <b>int</b> <u>len</u><b>,</b> <b>char</b> <b>**</b><u>value</u><b>);</b>

              This function behaves like <b><a href="../man3/PX_get_data_alpha.3.html">PX_get_data_alpha</a>(3)</b> except for the character conversion which does not
              take  place.  It will always copy exactely <u>len</u> bytes. This function allocates memory for the field
              data which must be freed by the application.

       Each function takes the current Paradox database object as the first argument.  The  second  argument  is
       the  start  of  the  field  data. For the first field this will be the beginning of the whole record. The
       second field starts at an offset of length(first field), the third field starts  at  length(first  field)
       plus length(second field) and so on. The <u>len</u> is the size of the field. The last parameter is a pointer to
       the  data  converted to an equivalent C type. Each function either returns 0 on success or a value &lt; 0 in
       case of an error. Nobody prevents you from accessing the  data  with  the  wrong  function,  or  pointing
       towards  the  wrong  position  in  the record. Check the manual page of each function for a more detailed
       description.

       Sequencialy reading records and fields from a Paradox database is  illustrated  in  the  next  simplified
       example.

       for(j=0; j&lt;pxh-&gt;px_numrecords; j++) {
         int offset;
         if(PX_get_record(pxdoc, j, data)) {
           offset = 0;
           pxf = pxh-&gt;px_fields;
           for(i=0; i&lt;pxh-&gt;px_numfields; i++) {
             switch(pxf-&gt;px_ftype) {
               case pxfAlpha: {
                 char *value;
                 if(0 &lt; PX_get_data_alpha(pxdoc, &amp;data[offset], pxf-&gt;px_flen, &amp;value)) {
                   // ...
                   pxdoc-&gt;free(pxdoc, value);
                 } else {
                   // ...
                 }
                 break;
               }
               case pxfDate: {
                 long value;
                 int year, month, day;
                 if(0 &lt; PX_get_data_long(pxdoc, &amp;data[offset], pxf-&gt;px_flen, &amp;value)) {
                   PX_SdnToGregorian(value+1721425, &amp;year, &amp;month, &amp;day);
                   // ...
                 } else {
                   // ...
                 }
                 break;
               }
               case pxfShort: {
                 short int value;
                 if(0 &lt; PX_get_data_short(pxdoc, &amp;data[offset], pxf-&gt;px_flen, &amp;value)) {
                   // ...
                 } else {
                   // ...
                 }
                 break;
               }
               case pxfAutoInc:
               case pxfLong: {
                 long value;
                 if(0 &lt; PX_get_data_long(pxdoc, &amp;data[offset], pxf-&gt;px_flen, &amp;value)) {
                   // ...
                 } else {
                   // ...
                 }
                 break;
               }
               case pxfTimestamp: {
                 double value;
                 if(0 &lt; PX_get_data_double(pxdoc, &amp;data[offset], pxf-&gt;px_flen, &amp;value)) {
                   char *str = PX_timestamp2string(pxdoc, value, "Y-m-d H:i:s");
                   // ...
                   pxdoc-&gt;free(pxdoc, str);
                 } else {
                   // ...
                 }
                 break;
               }
               case pxfTime: {
                 long value;
                 if(0 &lt; PX_get_data_long(pxdoc, &amp;data[offset], pxf-&gt;px_flen, &amp;value)) {
                   // ...
                 } else {
                   // ...
                 }
                 break;
               }
               case pxfCurrency:
               case pxfNumber: {
                 double value;
                 if(0 &lt; PX_get_data_double(pxdoc, &amp;data[offset], pxf-&gt;px_flen, &amp;value)) {
                   // ...
                 } else {
                   // ...
                 }
                 break;
               }
               case pxfLogical: {
                 char value;
                 if(0 &lt; PX_get_data_byte(pxdoc, &amp;data[offset], pxf-&gt;px_flen, &amp;value)) {
                   if(value)
                     // ...
                   else
                     // ...
                 } else {
                   // ...
                 }
                 break;
               }
               case pxfBLOb:
               case pxfGraphic:
               case pxfOLE:
               case pxfMemoBLOb:
               case pxfFmtMemoBLOb: {
                   char *blobdata;
                   int mod_nr, size, ret;
                   if(pxf-&gt;px_ftype == pxfGraphic)
                     ret = PX_get_data_graphic(pxdoc, &amp;data[offset], pxf-&gt;px_flen, &amp;mod_nr, &amp;size, &amp;blobdata);
                   else
                     ret = PX_get_data_blob(pxdoc, &amp;data[offset], pxf-&gt;px_flen, &amp;mod_nr, &amp;size, &amp;blobdata);
                   if(ret &gt; 0) {
                     if(blobdata) {
                       // ...
                       pxdoc-&gt;free(pxdoc, blobdata);
                     } else {
                       // ...
                     }
                   }
                   break;
               }
               case pxfBCD: {
                 char *value;
                 int ret;
                 if(0 &lt; (ret = PX_get_data_bcd(pxdoc, &amp;data[offset], pxf-&gt;px_fdc, &amp;value))) {
                   // ..
                   pxdoc-&gt;free(pxdoc, value);
                 } else if(ret == 0) {
                   // ..
                 } else {
                   // ..
                 }
                 break;
               }
               case pxfBytes:
                 // ..
                 break;
               default:
                 break;
             }
           }
           offset += pxf-&gt;px_flen;
           pxf++;
         } else {
           fprintf(stderr, _("Couldn't get record number %d\n"), j);
         }
       }

</pre><h4><b>WRITING</b> <b>RECORDS</b> <b>INTO</b> <b>A</b> <b>DATABASE</b></h4><pre>
       Write  support  has  been  introduced  into  pxlib  in  version  0.1.9  but  should  be  still considered
       experimental, though there has been reports from users who has successfully used it.

       Writing paradox databases is quite  similar  to  reading  them,  if  you  substitute  <b><a href="../man3/PX_open_file.3.html">PX_open_file</a>(3)</b>  by
       <b><a href="../man3/PX_create_file.3.html">PX_create_file</a>(3)</b> and <b><a href="../man3/PX_get_record.3.html">PX_get_record</a>(3)</b> by <b><a href="../man3/PX_put_record.3.html">PX_put_record</a>(3)</b>.

       Modifying  the  above  example  in  order to create a simple database with two columns will result in the
       following code:

       ...
       #include &lt;paradox.h&gt;

       main(int argc, char *argv[]) {
            pxdoc_t *pxdoc;
            pxfield_t pxf[2];
            int numfields = 2;

            PX_boot();
            pxdoc = PX_new();
            pxf[0].px_fname = PX_strdup(pxdoc, "column1");
            pxf[0].px_ftype = pxfShort;
            pxf[0].px_flen = 2;
            pxf[0].px_fdc = 0;
            pxf[1].px_fname = PX_strdup(pxdoc, "column2");
            pxf[1].px_ftype = pxfAlpha;
            pxf[1].px_flen = 20;
            pxf[1].px_fdc = 0;
            PX_create_file(pxdoc, pxf, numfields, "test.db", pxfFileTypNonIndexDB);
            PX_close(pxdoc);
            PX_delete(pxdoc);
            PX_shutdown();
       }

</pre><h4><b>MODIFYING</b> <b>A</b> <b>DATABASE</b></h4><pre>
       Starting from version 0.6.0 pxlib supports to open databases for reading and writing at the same time. If
       you intend to do so, please ensure to open the file for the database in `w+', `r+',  or  `a+'  mode.  You
       will also have to use a new set of functions as described below.

       <b>int</b> <b>PX_insert_record</b> <b>(pxdoc_t</b> <b>*</b><u>pxdoc</u><b>,</b> <b>pxval_t</b> <b>**</b><u>data</u><b>);</b>

       <b><a href="../man3/PX_insert_record.3.html">PX_insert_record</a>(3)</b> inserts a new record into a database.

       <b>int</b> <b>PX_update_record</b> <b>(pxdoc_t</b> <b>*</b><u>pxdoc</u><b>,</b> <b>pxval_t</b> <b>**</b><u>data</u><b>,</b> <b>int</b> <u>recno</u><b>);</b>

       <b><a href="../man3/PX_update_record.3.html">PX_update_record</a>(3)</b> updates an existing record in database.

       <b>int</b> <b>PX_delete_record</b> <b>(pxdoc_t</b> <b>*</b><u>pxdoc</u><b>,</b> <b>int</b> <u>recno</u><b>);</b>

       <b>int</b> <b>PX_retrieve_record</b> <b>(pxdoc_t</b> <b>*</b><u>pxdoc</u><b>,</b> <b>int</b> <u>recno</u><b>);</b>

</pre><h4><b>ENCODING</b></h4><pre>
       Exchanging  text is not problem as long as both parties use the same encoding or stipulate to use plain 7
       bit ascii. Paradox allows one to use any encoding with a know dos code page and saves  the  corresponding
       code  page  number  in  the  header  of the database. You can request this number with <b><a href="../man3/PX_get_value.3.html">PX_get_value</a>(3)</b> by
       passing `codepage' as the value name. Reading fields of type pxfAlpha will return  the  unmodified  value
       unless  the  target  encoding  has been set by <b><a href="../man3/PX_set_parameter.3.html">PX_set_parameter</a>(3)</b> differently from the one stored in the
       database header. If the target  encoding  is  set  differently  <b><a href="../man3/PX_get_data_alpha.3.html">PX_get_data_alpha</a>(3)</b>  will  automatically
       convert  into  the  requested  encoding. This is either done be the iconv or recode library, depending on
       which one was found when pxlib was configured. If both were available iconv is preferred.

</pre><h4><b>READING</b> <b>BLOBS</b></h4><pre>
       Paradox knows five field types which all represent a type of blob data.   Blobs  can  be  stored  in  the
       database  file  but  are  usually  stored  in  an  extra  file with the extension .MB. pxlib provides two
       functions to read blob data.

       <b>int</b> <b>PX_get_data_blob</b> <b>(pxdoc_t</b> <b>*</b><u>pxdoc</u><b>,</b> <b>char</b> <b>*</b><u>data</u><b>,</b> <b>int</b> <u>len</u><b>,</b> <b>int</b> <b>*</b><u>modnr</u><b>,</b> <b>int</b> <b>*</b><u>blobsize</u><b>,</b> <b>char</b> <b>**</b><u>value</u><b>);</b>

       and

       <b>int</b> <b>PX_get_data_graphic</b> <b>(pxdoc_t</b> <b>*</b><u>pxdoc</u><b>,</b> <b>char</b> <b>*</b><u>data</u><b>,</b> <b>int</b> <u>len</u><b>,</b> <b>int</b> <b>*</b><u>modnr</u><b>,</b> <b>int</b> <b>*</b><u>blobsize</u><b>,</b> <b>char</b> <b>**</b><u>value</u><b>);</b>

       The second function must be used for fields of type pxfGraphic, the first function can be safely use  for
       fields of type pxfBLOb, pxfMemoBLOb, and pxfFmtMemoBLOb.

       In  order  to read blob data from a .MB file one must first associate that file with the database file by
       calling

       <b>int</b> <b>PX_set_blob_file</b> <b>(pxdoc_t</b> <b>*</b><u>pxdoc</u><b>,</b> <b>const</b> <b>char</b> <b>*</b><u>filename</u><b>);</b>

</pre><h4><b>WRITING</b> <b>BLOBS</b></h4><pre>
       Writing blobs is still the most experimental part of pxlib. There has been already  success  stories  but
       there are also some missing parts in the paradox file format which decreases confidence on those files.

</pre><h4><b>MEMORY</b> <b>MANAGEMENT,</b> <b>ERROR</b> <b>HANDLING</b></h4><pre>
       pxlib  uses  by  default its on memory management and error handling functions. In many cases the calling
       application has its own memory management and error handling. pxlib can be told to use those functions by
       calling <b><a href="../man3/PX_new3.3.html">PX_new3</a>(3)</b> instead of <b><a href="../man3/PX_new.3.html">PX_new</a>(3)</b>.

       <b>int</b> <b>PX_new3</b> <b>(pxdoc_t</b> <b>*</b><u>psdoc</u><b>,</b> <b>(errorhandler</b> <b>*)</b> <u>(pxdoc_t</u> <u>*p,</u>  <u>int</u>  <u>type,</u>  <u>const</u>  <u>char</u>  <u>*msg,</u>  <u>void</u>  <u>*data)</u><b>,</b>
       <b>(allocproc</b>  <b>*)</b>  <u>(pxdoc_t</u>  <u>*p,</u>  <u>size_t</u>  <u>size,</u> <u>const</u> <u>char</u> <u>*caller)</u><b>,</b> <b>(reallocproc</b> <b>*)</b> <u>(pxdoc_t</u> <u>*p,</u> <u>void</u> <u>*mem,</u>
       <u>size_t</u> <u>size,</u> <u>const</u> <u>char</u> <u>*caller)</u><b>,</b> <b>(freeproc</b> <b>*)</b> <u>(pxdoc_t</u> <u>*p,</u> <u>void</u> <u>*mem)</u><b>,</b> <b>void</b> <b>*</b><u>errorhandler_user_data</u><b>);</b>

       The errorhandler and the last parameter <u>errorhandler_user_data</u> allows one to pass arbitrary data  as  the
       last  parameter  to its own errorhandler. This is quite often used if errors are being output in a widget
       of a graphical toolkit. The pointer to that widget can be passed as <u>errorhandler_user_data</u> and pxlib will
       pass it forward to the error handler.

</pre><h4><b>ENCRYPTION</b></h4><pre>
       Paradox supports a very weak encryption of the data blocks. The headers are not encrypted. Encryption  is
       accomplished by three static tables with 256 bytes each and a long integer generated from a password. The
       integer  is  called  the  checksum of the password.  The checksum is stored in the header of the .db file
       which makes it feasible to decrypt a file even without knowing the password.  pxlib reads encrypted files
       silently without asking for additional information. Writing  an  encrypted  file  requires  to  supply  a
       password  for calculating the checksum. The password can be set with <b><a href="../man3/PX_set_parameter.3.html">PX_set_parameter</a>(3)</b>. Once it is set,
       encryption is automatically turned on. The password must be set before  writing  any  records.  The  best
       place to do this, is right after calling <b><a href="../man3/PX_create_file.3.html">PX_create_file</a>(3)</b> or <b><a href="../man3/PX_create_fp.3.html">PX_create_fp</a>(3)</b>.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       The detailed manual pages for each function of the library.

</pre><h4><b>AUTHOR</b></h4><pre>
       This manual page was written by Uwe Steinmann &lt;<a href="mailto:uwe@steinmann.cx">uwe@steinmann.cx</a>&gt;.

                                                 March 27, 2006                                         <u><a href="../man3/PXLIB.3.html">PXLIB</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>