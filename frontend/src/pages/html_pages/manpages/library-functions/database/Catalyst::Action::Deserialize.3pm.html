<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Catalyst::Action::Deserialize - Deserialize Data in a Request</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcatalyst-action-rest-perl">libcatalyst-action-rest-perl_1.21-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Catalyst::Action::Deserialize - Deserialize Data in a Request

</pre><h4><b>SYNOPSIS</b></h4><pre>
           package Foo::Controller::Bar;

           __PACKAGE__-&gt;config(
               'default'   =&gt; 'text/x-yaml',
               'stash_key' =&gt; 'rest',
               'map'       =&gt; {
                   'text/x-yaml'        =&gt; 'YAML',
                   'text/x-data-dumper' =&gt; [ 'Data::Serializer', 'Data::Dumper' ],
               },
           );

           sub begin :ActionClass('Deserialize') {}

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This action will deserialize HTTP POST, PUT, OPTIONS and DELETE requests.  It assumes that the body of
       the HTTP Request is a serialized object.  The serializer is selected by introspecting the requests
       content-type header.

       If you want deserialize any other HTTP method besides POST, PUT, OPTIONS and DELETE you can do this by
       setting the "deserialize_http_methods" list via "action_args".  Just modify the config in your controller
       and define a list of HTTP methods the deserialization should happen for:

           __PACKAGE__-&gt;config(
               action_args =&gt; {
                   '*' =&gt; {
                       deserialize_http_methods =&gt; [qw(POST PUT OPTIONS DELETE GET)]
                   }
               }
           );

       See also "action_args" in Catalyst::Controller.

       The specifics of deserializing each content-type is implemented as a plugin to
       Catalyst::Action::Deserialize.  You can see a list of currently implemented plugins in
       Catalyst::Controller::REST.

       The results of your Deserializing will wind up in $c-&gt;req-&gt;data.  This is done through the magic of
       Catalyst::Request::REST.

       While it is common for this Action to be called globally as a "begin" method, there is nothing stopping
       you from using it on a single routine:

          sub foo :Local :Action('Deserialize') {}

       Will work just fine.

       When you use this module, the request class will be changed to Catalyst::Request::REST.

</pre><h4><b>RFC</b> <b>7231</b> <b>Compliance</b> <b>Mode</b></h4><pre>
       To maintain backwards compatibility with the module's original functionality, where it was assumed the
       deserialize and serialize content types are the same, an optional compliance mode can be enabled to break
       this assumption.

           __PACKAGE__-&gt;config(
               'compliance_mode'    =&gt; 1,
               'default'            =&gt; 'text/x-yaml',
               'stash_key'          =&gt; 'rest',
               'map'                =&gt; {
                   'text/x-yaml'        =&gt; 'YAML',
                   'text/x-data-dumper' =&gt; [ 'Data::Serializer', 'Data::Dumper' ],
               },
               'deserialize_default =&gt; 'application/json',
               'deserialize_map'    =&gt; {
                   'application/json'   =&gt; 'JSON',
               },
           );

       Three extra keys are added to the controller configuration. compliance_mode, a boolean to enable the
       mode. And a parallel set of content type mappings 'deserialize_default' and 'deserialize_map' to mirror
       the default/map configuration keys.

       The module will use the default/map keys when negotiating the serializing content type specified by the
       client in the Accept header. And will use the deserialize_default/deserialize_map in conjunction with the
       Content-Type header where the client is giving the content type being sent in the request.

</pre><h4><b>CUSTOM</b> <b>ERRORS</b></h4><pre>
       For building custom error responses when de-serialization fails, you can create an ActionRole (and use
       Catalyst::Controller::ActionRole to apply it to the "begin" action) which overrides
       "unsupported_media_type" and/or "serialize_bad_request" methods.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       You likely want to look at Catalyst::Controller::REST, which implements a sensible set of defaults for a
       controller doing REST.

       Catalyst::Action::Serialize, Catalyst::Action::REST

</pre><h4><b>AUTHORS</b></h4><pre>
       See Catalyst::Action::REST for authors.

</pre><h4><b>LICENSE</b></h4><pre>
       You may distribute this code under the same terms as Perl itself.

perl v5.34.0                                       2022-06-09                 <u>Catalyst::Action::<a href="../man3pm/Deserialize.3pm.html">Deserialize</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>