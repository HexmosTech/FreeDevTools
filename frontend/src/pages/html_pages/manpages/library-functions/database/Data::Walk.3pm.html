<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data::Walk - Traverse Perl data structures</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdata-walk-perl">libdata-walk-perl_2.01-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Data::Walk - Traverse Perl data structures

</pre><h4><b>SYNOPSIS</b></h4><pre>
        use Data::Walk;
        walk \&amp;wanted, @items_to_walk;

        use Data::Walk;
        walkdepth \&amp;wanted, @items_to_walk;

        use Data::Walk;
        walk { wanted =&gt; \&amp;process, follow =&gt; 1 }, $self;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The above synopsis bears an amazing similarity to <b>File::<a href="../man3pm/Find.3pm.html">Find</a></b>(3pm) and this is not coincidental.

       <b>Data::<a href="../man3pm/Walk.3pm.html">Walk</a></b>(3pm) is for data what <b>File::<a href="../man3pm/Find.3pm.html">Find</a></b>(3pm) is for files.  You can use it for rolling your own
       serialization class, for displaying Perl data structures, for deep copying or comparing, for recursive
       deletion of data, or ...

       If you are impatient and already familiar with <b>File::<a href="../man3pm/Find.3pm.html">Find</a></b>(3pm), you can skip the following documentation
       and proceed with "DIFFERENCES TO FILE::FIND".

</pre><h4><b>FUNCTIONS</b></h4><pre>
       The module exports two functions by default:

       <b>walk</b>
             walk \&amp;wanted, @items;
             walk \%options, @items;

           As the name suggests, the function traverses the items in the order they are given.  For every object
           visited, it calls the &amp;wanted subroutine.  See "THE WANTED FUNCTION" for details.

       <b>walkdepth</b>
             walkdepth \&amp;wanted, @items;
             walkdepth \%options, @items;

           Works  exactly  like  "walk()"  but  it first descends deeper into the structure, before visiting the
           nodes on the current level.  If you want to delete visited nodes, then "walkdepth()" is probably your
           friend.

</pre><h4><b>OPTIONS</b></h4><pre>
       The first argument to "walk()" and "walkdepth()" is either a code reference to your &amp;wanted function,  or
       a hash reference describing the operations to be performed for each visited node.

       Here are the possible keys for the hash.

       <b>wanted</b>
           The  value  should  be  a  code reference.  This code reference is described in "THE WANTED FUNCTION"
           below.

       <b>bydepth</b>
           Visits nodes on the current level of recursion only <b>after</b> descending into subnotes.  The entry  point
           "walkdepth()" is a shortcut for specifying "{ bydepth =&gt; 1 }".

       <b>preprocess</b>
           The  value  should  be  a code reference.  This code reference is used to preprocess the current node
           $Data::Walk::container.  Your preprocessing function  is  called  before  the  loop  that  calls  the
           "wanted()" function.  It is called with a list of member nodes and is expected to return such a list.
           The  list  will  contain  all sub-nodes, regardless of the value of the option <u>follow</u>!  The list is a
           shallow copy of the data contained in the original structure.  You can therefore safely delete  items
           in it, without affecting the original data.

           The  behavior  is  identical  for  regular arrays and hashes, so you probably want to coerce the list
           passed as an argument into a hash then.  The  variable  $Data::Walk::type  will  contain  the  string
           "HASH" if the currently inspected node is a hash.

           You  can  use the preprocessing function to sort the items contained or to filter out unwanted items.
           The order is also preserved for hashes!

       <b>preprocess_hash</b>
           The value should be a code reference.  The code is executed right after an  eventual  <u>preprocess_hash</u>
           handler, but only if the current container is a hash.  It is skipped for regular arrays.

           You  will usually prefer a <u>preprocess_hash</u> handler over a <u>preprocess</u> handler if you only want to sort
           hash keys.

       <b>postprocess</b>
           The value should be a code reference.  It is invoked just before leaving the currently visited  node.
           It  is  called  in void context with no arguments.  The variable $Data::Walk::container points to the
           currently visited node.

       <b>follow</b>
           Causes cyclic references to be followed.  Normally, the traversal will not descend  into  nodes  that
           have  already  been  visited.   If  you  set  the option <u>follow</u> to a truth value, you can change this
           behavior.  Unless you take additional measures, this will always imply an infinite loop!

           Please note that the &amp;wanted function is also called for nodes that have already been  visited!   The
           effect of <u>follow</u> is to suppress descending into subnodes.

       All other options are silently ignored.

</pre><h4><b>THE</b> <b>WANTED</b> <b>FUNCTION</b></h4><pre>
       The  &amp;wanted function does whatever verifications you want on each item in the data structure.  Note that
       despite its name, the &amp;wanted function is a generic callback and does <b>not</b> tell <b>Data::<a href="../man3pm/Walk.3pm.html">Walk</a></b>(3pm) if an item
       is "wanted" or not.  In fact, its return value is ignored.

       The wanted function takes no arguments but rather does its work through a collection of variables:

       <b>$_</b>  The currently visited node.  Think "file" in terms of <b>File::<a href="../man3pm/Find.3pm.html">Find</a></b>(3pm)!

       <b>$Data::Walk::container</b>
           The node containing the currently visited node, either a reference to a  hash  or  an  array.   Think
           "directory" in terms of <b>File::<a href="../man3pm/Find.3pm.html">Find</a></b>(3pm)!

       <b>$Data::Walk::type</b>
           The base type of the object that $Data::Walk::container references.  This is either "ARRAY" or "HASH"
           or the empty string for everything else.

       <b>$Data::Walk::seen</b>
           For   references,  this  will  hold  the  number of times the currently visited node has been visited
           <u>before</u>.  The value is consequently set to 0 not 1 on the first visit.  For non-references, the  value
           is undefined.

       <b>$Data::Walk::address</b>
           For  references,  this  will  hold  the  memory  address  it  points  to.  It can be used as a unique
           identifier for the current node.  For non- references, the value is undefined.

       <b>$Data::Walk::depth</b>
           The depth of the current recursion.

       <b>$Data::Walk::index</b>
           Holds the index of the current item in the container.  Note that hashes and arrays  are  treated  the
           same.  Therefore, if the current container is a hash and <b>$Data::Walk::index</b> is even then <b>$_</b> is a hash
           key.  If it is odd, then <b>$_</b> is a hash value.

           Note that the root container is the array of items to search that you passed to the wanted function!

           This variable has been added in Data::Walk version 1.01.

       These variables should not be modified.

</pre><h4><b>DIFFERENCES</b> <b>TO</b> <b>FILE::FIND</b></h4><pre>
       The  API  of  <b>Data::<a href="../man3pm/Walk.3pm.html">Walk</a></b>(3pm)  tries to mimic the API of <b>File::<a href="../man3pm/Find.3pm.html">Find</a></b>(3pm) to a certain extent.  If you are
       already familiar with <b>File::<a href="../man3pm/Find.3pm.html">Find</a></b>(3pm) you will find it  very  easy  to  use  <b>Data::<a href="../man3pm/Walk.3pm.html">Walk</a></b>(3pm).   Even  the
       documentation for <b>Data::<a href="../man3pm/Walk.3pm.html">Walk</a></b>(3pm) is in parts similar or identcal to that of <b>File::<a href="../man3pm/Find.3pm.html">Find</a></b>(3pm).

   <b>Analogies</b>
       The  equivalent  of  directories  in  <b>File::<a href="../man3pm/Find.3pm.html">Find</a></b>(3pm)  are  the  container data types in <b>Data::<a href="../man3pm/Walk.3pm.html">Walk</a></b>(3pm).
       Container data types are arrays (aka lists) and associative arrays (aka hashes).  Files are equivalent to
       scalars.  Wherever <b>File::<a href="../man3pm/Find.3pm.html">Find</a></b>(3pm) passes lists of strings to functions, <b>Data::<a href="../man3pm/Walk.3pm.html">Walk</a></b>(3pm) passes lists  of
       variables.

   <b>Function</b> <b>Names</b>
       Instead  of  "find()"  and "finddepth()", <b>Data::<a href="../man3pm/Walk.3pm.html">Walk</a></b>(3pm) uses "walk()" and "walkdepth()", like the smart
       reader has already guessed after reading the "SYNOPSIS".

   <b>Variables</b>
       The variable $Data::Walk::container is vaguely equivalent to $File::Find::dir.  All other  variables  are
       specific to the corresponding module.

   <b>Wanted</b> <b>Function</b>
       Like  its archetype from <b>File::<a href="../man3pm/Find.3pm.html">Find</a></b>(3pm), the wanted function of <b>Data::<a href="../man3pm/Walk.3pm.html">Walk</a></b>(3pm) is called with $_ set to
       the currently inspected item.

   <b>Options</b>
       The option <u>follow</u> has the effect that <b>Data::<a href="../man3pm/Walk.3pm.html">Walk</a></b>(3pm) also descends into nodes it  has  already  visited.
       Unless you take extra measures, this will lead to an infinite loop!

       A  number  of options are not applicable to data traversion and are ignored by <b>Data::<a href="../man3pm/Walk.3pm.html">Walk</a></b>(3pm).  Examples
       are <u>follow_fast</u>, <u>follow_skip</u>, <u>no_chdir</u>, <u>untaint</u>, <u>untaint_pattern</u>, and <u>untaint_skip</u>.  To  give  truth  the
       honor, all unrecognized options are skipped.

</pre><h4><b>EXAMPLES</b></h4><pre>
       Following are some recipes for common tasks.

   <b>Recurse</b> <b>To</b> <b>Maximum</b> <b>Depth</b>
       If you want to stop the recursion at a certain level, do it as follows:

           my $max_depth = 20;
           sub not_too_deep {
               if ($Data::Walk::depth &gt; $max_depth) {
               return ();
               } else {
               return @_;
               }
           }
           sub do_something1 {
               # Your code goes here.
           }
           walk { wanted =&gt; \&amp;do_something, preprocess =&gt; \&amp;not_too_deep };

</pre><h4><b>BUGS</b></h4><pre>
       If  you  think  you  have  spotted  a  bug,  you  can  share it with others in the bug tracking system at
       <a href="http://rt.cpan.org/NoAuth/Bugs.html">http://rt.cpan.org/NoAuth/Bugs.html</a>?Dist=Data-Walk.

</pre><h4><b>COPYING</b></h4><pre>
       Copyright (C) 2005-2016 Guido Flohr &lt;<a href="http://www.guido-flohr.net/">http://www.guido-flohr.net/</a>&gt;, &lt;<a href="mailto:guido.flohr@cantanea.com">mailto:guido.flohr@cantanea.com</a>&gt;, all
       rights reserved.

       This program is free software; you can redistribute it and/or modify  it  under  the  terms  of  the  GNU
       Library  General  Public  License  as published by the Free Software Foundation; either version 2, or (at
       your option) any later version.

       This program is distributed in the hope that it will be useful, but WITHOUT ANY  WARRANTY;  without  even
       the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General
       Public License for more details.

       You  should  have  received  a copy of the GNU Library General Public License along with this program; if
       not, write to the Free Software Foundation, Inc., 59 Temple Place - Suite  330,  Boston,  MA  02111-1307,
       USA.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b>Data::<a href="../man3pm/Dumper.3pm.html">Dumper</a></b>(3pm), <b><a href="../man3pm/Storable.3pm.html">Storable</a></b>(3pm), <b>File::<a href="../man3pm/Find.3pm.html">Find</a></b>(3pm), <b><a href="../man1/perl.1.html">perl</a></b>(1)

perl v5.34.0                                       2022-06-13                                    <u>Data::<a href="../man3pm/Walk.3pm.html">Walk</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>