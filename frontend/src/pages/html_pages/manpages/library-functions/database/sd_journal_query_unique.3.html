<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sd_journal_query_unique, sd_journal_enumerate_unique, sd_journal_enumerate_available_unique,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libsystemd-dev">libsystemd-dev_257.7-1ubuntu3_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       sd_journal_query_unique, sd_journal_enumerate_unique, sd_journal_enumerate_available_unique,
       sd_journal_restart_unique, SD_JOURNAL_FOREACH_UNIQUE - Read unique data fields from the journal

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;systemd/sd-journal.h&gt;</b>

       <b>int</b> <b>sd_journal_query_unique(sd_journal</b> <b>*</b><u>j</u><b>,</b> <b>const</b> <b>char</b> <b>*</b><u>field</u><b>);</b>

       <b>int</b> <b>sd_journal_enumerate_available_unique(sd_journal</b> <b>*</b><u>j</u><b>,</b> <b>const</b> <b>void</b> <b>**</b><u>data</u><b>,</b> <b>size_t</b> <b>*</b><u>length</u><b>);</b>

       <b>int</b> <b>sd_journal_enumerate_unique(sd_journal</b> <b>*</b><u>j</u><b>,</b> <b>const</b> <b>void</b> <b>**</b><u>data</u><b>,</b> <b>size_t</b> <b>*</b><u>length</u><b>);</b>

       <b>void</b> <b>sd_journal_restart_unique(sd_journal</b> <b>*</b><u>j</u><b>);</b>

       <b>SD_JOURNAL_FOREACH_UNIQUE(sd_journal</b> <b>*</b><u>j</u><b>,</b> <b>const</b> <b>void</b> <b>*</b><u>data</u><b>,</b> <b>size_t</b> <u>length</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>sd_journal_query_unique()</b> queries the journal for all unique values the specified field can take. It
       takes two arguments: the journal to query and the field name to look for. Well-known field names are
       listed on <b><a href="../man7/systemd.journal-fields.7.html">systemd.journal-fields</a></b>(7), but any field can be specified. Field names must be specified
       without a trailing "=". After this function has been executed successfully the field values may be
       queried using <b>sd_journal_enumerate_unique()</b> and <b>sd_journal_enumerate_available_unique()</b>. Invoking one of
       those calls will change the field name being queried and reset the enumeration index to the first field
       value that matches.

       <b>sd_journal_enumerate_unique()</b> may be used to iterate through all data fields which match the previously
       selected field name as set with <b>sd_journal_query_unique()</b>. On each invocation the next field data
       matching the field name is returned. The order of the returned data fields is not defined. It takes three
       arguments: the journal object, plus a pair of pointers to pointer/size variables where the data object
       and its size shall be stored. The returned data is in a read-only memory map and is only valid until the
       next invocation of <b>sd_journal_enumerate_unique()</b>. Note that the data returned will be prefixed with the
       field name and "=". Note that this call is subject to the data field size threshold as controlled by
       <b>sd_journal_set_data_threshold()</b> and only the initial part of the field up to the threshold is returned.
       An error is returned for fields which cannot be retrieved. See the error list below for details.

       <b>sd_journal_enumerate_available_unique()</b> is similar to <b>sd_journal_enumerate_unique()</b>, but silently skips
       any fields which may be valid, but are too large or not supported by current implementation.

       <b>sd_journal_restart_unique()</b> resets the data enumeration index to the beginning of the list. The next
       invocation of <b>sd_journal_enumerate_unique()</b> will return the first field data matching the field name
       again.

       Note that the <b>SD_JOURNAL_FOREACH_UNIQUE()</b> macro may be used as a handy wrapper around
       <b>sd_journal_restart_unique()</b> and <b>sd_journal_enumerate_available_unique()</b>.

       Note that these functions currently are not influenced by matches set with <b>sd_journal_add_match()</b> but
       this might change in a later version of this software.

       To enumerate all field names currently in use (and thus all suitable field parameters for
       <b>sd_journal_query_unique()</b>), use the <b><a href="../man3/sd_journal_enumerate_fields.3.html">sd_journal_enumerate_fields</a></b>(3) call.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       <b>sd_journal_query_unique()</b> returns 0 on success or a negative errno-style error code.
       <b>sd_journal_enumerate_unique()</b> and <b>sd_journal_query_available_unique()</b> return a positive integer if the
       next field data has been read, 0 when no more fields remain, or a negative errno-style error code.
       <b>sd_journal_restart_unique()</b> does not return anything.

   <b>Errors</b>
       Returned errors may indicate the following problems:

       <b>-EINVAL</b>
           One of the required parameters is <b>NULL</b> or invalid.

           Added in version 246.

       <b>-ECHILD</b>
           The journal object was created in a different process, library or module instance.

           Added in version 246.

       <b>-EADDRNOTAVAIL</b>
           The read pointer is not positioned at a valid entry; <b><a href="../man3/sd_journal_next.3.html">sd_journal_next</a></b>(3) or a related call has not
           been called at least once.

           Added in version 246.

       <b>-ENOENT</b>
           The current entry does not include the specified field.

           Added in version 246.

       <b>-ENOBUFS</b>
           A compressed entry is too large.

           Added in version 246.

       <b>-E2BIG</b>
           The data field is too large for this computer architecture (e.g. above 4 GB on a 32-bit
           architecture).

           Added in version 246.

       <b>-EPROTONOSUPPORT</b>
           The journal is compressed with an unsupported method or the journal uses an unsupported feature.

           Added in version 246.

       <b>-EBADMSG</b>
           The journal is corrupted (possibly just the entry being iterated over).

           Added in version 246.

       <b>-EIO</b>
           An I/O error was reported by the kernel.

           Added in version 246.

</pre><h4><b>NOTES</b></h4><pre>
       All functions listed here are thread-agnostic and only a single specific thread may operate on a given
       object during its entire lifetime. It is safe to allocate multiple independent objects and use each from
       a specific thread in parallel. However, it is not safe to allocate such an object in one thread, and
       operate or free it from any other, even if locking is used to ensure these threads do not operate on it
       at the very same time.

       Functions described here are available as a shared library, which can be compiled against and linked to
       with the <b>libsystemd</b> <b><a href="../man1/pkg-config.1.html">pkg-config</a></b>(1) file.

</pre><h4><b>EXAMPLES</b></h4><pre>
       Use the <b>SD_JOURNAL_FOREACH_UNIQUE()</b> macro to iterate through all values a field of the journal can take
       (and which can be accessed on the given architecture and are not compressed with an unsupported
       mechanism). The following example lists all unit names referenced in the journal:

           /* SPDX-License-Identifier: MIT-0 */

           #include &lt;<a href="file:/usr/include/errno.h">errno.h</a>&gt;
           #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
           #include &lt;systemd/sd-journal.h&gt;

           int main(int argc, char *argv[]) {
             sd_journal *j;
             const void *d;
             size_t l;
             int r;

             r = sd_journal_open(&amp;j, SD_JOURNAL_LOCAL_ONLY);
             if (r &lt; 0) {
               fprintf(stderr, "Failed to open journal: %s\n", strerror(-r));
               return 1;
             }
             r = sd_journal_query_unique(j, "_SYSTEMD_UNIT");
             if (r &lt; 0) {
               fprintf(stderr, "Failed to query journal: %s\n", strerror(-r));
               return 1;
             }
             SD_JOURNAL_FOREACH_UNIQUE(j, d, l)
               printf("%.*s\n", (int) l, (const char*) d);
             sd_journal_close(j);
             return 0;
           }

</pre><h4><b>HISTORY</b></h4><pre>
       <b>sd_journal_query_unique()</b>, <b>sd_journal_enumerate_unique()</b>, <b>sd_journal_restart_unique()</b>, and
       <b>SD_JOURNAL_FOREACH_UNIQUE()</b> were added in version 195.

       <b>sd_journal_enumerate_available_unique()</b> was added in version 246.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/systemd.1.html">systemd</a></b>(1), <b><a href="../man7/systemd.journal-fields.7.html">systemd.journal-fields</a></b>(7), <b><a href="../man3/sd-journal.3.html">sd-journal</a></b>(3), <b><a href="../man3/sd_journal_open.3.html">sd_journal_open</a></b>(3), <b><a href="../man3/sd_journal_enumerate_fields.3.html">sd_journal_enumerate_fields</a></b>(3),
       <b><a href="../man3/sd_journal_get_data.3.html">sd_journal_get_data</a></b>(3), <b><a href="../man3/sd_journal_add_match.3.html">sd_journal_add_match</a></b>(3)

systemd 257.7                                                                         <u><a href="../man3/SD_JOURNAL_QUERY_UNIQUE.3.html">SD_JOURNAL_QUERY_UNIQUE</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>