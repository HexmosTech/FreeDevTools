<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data::ObjectDriver::SQL - an SQL statement</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdata-objectdriver-perl">libdata-objectdriver-perl_0.25-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Data::ObjectDriver::SQL - an SQL statement

</pre><h4><b>SYNOPSIS</b></h4><pre>
           my $sql = Data::ObjectDriver::SQL-&gt;new();
           $sql-&gt;select([ 'id', 'name', 'bucket_id', 'note_id' ]);
           $sql-&gt;from([ 'foo' ]);
           $sql-&gt;add_where('name',      'fred');
           $sql-&gt;add_where('bucket_id', { op =&gt; '!=', value =&gt; 47 });
           $sql-&gt;add_where('note_id',   \'IS NULL');
           $sql-&gt;<a href="../man1/limit.1.html">limit</a>(1);

           my $sth = $dbh-&gt;prepare($sql-&gt;as_sql);
           $sth-&gt;execute(@{ $sql-&gt;{bind} });
           my @values = $sth-&gt;selectrow_array();

           my $obj = SomeObject-&gt;new();
           $obj-&gt;set_columns(...);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <u>Data::ObjectDriver::SQL</u> represents an SQL statement. SQL statements are used internally to
       "Data::ObjectDriver::Driver::DBI" object drivers to convert database operations (search(), update(), etc)
       into database operations, but sometimes you just gotta use SQL.

</pre><h4><b>ATTRIBUTES</b></h4><pre>
       <u>Data::ObjectDriver::SQL</u> sports several data attributes that represent the parts of the modeled SQL
       statement.  These attributes all have accessor and mutator methods. Note that some attributes have more
       convenient methods of modification (for example, add_where() for the "where" attribute).

   <b>"select"</b> <b>(arrayref)</b>
       The database columns to select in a "SELECT" query.

   <b>"distinct"</b> <b>(boolean)</b>
       Whether the "SELECT" query should return DISTINCT rows only.

   <b>"select_map"</b> <b>(hashref)</b>
       The map of database column names to object fields in a "SELECT" query. Use this mapping to convert
       members of the "select" list to column names.

   <b>"select_map_reverse"</b> <b>(hashref)</b>
       The map of object fields to database column names in a "SELECT" query. Use this map to reverse the
       "select_map" mapping where needed.

   <b>"from"</b> <b>(arrayref)</b>
       The list of tables from which to query results in a "SELECT" query.

       Note if you perform a "SELECT" query with multiple tables, the rows will be selected as Cartesian
       products that you'll need to reduce with "WHERE" clauses. Your query might be better served with real
       joins specified through the "joins" attribute of your statement.

   <b>"joins"</b> <b>(arrayref</b> <b>of</b> <b>hashrefs</b> <b>containing</b> <b>scalars</b> <b>and</b> <b>hashrefs)</b>
       The list of "JOIN" clauses to use in the table list of the statement. Each clause is a hashref containing
       these members:

       •   "table"

           The name of the table in "from" being joined.

       •   "joins" (arrayref)

           The  list  of  joins  to  perform  on the table named in "table". Each member of "joins" is a hashref
           containing:

           •   "type"

               The type of join to use. That is, the SQL string to use  before  the  word  "JOIN"  in  the  join
               expression;  for  example,  "INNER"  or "NATURAL RIGHT OUTER"). This member is optional. When not
               specified, the default plain "JOIN" join is specified.

           •   "table"

               The name of the table to which to join.

           •   "condition"

               The SQL expression across which to perform the join, as a string.

   <b>"where"</b> <b>(arrayref)</b>
       The list of "WHERE" clauses that apply to the SQL statement. Individual members of the list  are  strings
       of  SQL. All members of this attribute must be true for a record to be included as a result; that is, the
       list members are "AND"ed together to form the full "WHERE" clause.

   <b>"where_values"</b> <b>(hashref</b> <b>of</b> <b>variant</b> <b>structures)</b>
       The set of data structures used to generate the "WHERE" clause SQL found in the "where" attributes, keyed
       on the associated column names.

   <b>"bind"</b> <b>(arrayref)</b>
       The list of values to bind to the query when performed. That is, the list of values to  be  replaced  for
       the "?"es in the SQL.

   <b>"limit"</b> <b>(scalar)</b>
       The maximum number of results on which to perform the query.

   <b>"offset"</b> <b>(scalar)</b>
       The  number of records to skip before performing the query. Combined with a "limit" and application logic
       to increase the offset in subsequent queries, you can paginate a set of  records  with  a  moving  window
       containing "limit" records.

   <b>"group"</b> <b>(hashref,</b> <b>or</b> <b>an</b> <b>arrayref</b> <b>of</b> <b>hashrefs)</b>
       The fields on which to group the results. Grouping fields are hashrefs containing these members:

       •   "column"

           Name of the column on which to group.

       Note you can set a single grouping field, or use an arrayref containing multiple grouping fields.

   <b>"having"</b> <b>(arrayref)</b>
       The  list  of  clauses  to  specify  in  the "HAVING" portion of a "GROUP ...  HAVING" clause. Individual
       clauses are simple strings containing the conditional expression, as in "where".

   <b>"order"</b> <b>(hashref,</b> <b>or</b> <b>an</b> <b>arrayref</b> <b>of</b> <b>hashrefs)</b>
       Returns or sets the fields by which to order the results. Ordering fields are hashrefs  containing  these
       members:

       •   "column"

           Name of the column by which to order.

       •   "desc"

           The  SQL  keyword  to  use  to  specify the ordering. For example, use "DESC" to specify a descending
           order. This member is optional.

       Note you can set a single ordering field, or use an arrayref containing multiple ordering fields.

   <b>"$sql-&gt;comment([</b> <b>$comment</b> <b>])"</b>
       Returns or sets a simple comment to the SQL statement

</pre><h4><b>USAGE</b></h4><pre>
   <b>"Data::ObjectDriver::SQL-&gt;new()"</b>
       Creates a new, empty SQL statement.

   <b>"$sql-&gt;add_select($column</b> <b>[,</b> <b>$term</b> <b>])"</b>
       Adds the database column $column to the list of fields to return  in  a  "SELECT"  query.  The  requested
       object  member  will  be  indicated  to be $term in the statement's "select_map" and "select_map_reverse"
       attributes.

       $term is optional, and defaults to the same value as $column.

   <b>"$sql-&gt;add_join($table,</b> <b>\@joins)"</b>
       Adds the join statement indicated by $table and "\@joins" to the list of "JOIN" table references for  the
       statement. The structure for the set of joins are as described for the "joins" attribute member above.

   <b>"$sql-&gt;add_index_hint($table,</b> <b>$index)"</b>
       Specifies a particular index to use for a particular table.

   <b>"$sql-&gt;add_where($column,</b> <b>$value)"</b>
       Adds  a condition on the value of the database column $column to the statement's "WHERE" clause. A record
       will be tested against the below conditions according to what type of data structure $value is:

       •   a scalar

           The value of $column must equal $value.

       •   a reference to a scalar

           The value of $column must evaluate true against the SQL given in $$value.  For  example,  if  $$value
           were "IS NULL", $column must be "NULL" for a record to pass.

       •   a hashref

           The  value of $column must compare against the condition represented by $value, which can contain the
           members:

           •   "value"

               The value with which to compare (required).

           •   "op"

               The SQL operator with which to compare "value" and the value of $column (required).

           •   "column"

               The column name for the comparison. If this is present, it overrides  the  column  name  $column,
               allowing you to build more complex conditions like "((foo = 1 AND bar = 2) OR (baz = 3))".

           For  example,  if  "value" were "NULL" and "op" were "IS", a record's $column column would have to be
           "NULL" to match.

       •   an arrayref of scalars

           The value of $column may equal any of  the  members  of  @$value.  The  generated  SQL  performs  the
           comparison with as an "IN" expression.

       •   an arrayref of (mostly) references

           The  value of $column must compare against <u>any</u> of the expressions represented in @$value. Each member
           of the list can be any of the structures described here as possible forms of $value.

           If the first member of the @$value array is the scalar  string  "-and",  <u>all</u>  subsequent  members  of
           &lt;@$value&gt;  must be met for the record to match.  Note this is not very useful unless contained as one
           option of a larger "OR" alternation.

       All individual conditions specified with add_where() must be true for a record to  be  a  result  of  the
       query.

       Beware  that you can create a circular reference that will recursively generate an infinite SQL statement
       (for example, by specifying a arrayref $value that itself contains $value). As add_where() evaluates your
       expressions before storing the conditions in the "where" attribute as a generated SQL string,  this  will
       occur when calling add_where(), not as_sql(). So don't do that.

   <b>"$sql-&gt;add_complex_where(\@list)"</b>
       This  method  accepts  an array reference of clauses that are glued together with logical operators. With
       it, you can express where clauses that mix logical operators together to produce  more  complex  queries.
       For instance:

           [ { foo =&gt; 1, bar =&gt; 2 }, -or =&gt; { baz =&gt; 3 } ]

       The  values  given  for the columns support all the variants documented for the add_where() method above.
       Logical operators used  inbetween  the  hashref  elements  can  be  one  of:  '-or',  '-and',  '-or_not',
       '-and_not'.

   <b>"$sql-&gt;has_where($column,</b> <b>[$value])"</b>
       Returns  whether  a  where  clause for the column $column was added to the statement with the add_where()
       method.

       The $value argument is currently ignored.

   <b>"$sql-&gt;add_having($column,</b> <b>$value)"</b>
       Adds an expression to the "HAVING" portion of the statement's "GROUP ...  HAVING" clause. The  expression
       compares  $column  using  $value,  which can be any of the structures described above for the add_where()
       method.

   <b>"$sql-&gt;add_index_hint($table,</b> <b>\@hints)"</b>
       Addes the index hint into a "SELECT" query. The structure for  the  set  of  "\@hints"  are  arrayref  of
       hashrefs containing these members:

       •   "type" (scalar)

           The name of the type. "USE", "IGNORE or "FORCE".

       •   "list" (arrayref)

           The list of name of indexes which to use.

   <b>"$sql-&gt;as_sql()"</b>
       Returns the SQL fully representing the SQL statement $sql.

   <b>"$sql-&gt;as_sql_having()"</b>
       Returns the SQL representing the "HAVING" portion of $sql's "GROUP ...  HAVING" clause.

   <b>"$sql-&gt;as_sql_where()"</b>
       Returns the SQL representing $sql's "WHERE" clause.

   <b>"$sql-&gt;as_limit()"</b>
       Returns the SQL for the "LIMIT ... OFFSET" clause of the statement.

   <b>"$sql-&gt;as_aggregate($set)"</b>
       Returns  the  SQL representing the aggregation clause of type $set for the SQL statement $sql. Reasonable
       values of $set are "ORDER" and "GROUP".

</pre><h4><b>DIAGNOSTICS</b></h4><pre>
       •   "Invalid/unsafe column name <u>column</u>"

           The column name you specified to add_where() contained characters that are not  allowed  in  database
           column names. Only word characters and periods are allowed. Perhaps you didn't filter punctuation out
           of a generated column name correctly.

</pre><h4><b>BUGS</b> <b>AND</b> <b>LIMITATIONS</b></h4><pre>
       <u>Data::ObjectDriver::SQL</u>  does  not provide the functionality for turning SQL statements into instances of
       object classes.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
</pre><h4><b>LICENSE</b></h4><pre>
       <u>Data::ObjectDriver</u> is free software; you may redistribute it and/or modify it under  the  same  terms  as
       Perl itself.

</pre><h4><b>AUTHOR</b> <b>&amp;</b> <b>COPYRIGHT</b></h4><pre>
       Except where otherwise noted, <u>Data::ObjectDriver</u> is Copyright 2005-2006 Six Apart, <a href="mailto:cpan@sixapart.com">cpan@sixapart.com</a>. All
       rights reserved.

perl v5.40.1                                       2025-04-19                       <u>Data::ObjectDriver::<a href="../man3pm/SQL.3pm.html">SQL</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>