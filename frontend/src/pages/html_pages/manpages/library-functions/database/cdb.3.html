<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>cdb - Constant DataBase library</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcdb-dev">libcdb-dev_0.81-2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       cdb - Constant DataBase library

</pre><h4><b>SYNOPSYS</b></h4><pre>
        <b>#include</b> <b>&lt;cdb.h&gt;</b>
        <b>cc</b> <b>...</b> <b>-lcdb</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>cdb</b> is a library to create and access Constant DataBase files.  File stores (key,value) pairs and used to
       quickly  find a value based on a given key.  Cdb files are create-once files, that is, once created, file
       cannot be updated but recreated from scratch -- this is why database is called  <u>constant</u>.   Cdb  file  is
       optimized  for  quick  access.   Format  of  such  file  described  in  <u><a href="../man5/cdb.5.html">cdb</a></u>(5) manpage.  This manual page
       corresponds to version <b>0.81</b> of <b>tinycdb</b> package.

       Library defines two non-interlaced interfaces: for querying existing cdb file data (read-only  mode)  and
       for  creating such a file (almost write-only).  Strictly speaking, those modes allows very limited set of
       opposite operation as well (i.e. in query mode, it is possible to update key's value).

       All routines in this library are thread-safe as no global data used, except of <u>errno</u> variable  for  error
       indication.

       <b>cdb</b> datafiles may be moved between systems safely, since format does not depend on architecture.

</pre><h4><b>QUERY</b> <b>MODE</b></h4><pre>
       There  are  two  query modes available.  First uses a structure that represents a cdb database, just like
       <b>FILE</b> structure in stdio library, and another  works  with  plain  filedescriptor.   First  mode  is  more
       sophisticated and flexible, and usually somewhat faster.  It uses <b><a href="../man2/mmap.2.html">mmap</a></b>(2) internally.  This mode may look
       more "natural" or object-oriented compared to second one.

       The following routines works with any mode:

       unsigned <b>cdb_unpack</b>(<u>buf</u>)
          const unsigned char <u>buf</u>[4];
              helper  routine  to convert 32-bit integer from internal representation to machine format.  May be
              used to handle application integers in a portable way.  There is no error return.

   <b>Query</b> <b>Mode</b> <b>1</b>
       All query operations in first more deals with common data structure, <b>struct</b> <b>cdb</b>, associated with an  open
       file descriptor.  This structure is opaque to application.

       The following routines exists for accessing <b>cdb</b> database:

       int <b>cdb_init</b>(<u>cdbp</u>, <u>fd</u>)
          struct cdb *<u>cdbp</u>;
          int <u>fd</u>;
              initializes  structure  given  by  <u>cdbp</u>  pointer and associates it with opened file descriptor <u>fd</u>.
              Memory allocation for structure itself if needed  and  file  open  operation  should  be  done  by
              application.   File  <u>fd</u>  should  be  opened  at  least read-only, and should be seekable.  Routine
              returns 0 on success or negative value on error.

       void <b>cdb_free</b>(<u>cdbp</u>)
          struct cdb *<u>cdbp</u>;
              frees internal resources held by structure.  Note that this routine does <u>not</u> closes a file.

       int <b>cdb_fileno</b>(<u>cdbp</u>)
         const struct cdb *<u>cdbp</u>;
              returns filedescriptor associated with cdb (as was passed to <b>cdb_init</b>()).

       int <b>cdb_read</b>(<u>cdbp</u>, <u>buf</u>, <u>len</u>, <u>pos</u>)
       int <b>cdb_readdata</b>(<u>cdbp</u>, <u>buf</u>, <u>len</u>, <u>pos</u>)
       int <b>cdb_readkey</b>(<u>cdbp</u>, <u>buf</u>, <u>len</u>, <u>pos</u>)
          const struct cdb *<u>cdbp</u>;
          void *<u>buf</u>;
          unsigned <u>len</u>;
          unsigned <u>pos</u>;
              reads a data from cdb file, starting at position <u>pos</u> of length <u>len</u>, placing result to  <u>buf</u>.   This
              routine  may  be  used  to  get  actual  value  found by <b>cdb_find</b>() or other routines that returns
              position and length of a data.  Returns 0  on  success  or  negative  value  on  error.   Routines
              <b>cdb_readdata</b>()  and  <b>cdb_readkey</b>() are shorthands to read current (after e.g. <b>cdb_find</b>()) data and
              key respectively, using <b>cdb_read</b>().

       const void *<b>cdb_get</b>(<u>cdbp</u>, <u>len</u>, <u>pos</u>)
       const void *<b>cdb_getdata</b>(<u>cdbp</u>)
       const void *<b>cdb_getkey</b>(<u>cdbp</u>)
          const struct cdb *<u>cdbp</u>;
          unsigned <u>len</u>;
          unsigned <u>pos</u>;
              Internally, cdb library uses memory-mmaped region  to  access  the  on-disk  database.   <b>cdb_get</b>()
              allows  one to access internal memory in a way similar to <b>cdb_read</b>() but without extra copying and
              buffer allocation.  Returns pointer to actual data on success or NULL on error (position points to
              outside of the database).  Routines  <b>cdb_getdata</b>()  and  <b>cdb_getkey</b>()  are  shorthands  to  access
              current (after e.g. <b>cdb_find</b>()) data and key respectively, using <b>cdb_get</b>().

       int <b>cdb_find</b>(<u>cdbp</u>, <u>key</u>, <u>klen</u>)
       unsigned <b>cdb_datapos</b>(<u>cdbp</u>)
       unsigned <b>cdb_datalen</b>(<u>cdbp</u>)
       unsigned <b>cdb_keypos</b>(<u>cdbp</u>)
       unsigned <b>cdb_keylen</b>(<u>cdbp</u>)
          struct cdb *<u>cdbp</u>;
          const void *<u>key</u>;
          unsigned <u>klen</u>;
              attempts to find a key given by (<u>key</u>,<u>klen</u>) parameters.  If key exists in database, routine returns
              1  and places position and length of value associated with this key to internal fields inside <u>cdbp</u>
              structure, to be accessible by <b>cdb_datapos</b>(<u>cdbp</u>) and <b>cdb_datalen</b>(<u>cdbp</u>) routines.  If key is not in
              database, <b>cdb_find</b>() returns 0.  On error, negative value is returned.  Data  pointers  (available
              via  <b>cdb_datapos</b>()  and  <b>cdb_datalen</b>()) gets updated only in case of successful search.  Note that
              using <b>cdb_find</b>() it is possible to lookup only <u>first</u> record with a given key.

       int <b>cdb_findinit(</b><u>cdbfp</u>, <u>cdbp</u>, <u>key</u>, <u>klen</u>)
       int <b>cdb_findnext</b>(<u>cdbfp</u>)
         struct cdb_find *<u>cdbfp</u>;
         const struct cdb *<u>cdbp</u>;
         const void *<u>key</u>;
         unsigned <u>klen</u>;
              sequential-find routines that used separate structure.  It is  possible  to  have  more  than  one
              record  with  the  same  key  in  a database, and these routines allows one to enumerate all them.
              <b>cdb_findinit</b>() initializes search structure pointed to by <u>cdbfp</u>.  It will return negative value on
              error or non-negative value on success.  <b>cdb_findnext</b>() attempts to find next (first  when  called
              right  after  <b>cdb_findinit</b>())  matching key, setting value position and length in <u>cdbfp</u> structure.
              It will return positive value if given key was found, 0 if  there  is  no  more  such  key(s),  or
              negative  value  on  error.   To  access  value  position  and  length  after  successful  call to
              <b>cdb_findnext</b>() (when it returned positive result),  use  <b>cdb_datapos</b>(<u>cdbp</u>)  and  <b>cdb_datalen</b>(<u>cdbp</u>)
              routines.   It  is  error  to continue using <b>cdb_findnext</b>() after it returned 0 or error condition
              (<b>cdb_findinit</b>() should be called again).  Current data pointers (available via  <b>cdb_datapos</b>()  and
              <b>cdb_datalen</b>()) gets updated only on successful search.

       void <b>cdb_seqinit</b>(<u>cptr</u>, <u>cdbp</u>)
       int <b>cdb_seqnext</b>(<u>cptr</u>, <u>cdbp</u>)
         unsigned *<u>cptr</u>;
         struct cdb *<u>cdbp</u>;
              sequential  enumeration  of  all  records  stored  in  cdb file.  <b>cdb_seqinit</b>() initializes access
              current data pointer <u>cptr</u> to point before first record in a cdb file. <b>cdb_seqnext</b>()  updates  data
              pointers  in  <u>cdbp</u>  to  point  to  the  next  record and updates <u>cptr</u>, returning positive value on
              success, 0 on end of data condition and negative value on error.  Current record will be available
              after successful operation using  <b>cdb_datapos</b>(<u>cdbp</u>)  and  <b>cdb_datalen</b>(<u>cdbp</u>)  (for  the  data)  and
              <b>cdb_keypos</b>(<u>cdbp</u>)  and  <b>cdb_keylen</b>(<u>cdbp</u>)  (for  the key of the record).  Data pointers gets updated
              only in case of successful operation.

   <b>Query</b> <b>Mode</b> <b>2</b>
       In this mode, one need to open a <b>cdb</b> file using one of standard system calls (such as <b><a href="../man2/open.2.html">open</a></b>(2)) to  obtain
       a  filedescriptor,  and  then pass that filedescriptor to cdb routines.  Available methods to query a cdb
       database using only a filedescriptor include:

       int <b>cdb_seek</b>(<u>fd</u>, <u>key</u>, <u>klen</u>, <u>dlenp</u>)
         int <u>fd</u>;
         const void *<u>key</u>;
         unsigned <u>klen</u>;
         unsigned *<u>dlenp</u>;
              searches a cdb database (as pointed to by <u>fd</u> filedescriptor) for a key given by (<u>key</u>,  <u>klen</u>),  and
              positions  file  pointer  to  start  of  data associated with that key if found, so that next read
              operation from this filedescriptor will read that value, and places length of value, in bytes,  to
              variable  pointed  to  by <u>dlenp</u>.  Returns positive value if operation was successful, 0 if key was
              not found, or negative value on error.  To read the data from  a  cdb  file,  <b>cdb_bread</b>()  routine
              below can be used.

       int <b>cdb_bread</b>(<u>fd</u>, <u>buf</u>, <u>len</u>)
         int <u>fd</u>;
         void *<u>buf</u>;
         int <u>len</u>;
              reads data from a file (as pointed to by <u>fd</u> filedescriptor) and places <u>len</u> bytes from this file to
              a  buffer pointed to by <u>buf</u>.  Returns 0 if exactly <u>len</u> bytes was read, or a negative value in case
              of error or end-of-file.  This routine ignores interrupt errors (EINTR).  Sets errno  variable  to
              <b>EIO</b> in case of end-of-file condition (when there is less than <u>len</u> bytes available to read).

   <b>Notes</b>
       Note that <u>value</u> of any given key may be updated in place by another value of the same size, by writing to
       file  at  position  found by <b>cdb_find</b>() or <b>cdb_seek</b>().  However one should be very careful when doing so,
       since write operation may not succeed in case of e.g. power failure, thus leaving corrupted  data.   When
       database  is  (re)created,  one can guarantee that no incorrect data will be written to database, but not
       with inplace update.  Note also that it is not possible to update any key or to change length of value.

</pre><h4><b>CREATING</b> <b>MODE</b></h4><pre>
       <b>cdb</b> database file should usually be created in two steps: first, temporary file created  and  written  to
       disk,  and  second,  that  temporary  file  is renamed to permanent place.  Unix <a href="../man2/rename.2.html">rename</a>(2) call is atomic
       operation, it removes destination file if any AND renaes another file  in  one  step.   This  way  it  is
       guaranteed  that  readers  will  not  see incomplete database.  To prevent multiple simultaneous updates,
       locking may also be used.

       All routines used to create <b>cdb</b> database works with <b>struct</b> <b>cdb_make</b> object that is opaque to application.
       Application may assume that <b>struct</b> <b>cdb_make</b> has at least the same member(s) as published  in  <b>struct</b>  <b>cdb</b>
       above.

       int <b>cdb_make_start</b>(<u>cdbmp</u>, <u>fd</u>)
          struct cdb_make *<u>cdbmp</u>;
          int <u>fd</u>;
              initializes  structure  to  create  a database.  File <u>fd</u> should be opened read-write and should be
              seekable.  Returns 0 on success or negative value on error.

       int <b>cdb_make_add</b>(<u>cdbmp</u>, <u>key</u>, <u>klen</u>, <u>val</u>, <u>vlen</u>)
          struct cdb_make *<u>cdbmp</u>;
          const void *<u>key</u>, *<u>val</u>;
          unsigned <u>klen</u>, <u>vlen</u>;
              adds record with key (<u>key</u>,<u>klen</u>) and value (<u>val</u>,<u>vlen</u>) to a  database.   Returns  0  on  success  or
              negative  value on error.  Note that this routine does not checks if given key already exists, but
              <b>cdb_find</b>() will not see second record with the same key.  It is not possible to continue  building
              a database if <b>cdb_make_add</b>() returned error indicator.

       int <b>cdb_make_finish</b>(<u>cdbmp</u>)
          struct cdb_make *<u>cdbmp</u>;
              finalizes  database  file,  constructing all needed indexes, and frees memory structures.  It does
              <u>not</u> closes filedescriptor.  Returns 0 on success or negative value on error.

       int <b>cdb_make_exists</b>(<u>cdbmp</u>, <u>key</u>, <u>klen</u>)
          struct cdb_make *<u>cdbmp</u>;
          const void *<u>key</u>;
          unsigned <u>klen</u>;
              This routine attempts to find given by (<u>key</u>,<u>klen</u>) key in  a  not-yet-complete  database.   It  may
              significantly  slow  down  the  whole process, and currently it flushes internal buffer to disk on
              every call with key those hash value already exists in db.  Returns 0 if such key doesn't  exists,
              1  if it is, or negative value on error.  Note that database file should be opened read-write (not
              write-only) to use this routine.  If <b>cdb_make_exists</b>() returned error, it may be not  possible  to
              continue constructing database.

       int <b>cdb_make_find</b>(<u>cdbmp</u>, <u>key</u>, <u>klen</u>, <u>mode</u>)
          struct cdb_make *<u>cdbmp</u>;
          const void *<u>key</u>;
          unsigned <u>klen</u>;
          int <u>mode</u>;
              This routine attempts to find given by (<u>key</u>,<u>klen</u>) key in the database being created.  If the given
              key is already exists, it an action specified by <u>mode</u> will be performed:

              <b>CDB_FIND</b>
                     checks whenever the given record is already in the database.

              <b>CDB_FIND_REMOVE</b>
                     removes all matching records by re-writing the database file accordingly.

              <b>CDB_FIND_FILL0</b>
                     fills  all  matching  records with zeros and removes them from index so that the records in
                     question will not be findable with <b>cdb_find</b>().  This is faster  than  CDB_FIND_REMOVE,  but
                     leaves  zero  "gaps"  in  the  database.   Lastly  inserted records, if matched, are always
                     removed.

              If no matching keys was found,  routine  returns  0.   In  case  at  least  one  record  has  been
              found/removed,  positive  value  will  be returned.  On error, negative value will be returned and
              <b>errno</b> will be set appropriately.  When <b>cdb_make_find</b>() returned negative value in case  of  error,
              it is not possible to continue constructing the database.

              <b>cdb_make_exists</b>() is the same as calling <b>cdb_make_find</b>() with <u>mode</u> set to CDB_FIND.

       int <b>cdb_make_put</b>(<u>cdbmp</u>, <u>key</u>, <u>klen</u>, <u>val</u>, <u>vlen</u>, <u>mode</u>)
          struct cdb_make *<u>cdbmp</u>;
          const void *<u>key</u>, *<u>val</u>;
          unsigned <u>klen</u>, <u>vlen</u>;
          int <u>mode</u>;
              This is a somewhat combined <b>cdb_make_exists</b>() and <b>cdb_make_add</b>() routines.  <u>mode</u> argument controls
              how repeated (already existing) keys will be treated:

              <b>CDB_PUT_ADD</b>
                     no  duplicate  checking will be performed.  This mode is the same as <b>cdb_make_add</b>() routine
                     does.

              <b>CDB_PUT_REPLACE</b>
                     If the key already exists, it will be removed from the database before adding new key,value
                     pair.  This requires moving data in the file, and can be quite slow if the file  is  large.
                     All  matching  old  records  will  be  removed  this  way.   This  is  the  same as calling
                     <b>cdb_make_find</b>() with CDB_FIND_REMOVE <u>mode</u> argument followed by calling <b>cdb_make_add</b>().

              <b>CDB_PUT_REPLACE0</b>
                     If the key already exists and it isn't the last record in the  file,  old  record  will  be
                     zeroed  out  before  adding new key,value pair.  This is a lot faster than CDB_PUT_REPLACE,
                     but some extra data will still be present in the file.  The data -- old record -- will  not
                     be  accessible  by normal searches, but will appear in sequential database traversal.  This
                     is the same as calling  <b>cdb_make_find</b>()  with  CDB_FIND_FILL0  <u>mode</u>  argument  followed  by
                     <b>cdb_make_add</b>().

              <b>CDB_PUT_INSERT</b>
                     add  key,value  pair only if such key does not exists in a database.  Note that since query
                     (see query mode above) will find first added record, this mode  is  somewhat  useless  (but
                     allows  one to reduce database size in case of repeated keys).  This is the same as calling
                     <b>cdb_make_exists</b>(), followed by <b>cdb_make_add</b>() if the key was not found.

              <b>CDB_PUT_WARN</b>
                     add key,value pair unconditionally, but also check if this key  already  exists.   This  is
                     equivalent  of  <b>cdb_make_exists</b>()  to  check  existence  of  the given key, unconditionally
                     followed by <b>cdb_make_add</b>().

              If any error occurred during operations, the routine will return negative  integer  and  will  set
              global  variable  <b>errno</b>  to  indicate  reason  of failure.  In case of successful operation and no
              duplicates found, routine will return 0.  If any duplicates has been found or removed  (which,  in
              case  of  CDB_PUT_INSERT  mode,  indicates that the new record was not added), routine will return
              positive value.  If an error occurred and  <b>cdb_make_put</b>()  returned  negative  error,  it  is  not
              possible to continue database construction process.

              As with <b>cdb_make_exists</b>() and <b>cdb_make_find</b>(), usage of this routine with any but CDB_PUT_ADD mode
              can  significantly  slow  down  database  creation  process,  especially  when  <u>mode</u>  is  equal to
              CDB_PUT_REPLACE0.

       void <b>cdb_pack</b>(<u>num</u>, <u>buf</u>)
          unsigned <u>num</u>;
          unsigned char <u>buf</u>[4];
              helper routine that used internally to convert machine integer <u>n</u> to internal form to be stored  in
              datafile.   32-bit  integer  is  stored  in  4 bytes in network byte order.  May be used to handle
              application data.  There is no error return.

       unsigned <b>cdb_hash</b>(<u>buf</u>, <u>len</u>)
          const void *<u>buf</u>;
          unsigned <u>len</u>;
              helper routine that calculates cdb hash value of given bytes.  CDB hash function is
                hash[n] = (hash[n-1] + (hash[n-1] &lt;&lt; 5)) ^ buf[n]
              starting with
                hash[-1] = 5381

</pre><h4><b>ERRORS</b></h4><pre>
       <b>cdb</b> library may set <b>errno</b> to following on error:

       EPROTO database file is corrupted in some way

       EINVAL the same as EPROTO above if system lacks EPROTO constant

       EINVAL <u>flag</u> argument for <b>cdb_make_put</b>() is invalid

       EEXIST <u>flag</u> argument for <b>cdb_make_put</b>() is CDB_PUT_INSERT, and key already exists

       ENOMEM not enough memory to complete operation (<b>cdb_make_finish</b> and <b>cdb_make_add</b>)

       EIO    set by <b>cdb_bread</b> and <b>cdb_seek</b> if a cdb file is shorter than expected or corrupted  in  some  other
              way.

</pre><h4><b>EXAMPLES</b></h4><pre>
       Note: in all examples below, error checking is not shown for brewity.

   <b>Query</b> <b>Mode</b>
        int fd;
        struct cdb cdb;
        char *key, *data;
        unsigned keylen, datalen;

        /* opening the database */
        fd = open(filename, O_RDONLY);
        cdb_init(&amp;cdb, fd);
        /* initialize key and keylen here */

        /* single-record search. */
        if (cdb_find(&amp;cdb, key, keylen) &gt; 0) {
          datalen = cdb_datalen(&amp;cdb);
          data = malloc(datalen + 1);
          cdb_read(&amp;cdb, data, datalen, cdb_datapos(&amp;cdb));
          data[datalen] = '\0';
          printf("key=%s data=%s\n", key, data);
          free(data);
        }
        else
          printf("key=%s not found\n", key);

        /* multiple record search */
        struct cdb_find cdbf;
        int n;
        cdb_findinit(&amp;cdbf, &amp;cdb, key, keylen);
        n = 0;
        while(cdb_findnext(&amp;cdbf) &gt; 0) {
          datalen = cdb_datalen(&amp;cdb);
          data = malloc(datalen + 1);
          cdb_read(&amp;cdb, data, datalen, cdb_datapos(&amp;cdb));
          data[datalen] = '\0';
          printf("key=%s data=%s\n", key, data);
          free(data);
          ++n;
        }
        printf("key=%s %d records found\n", n);

        /* sequential database access */
        unsigned pos;
        int n;
        cdb_seqinit(&amp;pos, &amp;cdb);
        n = 0;
        while(cdb_seqnext(&amp;pos, &amp;cdb) &gt; 0) {
          keylen = cdb_keylen(&amp;cdb);
          key = malloc(keylen + 1);
          cdb_read(&amp;cdb, key, keylen, cdb_keypos(&amp;cdb));
          key[keylen] = '\0';
          datalen = cdb_datalen(&amp;cdb);
          data = malloc(datalen + 1);
          cdb_read(&amp;cdb, data, datalen, cdb_datapos(&amp;cdb));
          data[datalen] = '\0';
          ++n;
          printf("record %n: key=%s data=%s\n", n, key, data);
          free(data); free(key);
        }
        printf("total records found: %d\n", n);

        /* close the database */
        cdb_free(&amp;cdb);
        close(fd);

        /* simplistic query mode */
        fd = open(filename, O_RDONLY);
        if (cdb_seek(fd, key, keylen, &amp;datalen) &gt; 0) {
          data = malloc(datalen + 1);
          cdb_bread(fd, data, datalen);
          data[datalen] = '\0';
          printf("key=%s data=%s\n", key, data);
        }
        else
          printf("key=%s not found\n", key);
        close(fd);

   <b>Create</b> <b>Mode</b>
        int fd;
        struct cdb_make cdbm;
        char *key, *data;
        unsigned keylen, datalen;

        /* initialize the database */
        fd = open(filename, O_RDWR|O_CREAT|O_TRUNC, 0644);
        cdb_make_start(&amp;cdbm, fd);

        while(have_more_data()) {
          /* initialize key and data */
          if (cdb_make_exists(&amp;cdbm, key, keylen) == 0)
            cdb_make_add(&amp;cdbm, key, keylen, data, datalen);
          /* or use cdb_make_put() with appropriate flags */
        }

        /* finalize and close the database */
        cdb_make_finish(&amp;cdbm);
        close(fd);

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man5/cdb.5.html">cdb</a>(5), <a href="../man1/cdb.1.html">cdb</a>(1), <a href="../man3/dbm.3.html">dbm</a>(3), <a href="../man3/db.3.html">db</a>(3), <a href="../man2/open.2.html">open</a>(2).

</pre><h4><b>AUTHOR</b></h4><pre>
       The <b>tinycdb</b> package written by Michael Tokarev &lt;mjt+<a href="mailto:cdb@corpit.ru">cdb@corpit.ru</a>&gt;, based on ideas and shares file format
       with original cdb library by Dan Bernstein.

</pre><h4><b>LICENSE</b></h4><pre>
       Tinycdb is licensed under MIT license.

                                                    Jun 2006                                              <u><a href="../man3/cdb.3.html">cdb</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>