<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ustr_const - ustr string library constants</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/libustr-dev">libustr-dev_1.0.4-6_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ustr_const - ustr string library constants

</pre><h4><b>SYNOPSIS</b></h4><pre>
  #include "ustr.h"

  <b>USTR_CONF_INCLUDE_CODEONLY_HEADERS</b>
  <b>USTR_CONF_USE_EOS_MARK</b>
  <b>USTR_CONF_USE_ASSERT</b>
  <b>USTR_CONF_COMPILE_USE_ATTRIBUTES</b>
  <b>USTR_CONF_COMPILE_TYPEDEF</b>
  <b>USTR_CONF_COMPILE_USE_INLINE</b>

  <b>USTR_BEG_CONST1</b>
  <b>USTR_BEG_CONST2</b>
  <b>USTR_BEG_CONST4</b>
  <b>USTR_BEG_FIXED1</b>
  <b>USTR_BEG_FIXED2</b>
  <b>USTR_BEG_FIXED4</b>
  <b>USTR_BEG_FIXED8</b>
  <b>USTR_END_ALOCDx</b>
  <b>USTR_END_CONSTx</b>
  <b>USTR_END_FIXEDx</b>

  <b>USTR_FLAG_PARSE_NUM_DEF</b>
  <b>USTR_FLAG_PARSE_NUM_SEP</b>
  <b>USTR_FLAG_PARSE_NUM_OVERFLOW</b>
  <b>USTR_FLAG_PARSE_NUM_SPACE</b>
  <b>USTR_FLAG_PARSE_NUM_NO_BEG_ZERO</b>
  <b>USTR_FLAG_PARSE_NUM_NO_BEG_PM</b>
  <b>USTR_FLAG_PARSE_NUM_NO_NEGATIVE</b>
  <b>USTR_FLAG_PARSE_NUM_EXACT</b>
  <b>USTR_TYPE_PARSE_NUM_ERR_NONE</b>
  <b>USTR_TYPE_PARSE_NUM_ERR_ONLY_S</b>
  <b>USTR_TYPE_PARSE_NUM_ERR_ONLY_SPM</b>
  <b>USTR_TYPE_PARSE_NUM_ERR_ONLY_SPMX</b>
  <b>USTR_TYPE_PARSE_NUM_ERR_OOB</b>
  <b>USTR_TYPE_PARSE_NUM_ERR_OVERFLOW</b>
  <b>USTR_TYPE_PARSE_NUM_ERR_NEGATIVE</b>
  <b>USTR_TYPE_PARSE_NUM_ERR_BEG_ZERO</b>

  <b>USTR_FLAG_SPLIT_DEF</b>
  <b>USTR_FLAG_SPLIT_RET_SEP</b>
  <b>USTR_FLAG_SPLIT_RET_NON</b>
  <b>USTR_FLAG_SPLIT_KEEP_CONFIG</b>

  <b>USTR_NULL</b>
  <b>USTR_POOL_NULL</b>
  <b>USTR_TRUE</b>
  <b>USTR_FALSE</b>

  <b>USTR_CNTL_OPT_GET_REF_BYTES</b>
  <b>USTR_CNTL_OPT_SET_REF_BYTES</b>
  <b>USTR_CNTL_OPT_GET_HAS_SIZE</b>
  <b>USTR_CNTL_OPT_SET_HAS_SIZE</b>
  <b>USTR_CNTL_OPT_GET_EXACT_BYTES</b>
  <b>USTR_CNTL_OPT_SET_EXACT_BYTES</b>
  <b>USTR_CNTL_OPT_GET_MEM</b>
  <b>USTR_CNTL_OPT_SET_MEM</b>
  <b>USTR_CNTL_OPT_GET_MC_M_SCRUB</b>
  <b>USTR_CNTL_OPT_SET_MC_M_SCRUB</b>
  <b>USTR_CNTL_OPT_GET_MC_F_SCRUB</b>
  <b>USTR_CNTL_OPT_SET_MC_F_SCRUB</b>
  <b>USTR_CNTL_OPT_GET_MC_R_SCRUB</b>
  <b>USTR_CNTL_OPT_SET_MC_R_SCRUB</b>
  <b>USTR_CNTL_OPT_GET_FMT</b>
  <b>USTR_CNTL_OPT_SET_FMT</b>

  <b>USTR_POOL_LL_CNTL_GET_FREE_CMP</b>
  <b>USTR_POOL_LL_CNTL_SET_FREE_CMP</b>
  <b>USTR_POOL_LL_CNTL_GET_REALLOC</b>
  <b>USTR_POOL_LL_CNTL_SET_REALLOC</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
</pre><h4><b>Compile</b> <b>switch</b> <b>constants</b></h4><pre>
       <b>Constant:</b>  USTR_CONF_INCLUDE_CODEONLY_HEADERS

       <b>Explanation:</b>

         This switch controls whether all the code will be included as inline functions. Having this be non-zero
       means that you don't have to link against the library.

       <b>Constant:</b>  USTR_CONF_USE_EOS_MARK

       <b>Explanation:</b>

         This   switch   turns   on  End  of  String  markers,  so  any  bounds  overflow  will  be  noticed  by
       ustr_assert_valid().

       <b>Note:</b>

         Changing this will not do anything useful unless USTR_CONF_INCLUDE_CODEONLY_HEADERS is non-zero.

       <b>Constant:</b>  USTR_CONF_USE_ASSERT

       <b>Explanation:</b>

         This switch turns USTR_ASSERT() calls on, so the code within them will be evaluated.  Note  that  there
       are many calls to ustr_assert_valid() within USTR_ASSERT() macros and that call is relatively expensive.

       <b>Note:</b>

         Changing this will not do anything useful unless USTR_CONF_INCLUDE_CODEONLY_HEADERS is non-zero.

       <b>Constant:</b>  USTR_CONF_COMPILE_USE_ATTRIBUTES

       <b>Explanation:</b>

         This switch controls whether gcc type __attribute__() statements are used in the public headers headers
       for the library. If the value is 1 then if they are supported by the compiler that built the library they
       will be used, if the value is 0 they won't be used at all.

       <b>Constant:</b>  USTR_CONF_COMPILE_TYPEDEF

       <b>Explanation:</b>

         This  switch  controls  whether  typedef  will  be  used  for the structs in the public headers for the
       library. If the value is 1 then they will be used, if the value is 0 they won't be used at all (and  your
       code  will  have  to use struct tags instead -- note all libraries using ustr should compile without this
       option set).
       <b>Constant:</b>  USTR_CONF_COMPILE_USE_INLINE

       <b>Explanation:</b>

         This switch controls whether inline functions will be used in a few cases where the function bodies are
       very small.

       <b>Note:</b>

         In some cases this is used so that GCC can eliminate calls to strlen(), for the *_cstr() functions.

</pre><h4><b>Constants</b> <b>to</b> <b>created</b> <b>fixed/read-only</b> <b>Ustr's</b></h4><pre>
       <b>Constant:</b>  USTR_BEG_CONST1

       <b>Explanation:</b>

         This macro is a constant C-style string of the first byte of  a  constant/read-only  Ustr  that  has  a
       length in the range 0-255.

       <b>Constant:</b>  USTR_BEG_CONST2

       <b>Explanation:</b>

         This  macro  is  a  constant  C-style  string of the first byte of a constant/read-only Ustr that has a
       length in the range 0-65535.

       <b>Constant:</b>  USTR_BEG_CONST4

       <b>Explanation:</b>

         This macro is a constant C-style string of the first byte of  a  constant/read-only  Ustr  that  has  a
       length in the range 0-4294967295.

       <b>Constant:</b>  USTR_BEG_FIXED1

       <b>Explanation:</b>

         This  macro  is  a  constant  C-style string of the first byte of a fixed Ustr that has a length in the
       range 0-255.

       <b>Constant:</b>  USTR_BEG_FIXED2

       <b>Explanation:</b>

         This macro is a constant C-style string of the first byte of a fixed Ustr that  has  a  length  in  the
       range 0-65535.

       <b>Constant:</b>  USTR_BEG_FIXED4

       <b>Explanation:</b>

         This  macro  is  a  constant  C-style string of the first byte of a fixed Ustr that has a length in the
       range 0-4294967295.

       <b>Constant:</b>  USTR_BEG_FIXED8

       <b>Explanation:</b>

         This macro is a constant C-style string of the first byte of a fixed Ustr that  has  a  length  in  the
       range 0-18446744073709551615.

       <b>Note:</b>

         This macro is only available if the Ustr code was compiled in a 64bit environment.

       <b>Constant:</b>  USTR_END_ALOCDx

       <b>Explanation:</b>

         This macro is a constant C-style string of the last bytes of an allocated Ustr.

       <b>Note:</b>

         Unless USTR_CONF_USE_EOS_MARK is non-zero, this is just the NIL byte.

       <b>Constant:</b>  USTR_END_CONSTx

       <b>Explanation:</b>

         This macro is a constant C-style string of the last bytes of a constant/read-only Ustr.

       <b>Note:</b>

         Unless USTR_CONF_USE_EOS_MARK is non-zero, this is just the NIL byte.

       <b>Constant:</b>  USTR_END_FIXEDx

       <b>Explanation:</b>

         This macro is a constant C-style string of the last bytes of a fixed Ustr.

       <b>Note:</b>

         Unless USTR_CONF_USE_EOS_MARK is non-zero, this is just the NIL byte.

</pre><h4><b>Constants</b> <b>to</b> <b>use</b> <b>with</b> <b>parsing</b> <b>numbers:</b> <b>ustr_parse_uintmaxx,</b> <b>etc.</b></h4><pre>
       <b>Constant:</b>  USTR_FLAG_PARSE_NUM_DEF

       <b>Explanation:</b>

         Default flags, this is merely 0 but can be used as live documentation.

       <b>Constant:</b>  USTR_FLAG_PARSE_NUM_SEP

       <b>Explanation:</b>

         This  flag  allows  the parsing (and ignoring) of the separator character, at arbitrary pointers in the
       number, so "1234" and "1_234" would both parse the same (assuming "_" is the separator).

       <b>Constant:</b>  USTR_FLAG_PARSE_NUM_OVERFLOW

       <b>Explanation:</b>

         This flag turns on the overflow checking, in other words  without  it  USTR_TYPE_PARSE_NUM_ERR_OVERFLOW
       will never be returned as an error code.

       <b>Constant:</b>  USTR_FLAG_PARSE_NUM_SPACE

       <b>Explanation:</b>

         This  flag  allows  one  or  more ' ' (Space) characters before the number or number prefix (Plus Sign,
       Hyphen).

       <b>Note:</b>

         Other forms of whitespace don't count, this just affects ' '.

       <b>Constant:</b>  USTR_FLAG_PARSE_NUM_NO_BEG_ZERO

       <b>Explanation:</b>

         This flag disallows one or more '0' (Digit Zero) characters before the number.

       <b>Constant:</b>  USTR_FLAG_PARSE_NUM_NO_BEG_PM

       <b>Explanation:</b>

         This flag disallows a plus or a minus character before the number.

       <b>Constant:</b>  USTR_FLAG_PARSE_NUM_NO_NEGATIVE

       <b>Explanation:</b>

         This flag disallows negative values.

       <b>Constant:</b>  USTR_FLAG_PARSE_NUM_EXACT

       <b>Explanation:</b>

         This flag makes the parsing functions return an error if the entire string doesn't contain  the  number
       being parsed.

       <b>Constant:</b>  USTR_TYPE_PARSE_NUM_ERR_NONE

       <b>Explanation:</b>

         This error code has the value 0, and means that no error occurred parsing the number.

       <b>Constant:</b>  USTR_TYPE_PARSE_NUM_ERR_ONLY_S

       <b>Explanation:</b>

         This error code means that the Ustr string consisted only of spaces.

       <b>Constant:</b>  USTR_TYPE_PARSE_NUM_ERR_ONLY_SPM

       <b>Explanation:</b>

         This error code means that the Ustr string consisted only spaces, and a plus or minus sign.

       <b>Constant:</b>  USTR_TYPE_PARSE_NUM_ERR_ONLY_SPMX

       <b>Explanation:</b>

         This  error  code  means that the Ustr string consisted of only spaces, a plus or minus sign and a "0x"
       base 16 prefix.
       <b>Constant:</b>  USTR_TYPE_PARSE_NUM_ERR_OOB

       <b>Explanation:</b>

         This error code means that the Ustr string had characters in it that  where  out  of  bounds  from  the
       working base.

       <b>Note:</b>

         Without the USTR_FLAG_PARSE_NUM_EXACT, this error is ignored as soon as any number is parsed.
         This out of bounds includes the Ustr string "++" as well as "4A", when parsing in a base less than 11.

       <b>Constant:</b>  USTR_TYPE_PARSE_NUM_ERR_OVERFLOW

       <b>Explanation:</b>

         This  error  code means that the number parsed from the Ustr string would overflow the type it is being
       parsed into, this is only returned when the USTR_FLAG_PARSE_NUM_OVERFLOW flag was  passed  to  the  parse
       function.

       <b>Constant:</b>  USTR_TYPE_PARSE_NUM_ERR_NEGATIVE

       <b>Explanation:</b>

         This  error code means that the number parsed from the Vstr string starts with a '-' (Hyphen) character
       when it is supposed to be an unsigned number.

       <b>Constant:</b>  USTR_TYPE_PARSE_NUM_ERR_BEG_ZERO

       <b>Explanation:</b>

         This error code means that the number parsed from the Vstr  string  starts  with  a  '0'  (Digit  Zero)
       character, when the USTR_FLAG_PARSE_NUM_NO_BEG_ZERO flag was passed to the parse function.

</pre><h4><b>Constants</b> <b>to</b> <b>pass</b> <b>to</b> <b>ustr_split*</b></h4><pre>
       <b>Constant:</b>  USTR_FLAG_SPLIT_DEF

       <b>Explanation:</b>

         Default flags, this is merely 0 but can be used as live documentation.

       <b>Constant:</b>  USTR_FLAG_SPLIT_RET_SEP

       <b>Explanation:</b>

         Return  the  separator  along  with  the  tokens. For example splitting "a,b," using separator "," will
       return the tokens "a," and "b," whereas without this flag only "a" and "b" would be returned.
           .br <b>Constant:</b>  USTR_FLAG_SPLIT_RET_NON

       <b>Explanation:</b>

         Return empty tokens. For example: splitting "a,,b" with separator "," will return the  tokens  {"a"  ""
       "b"}.
       <b>Constant:</b>  USTR_FLAG_SPLIT_KEEP_CONFIG

       <b>Explanation:</b>

         Force the returned Ustr's to have same configuration parameters as the Ustr string that is being split.

</pre><h4><b>Misc</b> <b>constants</b> <b>to</b> <b>use</b> <b>in</b> <b>code</b></h4><pre>
       <b>Constant:</b>  USTR_NULL

       <b>Explanation:</b>

         This  macro  is  merely 0 cast to (struct Ustr *), and can be used anywhere NULL would be but "returns"
       the correct type.

       <b>Constant:</b>  USTR_POOL_NULL

       <b>Explanation:</b>

         This macro is merely 0 cast to (struct Ustr_pool *), and  can  be  used  anywhere  NULL  would  be  but
       "returns" the correct type.

       <b>Constant:</b>  USTR_TRUE

       <b>Explanation:</b>

         This macro is 1, but shows the intent that a boolean value is expected and not a number.

       <b>Constant:</b>  USTR_FALSE

       <b>Explanation:</b>

         This macro is 0, but shows the intent that a boolean value is expected and not a number.

</pre><h4><b>Constants</b> <b>passed</b> <b>to</b> <b>ustr_cntl_opt()</b></h4><pre>
       <b>Constant:</b>  USTR_CNTL_OPT_GET_REF_BYTES

       Parameter<b>[1]</b>: Number of bytes for default reference count in Ustr
       Type<b>[1]</b>: size_t *

       <b>Explanation:</b>

         This option will get the default number of bytes used for a reference count when creating Ustr's.

       <b>Constant:</b>  USTR_CNTL_OPT_SET_REF_BYTES

       Parameter<b>[1]</b>: Number of bytes for default reference count in Ustr
       Type<b>[1]</b>: size_t

       <b>Explanation:</b>

         This option will set the default number of bytes used for a reference count when creating Ustr's.

       <b>Note:</b>

         For a single instance, the ustr_dupx_*() functions can be used.

       <b>Constant:</b>  USTR_CNTL_OPT_GET_HAS_SIZE

       Parameter<b>[1]</b>: Default flag for whether to include an explicit size in a Ustr
       Type<b>[1]</b>: int *

       <b>Explanation:</b>

         This option will get the default flag for whether to store an explicit size in created Ustr's.

       <b>Constant:</b>  USTR_CNTL_OPT_SET_HAS_SIZE

       Parameter<b>[1]</b>: Default flag for whether to include an explicit size in a Ustr
       Type<b>[1]</b>: int

       <b>Explanation:</b>

         This option will set the default flag for whether to store an explicit size in created Ustr's.

       <b>Note:</b>

         For a single instance, the ustr_dupx_*() functions can be used.

       <b>Constant:</b>  USTR_CNTL_OPT_GET_EXACT_BYTES

       Parameter<b>[1]</b>: Default flag for whether to exactly allocate memory
       Type<b>[1]</b>: int *

       <b>Explanation:</b>

         This  option  will  get the default flag for whether to exactly allocate memory when a Ustr needs to be
       resized.

       <b>Constant:</b>  USTR_CNTL_OPT_SET_EXACT_BYTES

       Parameter<b>[1]</b>: Default flag for whether to exactly allocate memory
       Type<b>[1]</b>: int

       <b>Explanation:</b>

         This option will set the default flag for whether to exactly allocate memory when a Ustr  needs  to  be
       resized.

       <b>Note:</b>

         For a single instance, the ustr_dupx_*() functions can be used.

       <b>Constant:</b>  USTR_CNTL_OPT_GET_MEM
       Parameter<b>[1]</b>: Pointer to colleciton of function pointers for system allocation
       Type<b>[1]</b>: struct Ustr_cntl_mem *

       <b>Explanation:</b>

         This option will get the "system" allocation functions (malloc, realloc, free) for allocated Ustr's.

       <b>Note:</b>

         As you would expect the default values are: malloc, realloc, free.

       <b>Constant:</b>  USTR_CNTL_OPT_SET_MEM
       Parameter<b>[1]</b>: Pointer to colleciton of function pointers for system allocation
       Type<b>[1]</b>: const struct Ustr_cntl_mem *

       <b>Explanation:</b>

         This option will set the "system" allocation functions (malloc, realloc, free) for allocated Ustr's.

       <b>Note:</b>

         If  this  option  is  set after a Ustr has been created, then when freeing or reallocating the existing
       Ustr the given functions will be used. So they must either be compatible with the  default  or  you  must
       ensure that nothing is allocated before they are set.

       <b>Constant:</b>  USTR_CNTL_OPT_GET_MC_M_SCRUB

       Parameter<b>[1]</b>: Flag for whether to include an explicit size in a Ustr
       Type<b>[1]</b>: int *

       <b>Explanation:</b>

         This option will get the flag for whether to "scrub" data allocated via. malloc check.

       <b>Note:</b>

         Malloc check has to be enabled for this to mean anything, Ie. USTR_CNTL_MALLOC_LVL() must be positive.

       <b>Constant:</b>  USTR_CNTL_OPT_SET_MC_M_SCRUB

       Parameter<b>[1]</b>: Flag for whether to include an explicit size in a Ustr
       Type<b>[1]</b>: int

       <b>Explanation:</b>

         This option will set the flag for whether to "scrub" data allocated via. malloc check.

       <b>Note:</b>

         Malloc check has to be enabled for this to mean anything, Ie. USTR_CNTL_MALLOC_LVL() must be positive.

       <b>Constant:</b>  USTR_CNTL_OPT_GET_MC_F_SCRUB

       Parameter<b>[1]</b>: Flag for whether to include an explicit size in a Ustr
       Type<b>[1]</b>: int *

       <b>Explanation:</b>

         This option will get the flag for whether to "scrub" data freed via. malloc check.

       <b>Note:</b>

         Malloc check has to be enabled for this to mean anything, Ie. USTR_CNTL_MALLOC_LVL() must be positive.

       <b>Constant:</b>  USTR_CNTL_OPT_SET_MC_F_SCRUB

       Parameter<b>[1]</b>: Flag for whether to include an explicit size in a Ustr
       Type<b>[1]</b>: int

       <b>Explanation:</b>

         This option will set the flag for whether to "scrub" data freed via. malloc check.

       <b>Note:</b>

         Malloc check has to be enabled for this to mean anything, Ie. USTR_CNTL_MALLOC_LVL() must be positive.

       <b>Constant:</b>  USTR_CNTL_OPT_GET_MC_R_SCRUB

       Parameter<b>[1]</b>: Flag for whether to include an explicit size in a Ustr
       Type<b>[1]</b>: int *

       <b>Explanation:</b>

         This  option  will get the flag for whether to "scrub" data reallocated via. malloc check. This is done
       by turning all reallocations into a malloc()  and  free(),  and  so  is  even  more  costly  than  normal
       scrubbing.

       <b>Note:</b>

         Malloc check has to be enabled for this to mean anything, Ie. USTR_CNTL_MALLOC_LVL() must be positive.

       <b>Constant:</b>  USTR_CNTL_OPT_SET_MC_R_SCRUB

       Parameter<b>[1]</b>: Flag for whether to include an explicit size in a Ustr
       Type<b>[1]</b>: int

       <b>Explanation:</b>

         This  option  will set the flag for whether to "scrub" data reallocated via. malloc check. This is done
       by turning all reallocations into a malloc()  and  free(),  and  so  is  even  more  costly  than  normal
       scrubbing.

       <b>Note:</b>

         Malloc check has to be enabled for this to mean anything, Ie. USTR_CNTL_MALLOC_LVL() must be positive.

       <b>Constant:</b>  USTR_CNTL_OPT_GET_FMT
       Parameter<b>[1]</b>: Pointer to colleciton of function pointers for system formatting
       Type<b>[1]</b>: struct Ustr_cntl_fmt *

       <b>Explanation:</b>

         This option will get the system formatting functions (vsnprintf) for Ustr's.
         There  are  two  functions, the first is always called and the second is likely called (always with the
       exact same arguments) if the length passed to the first call was not big enough.

       <b>Note:</b>

         As you would expect the default values are: vsnprintf and vsnprintf

       <b>Constant:</b>  USTR_CNTL_OPT_SET_FMT
       Parameter<b>[1]</b>: Pointer to colleciton of function pointers for system formatting
       Type<b>[1]</b>: const struct Ustr_cntl_fmt *

       <b>Explanation:</b>

         This option will set the system formatting functions (vsnprintf) for Ustr's.

</pre><h4><b>Constants</b> <b>passed</b> <b>to</b> <b>ustr_pool_ll_cntl()</b></h4><pre>
       <b>Constant:</b>  USTR_POOL_LL_CNTL_GET_FREE_CMP

       Parameter<b>[1]</b>: Number of pointers to compare to in the pool
       Type<b>[1]</b>: unsigned int *

       <b>Explanation:</b>

         This option will get the number of comparisons done on a pool free operation.

       <b>Constant:</b>  USTR_POOL_LL_CNTL_SET_FREE_CMP

       Parameter<b>[1]</b>: Number of pointers to compare to in the pool
       Type<b>[1]</b>: unsigned int

       <b>Explanation:</b>

         This option will set the number of comparisons done on a pool free operation.

       <b>Note:</b>

         The default is a small non-zero value, as it's significantly common to have very short lived ustr's ...
       however this doesn't mean that you can't forget to take references even with pool allocated ustrs.

       <b>Constant:</b>  USTR_POOL_LL_CNTL_GET_REALLOC

       Parameter<b>[1]</b>: Flag for if we should call realloc()
       Type<b>[1]</b>: int *

       <b>Explanation:</b>

         This option will get the flag for if we  call  realloc()  to  make  data  bigger,  or  revert  to  just
       allocating anew each time.

       <b>Constant:</b>  USTR_POOL_LL_CNTL_SET_REALLOC

       Parameter<b>[1]</b>: Flag for if we should call realloc()
       Type<b>[1]</b>: int

       <b>Explanation:</b>

         This  option  will  set  the  flag  for  if  we  call  realloc() to make data bigger, or revert to just
       allocating anew each time.

       <b>Note:</b>

         As with USTR_POOL_LL_CNTL_SET_FREE_CMP this option means you can't assume that pool allocated  data  is
       never  freed  until  ustr_pool_free()  is  called,  and  again it is due to there being significant speed
       improvements for not making that assumption. Instead of  disabling  this  option,  just  take  areference
       (which will also make sure the ustr isn't modified behind your back).

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/ustr.3.html">ustr</a></b>(3)

Ustr 1.0.4                                         05-Mar-2008                                     <u><a href="../man3/ustr_const.3.html">ustr_const</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>