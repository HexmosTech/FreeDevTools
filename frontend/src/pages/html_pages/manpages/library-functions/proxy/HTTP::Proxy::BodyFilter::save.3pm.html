<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTTP::Proxy::BodyFilter::save - A filter that saves transferred data to a file</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libhttp-proxy-perl">libhttp-proxy-perl_0.304-5build1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       HTTP::Proxy::BodyFilter::save - A filter that saves transferred data to a file

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use HTTP::Proxy;
           use HTTP::Proxy::BodyFilter::save;

           my $proxy = HTTP::Proxy-&gt;new;

           # save RFC files as we browse them
           $proxy-&gt;push_filter(
               path     =&gt; qr!/rfc\d+.txt!,
               mime     =&gt; 'text/plain',
               response =&gt; HTTP::Proxy::BodyFilter::save-&gt;new(
                   template =&gt; '%f',
                   prefix   =&gt; 'rfc',
                   keep_old =&gt; 1,
               )
           );

           $proxy-&gt;start;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The HTTP::Proxy::BodyFilter::save filter can save HTTP messages (responses or request) bodies to files.
       The name of the file is determined by a template and the URI of the request.

       Simply insert this filter in a filter stack, and it will save the data as it flows through the proxy.
       Depending on where the filter is located in the stack, the saved data can be more or less modified.

       This filter <u>will</u> create directories if it needs to!

       <u>Note:</u> Remember that the default "mime" parameter for push_filter() is "text/*" and that you may need to
       change it for other MIME types.

   <b>Constructor</b>
       The constructor accepts quite a few options. Most of them control the construction of the filename that
       will be used to save the response body. There are two options to compute this filename:

       •   use a template

       •   use your own filename creation routine

       The template option uses the following options:

       <b>template</b> =&gt; <u>string</u>
           The file name is build from the "template" option. The following placeholders are available:

               %%   a percent sign
               %h   the host
               %p   the path (no leading separator)
               %d   the path (filename removed)
               %f   the filename (or 'index.html' if absent)
               %q   the query string
               %P   the path and the query string,
                    separated by '?' (if the query string is not empty)

           "/" in the URI path are replaced by the separator used by File::Spec.

           The result of the template is modified by the <b>no_host</b>, <b>no_dirs</b> and <b>cut_dirs</b>.

           The default template is the local equivalent of the "%h/%P" Unix path.

       <b>no_host</b> =&gt; <u>boolean</u>
           The "no_host" option makes %h empty. Default is <u>false</u>.

       <b>no_dirs</b> =&gt; <u>boolean</u>
           The "no_dirs" option removes all directories from %p, %P and %d.  Default is <u>false</u>.

       <b>cut_dirs</b> =&gt; <u>number</u>
           The  "cut_dirs" options removes the first <u>n</u> directories from the content of %p, %P and %d. Default is
           0.

       <b>prefix</b> =&gt; <u>string</u>
           The <b>prefix</b> option prepends the given prefix to the filename created from the template. Default is "".

       Using your own subroutine is also possible, with the following parameter:

       <b>filename</b> =&gt; <u>coderef</u>
           When the "filename" option is used, the "template" option  and  the  other  template-related  options
           ("no_host", "no_dirs", "cut_dirs" and "prefix") are ignored.

           The  "filename"  option  expects  a  reference  to  a  subroutine.  The  subroutine  will receive the
           HTTP::Message object and must return a string which is the  path  of  the  file  to  be  created  (an
           absolute path is recommended, but a relative path is accepted).

           Returning  ""  or "undef" will prevent the creation of the file.  This lets a filter decide even more
           precisely what to save or not, even  though  this  should  be  done  in  the  match  subroutine  (see
           HTTP::Proxy's push_filter() method).

       Other options help the filter decide where and when to save:

       <b>multiple</b> =&gt; <u>boolean</u>
           With the <b>multiple</b> option, saving the same file in the same directory will result in the original copy
           of  file  being  preserved  and the second copy being named <u>file.1</u>. If that a file is saved yet again
           with the same name, the third copy will be named <u>file.2</u>, and so on.

           Default is <u>true</u>.

           If <b>multiple</b> is set to <u>false</u> then a file will be overwritten by the next one with the same name.

       <b>timestamp</b> =&gt; <u>boolean</u>
           With the "timestamp" option, the decision as to whether or not to save a newer copy of a file depends
           on the local and remote timestamp and size of the file.

           The file is saved only if the date given in the "Last-Modified" is more recent than the local  file's
           timestamp.

           Default is <u>false</u>.

           <b>This</b> <b>option</b> <b>is</b> <b>not</b> <b>implemented.</b>

       <b>keep_old</b> =&gt; <u>boolean</u>
           The  "keep_old" option will prevent the file to be saved if a file with the same name already exists.
           Default is <u>false</u>.

           No matter if <b>multiple</b> is set or not, the file will <u>not</u> be saved if <b>keep_old</b> is set to true.

       <b>status</b> =&gt; \@codes
           The "status" option limits the status codes for which a response body will be saved. The  default  is
           "[ 200 ]", which prevent saving error pages (for 404 codes).

   <b>Examples</b>
       Given  a  request  for  the  &lt;<a href="http://search.cpan.org/dist/HTTP-Proxy/">http://search.cpan.org/dist/HTTP-Proxy/</a>&gt;  URI,  the filename is computed as
       follows, depending on the constructor options:

           No options          -&gt; search.cpan.org/dist/HTTP-Proxy/index.html

           no_host  =&gt; 1       -&gt; dist/HTTP-Proxy/index.html

           no_dirs  =&gt; 1       -&gt; search.cpan.org/index.html

           no_host  =&gt; 1,
           no_dirs  =&gt; 1,
           prefix   =&gt; 'data'  -&gt; data/index.html

           cut_dirs =&gt; 1       -&gt; search.cpan.org/HTTP-Proxy/index.html

           cut_dirs =&gt; 2       -&gt; search.cpan.org/index.html

</pre><h4><b>METHODS</b></h4><pre>
       This filter implements several methods, which are all called automatically:

       <b>init()</b>
           Handle all the parameters passed to the constructor to define the filter behaviour.

       <b>begin()</b>
           Open the file to which the data will be saved.

       <b>filter()</b>
           Save all the data that goes through to the opened file.

       <b>end()</b>
           Close the file when the whole message body has been processed.

       <b>will_modify()</b>
           This method returns a <u>false</u> value, thus indicating to the system that it will not modify data passing
           through.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       HTTP::Proxy, HTTP::Proxy::BodyFilter.

</pre><h4><b>AUTHOR</b></h4><pre>
       Philippe "BooK" Bruhat, &lt;<a href="mailto:book@cpan.org">book@cpan.org</a>&gt;.

</pre><h4><b>ACKNOWLEDGMENTS</b></h4><pre>
       Thanks to Mat Proud for asking how to store all pages which go through the proxy  to  disk,  without  any
       processing. The further discussion we had led to the writing of this class.

       <b><a href="../man1/Wget.1.html">Wget</a></b>(1) provided the inspiration for many of the file naming options.

       Thanks to Nicolas Chuche for telling me about "O_EXCL".

       Thanks  to Rafaël Garcia-Suarez and David Rigaudiere for their help on irc while coding the nasty begin()
       method. ";-)"

       Thanks to Howard Jones for the inspiration and initial patch  for  the  "filename"  option.  Lucas  Gonze
       provided a patch to make "status" actually work.

       Thanks   to   Max   Maischein   for   detecting   a  bug  in  the  parameter  validation  for  "filename"
       (&lt;<a href="http://rt.cpan.org/Ticket/Display.html">http://rt.cpan.org/Ticket/Display.html</a>?id=14548&gt;).

       Thanks to Mark Tilford, who found  out  that  the  "filename"  option  was  incorrectly  used  internally
       (&lt;<a href="http://rt.cpan.org/Ticket/Display.html">http://rt.cpan.org/Ticket/Display.html</a>?id=18644&gt;).

       Thanks  to  Roland  Stigge  and  Gunnar  Wolf  for reporting and forwarding Debian bug #433951 to CPAN RT
       (&lt;<a href="http://bugs.debian.org/cgi-bin/bugreport.cgi">http://bugs.debian.org/cgi-bin/bugreport.cgi</a>?bug=433951&gt;,
       &lt;<a href="http://rt.cpan.org/Ticket/Display.html">http://rt.cpan.org/Ticket/Display.html</a>?id=33018&gt;).

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2004-2015, Philippe Bruhat.

</pre><h4><b>LICENSE</b></h4><pre>
       This module is free software; you can redistribute it or modify it under the same terms as Perl itself.

perl v5.40.1                                       2025-02-18                 <u>HTTP::Proxy::BodyFilter::<a href="../man3pm/save.3pm.html">save</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>