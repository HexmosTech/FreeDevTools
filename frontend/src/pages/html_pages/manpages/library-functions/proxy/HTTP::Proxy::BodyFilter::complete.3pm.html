<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTTP::Proxy::BodyFilter::complete - A filter that passes on a complete body or nothing</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libhttp-proxy-perl">libhttp-proxy-perl_0.304-5build1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       HTTP::Proxy::BodyFilter::complete - A filter that passes on a complete body or nothing

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use HTTP::Proxy;
           use HTTP::Proxy::BodyFilter::simple;
           use HTTP::Proxy::BodyFilter::complete;

           my $proxy = HTTP::Proxy-&gt;new;

           # pass the complete response body to our filter (in one pass)
           $proxy-&gt;push_filter(
               mime =&gt; 'text/html',
               response =&gt; HTTP::Proxy::BodyFilter::complete-&gt;new,
               response =&gt; HTTP::Proxy::BodyFilter::simple-&gt;new(
                   sub {
                       my ( $self, $dataref, $message, $protocol, $buffer ) = @_;
                       # some complex processing that needs
                       # the whole response body
                   }
               );
           );

           $proxy-&gt;start;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The HTTP::Proxy::BodyFilter::complete filter will ensure that the next filter in the filter chain will
       only receive complete message bodies (either request or response).

       It will store the chunks of data as they arrive, only to pass the <b>entire</b> message body after the whole
       message has been received by the proxy.

       Subsequent filters is the chain will receive the whole body as a big piece of data.

</pre><h4><b>CAVEAT</b> <b>EMPTOR</b></h4><pre>
       This consumes memory and time.

       Use with caution, otherwise your client will timeout, or your proxy will run out of memory.

       Also note that all filters after "complete" are still called when the proxy receives data: they just
       receive empty data. They will receive the complete data when the filter chain is called for the very last
       time (the $buffer parameter is "undef"). (See the documentation of HTTP::Proxy::BodyFilter for details
       about the $buffer parameter.)

</pre><h4><b>METHOD</b></h4><pre>
       This filter defines two methods, called automatically:

       <b>filter()</b>
           Stores  the  incoming  data  in  memory until the last moment and passes empty data to the subsequent
           filters in the chain. They will receive the full body during the last round of filter calls.

       <b>will_modify()</b>
           This method returns a <u>false</u> value, thus indicating to the system that it will not modify data passing
           through.

</pre><h4><b>AUTHOR</b></h4><pre>
       Philippe "BooK" Bruhat, &lt;<a href="mailto:book@cpan.org">book@cpan.org</a>&gt;.

</pre><h4><b>THANKS</b></h4><pre>
       Thanks to Simon Cozens and Merijn H. Brandt, who needed this almost at the same time. ";-)"

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2004-2015, Philippe Bruhat.

</pre><h4><b>LICENSE</b></h4><pre>
       This module is free software; you can redistribute it or modify it under the same terms as Perl itself.

perl v5.40.1                                       2025-02-18             <u>HTTP::Proxy::BodyFilter::<a href="../man3pm/complete.3pm.html">complete</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>