<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>zproxy - Class for run a steerable proxy in the background</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libczmq-dev">libczmq-dev_4.2.1-3_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       zproxy - Class for run a steerable proxy in the background

</pre><h4><b>SYNOPSIS</b></h4><pre>
       //  Create new zproxy actor instance. The proxy switches messages between
       //  a frontend socket and a backend socket; use the FRONTEND and BACKEND
       //  commands to configure these:
       //
       //      zactor_t *proxy = zactor_new (zproxy, NULL);
       //
       //  Destroy zproxy instance. This destroys the two sockets and stops any
       //  message flow between them:
       //
       //      zactor_destroy (&amp;proxy);
       //
       //  Note that all zproxy commands are synchronous, so your application always
       //  waits for a signal from the actor after each command.
       //
       //  Enable verbose logging of commands and activity:
       //
       //      zstr_send (proxy, "VERBOSE");
       //      zsock_wait (proxy);
       //
       //  Specify frontend socket type -- see zsock_type_str () -- and attach to
       //  endpoints, see zsock_attach (). Note that a proxy socket is always
       //  serverish:
       //
       //      zstr_sendx (proxy, "FRONTEND", "XSUB", endpoints, NULL);
       //      zsock_wait (proxy);
       //
       //  When the socket type is XSUB or SUB, topic(s) string(s) can be passed as
       //  additional arguments (NOTE: in DRAFT state) and the socket will subscribe
       //  using them.
       //
       //  Specify backend socket type -- see zsock_type_str () -- and attach to
       //  endpoints, see zsock_attach (). Note that a proxy socket is always
       //  serverish:
       //
       //      zstr_sendx (proxy, "BACKEND", "XPUB", endpoints, NULL);
       //      zsock_wait (proxy);
       //
       //  Capture all proxied messages; these are delivered to the application
       //  via an inproc PULL socket that you have already bound to the specified
       //  endpoint:
       //
       //      zstr_sendx (proxy, "CAPTURE", endpoint, NULL);
       //      zsock_wait (proxy);
       //
       //  Pause the proxy. A paused proxy will cease processing messages, causing
       //  them to be queued up and potentially hit the high-water mark on the
       //  frontend or backend socket, causing messages to be dropped, or writing
       //  applications to block:
       //
       //      zstr_sendx (proxy, "PAUSE", NULL);
       //      zsock_wait (proxy);
       //
       //  Resume the proxy. Note that the proxy starts automatically as soon as it
       //  has a properly attached frontend and backend socket:
       //
       //      zstr_sendx (proxy, "RESUME", NULL);
       //      zsock_wait (proxy);
       //
       //  Configure an authentication domain for the "FRONTEND" or "BACKEND" proxy
       //  socket -- see zsock_set_zap_domain (). Call before binding socket:
       //
       //      zstr_sendx (proxy, "DOMAIN", "FRONTEND", "global", NULL);
       //      zsock_wait (proxy);
       //
       //  Configure PLAIN authentication for the "FRONTEND" or "BACKEND" proxy
       //  socket -- see zsock_set_plain_server (). Call before binding socket:
       //
       //      zstr_sendx (proxy, "PLAIN", "BACKEND", NULL);
       //      zsock_wait (proxy);
       //
       //  Configure CURVE authentication for the "FRONTEND" or "BACKEND" proxy
       //  socket -- see zsock_set_curve_server () -- specifying both the public and
       //  secret keys of a certificate as Z85 armored strings -- see
       //  zcert_public_txt () and zcert_secret_txt (). Call before binding socket:
       //
       //      zstr_sendx (proxy, "CURVE", "FRONTEND", public_txt, secret_txt, NULL);
       //      zsock_wait (proxy);
       //
       //  This is the zproxy constructor as a zactor_fn; the argument is a
       //  character string specifying frontend and backend socket types as two
       //  uppercase strings separated by a hyphen:
       CZMQ_EXPORT void
           zproxy (zsock_t *pipe, void *unused);

       //  Selftest
       CZMQ_EXPORT void
           zproxy_test (bool verbose);
       Please add '@interface' section in './../src/zproxy.c'.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       A zproxy actor switches messages between a frontend and a backend socket. It acts much like the
       zmq_proxy_steerable method, though it makes benefit of CZMQâ€™s facilities, to be somewhat simpler to
       set-up.

       This class replaces zproxy_v2, and is meant for applications that use the CZMQ v3 API (meaning, zsock).

</pre><h4><b>EXAMPLE</b></h4><pre>
       <b>From</b> <b>zproxy_test</b> <b>method</b>.

           //  Create and configure our proxy
           zactor_t *proxy = zactor_new (zproxy, NULL);
           assert (proxy);
           if (verbose) {
               zstr_sendx (proxy, "VERBOSE", NULL);
               zsock_wait (proxy);
           }
           zstr_sendx (proxy, "FRONTEND", "PULL", "inproc://frontend", NULL);
           zsock_wait (proxy);
           zstr_sendx (proxy, "BACKEND", "PUSH", "inproc://backend", NULL);
           zsock_wait (proxy);

           //  Connect application sockets to proxy
           zsock_t *faucet = zsock_new_push ("&gt;inproc://frontend");
           assert (faucet);
           zsock_t *sink = zsock_new_pull ("&gt;inproc://backend");
           assert (sink);

           //  Send some messages and check they arrived
           char *hello, *world;
           zstr_sendx (faucet, "Hello", "World", NULL);
           zstr_recvx (sink, &amp;hello, &amp;world, NULL);
           assert (streq (hello, "Hello"));
           assert (streq (world, "World"));
           zstr_free (&amp;hello);
           zstr_free (&amp;world);

           //  Test pause/resume functionality
           zstr_sendx (proxy, "PAUSE", NULL);
           zsock_wait (proxy);
           zstr_sendx (faucet, "Hello", "World", NULL);
           zsock_set_rcvtimeo (sink, 100);
           zstr_recvx (sink, &amp;hello, &amp;world, NULL);
           assert (!hello &amp;&amp; !world);

           zstr_sendx (proxy, "RESUME", NULL);
           zsock_wait (proxy);
           zstr_recvx (sink, &amp;hello, &amp;world, NULL);
           assert (streq (hello, "Hello"));
           assert (streq (world, "World"));
           zstr_free (&amp;hello);
           zstr_free (&amp;world);

           //  Test capture functionality
           zsock_t *capture = zsock_new_pull ("inproc://capture");
           assert (capture);

           //  Switch on capturing, check that it works
           zstr_sendx (proxy, "CAPTURE", "inproc://capture", NULL);
           zsock_wait (proxy);
           zstr_sendx (faucet, "Hello", "World", NULL);
           zstr_recvx (sink, &amp;hello, &amp;world, NULL);
           assert (streq (hello, "Hello"));
           assert (streq (world, "World"));
           zstr_free (&amp;hello);
           zstr_free (&amp;world);

           zstr_recvx (capture, &amp;hello, &amp;world, NULL);
           assert (streq (hello, "Hello"));
           assert (streq (world, "World"));
           zstr_free (&amp;hello);
           zstr_free (&amp;world);

           zsock_destroy (&amp;faucet);
           zsock_destroy (&amp;sink);
           zsock_destroy (&amp;capture);
           zactor_destroy (&amp;proxy);

           //  Test socket creation dependency
           proxy = zactor_new (zproxy, NULL);
           assert (proxy);

           char *frontend = NULL;
           char *backend = NULL;
           backend = zsys_sprintf (LOCALENDPOINT, s_get_available_port ());
           zclock_sleep (200);
           sink = zsock_new_sub (backend, "whatever");
           assert (sink);

           zstr_sendx (proxy, "BACKEND", "XPUB", backend, NULL);
           zsock_wait (proxy);

           zsock_destroy(&amp;sink);
           zactor_destroy(&amp;proxy);
           zstr_free (&amp;backend);

           #ifdef CZMQ_BUILD_DRAFT_API
           //  Create and configure our proxy with PUB/SUB to test subscriptions
           proxy = zactor_new (zproxy, NULL);
           assert (proxy);
           if (verbose) {
               zstr_sendx (proxy, "VERBOSE", NULL);
               zsock_wait (proxy);
           }
           zstr_sendx (proxy, "FRONTEND", "SUB", "inproc://frontend", "He", "b", NULL);
           zsock_wait (proxy);
           zstr_sendx (proxy, "BACKEND", "PUB", "inproc://backend", NULL);
           zsock_wait (proxy);

           //  Connect application sockets to proxy
           faucet = zsock_new_pub ("&gt;inproc://frontend");
           assert (faucet);
           sink = zsock_new_sub ("&gt;inproc://backend", "");
           assert (sink);

           //  Send some messages and check they arrived
           zstr_sendx (faucet, "Hello", "World", NULL);
           // since SUB is binding, subscription might be lost see:
           // https://github.com/zeromq/libzmq/issues/2267
           zsock_set_rcvtimeo (sink, 100);
           hello = zstr_recv (sink);
           if (hello) {
               assert (streq (hello, "Hello"));
               world = zstr_recv (sink);
               assert (streq (world, "World"));
               zstr_free (&amp;hello);
               zstr_free (&amp;world);
           }

           zsock_destroy (&amp;faucet);
           zsock_destroy (&amp;sink);
           zactor_destroy(&amp;proxy);
           #endif // CZMQ_BUILD_DRAFT_API

           #if (ZMQ_VERSION_MAJOR == 4)
           // Test authentication functionality
           const char *basedirpath = "src/selftest-rw/.test_zproxy";
           const char *passfilepath = "src/selftest-rw/.test_zproxy/password-file";
           const char *certfilepath = "src/selftest-rw/.test_zproxy/mycert.txt";

           // Make sure old aborted tests do not hinder us
           zdir_t *dir = zdir_new (basedirpath, NULL);
           if (dir) {
               zdir_remove (dir, true);
               zdir_destroy (&amp;dir);
           }
           zsys_file_delete (passfilepath);
           zsys_file_delete (certfilepath);
           zsys_dir_delete (basedirpath);

           //  Create temporary directory for test files
           zsys_dir_create (basedirpath);

           //  Check there's no authentication
           s_create_test_sockets (&amp;proxy, &amp;faucet, &amp;sink, verbose);
           s_bind_test_sockets (proxy, &amp;frontend, &amp;backend);
           bool success = s_can_connect (&amp;proxy, &amp;faucet, &amp;sink, frontend, backend,
               verbose, true);
           assert (success);

           //  Install the authenticator
           zactor_t *auth = zactor_new (zauth, NULL);
           assert (auth);
           if (verbose) {
               zstr_sendx (auth, "VERBOSE", NULL);
               zsock_wait (auth);
           }

           //  Check there's no authentication on a default NULL server
           s_bind_test_sockets (proxy, &amp;frontend, &amp;backend);
           success = s_can_connect (&amp;proxy, &amp;faucet, &amp;sink, frontend, backend, verbose,
               true);
           assert (success);

           //  When we set a domain on the server, we switch on authentication
           //  for NULL sockets, but with no policies, the client connection
           //  will be allowed.
           zstr_sendx (proxy, "DOMAIN", "FRONTEND", "global", NULL);
           zsock_wait (proxy);
           s_bind_test_sockets (proxy, &amp;frontend, &amp;backend);
           success = s_can_connect (&amp;proxy, &amp;faucet, &amp;sink, frontend, backend, verbose,
               true);
           assert (success);

           //  Block 127.0.0.1, connection should fail
           zstr_sendx (proxy, "DOMAIN", "FRONTEND", "global", NULL);
           zsock_wait (proxy);
           s_bind_test_sockets (proxy, &amp;frontend, &amp;backend);
           zstr_sendx (auth, "DENY", "127.0.0.1", NULL);
           zsock_wait (auth);
           success = s_can_connect (&amp;proxy, &amp;faucet, &amp;sink, frontend, backend, verbose,
               false);
           assert (!success);

           //  Allow our address, which overrides the block list
           zstr_sendx (proxy, "DOMAIN", "FRONTEND", "global", NULL);
           zsock_wait (proxy);
           zstr_sendx (proxy, "DOMAIN", "BACKEND", "global", NULL);
           zsock_wait (proxy);
           s_bind_test_sockets (proxy, &amp;frontend, &amp;backend);
           zstr_sendx (auth, "ALLOW", "127.0.0.1", NULL);
           zsock_wait (auth);
           success = s_can_connect (&amp;proxy, &amp;faucet, &amp;sink, frontend, backend, verbose,
               true);
           assert (success);

           //  Try PLAIN authentication

           //  Test negative case (no server-side passwords defined)
           zstr_sendx (proxy, "PLAIN", "FRONTEND", NULL);
           zsock_wait (proxy);
           zstr_sendx (proxy, "DOMAIN", "FRONTEND", "global", NULL);
           zsock_wait (proxy);
           s_bind_test_sockets (proxy, &amp;frontend, &amp;backend);
           zsock_set_plain_username (faucet, "admin");
           zsock_set_plain_password (faucet, "Password");
           success = s_can_connect (&amp;proxy, &amp;faucet, &amp;sink, frontend, backend, verbose,
               false);
           assert (!success);

           //  Test positive case (server-side passwords defined)
           FILE *password = fopen (passfilepath, "w");
           assert (password);
           fprintf (password, "admin=Password\n");
           fclose (password);
           zstr_sendx (proxy, "PLAIN", "FRONTEND", NULL);
           zsock_wait (proxy);
           zstr_sendx (proxy, "DOMAIN", "FRONTEND", "global", NULL);
           zsock_wait (proxy);
           zstr_sendx (proxy, "PLAIN", "BACKEND", NULL);
           zsock_wait (proxy);
           zstr_sendx (proxy, "DOMAIN", "BACKEND", "global", NULL);
           zsock_wait (proxy);
           s_bind_test_sockets (proxy, &amp;frontend, &amp;backend);
           zsock_set_plain_username (faucet, "admin");
           zsock_set_plain_password (faucet, "Password");
           zsock_set_plain_username (sink, "admin");
           zsock_set_plain_password (sink, "Password");
           zstr_sendx (auth, "PLAIN", passfilepath, NULL);
           zsock_wait (auth);
           success = s_can_connect (&amp;proxy, &amp;faucet, &amp;sink, frontend, backend, verbose,
               true);
           assert (success);

           //  Test negative case (bad client password)
           zstr_sendx (proxy, "PLAIN", "FRONTEND", NULL);
           zsock_wait (proxy);
           zstr_sendx (proxy, "DOMAIN", "FRONTEND", "global", NULL);
           zsock_wait (proxy);
           s_bind_test_sockets (proxy, &amp;frontend, &amp;backend);
           zsock_set_plain_username (faucet, "admin");
           zsock_set_plain_password (faucet, "Bogus");
           success = s_can_connect (&amp;proxy, &amp;faucet, &amp;sink, frontend, backend, verbose,
               false);
           assert (!success);

           if (zsys_has_curve ()) {
               //  We'll create two new certificates and save the client public
               //  certificate on disk
               zcert_t *server_cert = zcert_new ();
               assert (server_cert);
               zcert_t *client_cert = zcert_new ();
               assert (client_cert);
               const char *public_key = zcert_public_txt (server_cert);
               const char *secret_key = zcert_secret_txt (server_cert);

               //  Try CURVE authentication

               //  Test without setting-up any authentication
               zstr_sendx (proxy, "CURVE", "FRONTEND", public_key, secret_key, NULL);
               zsock_wait (proxy);
               zstr_sendx (proxy, "DOMAIN", "FRONTEND", "global", NULL);
               zsock_wait (proxy);
               s_bind_test_sockets (proxy, &amp;frontend, &amp;backend);
               zcert_apply (client_cert, faucet);
               zsock_set_curve_serverkey (faucet, public_key);
               success = s_can_connect (&amp;proxy, &amp;faucet, &amp;sink, frontend, backend,
                   verbose, false);
               assert (!success);

               //  Test CURVE_ALLOW_ANY
               zstr_sendx (proxy, "CURVE", "FRONTEND", public_key, secret_key, NULL);
               zsock_wait (proxy);
               s_bind_test_sockets (proxy, &amp;frontend, &amp;backend);
               zcert_apply (client_cert, faucet);
               zsock_set_curve_serverkey (faucet, public_key);
               zstr_sendx (auth, "CURVE", CURVE_ALLOW_ANY, NULL);
               zsock_wait (auth);
               success = s_can_connect (&amp;proxy, &amp;faucet, &amp;sink, frontend, backend,
                   verbose, true);
               assert (success);

               //  Test with client certificate file in authentication folder
               zstr_sendx (proxy, "CURVE", "FRONTEND", public_key, secret_key, NULL);
               zsock_wait (proxy);
               zstr_sendx (proxy, "CURVE", "BACKEND", public_key, secret_key, NULL);
               zsock_wait (proxy);
               s_bind_test_sockets (proxy, &amp;frontend, &amp;backend);
               zcert_apply (client_cert, faucet);
               zsock_set_curve_serverkey (faucet, public_key);
               zcert_apply (client_cert, sink);
               zsock_set_curve_serverkey (sink, public_key);
               zcert_save_public (client_cert, certfilepath);
               zstr_sendx (auth, "CURVE", basedirpath, NULL);
               zsock_wait (auth);
               success = s_can_connect (&amp;proxy, &amp;faucet, &amp;sink, frontend, backend,
                   verbose, true);
               assert (success);

               zcert_destroy (&amp;server_cert);
               zcert_destroy (&amp;client_cert);
           }

           //  Remove the authenticator and check a normal connection works
           zactor_destroy (&amp;auth);
           s_bind_test_sockets (proxy, &amp;frontend, &amp;backend);
           success = s_can_connect (&amp;proxy, &amp;faucet, &amp;sink, frontend, backend, verbose,
               true);
           assert (success);

           //  Cleanup
           zsock_destroy (&amp;faucet);
           zsock_destroy (&amp;sink);
           zactor_destroy (&amp;proxy);
           zstr_free (&amp;frontend);
           zstr_free (&amp;backend);

           //  Delete temporary directory and test files
           zsys_file_delete (passfilepath);
           zsys_file_delete (certfilepath);
           zsys_dir_delete (basedirpath);
           #endif

           #if defined (__WINDOWS__)
           zsys_shutdown();
           #endif

</pre><h4><b>AUTHORS</b></h4><pre>
       The czmq manual was written by the authors in the AUTHORS file.

</pre><h4><b>RESOURCES</b></h4><pre>
       Main web site:

       Report bugs to the email &lt;<b><a href="mailto:zeromq-dev@lists.zeromq.org">zeromq-dev@lists.zeromq.org</a></b>[1]&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) the Contributors as noted in the AUTHORS file. This file is part of CZMQ, the high-level C
       binding for 0MQ: <a href="http://czmq.zeromq.org">http://czmq.zeromq.org</a>. This Source Code Form is subject to the terms of the Mozilla
       Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at
       <a href="http://mozilla.org/MPL/2.0/">http://mozilla.org/MPL/2.0/</a>. LICENSE included with the czmq distribution.

</pre><h4><b>NOTES</b></h4><pre>
        1. <a href="mailto:zeromq-dev@lists.zeromq.org">zeromq-dev@lists.zeromq.org</a>
           <a href="mailto:zeromq-dev@lists.zeromq.org">mailto:zeromq-dev@lists.zeromq.org</a>

CZMQ 4.2.1                                         05/24/2024                                          <u><a href="../man3/ZPROXY.3.html">ZPROXY</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>