<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>zmq_proxy - start built-in 0MQ proxy</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libzmq3-dev">libzmq3-dev_4.3.5-1build2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       zmq_proxy - start built-in 0MQ proxy

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>int</b> <b>zmq_proxy</b> <b>(void</b> <u>*frontend</u><b>,</b> <b>void</b> <u>*backend</u><b>,</b> <b>void</b> <u>*capture</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <u>zmq_proxy()</u> function starts the built-in 0MQ proxy in the current application thread.

       The proxy connects a frontend socket to a backend socket. Conceptually, data flows from frontend to
       backend. Depending on the socket types, replies may flow in the opposite direction. The direction is
       conceptual only; the proxy is fully symmetric and there is no technical difference between frontend and
       backend.

       Before calling <u>zmq_proxy()</u> you must set any socket options, and connect or bind both frontend and backend
       sockets. The two conventional proxy models are:

       <u>zmq_proxy()</u> runs in the current thread and returns only if/when the current context is closed.

       If the capture socket is not NULL, the proxy shall send all messages, received on both frontend and
       backend, to the capture socket. The capture socket should be a <u>ZMQ_PUB</u>, <u>ZMQ_DEALER</u>, <u>ZMQ_PUSH</u>, or <u>ZMQ_PAIR</u>
       socket.

       Refer to <b><a href="../man3/zmq_socket.3.html">zmq_socket</a></b>(3) for a description of the available socket types.

</pre><h4><b>EXAMPLE</b> <b>USAGE</b></h4><pre>
   <b>Shared</b> <b>Queue</b>
       When the frontend is a ZMQ_ROUTER socket, and the backend is a ZMQ_DEALER socket, the proxy shall act as
       a shared queue that collects requests from a set of clients, and distributes these fairly among a set of
       services. Requests shall be fair-queued from frontend connections and distributed evenly across backend
       connections. Replies shall automatically return to the client that made the original request.

   <b>Forwarder</b>
       When the frontend is a ZMQ_XSUB socket, and the backend is a ZMQ_XPUB socket, the proxy shall act as a
       message forwarder that collects messages from a set of publishers and forwards these to a set of
       subscribers. This may be used to bridge networks transports, e.g. read on tcp:// and forward on pgm:/<a href="file:/.">/.</a>

   <b>Streamer</b>
       When the frontend is a ZMQ_PULL socket, and the backend is a ZMQ_PUSH socket, the proxy shall collect
       tasks from a set of clients and forwards these to a set of workers using the pipeline pattern.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       The <u>zmq_proxy()</u> function always returns -1 and <u>errno</u> set to <b>ETERM</b> or <b>EINTR</b> (the 0MQ <u>context</u> associated
       with either of the specified sockets was terminated) or <b>EFAULT</b> (the provided <u>frontend</u> or <u>backend</u> was
       invalid).

</pre><h4><b>EXAMPLE</b></h4><pre>
       <b>Creating</b> <b>a</b> <b>shared</b> <b>queue</b> <b>proxy</b>.

           //  Create frontend and backend sockets
           void *frontend = zmq_socket (context, ZMQ_ROUTER);
           assert (frontend);
           void *backend = zmq_socket (context, ZMQ_DEALER);
           assert (backend);
           //  Bind both sockets to TCP ports
           assert (zmq_bind (frontend, "tcp://*:5555") == 0);
           assert (zmq_bind (backend, "tcp://*:5556") == 0);
           //  Start the queue proxy, which runs until ETERM
           zmq_proxy (frontend, backend, NULL);

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/zmq_bind.3.html">zmq_bind</a></b>(3) <b><a href="../man3/zmq_connect.3.html">zmq_connect</a></b>(3) <b><a href="../man3/zmq_socket.3.html">zmq_socket</a></b>(3) <b><a href="../man7/zmq.7.html">zmq</a></b>(7)

</pre><h4><b>AUTHORS</b></h4><pre>
       This page was written by the 0MQ community. To make a change please read the 0MQ Contribution Policy at
       <b><a href="http://www.zeromq.org/docs">http://www.zeromq.org/docs</a>:contributing</b>.

0MQ 4.3.5                                          03/31/2024                                       <u><a href="../man3/ZMQ_PROXY.3.html">ZMQ_PROXY</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>