<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>asn1ct - ASN.1 compiler and compile-time support functions</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       asn1ct - ASN.1 compiler and compile-time support functions

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  ASN.1 compiler takes an ASN.1 module as input and generates a corresponding Erlang module, which can
       encode and decode the specified data types. Alternatively, the  compiler  takes  a  specification  module
       specifying  all  input  modules,  and  generates a module with encode/decode functions. In addition, some
       generic functions can be used during development of applications that handles ASN.1 data (encoded as  <u>BER</u>
       or <u>PER</u>).

   <b>Note:</b>
       By  default  in  OTP 17, the representation of the <u>BIT</u> <u>STRING</u> and <u>OCTET</u> <u>STRING</u> types as Erlang terms were
       changed. <u>BIT</u> <u>STRING</u> values are now Erlang bit strings and <u>OCTET</u> <u>STRING</u>  values  are  binaries.  Also,  an
       undecoded  open type is now wrapped in an <u>asn1_OPENTYPE</u> tuple. For details, see BIT STRING, OCTET STRING,
       and ASN.1 Information Objects in the User's Guide.

       To revert to the old representation of the types, use option <u>legacy_erlang_types</u>.

   <b>Note:</b>
       In OTP R16, the options were simplified. The back end is chosen using one of the options <u>ber</u>,  <u>per</u>,  <u>uper</u>
       or  <u>jer</u>.  Options  <u>optimize</u>,  <u>nif</u>,  and  <u>driver</u>  options  are no longer necessary (and the ASN.1 compiler
       generates a warning if they are used). Options <u>ber_bin</u>, <u>per_bin</u>, and <u>uper_bin</u>  options  still  work,  but
       generates a warning.

       Another  change  in  OTP  R16  is  that the generated function <u>encode/2</u> always returns a binary. Function
       <u>encode/2</u> for the <u>BER</u> back end used to return an iolist.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>compile(Asn1module)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>compile(Asn1module,</b> <b>Options)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Asn1module = atom() | string()
                 Options = [Option| OldOption]
                 Option  =  ber  |  per  |  uper  |  jer  |  der  |  compact_bit_string  |  legacy_bit_string  |
                 legacy_erlang_types | noobj | {n2n, EnumTypeName} |{outdir, Dir} | {i, IncludeDir} | asn1config
                 |  undec_rest  |  no_ok_wrapper  | {macro_name_prefix, Prefix} | {record_name_prefix, Prefix} |
                 verbose | warnings_as_errors
                 OldOption = ber | per
                 Reason = term()
                 Prefix = string()

              Compiles the <u>ASN.1</u> module <u>Asn1module</u> and generates an Erlang module <u>Asn1module.erl</u> with encode and
              decode functions for the types defined in <u>Asn1module</u>. For each ASN.1 value defined in the  module,
              an Erlang function that returns the value in Erlang representation is generated.

              If  <u>Asn1module</u> is a filename without extension, first <u>".asn1"</u> is assumed, then <u>".asn"</u>, and finally
              <u>".py"</u> (to be compatible with the old ASN.1 compiler). <u>Asn1module</u> can be a full pathname  (relative
              or absolute) including filename with (or without) extension.

              If  it  is  needed  to  compile  a  set  of  <u>ASN.1</u>  modules into an Erlang file with encode/decode
              functions, ensure to list all involved files in a configuration file. This configuration file must
              have a double extension <u>".set.asn"</u> (<u>".asn"</u> can alternatively be <u>".asn1"</u> or <u>".py"</u>). List the  input
              file  names  within  quotation  marks  (""),  one  at each row in the file. If the input files are
              <u>File1.asn</u>, <u>File2.asn</u>, and <u>File3.asn</u>, the configuration file must look as follows:

              File1.asn
              File2.asn
              File3.asn

              The output files in this case get their names from the configuration file.  If  the  configuration
              file   is   named   <u>SetOfFiles.set.asn</u>,   the  names  of  the  output  files  are  <u>SetOfFiles.hrl,</u>
              <u>SetOfFiles.erl,</u> <u>and</u> <u>SetOfFiles.asn1db</u>.

              Sometimes in a system of <u>ASN.1</u> modules, different  default  tag  modes,  for  example,  <u>AUTOMATIC</u>,
              <u>IMPLICIT</u>,  or  <u>EXPLICIT</u>. The multi-file compilation resolves the default tagging as if the modules
              were compiled separately.

              Name collisions is another unwanted effect that can occur in multi file-compilation. The  compiler
              solves this problem in one of two ways:

                * If  the  definitions  are  identical,  the  output  module  keeps only one definition with the
                  original name.

                * If the definitions have the same name and differs in the definition, they are renamed. The new
                  names are the definition name and the original module name concatenated.

              If a name collision occurs, the  compiler  reports  a  <u>"NOTICE:</u>  <u>..."</u>  message  that  tells  if  a
              definition was renamed, and the new name that must be used to encode/decode data.

              <u>Options</u> is a list with options specific for the <u>ASN.1</u> compiler and options that are applied to the
              Erlang  compiler.  The  latter  are not recognized as <u>ASN.1</u> specific. The available options are as
              follows:

                <u>ber</u> <u>|</u> <u>per</u> <u>|</u> <u>uper</u> <u>|</u> <u>jer</u>:
                  The encoding rule to be used. The supported encoding rules are  Basic  Encoding  Rules  (<u>ber</u>),
                  Packed  Encoding  Rules (<u>per</u>) aligned, PER unaligned (<u>uper</u>) and JSON Encoding Rules (<u>jer</u>). The
                  <u>jer</u> option can be used by itself to generate a module that only supports encoding/decoding  to
                  JER  or  it  can  be used as a supplementary option to ber, per and uper. In the latter case a
                  module with for both the main encoding rules and JER will be generated. The exported functions
                  for JER will then be <u>jer_encode(Type,</u> <u>Value)</u> and <u>jer_decode(Type,</u> <u>Bytes)</u>.

                  The <u>jer</u> encoding rules (ITU-T X.697) are experimental in OTP 22. There is support for a subset
                  of the X.697 standard, for example there is no support for:

                  * JER encoding instructions

                  * the REAL type

                  Also note that when using the <u>jer</u> encoding rules the generated module will get a dependency to
                  an external json component. The generated code is currently tested together with:

                  * <u>jsx</u> which currently is the default.

                  * <u>jsone</u> can be chosen instead of <u>jsx</u> by providing the option <u>{d,jsone}</u>.

                  If the encoding rule option is omitted, <u>ber</u> is the default.

                  The generated Erlang module always gets the same name as the <u>ASN.1</u> module. Therefore, only one
                  encoding rule per <u>ASN.1</u> module can be used at runtime.

                <u>der</u>:
                  With this option the Distinguished Encoding Rules (<u>der</u>)  is  chosen.  DER  is  regarded  as  a
                  specialized variant of the BER encoding rule. Therefore, this option only makes sense together
                  with  option  <u>ber</u>.  This  option  sometimes adds sorting and value checks when encoding, which
                  implies a slower encoding. The decoding routines are the same as for <u>ber</u>.

                <u>maps</u>:
                  This option changes the representation of the types <u>SEQUENCE</u> and <u>SET</u> to use maps  (instead  of
                  records). This option also suppresses the generation of <u>.hrl</u> files.

                  For details, see Section  Map representation for SEQUENCE and SET in the User's Guide.

                <u>compact_bit_string</u>:
                  The  <u>BIT</u>  <u>STRING</u> type is decoded to "compact notation". <u>This</u> <u>option</u> <u>is</u> <u>not</u> <u>recommended</u> <u>for</u> <u>new</u>
                  <u>code.</u> This option cannot be combined with the option <u>maps</u>.

                  For details, see Section  BIT STRING in the User's Guide.

                  This option implies option <u>legacy_erlang_types</u>.

                <u>legacy_bit_string</u>:
                  The <u>BIT</u> <u>STRING</u> type is decoded to the legacy format, that is, a list of zeroes and ones.  <u>This</u>
                  <u>option</u> <u>is</u> <u>not</u> <u>recommended</u> <u>for</u> <u>new</u> <u>code.</u> This option cannot be combined with the option <u>maps</u>.

                  For details, see Section BIT STRING in the User's Guide

                  This option implies option <u>legacy_erlang_types</u>.

                <u>legacy_erlang_types</u>:
                  Use the same Erlang types to represent <u>BIT</u> <u>STRING</u> and <u>OCTET</u> <u>STRING</u> as in OTP R16.

                  For details, see Section BIT STRING and Section OCTET STRING in the User's Guide.

                  <u>This</u>  <u>option</u>  <u>is</u>  <u>not</u> <u>recommended</u> <u>for</u> <u>new</u> <u>code.</u> This option cannot be combined with the option
                  <u>maps</u>.

                <u>{n2n,</u> <u>EnumTypeName}</u>:
                  Tells the compiler to generate functions for conversion between names (as atoms)  and  numbers
                  and  conversely  for  the  specified  <u>EnumTypeName</u>.  There can be multiple occurrences of this
                  option to specify several type names. The type names must be declared as <u>ENUMERATIONS</u>  in  the
                  ASN.1 specification.

                  If <u>EnumTypeName</u> does not exist in the ASN.1 specification, the compilation stops with an error
                  code.

                  The     generated    conversion    functions    are    named    <u>name2num_EnumTypeName/1</u>    and
                  <u>num2name_EnumTypeName/1</u>.

                <u>noobj</u>:
                  Do not compile (that is, do not produce object code) the generated <u>.erl</u> file. If  this  option
                  is omitted, the generated Erlang module is compiled.

                <u>{i,</u> <u>IncludeDir}</u>:
                  Adds  <u>IncludeDir</u>  to the search-path for <u>.asn1db</u> and <u>ASN.1</u> source files. The compiler tries to
                  open an <u>.asn1db</u> file when a module imports  definitions  from  another  <u>ASN.1</u>  module.  If  no
                  <u>.asn1db</u> file is found, the <u>ASN.1</u> source file is parsed. Several <u>{i,</u> <u>IncludeDir}</u> can be given.

                <u>{outdir,</u> <u>Dir}</u>:
                  Specifies directory <u>Dir</u> where all generated files are to be placed. If this option is omitted,
                  the files are placed in the current directory.

                <u>asn1config</u>:
                  When using one of the specialized decodes, exclusive or selective decode, instructions must be
                  given  in  a  configuration  file. Option <u>asn1config</u> enables specialized decodes and takes the
                  configuration file in concern.  The  configuration  file  has  the  same  name  as  the  ASN.1
                  specification, but with extension <u>.asn1config</u>.

                  For instructions for exclusive decode, see Section Exclusive Decode in the User's Guide.

                  For instructions for selective decode, see Section Selective Decode in the User's Guide.

                <u>undec_rest</u>:
                  A  buffer  that  holds  a  message, being decoded it can also have some following bytes. Those
                  following bytes can now be returned together with the decoded value. If an ASN.1 specification
                  is compiled with this option, a tuple <u>{ok,</u> <u>Value,</u> <u>Rest}</u> is returned. <u>Rest</u> can be a list  or  a
                  binary. Earlier versions of the compiler ignored those following bytes.

                <u>no_ok_wrapper</u>:
                  With  this  option,  the  generated  <u>encode/2</u>  and <u>decode/2</u> functions do not wrap a successful
                  return value in an <u>{ok,...}</u> tuple. If any error occurs, an exception will be raised.

                <u>{macro_name_prefix,</u> <u>Prefix}</u>:
                  All macro names generated by the compiler are  prefixed  with  <u>Prefix</u>.  This  is  useful  when
                  multiple protocols that contain macros with identical names are included in a single module.

                <u>{record_name_prefix,</u> <u>Prefix}</u>:
                  All  record  names  generated  by  the  compiler are prefixed with <u>Prefix</u>. This is useful when
                  multiple protocols that contain records with identical names are included in a single module.

                <u>verbose</u>:
                  Causes more verbose information from the compiler describing what it is doing.

                <u>warnings_as_errors</u>:
                  Causes warnings to be treated as errors.

              Any more option that is applied is passed to the final  step  when  the  generated  <u>.erl</u>  file  is
              compiled.

              The compiler generates the following files:

                * <u>Asn1module.hrl</u> (if any <u>SET</u> or <u>SEQUENCE</u> is defined)

                * <u>Asn1module.erl</u> - Erlang module with encode, decode, and value functions

                * <u>Asn1module.asn1db</u>  -  Intermediate format used by the compiler when modules <u>IMPORT</u> definitions
                  from each other.

       <b>value(Module,</b> <b>Type)</b> <b>-&gt;</b> <b>{ok,</b> <b>Value}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Module = Type = atom()
                 Value = term()
                 Reason = term()

              Returns an Erlang term that is an example of a valid Erlang representation of a value of the <u>ASN.1</u>
              type <u>Type</u>. The value is a random value and subsequent calls to this function will for  most  types
              return different values.

          <b>Note:</b>
              Currently,  the  <u>value</u>  function  has  many  limitations. Essentially, it will mostly work for old
              specifications based on the 1997 standard for ASN.1, but not for most  modern-style  applications.
              Another limitation is that the <u>value</u> function may not work if options that change code generations
              strategies such as the options <u>macro_name_prefix</u> and <u>record_name_prefix</u> have been used.

       <b>test(Module)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>test(Module,</b> <b>Type</b> <b>|</b> <b>Options)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>
       <b>test(Module,</b> <b>Type,</b> <b>Value</b> <b>|</b> <b>Options)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Module = Type = atom()
                 Value = term()
                 Options = [{i, IncludeDir}]
                 Reason = term()

              Performs  a  test  of  encode and decode of types in <u>Module</u>. The generated functions are called by
              this function. This function is useful during test to secure that the generated encode and  decode
              functions as well as the general runtime support work as expected.

          <b>Note:</b>
              Currently,  the  <u>test</u>  functions have many limitations. Essentially, they will mostly work for old
              specifications based on the 1997 standard for ASN.1, but not for most  modern-style  applications.
              Another limitation is that the <u>test</u> functions may not work if options that change code generations
              strategies such as the options <u>macro_name_prefix</u> and <u>record_name_prefix</u> have been used.

                * <u>test/1</u> iterates over all types in <u>Module</u>.

                * <u>test/2</u> tests type <u>Type</u> with a random value.

                * <u>test/3</u> tests type <u>Type</u> with <u>Value</u>.

              Schematically, the following occurs for each type in the module:

              {ok, Value} = asn1ct:value(Module, Type),
              {ok, Bytes} = Module:encode(Type, Value),
              {ok, Value} = Module:decode(Type, Bytes).

              The  <u>test</u>  functions  use  the  <u>*.asn1db</u>  files for all included modules. If they are located in a
              different directory than the current working directory, use the <u>include</u> option to add paths.  This
              is  only needed when automatically generating values. For static values using <u>Value</u> no options are
              needed.

Ericsson AB                                        asn1 5.0.17                                      <u><a href="../man3erl/asn1ct.3erl.html">asn1ct</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>