<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XML::Compile::SOAP11 - SOAP 1.1 protocol</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libxml-compile-soap-perl">libxml-compile-soap-perl_3.28+ds-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       XML::Compile::SOAP11 - SOAP 1.1 protocol

</pre><h4><b>INHERITANCE</b></h4><pre>
        XML::Compile::SOAP11 has extra code in
          XML::Compile::SOAP11::Encoding

        XML::Compile::SOAP11
          is a XML::Compile::SOAP

        XML::Compile::SOAP11 is extended by
          XML::Compile::SOAP11::Client
          XML::Compile::SOAP11::Server

</pre><h4><b>SYNOPSIS</b></h4><pre>
        # use either XML::Compile::SOAP11::Client or ::Server
        # See XML::Compile::SOAP for global usage examples.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module handles the SOAP protocol version 1.1.  See <u><a href="http://www.w3.org/TR/2000/NOTE-SOAP-20000508/">http://www.w3.org/TR/2000/NOTE-SOAP-20000508/</a></u>).
       The implementation tries to behave like described in <u><a href="http://www.ws-i.org/Profiles/BasicProfile-1.0.html">http://www.ws-i.org/Profiles/BasicProfile-1.0.html</a></u>

       Two extensions are made: the SOAP11 client XML::Compile::SOAP11::Client.  and server in
       XML::Compile::SOAP11::Server.

       Extends "DESCRIPTION" in XML::Compile::SOAP.

</pre><h4><b>METHODS</b></h4><pre>
       Extends "METHODS" in XML::Compile::SOAP.

   <b>Constructors</b>
       Extends "Constructors" in XML::Compile::SOAP.

       $obj-&gt;<b>new</b>(%options)
           To  simplify  the  URIs  of  the  actors, as specified with the "destination" option, you may use the
           STRING "NEXT".  It will be replaced by the right URI.

            -Option    --Defined in        --Default
             media_type  XML::Compile::SOAP  text/xml
             schemas     XML::Compile::SOAP  created internally

           media_type =&gt; MIMETYPE
           schemas =&gt; "XML::Compile::Cache" object
       XML::Compile::SOAP11-&gt;<b>register</b>($uri, $envns)
           Inherited, see "Constructors" in XML::Compile::SOAP

   <b>Accessors</b>
       Extends "Accessors" in XML::Compile::SOAP.

       $obj-&gt;<b>mediaType</b>()
           Inherited, see "Accessors" in XML::Compile::SOAP

       $obj-&gt;<b>schemas</b>()
           Inherited, see "Accessors" in XML::Compile::SOAP

       $obj-&gt;<b>version</b>()
           Inherited, see "Accessors" in XML::Compile::SOAP

   <b>Single</b> <b>message</b>
       Extends "Single message" in XML::Compile::SOAP.

       $obj-&gt;<b>compileMessage</b>( &lt;'SENDER'|'RECEIVER'&gt;, %options )
            -Option        --Defined in        --Default
             body            XML::Compile::SOAP  []
             destination     XML::Compile::SOAP  []
             faults          XML::Compile::SOAP  []
             header          XML::Compile::SOAP  undef
             headerfault                         []
             mustUnderstand  XML::Compile::SOAP  []
             procedure       XML::Compile::SOAP  undef
             role            XML::Compile::SOAP  ULTIMATE
             roles           XML::Compile::SOAP  []

           body =&gt; ENTRIES|HASH
           destination =&gt; ARRAY-OF-PAIRS
           faults =&gt; ENTRIES|HASH
           header =&gt; ENTRIES|HASH
           headerfault =&gt; ENTRIES
             ARRAY of simple name with element references, for all expected faults.   There  can  be  unexpected
             faults, which will not get decoded automatically.

           mustUnderstand =&gt; STRING|ARRAY-OF-STRING
           procedure =&gt; TYPE
           role =&gt; URI|ARRAY-OF-URI
           roles =&gt; ARRAY-OF-URI
       $obj-&gt;<b>messageStructure</b>($xml)
       XML::Compile::SOAP11-&gt;<b>messageStructure</b>($xml)
           Inherited, see "Single message" in XML::Compile::SOAP

   <b>Helpers</b>
       Extends "Helpers" in XML::Compile::SOAP.

   <b>Transcoding</b>
       Extends "Transcoding" in XML::Compile::SOAP.

       $obj-&gt;<b>replyMustUnderstandFault</b>($type)
           Inherited, see "Transcoding" in XML::Compile::SOAP

       $obj-&gt;<b>roleAbbreviation</b>($uri)
           Inherited, see "Transcoding" in XML::Compile::SOAP

       $obj-&gt;<b>roleURI</b>($uri|STRING)
           Inherited, see "Transcoding" in XML::Compile::SOAP

</pre><h4><b>DETAILS</b></h4><pre>
       Extends "DETAILS" in XML::Compile::SOAP.

   <b>SOAP</b> <b>introduction</b>
       Extends "SOAP introduction" in XML::Compile::SOAP.

   <b>Supported</b> <b>servers</b>
       Extends "Supported servers" in XML::Compile::SOAP.

   <b>Naming</b> <b>types</b> <b>and</b> <b>elements</b>
       Extends "Naming types and elements" in XML::Compile::SOAP.

   <b>Client</b> <b>and</b> <b>Server</b> <b>implementations</b>
       Extends "Client and Server implementations" in XML::Compile::SOAP.

   <b>Use</b> <b>of</b> <b>wildcards</b> <b>(any</b> <b>and</b> <b>anyAttribute)</b>
       Extends "Use of wildcards (any and anyAttribute)" in XML::Compile::SOAP.

   <b>Header</b> <b>and</b> <b>Body</b> <b>entries</b>
       You only call <b>compileMessage()</b> explicitly if you do not have a WSDL file which contains this information.
       In the unlucky situation, you have to dig out the defined types by hand.

       But  even with a WSDL, there are still a few problems you may encounter.  For instance, the WSDL will not
       contain "mustUnderstand" and "actor" header routing information.  You can add these to the  compileClient
       call

         my $call = $wsdl-&gt;compileClient
           ( 'MyCall'
           , mustUnderstand =&gt; 'h1'
           , destination    =&gt; [ h1 =&gt; 'NEXT' ]
           );

       <u>Simplest</u> <u>form</u>

       In  the  simplest  form, the "header" and "body" refer (optionally) to a list of PAIRS, each containing a
       free to choose unique label and the type of the element.  The unique label will be used in the Perl  HASH
       which represents the message.

        my $h1el = pack_type $myns, $some_local;
        my $b1el = 'myprefix:$other_local';

        my $encode_query = $client-&gt;compileMessage
          ( 'SENDER'
          , header   =&gt; [ h1 =&gt; $h1el ]
          , body     =&gt; [ b1 =&gt; $b1el ]
          , mustUnderstand =&gt; 'h1'
          , destination    =&gt; [ h1 =&gt; 'NEXT' ]
          );

       <u>Most</u> <u>powerful</u> <u>form</u>

       When  the simple form is too simple, you can use a HASH for the header, body or both.  The HASH structure
       is much like the WSDL structure.  For example:

        my $encode_query = $client-&gt;compileMessage
          ( 'SENDER'
          , header   =&gt;
             { use   =&gt; 'literal'
             , parts =&gt; [ { name =&gt; 'h1', element =&gt; $h1el
                          , mustUnderstand =&gt; 1, destination =&gt; 'NEXT'
                          } ]
             }
          , body     =&gt; [ b1 =&gt; $b1el ]
          );

       So, the header now is one HASH, which tells us that we have a literal definition (this is  the  default).
       The  optional  parts for the header is an ARRAY of HASHes, each describing one part.  As you can see, the
       mustUnderstand and destination fields are more convenient (although the other syntax will work as well).

       If you feel the need to control the compilation  of  the  various  parts,  with  hooks  or  options  (see
       <b>XML::Compile::Schema::compile()</b>),  then  have  a  look at <b>XML::Compile::Cache::declare()</b>.  Declare how to
       handle the various types before you call <b>compileMessage()</b>.

   <b>Receiving</b> <b>faults</b> <b>in</b> <b>SOAP1.1</b>
       When faults are received, they will be returned with the "Fault" key in the data structure.  So:

         my $answer = $call-&gt;($question);
         if($answer-&gt;{Fault}) { ... }

       As extra service, for each of  the  fault  types,  as  defined  with  compileMessage(faults),  a  decoded
       structure is included.  The name of that structure can be found like this:

         if(my $faults = $answer-&gt;{Fault})
         {   my $name    = $faults-&gt;{_NAME};
             my $decoded = $answer-&gt;{$name};
             ...
         }

       The untranslated $faults HASH looks like this:

        Fault =&gt;
          { faultcode =&gt; '{<a href="http://schemas.xmlsoap.org/soap/envelope/">http://schemas.xmlsoap.org/soap/envelope/</a>}Server.first'
          , faultstring =&gt; 'my mistake'
          , faultactor =&gt; '<a href="http://schemas.xmlsoap.org/soap/actor/next">http://schemas.xmlsoap.org/soap/actor/next</a>'
          , detail =&gt; { '{<a href="http://test-types">http://test-types</a>}fault_one' =&gt; [ XMLNODES ] }
          , _NAME =&gt; 'fault1'
          }

       The "_NAME" originates from the compileMessage(faults) option:

          $soap-&gt;compileMessage('RECEIVER', ...
            , faults =&gt; [ fault1 =&gt; '{<a href="http://test-types">http://test-types</a>}fault_one' ] );

       Now, automatically the answer will contain the decoded fault structure as well:

         fault1 =&gt;
           { code =&gt; '{<a href="http://schemas.xmlsoap.org/soap/envelope/">http://schemas.xmlsoap.org/soap/envelope/</a>}Server.first'
           , class  =&gt; [ '<a href="http://schemas.xmlsoap.org/soap/envelope/">http://schemas.xmlsoap.org/soap/envelope/</a>'
                , 'Receiver', 'first' ]
           , reason =&gt; 'my mistake',
           , role   =&gt; 'NEXT'
           , detail =&gt; { help =&gt; 'please ignore' }
           }

       The   "detail"   is   the   decoding   of   the   XMLNODES,   which   are   defined   to   be   of   type
       "{<a href="http://test-types">http://test-types</a>}fault_one".

       The "class" is an unpacked version of the code.   SOAP1.2  is  using  the  (better)  terms  "Sender"  and
       "Receiver".

       "role" is constructed by decoding the "faultactor" using <b>roleAbbreviation()</b>.  The names are closer to the
       SOAP1.2 specification.

       If  the  received  fault  is  of  an  unpredicted type, then the client tries to DWIM. in the worst case,
       "detail" will list the unparsed XMLNODEs.  When the XML::Compile::SOAP::Daemon server  has  produced  the
       error, the content of the reply will typically be

        { Fault =&gt;        # SOAP version specific
           { _NAME =&gt; 'error'
           , #...more...
           }
        , error =&gt;        # less SOAP version specific, readable
           { role    =&gt; 'NEXT'
           , reason  =&gt; 'procedure xyz for SOAP11 produced an invalid response'
           , error   =&gt; 'some explanation'
           , code    =&gt;
               '{<a href="http://schemas.xmlsoap.org/soap/envelope/">http://schemas.xmlsoap.org/soap/envelope/</a>}Server.invalidResponse'
           , class   =&gt; [ SOAP11ENV, 'Receiver', 'invalidResponse' ],
           }
         }

       Hence, a typical client routine could contain

         my ($answer, $trace) = $call-&gt;(message =&gt; $message);
         if(my $f = $answer-&gt;{Fault})
         {   if($f-&gt;{_NAME} eq 'error')
             {   # server implementation error
                 die "SERVER ERROR:\n$answer-&gt;{error}{error}\n";
             }
             else
             {   # the fault is described in the WSDL, handle it!
                 warn "FAULT:\n",Dumper $answer-&gt;{$f-&gt;{_NAME}};
             }
         }
         else
         {   # correct answer
             print Dumper $answer;
         }

       Or

         my ($answer, $trace) = $call-&gt;(message =&gt; $message);
         $answer or die $trace-&gt;error;

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       This  module  is  part  of XML-Compile-SOAP distribution version 3.28, built on August 01, 2022. Website:
       <u><a href="http://perl.overmeer.net/CPAN/">http://perl.overmeer.net/CPAN/</a></u>

</pre><h4><b>LICENSE</b></h4><pre>
       Copyrights 2007-2022 by [Mark Overmeer &lt;<a href="mailto:markov@cpan.org">markov@cpan.org</a>&gt;]. For other contributors see ChangeLog.

       This program is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.  See <u><a href="http://dev.perl.org/licenses/">http://dev.perl.org/licenses/</a></u>

perl v5.34.0                                       2022-08-04                          <u>XML::Compile::<a href="../man3pm/SOAP11.3pm.html">SOAP11</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>