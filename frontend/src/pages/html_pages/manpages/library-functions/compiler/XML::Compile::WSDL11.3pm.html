<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XML::Compile::WSDL11 - create SOAP messages defined by WSDL 1.1</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libxml-compile-wsdl11-perl">libxml-compile-wsdl11-perl_3.08-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       XML::Compile::WSDL11 - create SOAP messages defined by WSDL 1.1

</pre><h4><b>INHERITANCE</b></h4><pre>
        XML::Compile::WSDL11
          is a XML::Compile::Cache
          is a XML::Compile::Schema
          is a XML::Compile

</pre><h4><b>SYNOPSIS</b></h4><pre>
        # preparation
        use XML::Compile::WSDL11;      # use WSDL version 1.1
        use XML::Compile::SOAP11;      # use SOAP version 1.1
        use XML::Compile::Transport::SOAPHTTP;

        # you want some trace?
        use Log::Report mode =&gt; 'DEBUG';   # or 'VERBOSE'

        # collect one or more wsdls and xsds in one object
        my $wsdl = XML::Compile::WSDL11-&gt;new($wsdlfile
          , server_type =&gt; 'BEA'
          );
        $wsdl-&gt;addWSDL(...more WSDL files...);
        $wsdl-&gt;importDefinitions(...more schemas...);

        # during initiation, for each used call
        my $call = $wsdl-&gt;compileClient('GetStockPrice', ...);

        # at "run-time", call as often as you want (fast)
        my $answer = $call-&gt;(%request);

        # capture useful trace information
        my ($answer, $trace) = $call-&gt;(%request);
        if($trace-&gt;errors)
        {   $trace-&gt;printError;
        }

        # no need to administer the operations by hand: alternative
        $wsdl-&gt;compileCalls;  # at initiation
        my $answer = $wsdl-&gt;call(GetStockPrice =&gt; %request);

        # investigate the %request structure (server input)
        print $wsdl-&gt;explain('GetStockPrice', PERL =&gt; 'INPUT', recurse =&gt; 1);

        # investigate the $answer structure (server output)
        print $wsdl-&gt;explain('GetStockPrice', PERL =&gt; 'OUTPUT');

        # when you like, get all operation definitions
        my @all_ops = $wsdl-&gt;operations;

        # Install XML::Compile::SOAP::Daemon
        my $server  = XML::Compile::SOAP::HTTPDaemon-&gt;new;
        $server-&gt;operationsFromWSDL($wsdl);
        undef $wsdl;    # not needed any further

        # For debug info, start your script with:
        use Log::Report mode =&gt; 'DEBUG';

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module understands WSDL version 1.1.  An WSDL file defines a set of messages to be send and received
       over (SOAP) connections. This involves encoding of the message to be send into XML, sending the message
       to the server, collect the answer, and finally decoding the XML to Perl.

       As end-user, you do not have to worry about the complex details of the messages and the way to exchange
       them: it's all simple Perl for you.  Also, faults are handled automatically.  The only complication you
       have to worry about is to shape a nested HASH structure to the sending message structure.
       <b>XML::Compile::Schema::template()</b> may help you.

       When the definitions are spread over multiple files you will need to use <b>addWSDL()</b> (wsdl) or
       <b>importDefinitions()</b> (additional schema's) explicitly. Usually, interreferences between those files are
       broken.  Often they reference over networks (you should never trust). So, on purpose you <b>must</b> <b>explicitly</b>
       <b>load</b> the files you need from local disk!  (of course, it is simple to find one-liners as work-arounds,
       but I will not tell you how!  See XML::Compile::SOAP::FAQ)

       Extends "DESCRIPTION" in XML::Compile::Cache.

</pre><h4><b>METHODS</b></h4><pre>
       Extends "METHODS" in XML::Compile::Cache.

   <b>Constructors</b>
       Extends "Constructors" in XML::Compile::Cache.

       XML::Compile::WSDL11-&gt;<b>new</b>( [$xml], %options )
           The $xml is the WSDL file, which is anything accepted by <b>XML::Compile::dataToXML()</b>.

            -Option            --Defined in          --Default
             allow_undeclared    XML::Compile::Cache   &lt;false&gt;
             any_element         XML::Compile::Cache   'ATTEMPT'
             block_namespace     XML::Compile::Schema  []
             hook                XML::Compile::Schema  undef
             hooks               XML::Compile::Schema  []
             ignore_unused_tags  XML::Compile::Schema  &lt;false&gt;
             key_rewrite         XML::Compile::Schema  []
             opts_readers        XML::Compile::Cache   []
             opts_rw             XML::Compile::Cache   []
             opts_writers        XML::Compile::Cache   []
             parser_options      XML::Compile          &lt;many&gt;
             prefixes            XML::Compile::Cache   &lt;smart&gt;
             schema_dirs         XML::Compile          undef
             server_type                               undef
             typemap             XML::Compile::Cache   {}
             xsi_type            XML::Compile::Cache   {}

           allow_undeclared =&gt; BOOLEAN
           any_element =&gt; CODE|'TAKE_ALL'|'SKIP_ALL'|'ATTEMPT'|'SLOPPY'
           block_namespace =&gt; NAMESPACE|TYPE|HASH|CODE|ARRAY
           hook =&gt; $hook|ARRAY
           hooks =&gt; ARRAY
           ignore_unused_tags =&gt; BOOLEAN|REGEXP
           key_rewrite =&gt; HASH|CODE|ARRAY
           opts_readers =&gt; HASH|ARRAY-of-PAIRS
           opts_rw =&gt; HASH|ARRAY-of-PAIRS
           opts_writers =&gt; HASH|ARRAY-of-PAIRS
           parser_options =&gt; HASH|ARRAY
           prefixes =&gt; HASH|ARRAY-of-PAIRS
           schema_dirs =&gt; $directory|ARRAY-OF-directories
           server_type =&gt; NAME
             [3.01] When you specify the implementation of the server, we can work around some of the known bugs
             and limitation.  Read XML::Compile::SOAP section "Supported servers" for supported servers.

           typemap =&gt; HASH|ARRAY
           xsi_type =&gt; HASH|ARRAY

   <b>Accessors</b>
       Extends "Accessors" in XML::Compile::Cache.

       $obj-&gt;<b>addHook</b>($hook|LIST|undef)
           Inherited, see "Accessors" in XML::Compile::Schema

       $obj-&gt;<b>addHooks</b>( $hook, [$hook, ...] )
           Inherited, see "Accessors" in XML::Compile::Schema

       $obj-&gt;<b>addKeyRewrite</b>($predef|CODE|HASH, ...)
           Inherited, see "Accessors" in XML::Compile::Schema

       $obj-&gt;<b>addSchemaDirs</b>(@directories|$filename)
       XML::Compile::WSDL11-&gt;<b>addSchemaDirs</b>(@directories|$filename)
           Inherited, see "Accessors" in XML::Compile

       $obj-&gt;<b>addSchemas</b>($xml, %options)
           Inherited, see "Accessors" in XML::Compile::Schema

       $obj-&gt;<b>addTypemap</b>(PAIR)
           Inherited, see "Accessors" in XML::Compile::Schema

       $obj-&gt;<b>addTypemaps</b>(PAIRS)
           Inherited, see "Accessors" in XML::Compile::Schema

       $obj-&gt;<b>addXsiType</b>( [HASH|ARRAY|LIST] )
           Inherited, see "Accessors" in XML::Compile::Cache

       $obj-&gt;<b>allowUndeclared</b>( [BOOLEAN] )
           Inherited, see "Accessors" in XML::Compile::Cache

       $obj-&gt;<b>anyElement</b>('ATTEMPT'|'SLOPPY'|'SKIP_ALL'|'TAKE_ALL'|CODE)
           Inherited, see "Accessors" in XML::Compile::Cache

       $obj-&gt;<b>blockNamespace</b>($ns|$type|HASH|CODE|ARRAY)
           Inherited, see "Accessors" in XML::Compile::Schema

       $obj-&gt;<b>hooks</b>( [&lt;'READER'|'WRITER'&gt;] )
           Inherited, see "Accessors" in XML::Compile::Schema

       $obj-&gt;<b>typemap</b>( [HASH|ARRAY|PAIRS] )
           Inherited, see "Accessors" in XML::Compile::Cache

       $obj-&gt;<b>useSchema</b>( $schema, [$schema, ...] )
           Inherited, see "Accessors" in XML::Compile::Schema

   <b>Prefix</b> <b>management</b>
       Extends "Prefix management" in XML::Compile::Cache.

       $obj-&gt;<b>addNicePrefix</b>(BASE, NAMESPACE)
           Inherited, see "Prefix management" in XML::Compile::Cache

       $obj-&gt;<b>addPrefixes</b>( [PAIRS|ARRAY|HASH] )
           Inherited, see "Prefix management" in XML::Compile::Cache

       $obj-&gt;<b>learnPrefixes</b>($node)
           Inherited, see "Prefix management" in XML::Compile::Cache

       $obj-&gt;<b>prefix</b>($prefix)
           Inherited, see "Prefix management" in XML::Compile::Cache

       $obj-&gt;<b>prefixFor</b>($uri)
           Inherited, see "Prefix management" in XML::Compile::Cache

       $obj-&gt;<b>prefixed</b>( $type|&lt;$ns,$local&gt; )
           Inherited, see "Prefix management" in XML::Compile::Cache

       $obj-&gt;<b>prefixes</b>( [$params] )
           Inherited, see "Prefix management" in XML::Compile::Cache

   <b>Compilers</b>
       Extends "Compilers" in XML::Compile::Cache.

       $obj-&gt;<b>addCompileOptions</b>( ['READERS'|'WRITERS'|'RW'], %options )
           Inherited, see "Compilers" in XML::Compile::Cache

       $obj-&gt;<b>call</b>($opname, $data)
           [2.20]  Call  the  $opname (operation name) with $data (HASH or LIST of parameters).  This only works
           when you have called <b>compileCalls()</b> beforehand, always during the initiation phase of the program.

           example:

              # at initiation time (compile once)
              $wsdl-&gt;compileCalls;

              # at runtime (run often)
              my $answer = $wsdl-&gt;call($operation, $request);

       $obj-&gt;<b>compile</b>( &lt;'READER'|'WRITER'&gt;, $type, %options )
           Inherited, see "Compilers" in XML::Compile::Schema

       $obj-&gt;<b>compileAll</b>( [ &lt;'READERS'|'WRITERS'|'RW'|'CALLS'&gt;, [$ns] ] )
           [2.20] With explicit "CALLS" or without any parameter, it will call  <b>compileCalls()</b>.  Otherwise,  see
           <b>XML::Compile::Cache::compileAll()</b>.

       $obj-&gt;<b>compileCall</b>($operation|$opname, %options)
           [2.37]  The call to the $operation object (which extends XML::Compile::SOAP::Operation) gets compiled
           and cached so it can be used with <b>call()</b>.

           [2.38] Alteratively to an $operation object, you may also specify an operation by name.

            -Option--Default
             alias   undef

           alias =&gt; NAME
             [3.03] When defined, the compiled operation will be stored with the alias  name  in  stead  of  the
             operation name.  This may make your code more readible or solve naming conflicts.

           example:

             my $op = $wsdl-&gt;operation(name =&gt; 'getInfo');
             $wsdl-&gt;compileCall($op);

             # as often as you need it
             my ($answer, $trace) = $wsdl-&gt;call('getInfo')-&gt;(%request);

       $obj-&gt;<b>compileCalls</b>(%options)
           [2.20]  Compile  a handler for each of the available operations. The %options are passed to each call
           of <b>compileClient()</b>, but will be overruled by more specific declared options.

           Additionally, %options can contain "service", "port", and "binding" to  limit  the  set  of  involved
           calls. See <b>operations()</b> for details on these options.

           You may declare additional specific compilation options with the <b>declare()</b> method.

            -Option    --Default
             long_names  false

           long_names =&gt; BOOLEAN
             [3.03]  Prepend the service name to the operation name to produce an alias (see compileCall(alias))
             for the compiled call.  If the service name is 'X' and the operation name is 'Y',  then  the  alias
             becomes 'X#Y'.

             You will need this if you have multiple operations with the same name in your WSDL (-collection).

           example:

              my $trans = XML::Compile::Transport::SOAPHTTP
                -&gt;new(timeout =&gt; 500, address =&gt; $wsdl-&gt;endPoint);
              $wsdl-&gt;compileCalls(transport =&gt; $trans);

              # alternatives for simple cases
              $wsdl-&gt;compileAll('CALLS');
              $wsdl-&gt;compileAll;

              my $answer = $wsdl-&gt;call($myop, $request);

       $obj-&gt;<b>compileType</b>( &lt;'READER'|'WRITER'&gt;, $type, %options )
           Inherited, see "Compilers" in XML::Compile::Schema

       $obj-&gt;<b>dataToXML</b>($node|REF-XML|XML-STRING|$filename|$fh|$known)
       XML::Compile::WSDL11-&gt;<b>dataToXML</b>($node|REF-XML|XML-STRING|$filename|$fh|$known)
           Inherited, see "Compilers" in XML::Compile

       $obj-&gt;<b>initParser</b>(%options)
       XML::Compile::WSDL11-&gt;<b>initParser</b>(%options)
           Inherited, see "Compilers" in XML::Compile

       $obj-&gt;<b>reader</b>($type|$name, %options)
           Inherited, see "Compilers" in XML::Compile::Cache

       $obj-&gt;<b>template</b>( &lt;'XML'|'PERL'|'TREE'&gt;, $element, %options )
           Inherited, see "Compilers" in XML::Compile::Schema

       $obj-&gt;<b>writer</b>($type|$name)
           Inherited, see "Compilers" in XML::Compile::Cache

   <b>Extension</b>
       $obj-&gt;<b>addWSDL</b>($xmldata|\@xmldata, %options)
           The  $xmldata must be acceptable to <b>XML::Compile::dataToXML()</b> and should represent the top-level of a
           (partial) WSDL document.  The specification can be spread over multiple files,  each  of  which  must
           have a "definition" root element.

       $obj-&gt;<b>compileClient</b>( [$name], %options )
           Creates   an  XML::Compile::SOAP::Operation  temporary  object  using  <b>operation()</b>,  and  then  calls
           "compileClient()" on that.  This results in a code reference which will handle all client-server SOAP
           exchange.

           The %options available include all of the options for:

           •   <b>operation()</b> (i.e. "service" and "port"), and all of

           •   <b>XML::Compile::SOAP::Operation::compileClient()</b>  (there  are   many   of   these,   for   instance
               "transport_hook" and "server")

           You  <b>cannot</b> pass options for <b>XML::Compile::Schema::compile()</b>, like "&lt;sloppy_integers =" 0&gt;&gt;, hooks or
           typemaps this way. Use new(opts_rw) and friends to declare those.

           When you use <b>compileCall()</b>, the compiled code references get cached for you.  In that case,  you  can
           use <b>call()</b> to use them.

           example:

             my $call = $wsdl-&gt;compileClient
               ( operation =&gt; 'HelloWorld'
               , port      =&gt; 'PrefillSoap' # only required when multiple ports
               );
             my ($answer, $trace) = $call-&gt;($request);

             # 'operation' keyword optional
             my $call = $wsdl-&gt;compileClient('HelloWorld');

       $obj-&gt;<b>namesFor</b>($class)
           Returns  the  list  of names available for a certain definition $class in the WSDL. See <b>index()</b> for a
           way to determine the available $class information.

       $obj-&gt;<b>operation</b>( [$name], %options )
           Collect all information for  a  certain  operation.   Returned  is  an  XML::Compile::SOAP::Operation
           object.

           An operation is defined by a service name, a port, some bindings, and an operation name, which can be
           specified explicitly and is often left-out: in the many configurations where there are no alternative
           choices. In case there are alternatives, you will be requested to pick an option.

            -Option     --Default
             action       &lt;undef&gt;
             operation    &lt;required&gt;
             port         &lt;only when just one port in WSDL&gt;
             server_type  undef
             service      &lt;only when just one service in WSDL&gt;

           action =&gt; STRING
             Overrule the soapAction from the WSDL.

           operation =&gt; NAME
             Ignored  when  the  parameter  list  starts with a $name (which is an alternative for this option).
             Optional when there is only one operation defined within the portType.

           port =&gt; NAME
             Required when more than one port is defined.

           server_type =&gt; NAME
             Overrules new(server_type).

           service =&gt; QNAME|PREFIXED
             Required when more than one service is defined.

   <b>Administration</b>
       Extends "Administration" in XML::Compile::Cache.

       $obj-&gt;<b>declare</b>($group, $component|ARRAY, %options)
           Register    specific    compile    %options    for    the    specific    $component.     See     also
           <b>XML::Compile::Cache::declare()</b>.  The  $group  is  either  "READER",  "WRITER",  "RW" (both reader and
           writer), or "OPERATION".  As $component, you specify the element name (for readers  and  writers)  or
           operation name (for operations). %options are specified as LIST, ARRAY or HASH.

           example:

              $wsdl-&gt;declare(OPERATION =&gt; 'GetStockPrice', @extra_opts);
              $wsdl-&gt;compileCalls;
              my $answer = $wsdl-&gt;call(GetStockPrice =&gt; %request);

       $obj-&gt;<b>doesExtend</b>($exttype, $basetype)
           Inherited, see "Administration" in XML::Compile::Schema

       $obj-&gt;<b>elements</b>()
           Inherited, see "Administration" in XML::Compile::Schema

       $obj-&gt;<b>findName</b>($name)
           Inherited, see "Administration" in XML::Compile::Cache

       $obj-&gt;<b>findSchemaFile</b>($filename)
       XML::Compile::WSDL11-&gt;<b>findSchemaFile</b>($filename)
           Inherited, see "Administration" in XML::Compile

       $obj-&gt;<b>importDefinitions</b>($xmldata, %options)
           Inherited, see "Administration" in XML::Compile::Schema

       $obj-&gt;<b>knownNamespace</b>($ns|PAIRS)
       XML::Compile::WSDL11-&gt;<b>knownNamespace</b>($ns|PAIRS)
           Inherited, see "Administration" in XML::Compile

       $obj-&gt;<b>namespaces</b>()
           Inherited, see "Administration" in XML::Compile::Schema

       $obj-&gt;<b>types</b>()
           Inherited, see "Administration" in XML::Compile::Schema

       $obj-&gt;<b>walkTree</b>($node, CODE)
           Inherited, see "Administration" in XML::Compile

   <b>Introspection</b>
       All  of  the  following  methods  are  usually  NOT  meant  for  end-users. End-users should stick to the
       <b>operation()</b> and <b>compileClient()</b> methods.

       $obj-&gt;<b>endPoint</b>(%options)
           [2.20] Returns the address of the server, as specified by the WSDL. When there  are  no  alternatives
           for service or port, you not not need to specify those parameters.

           The  endpoint  in  the WSDL is often wrong.  All compile functions accept the "server" and "endpoint"
           parameters to overrule the value.  With "server", only the hostname:port  is  being  replaced.   With
           "endpoint", everything is replaced.

            -Option --Default
             port     &lt;undef&gt;
             service  &lt;undef&gt;

           port =&gt; NAME
           service =&gt; QNAME|PREFIXED

           example:

            my $devel = URI-&gt;new($wsdl-&gt;endPoint);
            $devel-&gt;path('/sdk');
            my $call = $wsdl-&gt;compileCall($opname, endpoint =&gt; $devel);

       $obj-&gt;<b>explain</b>($operation, $format, $direction, %options)
           [2.13]   Produce  templates  (see  <b>XML::Compile::Schema::template()</b>  which  detail  the  use  of  the
           $operation. Currently, only the "PERL" template $format is available.

           The $direction of operation is either "INPUT" (input for the server, hence  to  be  produced  by  the
           client), or "OUTPUT" (from the server, received by the client).

           The  actual  work  is  done  by <b>XML::Compile::SOAP::Operation::explain()</b>. The %options passed to that
           method include "recurse" and "skip_header".

           example:

             print $wsdl-&gt;explain('CheckStatus', PERL =&gt; 'INPUT');

             print $wsdl-&gt;explain('CheckStatus', PERL =&gt; 'OUTPUT'
                , recurse =&gt; 1                 # explain options
                , port    =&gt; 'Soap12PortName'  # operation options
                );

             foreach my $op ($wsdl-&gt;operations)
             {  print $op-&gt;explain($wsdl, PERL =&gt; 'INPUT');
             }

       $obj-&gt;<b>findDef</b>( $class, &lt;$qname|$prefixed|$name&gt; )
           With a $qname, the HASH which contains the parsed XML information from the  WSDL  template  for  that
           $class-$name  combination  is  returned.   You  may  also  have  a  $prefixed  name, using one of the
           predefined namespace abbreviations.  Otherwise, $name is considered  to  be  the  localName  in  that
           class.  When the $name is not found, an error is produced.

           Without  $qname  in  SCALAR  context,  there  may only be one such name defined otherwise an error is
           produced.  In LIST context, all definitions in $class are returned.

           example:

            $service  = $obj-&gt;findDef(service =&gt; '<a href="http://xyz">http://xyz</a>');
            @services = $obj-&gt;findDef('service');

       $obj-&gt;<b>index</b>( [$class, [$qname]] )
           With a $class and $qname, it returns one WSDL definition HASH or undef.  Returns the  index  for  the
           $class  group  of  names as HASH.  When no $class is specified, a HASH of HASHes is returned with the
           CLASSes on the top-level.

           $class includes "service", "binding", "portType", and "message".

       $obj-&gt;<b>operations</b>(%options)
           Return a list with all operations defined in the WSDL.

            -Option     --Default
             binding      &lt;undef&gt;
             port         &lt;undef&gt;
             server_type  undef
             service      &lt;undef&gt;

           binding =&gt; NAME
             Only return operations which use the binding with the specified NAME.  By default, all bindings are
             accepted.

           port =&gt; NAME
             Return only operations related to the specified port NAME.  By default operations from all ports.

           server_type =&gt; STRING
             [3.06]

           service =&gt; NAME
             Only return operations related to the NAMEd service, by default all services.

       $obj-&gt;<b>printIndex</b>( [$fh], %options )
           For available %options, see <b>operations()</b>.  This method is useful to understand the structure of  your
           WSDL: it shows a nested list of services, bindings, ports and portTypes.

            -Option       --Defined in         --Default
             show_declared  XML::Compile::Cache  &lt;true&gt;

           show_declared =&gt; BOOLEAN

</pre><h4><b>DETAILS</b></h4><pre>
       Extends "DETAILS" in XML::Compile::Cache.

   <b>Distribution</b> <b>collection</b> <b>overview</b>
       Extends "Distribution collection overview" in XML::Compile::Cache.

   <b>Comparison</b>
       Extends "Comparison" in XML::Compile::Cache.

   <b>Collecting</b> <b>definitions</b>
       Extends "Collecting definitions" in XML::Compile::Cache.

   <b>Addressing</b> <b>components</b>
       Extends "Addressing components" in XML::Compile::Cache.

   <b>Representing</b> <b>data-structures</b>
       Extends "Representing data-structures" in XML::Compile::Cache.

   <b>Schema</b> <b>hooks</b>
       Extends "Schema hooks" in XML::Compile::Cache.

   <b>Typemaps</b>
       Extends "Typemaps" in XML::Compile::Cache.

   <b>Handling</b> <b>xsi:type</b>
       Extends "Handling xsi:type" in XML::Compile::Cache.

   <b>Key</b> <b>rewrite</b>
       Extends "Key rewrite" in XML::Compile::Cache.

   <b>Initializing</b> <b>SOAP</b> <b>operations</b> <b>via</b> <b>WSDL</b>
       When  you  have  a  WSDL  file,  then SOAP is simple.  If there is no such file at hand, then it is still
       possible to use SOAP.  See the DETAILS chapter in XML::Compile::SOAP.

       The WSDL file contains operations which can be addressed by name.  In the WSDL file you need to find  the
       name  of  the  port to be used.  In most cases, the WSDL has only one service, one port, one binding, and
       one portType and those names can therefore be omitted.  If there is a choice, then  you  must  explicitly
       select one.

        use XML::Compile::WSDL11 ();

        # once in your program
        my $wsdl   = XML::Compile::WSDL11-&gt;new('def.wsdl');

        # XML::Compile::Schema refuses to follow "include" and
        # "import" commands, so you need to invoke them explicitly.
        # $wsdl-&gt;addWSDL('file2.wsdl');            # optional
        # $wsdl-&gt;importDefinitions('schema1.xsd'); # optional

        # once for each of the defined operations
        my $call   = $wsdl-&gt;compileClient('GetStockPrice');

        # see XML::Compile::SOAP chapter DETAILS about call params
        my $answer = $call-&gt;(%request);

</pre><h4><b>DESCRIPTIONS</b></h4><pre>
       Extends "DESCRIPTIONS" in XML::Compile::Cache.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       This  module  is part of XML-Compile-WSDL11 distribution version 3.08, built on August 27, 2021. Website:
       <u><a href="http://perl.overmeer.net/CPAN/">http://perl.overmeer.net/CPAN/</a></u>

</pre><h4><b>LICENSE</b></h4><pre>
       Copyrights 2014-2021 by [Mark Overmeer &lt;<a href="mailto:markov@cpan.org">markov@cpan.org</a>&gt;]. For other contributors see ChangeLog.

       This program is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.  See <u><a href="http://dev.perl.org/licenses/">http://dev.perl.org/licenses/</a></u>

perl v5.32.1                                       2021-10-11                          <u>XML::Compile::<a href="../man3pm/WSDL11.3pm.html">WSDL11</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>