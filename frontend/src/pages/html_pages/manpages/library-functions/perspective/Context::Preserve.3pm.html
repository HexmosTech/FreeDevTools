<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Context::Preserve - Run code after a subroutine call, preserving the context the subroutine would have</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcontext-preserve-perl">libcontext-preserve-perl_0.03-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Context::Preserve - Run code after a subroutine call, preserving the context the subroutine would have
       seen if it were the last statement in the caller

</pre><h4><b>VERSION</b></h4><pre>
       version 0.03

</pre><h4><b>SYNOPSIS</b></h4><pre>
       Have you ever written this?

           my ($result, @result);

           # run a sub in the correct context
           if(!defined wantarray){
               some::code();
           }
           elsif(wantarray){
               @result = some::code();
           }
           else {
               $result = some::code();
           }

           # do something after some::code
           $_ += 42 for (@result, $result);

           # finally return the correct value
           if(!defined wantarray){
               return;
           }
           elsif(wantarray){
               return @result;
           }
           else {
               return $result;
           }

       Now you can just write this instead:

         use Context::Preserve;

         return preserve_context { some::code() }
                    after =&gt; sub { $_ += 42 for @_ };

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Sometimes you need to call a function, get the results, act on the results, then return the result of the
       function.  This is painful because of contexts; the original function can behave different if it's called
       in void, scalar, or list context.  You can ignore the various cases and just pick one, but that's
       fragile.  To do things right, you need to see which case you're being called in, and then call the
       function in that context.  This results in 3 code paths, which is a pain to type in (and maintain).

       This module automates the process.  You provide a coderef that is the "original function", and another
       coderef to run after the original runs.  You can modify the return value (aliased to @_) here, and do
       whatever else you need to do.  "wantarray" is correct inside both coderefs; in "after", though, the
       return value is ignored and the value "wantarray" returns is related to the context that the original
       function was called in.

</pre><h4><b>EXPORT</b></h4><pre>
       "preserve_context"

</pre><h4><b>FUNCTIONS</b></h4><pre>
   <b>preserve_context</b> <b>{</b> <b>original</b> <b>}</b> <b>[after|replace]</b> <b>=&gt;</b> <b>sub</b> <b>{</b> <b>after</b> <b>}</b>
       Invokes "original" in the same context as "preserve_context" was called in, save the results, runs
       "after" in the same context, then returns the result of "original" (or "after" if "replace" is used).

       If the second argument is "after", then you can modify @_ to affect the return value.  "after"'s return
       value is ignored.

       If the second argument is "replace", then modifying @_ doesn't do anything.  The return value of "after"
       is returned from "preserve_context" instead.

       Run "preserve_context" like this:

         sub whatever {
             ...
             return preserve_context { orginal_function() }
                        after =&gt; sub { modify @_          };
         }

         or

         sub whatever {
             ...
             return preserve_context   { orginal_function() }
                        replace =&gt; sub { return @new_return };
         }

       Note that there's no comma between the first block and the "after =&gt;" part.  This is how perl parses
       functions with the "(&amp;@)" prototype.  The alternative is to say:

             preserve_context(sub { original }, after =&gt; sub { after });

       You can pick the one you like, but I think the first version is much prettier.

</pre><h4><b>SUPPORT</b></h4><pre>
       Bugs may be submitted through the RT bug tracker
       &lt;https://rt.cpan.org/Public/Dist/Display.html?Name=Context-Preserve&gt; (or <a href="mailto:bug-Context-Preserve@rt.cpan.org">bug-Context-Preserve@rt.cpan.org</a>
       &lt;<a href="mailto:bug-Context-Preserve@rt.cpan.org">mailto:bug-Context-Preserve@rt.cpan.org</a>&gt;).

       I am also usually active on irc, as 'ether' at "irc.perl.org".

</pre><h4><b>AUTHOR</b></h4><pre>
       Jonathan Rockway &lt;<a href="mailto:jrockway@cpan.org">jrockway@cpan.org</a>&gt;

</pre><h4><b>CONTRIBUTORS</b></h4><pre>
       •   Karen Etheridge &lt;<a href="mailto:ether@cpan.org">ether@cpan.org</a>&gt;

       •   Jonathan Rockway &lt;<a href="mailto:jon@jrock.us">jon@jrock.us</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENCE</b></h4><pre>
       This software is copyright (c) 2008 by Infinity Interactive.

       This  is  free  software;  you  can  redistribute  it and/or modify it under the same terms as the Perl 5
       programming language system itself.

perl v5.36.0                                       2022-10-13                             <u>Context::<a href="../man3pm/Preserve.3pm.html">Preserve</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>