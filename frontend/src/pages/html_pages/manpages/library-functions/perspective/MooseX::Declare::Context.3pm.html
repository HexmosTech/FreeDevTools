<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MooseX::Declare::Context - Per-keyword declaration context</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmoosex-declare-perl">libmoosex-declare-perl_0.43-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       MooseX::Declare::Context - Per-keyword declaration context

</pre><h4><b>VERSION</b></h4><pre>
       version 0.43

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This is not a subclass of Devel::Declare::Context::Simple, but it will delegate all default methods and
       extend it with some attributes and methods of its own.

       A context object will be instantiated for every keyword that is handled by MooseX::Declare. If handlers
       want to communicate with other handlers (for example handlers that will only be setup inside a namespace
       block) it must do this via the generated code.

       In addition to all the methods documented here, all methods from Devel::Declare::Context::Simple are
       available and will be delegated to an internally stored instance of it.

</pre><h4><b>ATTRIBUTES</b></h4><pre>
   <b>caller_file</b>
       A required "Str" containing the file the keyword was encountered in.

   <b>preamble_code_parts</b>
       An "ArrayRef" of "CodePart"s that will be used as preamble. A preamble in this context means the
       beginning of the generated code.

   <b>scope_code_parts</b>
       These parts will come before the actual body and after the "preamble_code_parts". It is an "ArrayRef" of
       "CodePart"s.

   <b>cleanup_code_parts</b>
       An "ArrayRef" of "CodePart"s that will not be directly inserted into the code, but instead be installed
       in a handler that will run at the end of the scope so you can do namespace cleanups and such.

   <b>stack</b>
       An "ArrayRef" that contains the stack of handlers. A keyword that was only setup inside a scoped block
       will have the blockhandler be put in the stack.

</pre><h4><b>METHODS</b></h4><pre>
   <b>add_preamble_code_parts(CodePart</b> <b>@parts)</b>
         Object-&gt;add_preamble_code_parts (CodeRef @parts)

       See "add_cleanup_code_parts".

   <b>add_scope_code_parts(CodePart</b> <b>@parts)</b>
         Object-&gt;add_scope_code_parts    (CodeRef @parts)

       See "add_cleanup_code_parts".

   <b>add_cleanup_code_parts(CodePart</b> <b>@parts)</b>
         Object-&gt;add_cleanup_code_parts  (CodeRef @parts)

       For these three methods please look at the corresponding *_code_parts attribute in the list above. These
       methods are merely convenience methods that allow adding entries to the code part containers.

   <b>inject_code_parts_here</b>
         True Object-&gt;inject_code_parts_here (CodePart @parts)

       Will inject the passed "CodePart"s at the current position in the code.

   <b>peek_next_char</b>
         Str Object-&gt;peek_next_char ()

       Will return the next char without stripping it from the stream.

   <b>inject_code_parts</b>
         Object-&gt;inject_code_parts (
             Bool    :$inject_cleanup_code_parts,
             CodeRef :$missing_block_handler
         )

       This will inject the code parts from the attributes above at the current position. The preamble and scope
       code parts will be inserted first. Then then call to the cleanup code will be injected, unless the
       options contain a key named "inject_cleanup_code_parts" with a false value.

       The "inject_if_block" method will be called if the next char is a "{" indicating a following block.

       If it is not a block, but a semi-colon is found and the options contained a "missing_block_handler" key
       was passed, it will be called as method on the context object with the code to inject and the options as
       arguments. All options that are not recognized are passed through to the "missing_block_handler". You are
       well advised to prefix option names in your extensions.

</pre><h4><b>TYPES</b></h4><pre>
   <b>BlockCodePart</b>
       An "ArrayRef" with at least one element that stringifies to either "BEGIN" or "END". The other parts will
       be stringified and used as the body for the generated block. An example would be this compiletime role
       composition:

         ['BEGIN', 'with q{ MyRole }']

   <b>CodePart</b>
       A part of code represented by either a "Str" or a "BlockCodePart".

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       •   MooseX::Declare

       •   Devel::Declare

       •   Devel::Declare::Context::Simple

</pre><h4><b>AUTHOR</b></h4><pre>
       Florian Ragwitz &lt;<a href="mailto:rafl@debian.org">rafl@debian.org</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2008 by Florian Ragwitz.

       This  is  free  software;  you  can  redistribute  it and/or modify it under the same terms as the Perl 5
       programming language system itself.

perl v5.34.0                                       2022-06-15                      <u>MooseX::Declare::<a href="../man3pm/Context.3pm.html">Context</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>