<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>makecontext, swapcontext - manipulate user context</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/manpages-dev">manpages-dev_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       makecontext, swapcontext - manipulate user context

</pre><h4><b>LIBRARY</b></h4><pre>
       Standard C library (<u>libc</u>, <u>-lc</u>)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;<a href="file:/usr/include/ucontext.h">ucontext.h</a>&gt;</b>

       <b>void</b> <b>makecontext(ucontext_t</b> <b>*</b><u>ucp</u><b>,</b> <b>void</b> <b>(*</b><u>func</u><b>)(),</b> <b>int</b> <u>argc</u><b>,</b> <b>...);</b>
       <b>int</b> <b>swapcontext(ucontext_t</b> <b>*restrict</b> <u>oucp</u><b>,</b>
                       <b>const</b> <b>ucontext_t</b> <b>*restrict</b> <u>ucp</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       In  a  System  V-like  environment, one has the type <u>ucontext_t</u> (defined in <u>&lt;ucontext.h&gt;</u> and described in
       <b><a href="../man3/getcontext.3.html">getcontext</a></b>(3)) and the four functions <b><a href="../man3/getcontext.3.html">getcontext</a></b>(3), <b><a href="../man3/setcontext.3.html">setcontext</a></b>(3), <b>makecontext</b>(), and <b>swapcontext</b>() that
       allow user-level context switching between multiple threads of control within a process.

       The <b>makecontext</b>() function modifies the context pointed to by <u>ucp</u> (which was  obtained  from  a  call  to
       <b><a href="../man3/getcontext.3.html">getcontext</a></b>(3)).  Before invoking <b>makecontext</b>(), the caller must allocate a new stack for this context and
       assign  its  address  to  <u>ucp-&gt;uc_stack</u>,  and  define  a  successor  context  and  assign  its address to
       <u>ucp-&gt;uc_link</u>.

       When this context is later activated (using <b><a href="../man3/setcontext.3.html">setcontext</a></b>(3) or <b>swapcontext</b>()) the function <u>func</u> is  called,
       and  passed the series of integer (<u>int</u>) arguments that follow <u>argc</u>; the caller must specify the number of
       these arguments in <u>argc</u>.  When this function  returns,  the  successor  context  is  activated.   If  the
       successor context pointer is NULL, the thread exits.

       The  <b>swapcontext</b>()  function  saves  the  current  context  in the structure pointed to by <u>oucp</u>, and then
       activates the context pointed to by <u>ucp</u>.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       When successful, <b>swapcontext</b>() does not return.  (But we may return later, in case <u>oucp</u> is activated,  in
       which  case it looks like <b>swapcontext</b>() returns 0.)  On error, <b>swapcontext</b>() returns -1 and sets <u>errno</u> to
       indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>ENOMEM</b> Insufficient stack space left.

</pre><h4><b>ATTRIBUTES</b></h4><pre>
       For an explanation of the terms used in this section, see <b><a href="../man7/attributes.7.html">attributes</a></b>(7).
       ┌───────────────┬───────────────┬───────────────────────────────────────────────────────────────────────┐
       │ <b>Interface</b>     │ <b>Attribute</b>     │ <b>Value</b>                                                                 │
       ├───────────────┼───────────────┼───────────────────────────────────────────────────────────────────────┤
       │ <b>makecontext</b>() │ Thread safety │ MT-Safe race:ucp                                                      │
       ├───────────────┼───────────────┼───────────────────────────────────────────────────────────────────────┤
       │ <b>swapcontext</b>() │ Thread safety │ MT-Safe race:oucp race:ucp                                            │
       └───────────────┴───────────────┴───────────────────────────────────────────────────────────────────────┘

</pre><h4><b>STANDARDS</b></h4><pre>
       None.

</pre><h4><b>HISTORY</b></h4><pre>
       glibc 2.1.  SUSv2, POSIX.1-2001.  Removed in POSIX.1-2008, citing portability  issues,  and  recommending
       that applications be rewritten to use POSIX threads instead.

</pre><h4><b>NOTES</b></h4><pre>
       The  interpretation of <u>ucp-&gt;uc_stack</u> is just as in <b><a href="../man2/sigaltstack.2.html">sigaltstack</a></b>(2), namely, this struct contains the start
       and length of a memory area to be used as the stack, regardless of the direction of growth of the  stack.
       Thus, it is not necessary for the user program to worry about this direction.

       On  architectures  where  <u>int</u>  and pointer types are the same size (e.g., x86-32, where both types are 32
       bits), you may be able to get away with passing pointers as arguments to  <b>makecontext</b>()  following  <u>argc</u>.
       However,  doing this is not guaranteed to be portable, is undefined according to the standards, and won't
       work on architectures where pointers are larger than <u>int</u>s.  Nevertheless, starting with glibc 2.8,  glibc
       makes some changes to <b>makecontext</b>(), to permit this on some 64-bit architectures (e.g., x86-64).

</pre><h4><b>EXAMPLES</b></h4><pre>
       The  example  program  below  demonstrates  the  use  of <b><a href="../man3/getcontext.3.html">getcontext</a></b>(3), <b>makecontext</b>(), and <b>swapcontext</b>().
       Running the program produces the following output:

           $ <b>./a.out</b>
           main: swapcontext(&amp;uctx_main, &amp;uctx_func2)
           func2: started
           func2: swapcontext(&amp;uctx_func2, &amp;uctx_func1)
           func1: started
           func1: swapcontext(&amp;uctx_func1, &amp;uctx_func2)
           func2: returning
           func1: returning
           main: exiting

   <b>Program</b> <b>source</b>

       #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
       #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
       #include &lt;<a href="file:/usr/include/ucontext.h">ucontext.h</a>&gt;

       static ucontext_t uctx_main, uctx_func1, uctx_func2;

       #define <a href="../manmsg/handle_error.msg.html">handle_error</a>(msg) \
           do { <a href="../manmsg/perror.msg.html">perror</a>(msg); exit(EXIT_FAILURE); } while (0)

       static void
       func1(void)
       {
           printf("%s: started\n", __func__);
           printf("%s: swapcontext(&amp;uctx_func1, &amp;uctx_func2)\n", __func__);
           if (swapcontext(&amp;uctx_func1, &amp;uctx_func2) == -1)
               handle_error("swapcontext");
           printf("%s: returning\n", __func__);
       }

       static void
       func2(void)
       {
           printf("%s: started\n", __func__);
           printf("%s: swapcontext(&amp;uctx_func2, &amp;uctx_func1)\n", __func__);
           if (swapcontext(&amp;uctx_func2, &amp;uctx_func1) == -1)
               handle_error("swapcontext");
           printf("%s: returning\n", __func__);
       }

       int
       main(int argc, char *argv[])
       {
           char func1_stack[16384];
           char func2_stack[16384];

           if (getcontext(&amp;uctx_func1) == -1)
               handle_error("getcontext");
           uctx_func1.uc_stack.ss_sp = func1_stack;
           uctx_func1.uc_stack.ss_size = sizeof(func1_stack);
           uctx_func1.uc_link = &amp;uctx_main;
           makecontext(&amp;uctx_func1, func1, 0);

           if (getcontext(&amp;uctx_func2) == -1)
               handle_error("getcontext");
           uctx_func2.uc_stack.ss_sp = func2_stack;
           uctx_func2.uc_stack.ss_size = sizeof(func2_stack);
           /* Successor context is f1(), unless argc &gt; 1 */
           uctx_func2.uc_link = (argc &gt; 1) ? NULL : &amp;uctx_func1;
           makecontext(&amp;uctx_func2, func2, 0);

           printf("%s: swapcontext(&amp;uctx_main, &amp;uctx_func2)\n", __func__);
           if (swapcontext(&amp;uctx_main, &amp;uctx_func2) == -1)
               handle_error("swapcontext");

           printf("%s: exiting\n", __func__);
           exit(EXIT_SUCCESS);
       }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man2/sigaction.2.html">sigaction</a></b>(2), <b><a href="../man2/sigaltstack.2.html">sigaltstack</a></b>(2), <b><a href="../man2/sigprocmask.2.html">sigprocmask</a></b>(2), <b><a href="../man3/getcontext.3.html">getcontext</a></b>(3), <b><a href="../man3/sigsetjmp.3.html">sigsetjmp</a></b>(3)

Linux man-pages 6.9.1                              2024-06-15                                     <u><a href="../man3/makecontext.3.html">makecontext</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>