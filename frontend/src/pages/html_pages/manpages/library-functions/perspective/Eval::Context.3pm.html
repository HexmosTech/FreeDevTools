<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Eval::Context - Evaluate perl code in context wrapper</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libeval-context-perl">libeval-context-perl_0.09.11-7_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
        Eval::Context - Evaluate perl code in context wrapper

</pre><h4><b>SYNOPSIS</b></h4><pre>
               use Eval::Context ;

               my $context = new Eval::Context(PRE_CODE =&gt; "use strict;\nuse warnings;\n") ;

               # code will be evaluated with strict and warnings loaded in the context.

               $context-&gt;eval(CODE =&gt; 'print "evaluated in an Eval::Context!" ;') ;
               $context-&gt;eval(CODE_FROM_FILE =&gt; 'file.pl') ;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module define a subroutine that let you evaluate Perl code in a specific context. The code can be
       passed directly as a string or as a file name to read from. It also provides some subroutines to let you
       define and optionally share variables and subroutines between your code and the code you wish to
       evaluate. Finally there is some support for running your code in a safe compartment.

</pre><h4><b>Don't</b> <b>play</b> <b>with</b> <b>fire!</b></h4><pre>
       Don't start using this module, or any other module, thinking it will let you take code from anywhere and
       be safe. Read perlsec, Safe, Opcode, Taint and other security related documents. Control your input.

</pre><h4><b>SUBROUTINES/METHODS</b></h4><pre>
       Subroutines that are not part of the public interface are marked with [p].

   <b>new(@named_arguments)</b>
       Create an Eval::Context object.  The object is used as a repository of "default" values for your code
       evaluations.  The context can be used many times. The values can be temporarily overridden during the
       "eval" call.

         my $context = new Eval::Context() ; # default context

         my $context = new Eval::Context
                       (
                       NAME              =&gt; 'libraries evaluation context',
                       PACKAGE           =&gt; 'libraries',
                       SAFE              =&gt; {...} ;

                       PRE_CODE          =&gt; "use strict ;\n"
                       POST_CODE         =&gt; sub{},
                       PERL_EVAL_CONTEXT =&gt; undef,

                       INSTALL_SUBS      =&gt; {...},
                       INSTALL_VARIABLES =&gt; [...],
                       EVAL_SIDE_PERSISTENT_VARIABLES =&gt; {...},

                       INTERACTION =&gt; {...},
                       DISPLAY_SOURCE_IN_CONTEXT =&gt; 1, #useful when debugging
                       ) ;

       <u>ARGUMENTS</u>

       • @named_arguments - setup data for the object

         All  the  arguments  optional. The argument passed to "new" can also be passed to "eval". All arguments
         are named.

         •   NAME - use when displaying information about the object.

             Set automatically to 'Anonymous' if not set. The name will also be reported by  perl  if  an  error
             occurs during your code evaluation.

         •   PACKAGE - the package the code passed to "eval" will evaluated be in.

             If not set, a unique package name is generated and used for every "eval" call.

         •   REMOVE_PACKAGE_AFTER_EVAL - When set the content of the package after evaluation will be erase

             The default behavior is to remove all data from after the call to "eval".

         •   PRE_CODE - code prepended to the code passed to <u>eval</u>

         •   POST_CODE - code appended to the code passed to <u>eval</u>

         •   PERL_EVAL_CONTEXT - the context to eval code in (void, scalar, list).

             This  option  Works  as   "wantarray"  in perlfunc. It will override the context in which "eval" is
             called.

         •   INSTALL_SUBS - subs that will be available in the eval.

             A hash where the keys are a function names and the values a code references.

         •   SAFE

             This argument must be a hash reference. if the hash is empty, a default safe  compartment  will  be
             used.  Read Safe documentation for more information.

                     SAFE =&gt; {} # default safe environment

             You can have a finer control over the safe compartment <b>Eval::Context</b> that will be used.

                     my $compartment = new Safe('ABC') ;

                     my $context = new Eval::Context
                             (
                             SAFE =&gt; # controlling the safe environment
                                     {
                                     PACKAGE     =&gt; 'ABC',
                                     PRE_CODE    =&gt; "use my module ;\n" # code we consider safe
                                     USE_STRICT  =&gt; 0,                # set to 1 by default
                                     COMPARTMENT =&gt; $compartment ,   # use default if not passed
                                     } ,
                             }

                     $context-&gt;eval(CODE =&gt; .....) ;

             •   COMPARTMENT - a Safe object, you create, that will be used by <b>Eval::Context</b>

             •   USE_STRICT - Controls if strict is used in the Safe compartment

                 The  default  is  to  use  strict.  Note  that  "Safe"  in perldoc default is to NOT use strict
                 (undocumented).

             •   PRE_CODE - safe code you want to evaluate in the same context as the unsafe code

                 This let you, for example, use certain modules which provide subroutines  to  be  used  in  the
                 evaluated  code.  The default compartment is quite restrictive and you can't even use strict in
                 it without tuning the safe compartment.

             A few remarks:

             - See &lt;<a href="http://rt.cpan.org/Ticket/Display.html">http://rt.cpan.org/Ticket/Display.html</a>?id=31090&gt; on RT

             - Pass the same package name to your safe compartment and to <b>Eval::Context</b>.

             - If you really want to be on the safe side, control your input. When you use  a  module,  are  you
             sure the module hasn't been fiddle with?

             - Leave strict on. Even for trivial code.

         •   INSTALL_VARIABLES - "Give me sugar baby" Ash.

             <b>Eval::Context</b>  has  mechanisms  you  can  use  to  set  and  share variables with the code you will
             evaluate. There are two sides in an <b>Eval::Context</b>. The <u>caller-side</u>, the side  where  the  calls  to
             "eval" are made and the <u>eval-side</u>, the side where the code to be evaluated is run.

             •   How should you get values back from the eval-side

                 Although you can use the mechanisms below to get values from the <u>eval-side</u>, the cleanest way is
                 to get the results directly from the "eval" call.

                         my $context = new Eval::Context() ;

                         my ($scalr_new_value, $a_string) =
                                 $context-&gt;eval
                                         (
                                         INSTALL_VARIABLES =&gt;[[ '$scalar'  =&gt; 42]] ,
                                         CODE =&gt; "\$scalar++ ;\n (\$scalar, 'a string') ;",
                                         ) ;

             •   initializing variables on the <u>eval</u> <u>side</u>

                 You  can  pass <b>INSTALL_VARIABLES</b> to "new" or "eval". You can initialize different variables for
                 each run of "eval".

                         my $context = new Eval::Context
                                 (
                                 INSTALL_VARIABLES =&gt;
                                         [
                                         # variables on eval-side    #initialization source
                                         [ '$data'                =&gt; 42],
                                         [ '$scalar'              =&gt; $scalar_caller_side ],
                                         [ '%hash'                =&gt; \%hash_caller_side ]
                                         [ '$hash'                =&gt; \%hash_caller_side ],
                                         [ '$object'              =&gt; $object ],
                                         ] ,
                                 ) ;

                 The variables will be <b>my</b> variables on the eval-side.

                 You can declare variables of any of the base types supported by perl. The initialization data ,
                 on the caller-side, is serialized and deserialized to make the values available  on  the  eval-
                 side.  Modifying  the  variables  on the eval-side does not modify the variables on the caller-
                 side. The initialization data can be scalars or references and even <b>my</b> variables.

             •   Persistent variables

                 When evaluating code many times in the same context, you may wish  to  have  variables  persist
                 between  evaluations.  <b>Eval::Context</b>  allows  you  to  declare,  define  and control such <u>state</u>
                 variables.

                 This mechanism lets you control which  variables  are  persistent.  Access  to  the  persistent
                 variables is controlled per "eval" run. Persistent variables are <b>my</b> variables on the <u>eval-side</u>.
                 Modifying the variables on the eval-side does not modify the variables on the <u>caller-side</u>.

                 Define persistent variables:

                         # note: creating persistent variables in 'new' makes little sense as
                         # it will force those values in the persistent variables for every run.
                         # This may or may not be what you want.

                         my $context = new Eval::Context() ;

                         $context-&gt;eval
                                 (
                                 INSTALL_VARIABLES =&gt;
                                         [
                                         [ '$scalar'  =&gt; 42                 =&gt; $Eval::Context::PERSISTENT ] ,

                                         # make %hash and $hash available on the eval-side. both are
                                         # initialized from the same caller-side hash
                                         [ '%hash'    =&gt; \%hash_caller_side =&gt; $Eval::Context::PERSISTENT ] ,
                                         [ '$hash'    =&gt; \%hash_caller_side =&gt; $Eval::Context::PERSISTENT ] ,
                                         ],
                                 CODE =&gt; '$scalar++',
                                 ) ;

                 Later, use the persistent value:

                         $context-&gt;eval
                                 (
                                 INSTALL_VARIABLES =&gt;
                                         [
                                         [ '$scalar'  =&gt; $Eval::Context::USE =&gt; $Eval::Context::PERSISTENT ] ,
                                         # here you decided %hash and $hash shouldn't be available on the eval-side
                                         ],

                                 CODE =&gt; '$scalar',
                                 ) ;

                 <b>$Eval::Context::USE</b>  means  <u>"make</u> <u>the</u> <u>persistent</u> <u>variable</u> <u>and</u> <u>it's</u> <u>value</u> <u>available</u> <u>on</u> <u>the</u> <u>eval-</u>
                 <u>side"</u>.  Any other value will reinitialize the persistent variable. See  also  <b>REMOVE_PERSISTENT</b>
                 in "eval".

             •   Manually synchronizing caller-side data with persistent eval-side data

                 Although the first intent of persistent variables is to be used as state variables on the eval-
                 side,  you  can  get  persistent variables values on the caller-side. To change the value of an
                 <u>eval-side</u> persistent variable, simply reinitialize it with <b>INSTALL_VARIABLES</b> next time you call
                 "eval".

                         my $context = new Eval::Context
                                         (
                                         INSTALL_VARIABLES =&gt;
                                                 [
                                                 ['%hash' =&gt; \%hash_caller_side =&gt; $Eval::Context::PERSISTENT]
                                                 ] ,
                                         ) ;

                         $context-&gt;Eval(CODE =&gt; '$hash{A}++ ;') ;

                         # throws exception if you request a non existing variable
                         my %hash_after_eval = $context-&gt;GetPersistantVariables('%hash') ;

             •   Getting the list of all the PERSISTENT variables

                         my @persistent_variable_names = $context-&gt;GetPersistantVariablesNames() ;

             •   Creating persistent variables on the eval-side

                 The mechanism above gave you fine control over persistent  variables  on  the  <u>eval-side</u>.   The
                 negative  side  is  that  <b>only</b>  the  variables  you  made  persistent  exist  on the <u>eval-side</u>.
                 <b>Eval::Context</b> has another mechanism that  allows  the  <u>eval-side</u>  to  store  variables  between
                 evaluations without the <u>caller-side</u> declaration of the variables.

                 To allow the <u>eval-side</u> to store any variable, add this to you "new" call.

                         my $context = new Eval::Context
                                 (
                                 PACKAGE =&gt; 'my_package',

                                 EVAL_SIDE_PERSISTENT_VARIABLES =&gt;
                                         {
                                         SAVE =&gt; { NAME =&gt; 'SavePersistent', VALIDATOR =&gt; sub{} },
                                         GET  =&gt; { NAME =&gt; 'GetPersistent',  VALIDATOR =&gt; sub{} },
                                         },
                                 ) ;

                 The <u>eval-side</u> can now store variables between calls to "eval"

                         SavePersistent('name', $value) ;

                 later in another call to "eval":

                         my $variable = GetPersistent('name') ;

                 By  fine tuning <b>EVAL_SIDE_PERSISTENT_VARIABLES</b> you can control what variables are stored by the
                 <u>eval-side</u>. This should seldom be used and only to help those storing data from the <u>eval-side</u>.

                 You may have notices in the code above that a package name was passed  as  argument  to  "new".
                 This  is  very  important as the package names that are automatically generated differ for each
                 "eval" call. If you want to run all you <u>eval-side</u> code  in  different  packages  (<b>Eval::Context</b>
                 default  behavior),  you  must  tell <b>Eval::Context</b> where to store the <u>eval-side</u> values. This is
                 done by setting <b>CATEGORY</b>

                 The validator sub can verify if the value to be stored are valid, E.G.: variable name, variable
                 value is within range, ...

                 Here is an example of code run in different packages but can share  variables.  Only  variables
                 which names start with <u>A</u> are valid.

                         new Eval::Context
                                 (
                                 EVAL_SIDE_PERSISTENT_VARIABLES =&gt;
                                         {
                                         CATEGORY =&gt; 'TEST',
                                         SAVE =&gt;
                                                 {
                                                 NAME =&gt; 'SavePersistent',
                                                 VALIDATOR =&gt; sub
                                                         {
                                                         my ($self, $name, $value, $package) = @_ ;
                                                         $self-&gt;{INTERACTION}{DIE}-&gt;
                                                                 (
                                                                 $self,
                                                                 "SavePersistent: name '$name' doesn't start with A!"
                                                                 )  unless $name =~ /^A/ ;
                                                         },
                                                 },

                                         GET =&gt; {NAME =&gt; 'GetPersistent',VALIDATOR =&gt; sub {}},
                                         },
                                 ) ;

                         $context-&gt;eval(CODE =&gt; 'SavePersistent('A_variable', 123) ;') ;

                 later:

                         $context-&gt;eval(CODE =&gt; 'GetPersistent('A_variable') ;') ;

             •   Shared variables

                 You can also share references between the <u>caller-side</u> and the <u>eval-side</u>.

                         my $context =
                                 new Eval::Context
                                         (
                                         INSTALL_VARIABLES =&gt;
                                                 [
                                                 # reference to reference only
                                                 [ '$scalar' =&gt; \$scalar           =&gt; $Eval::Context::SHARED ],
                                                 [ '$hash'   =&gt; \%hash_caller_side =&gt; $Eval::Context::SHARED ],
                                                 [ '$object' =&gt; $object            =&gt; $Eval::Context::SHARED ],
                                                 ] ,
                                         ) ;

                 Modification  of  the  variables  on the <u>eval-side</u> will modify the variable on the <u>caller-side</u>.
                 There are but a few reasons to share references. Note that  you  can  share  references  to  <b>my</b>
                 variables.

         •   INTERACTION

             Lets you define subs used to interact with the user.

                     INTERACTION      =&gt;
                             {
                             INFO     =&gt; \&amp;sub,
                             WARN     =&gt; \&amp;sub,
                             DIE      =&gt; \&amp;sub,
                             EVAL_DIE =&gt; \&amp;sub,
                             }

             INFO - defaults to CORE::print
                   This sub will be used when displaying information.

             WARN - defaults to Carp::carp
                   This sub will be used when a warning is displayed.

             DIE - defaults to Carp::confess
                   Used when an error occurs.

             EVAL_DIE - defaults to Carp::confess, with a dump of the code to be evaluated
                   Used when an error occurs during code evaluation.

         •   FILE - the file where the object has been created.

             This is practical if you want to wrap the object.

             <b>FILE</b> and <b>LINE</b> will be set automatically if not set.

         •   LINE - the line where the object has been created. Set automatically if not set.

         •   DISPLAY_SOURCE_IN_CONTEXT - if set, the code to evaluated will be displayed before evaluation

       <u>Return</u>

       • an <b>Eval::Context</b> object.

   <b>[p]</b> <b>Setup</b>
       Helper sub called by new.

   <b>[p]</b> <b>CheckOptionNames</b>
       Verifies  the named options passed as arguments with a list of valid options. Calls <b>{INTERACTION}{DIE}</b> in
       case of error.

   <b>[p]</b> <b>SetInteractionDefault</b>
       Sets {INTERACTION} fields that are not set by the user.

   <b>[p]</b> <b>CanonizeName</b>
       Transform a string into a a string with can be used as a package name or file  name  usable  within  perl
       code.

   <b>eval(@named_arguments)</b>
       Evaluates Perl code, passed as a string or read from a file, in the context.

               my $context = new Eval::Context(PRE_CODE =&gt; "use strict;\nuse warnings;\n") ;

               $context-&gt;eval(CODE =&gt; 'print "evaluated in an Eval::Context!";') ;
               $context-&gt;eval(CODE_FROM_FILE =&gt; 'file.pl') ;

       <u>Call</u> <u>context</u>

       Evaluation context of the code (void, scalar, list) is the same as the context this subroutine was called
       in or in the context defined by <b>PERL_EVAL_CONTEXT</b> if that option is present.

       <u>Arguments</u>

       <b>NOTE:</b>  <b>You</b>  <b>can</b>  <b>override</b>  <b>any</b> <b>argument</b> <b>passed</b> <b>to</b> "new"<b>.</b> <b>The</b> <b>override</b> <b>is</b> <b>temporary</b> <b>during</b> <b>the</b> <b>duration</b> <b>of</b>
       <b>this</b> <b>call.</b>

       • @named_arguments - Any of "new" options plus the following.

         •   CODE - a string containing perl code (valid code or an exception is raised)

         •   CODE_FROM_FILE - a file containing  perl code

         •   REMOVE_PERSISTENT

             A list of regex used to match the persistent variable names  to  be  removed,  persistent  variable
             removal is done before any variable installation is done

         •   FILE and LINE - will be used in the evaluated code 'file_name' set to the caller's file and line by
             default

         NOTE: <b>CODE</b> or <b>CODE_FROM_FILE</b> is <b>mandatory</b>.

       <u>Return</u>

       • What the code to be evaluated returns

   <b>[p]</b> <b>VerifyAndCompleteOptions</b>
       Helper sub for "eval".

   <b>[p]</b> <b>EvalCleanup</b>
       Handles the package cleanup or persistent variables cleanup after a call to "eval".

   <b>[p]</b> <b>GetPackageName</b>
       Returns  a  canonized  package name. the name is either passed as argument from the caller or a temporary
       package name.

   <b>[p]</b> <b>EvalSetup</b>
       Handles the setup of the context before <u>eval-side</u> code is evaluated. Sets the variables  and  the  shared
       subroutines.

   <b>[p]</b> <b>VerifyCodeInput</b>
       Verify that <b>CODE</b> or <b>CODE_FROM_FILE</b> are properly set.

   <b>[p]</b> <b>RemovePersistent</b>
       Handles the removal of persistent variables.

   <b>[p]</b> <b>GetCallContextWrapper</b>
       Generates perl code to wrap the code to be evaluated in the right calling context.

   <b>[p]</b> <b>SetupSafeCompartment</b>
       If  running  in  safe  mode, setup a safe compartment from the argument, otherwise defines the evaluation
       package.

   <b>[p]</b> <b>GetInstalledVariablesCode</b>
       Generates variables on the eval-side from the INSTALL_VARIABLES definitions.  Dispatches  the  generation
       to specialize subroutines.

   <b>[p]</b> <b>GetPersistentVariablesSetFromCaller</b>
       Generates code to make persistent variables, defined on the <u>caller-side</u> available on the <u>eval-side</u>.

   <b>[p]</b> <b>GetSharedVariablesSetFromCaller</b>
       Handles the mechanism used to share variables (references) between the <u>caller-side</u> and the <u>eval-side</u>.

       Shared  variables  must be defined and references. If the shared variable is <b>undef</b>, the variable that was
       previously shared, under the passed name, is used if it exists or an exception is raised.

       Also check that variables are not <b>PERSISTENT</b> and <b>SHARED</b>.

   <b>[p]</b> <b>GetVariablesSetFromCaller</b>
       Generates code that creates local variables on the <u>eval-side</u>

   <b>GetPersistentVariableNames()</b>
       <u>Arguments</u> - none

       <u>Returns</u> - the list of existing persistent variables names

               my @persistent_variable_names = $context-&gt;GetPersistantVariablesNames() ;

   <b>GetPersistantVariables(@variable_names)</b>
       <u>Arguments</u>

       • @variable_names - list of variable names to retrieve

       <u>Returns</u> - list of values corresponding to the input names

       This subroutine will return whatever the <u>caller-site</u> set or the <u>eval-side</u> modified. Thus if you created a
       <u>%hash</u> persistent variable, a hash (not a hash reference) will be returned.

       If you request multiple values, list flattening will be in effect. Be careful.

               my $context = new Eval::Context
                               (
                               INSTALL_VARIABLES =&gt;
                                       [
                                       ['%hash' =&gt; \%hash_caller_side =&gt; $Eval::Context::PERSISTENT]
                                       ] ,
                               ) ;

               $context-&gt;Eval(CODE =&gt; '$hash{A}++ ;') ;

               # may throw exception
               my %hash_after_eval = $context-&gt;GetPersistantVariables('%hash') ;

   <b>[p]</b> <b>SetEvalSidePersistenceHandlers</b>
       Set the code needed to handle <u>eval-side</u> persistent variables.

   <b>[p]</b> <b>RemoveEvalSidePersistenceHandlers</b>
       Removes <u>eval-side</u> persistent variable handlers. Used after calling "eval" so  the  next  "eval"  can  not
       access <u>eval-side</u> persistent variables without being allowed to do so.

</pre><h4><b>BUGS</b> <b>AND</b> <b>LIMITATIONS</b></h4><pre>
       I    have    reported    a    very    strange   error   when   <b>Safe</b>   and   <b>Carp</b>   are   used   together.
       &lt;<a href="http://rt.cpan.org/Ticket/Display.html">http://rt.cpan.org/Ticket/Display.html</a>?id=31090&gt;.  The   error   can   be   reproduced   without   using
       <b>Eval::Context</b>.

</pre><h4><b>AUTHOR</b></h4><pre>
               Khemir Nadim ibn Hamouda
               CPAN ID: NKH
               <a href="mailto:nadim@khemir.net">mailto:nadim@khemir.net</a>

</pre><h4><b>LICENSE</b> <b>AND</b> <b>COPYRIGHT</b></h4><pre>
       This  program  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself.

</pre><h4><b>SUPPORT</b></h4><pre>
       You can find documentation for this module with the perldoc command.

           perldoc Eval::Context

       You can also look for information at:

       •   AnnoCPAN: Annotated CPAN documentation

           &lt;<a href="http://annocpan.org/dist/Eval-Context">http://annocpan.org/dist/Eval-Context</a>&gt;

       •   RT: CPAN's request tracker

           Please report any bugs or feature requests to  L &lt;<a href="mailto:bug-eval-context@rt.cpan.org">bug-eval-context@rt.cpan.org</a>&gt;.

           We will be notified, and then you'll automatically be notified of progress on your  bug  as  we  make
           changes.

       •   Search CPAN

           &lt;<a href="http://search.cpan.org/dist/Eval-Context">http://search.cpan.org/dist/Eval-Context</a>&gt;

perl v5.38.2                                       2024-08-07                                 <u>Eval::<a href="../man3pm/Context.3pm.html">Context</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>