<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Catalyst::Utils - The Catalyst Utils</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcatalyst-perl">libcatalyst-perl_5.90132-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Catalyst::Utils - The Catalyst Utils

</pre><h4><b>SYNOPSIS</b></h4><pre>
       See Catalyst.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Catalyst Utilities.

</pre><h4><b>METHODS</b></h4><pre>
   <b>appprefix($class)</b>
           MyApp::Foo becomes myapp_foo

   <b>class2appclass($class);</b>
           MyApp::Controller::Foo::Bar becomes MyApp
           My::App::Controller::Foo::Bar becomes My::App

   <b>class2classprefix($class);</b>
           MyApp::Controller::Foo::Bar becomes MyApp::Controller
           My::App::Controller::Foo::Bar becomes My::App::Controller

   <b>class2classsuffix($class);</b>
           MyApp::Controller::Foo::Bar becomes Controller::Foo::Bar

   <b>class2env($class);</b>
       Returns the environment name for class.

           MyApp becomes MYAPP
           My::App becomes MY_APP

   <b>class2prefix(</b> <b>$class,</b> <b>$case</b> <b>);</b>
       Returns the uri prefix for a class. If case is false the prefix is converted to lowercase.

           My::App::Controller::Foo::Bar becomes foo/bar

   <b>class2tempdir(</b> <b>$class</b> <b>[,</b> <b>$create</b> <b>]</b> <b>);</b>
       Returns a tempdir for a class. If create is true it will try to create the path.

           My::App becomes /tmp/my/app
           My::App::Controller::Foo::Bar becomes /tmp/my/app/c/foo/bar

   <b>home($class)</b>
       Returns home directory for given class.

   <b>dist_indicator_file_list</b>
       Returns a list of files which can be tested to check if you're inside a CPAN distribution which is not
       yet installed.

       These are:

       Makefile.PL
       Build.PL
       dist.ini
       cpanfile

   <b>prefix($class,</b> <b>$name);</b>
       Returns a prefixed action.

           MyApp::Controller::Foo::Bar, yada becomes foo/bar/yada

   <b>request($uri)</b>
       Returns an HTTP::Request object for a uri.

   <b>ensure_class_loaded($class_name,</b> <b>\%opts)</b>
       Loads the class unless it already has been loaded.

       If  $opts{ignore_loaded} is true always tries the require whether the package already exists or not. Only
       pass this if you're either (a) sure you know the file exists on disk or (b) have code to catch  the  file
       not found exception that will result if it doesn't.

   <b>merge_hashes($hashref,</b> <b>$hashref)</b>
       Base code to recursively merge two hashes together with right-hand precedence.

   <b>env_value($class,</b> <b>$key)</b>
       Checks for and returns an environment value. For instance, if $key is 'home', then this method will check
       for and return the first value it finds, looking at $ENV{MYAPP_HOME} and $ENV{CATALYST_HOME}.

   <b>term_width</b>
       Try to guess terminal width to use with formatting of debug output

       All you need to get this work, is:

       1) Install Term::Size::Any, or

       2) Export $COLUMNS from your shell.

       (Warning  to bash users: 'echo $COLUMNS' may be showing you the bash variable, not $ENV{COLUMNS}. 'export
       COLUMNS=$COLUMNS' and you should see that 'env' now lists COLUMNS.)

       As last resort, default value of 80 chars will be used.

       Calling "term_width" with a true value will cause it to be recalculated; you can use this to cause it  to
       get recalculated when your terminal is resized like this

        $SIG{WINCH} = sub { Catalyst::Utils::<a href="../man1/term_width.1.html">term_width</a>(1) };

   <b>resolve_namespace</b>
       Method which adds the namespace for plugins and actions.

         __PACKAGE__-&gt;setup(qw(MyPlugin));

         # will load Catalyst::Plugin::MyPlugin

   <b>build_middleware</b> <b>(@args)</b>
       Internal  application  that  converts  a single middleware definition (see "psgi_middleware" in Catalyst)
       into an actual instance of middleware.

   <b>apply_registered_middleware</b> <b>($psgi)</b>
       Given a $psgi reference, wrap all the "registered_middlewares" in  Catalyst  around  it  and  return  the
       wrapped version.

       This  exists  to  deal  with  the fact Catalyst registered middleware can be either an object with a wrap
       method or a coderef.

   <b>inject_component</b>
       Used to add components at runtime:

           into        The Catalyst package to inject into (e.g. My::App)
           component   The component package to inject
           traits      (Optional) ArrayRef of L&lt;Moose::Role&gt;s that the component should consume.
           as          An optional moniker to use as the package name for the derived component

       For example:

           Catalyst::Utils::inject_component( into =&gt; My::App, component =&gt; Other::App::Controller::Apple )

               The above will create 'My::App::Controller::Other::App::Controller::Apple'

           Catalyst::Utils::inject_component( into =&gt; My::App, component =&gt; Other::App::Controller::Apple, as =&gt; Apple )

               The above will create 'My::App::Controller::Apple'

           Catalyst::Utils::inject_component( into =&gt; $myapp, component =&gt; 'MyRootV', as =&gt; 'Controller::Root' );

       Will inject Controller, Model, and View components into your Catalyst application at setup (run)time.  It
       does  this by creating a new package on-the-fly, having that package extend the given component, and then
       having Catalyst setup the new component (via $app-&gt;setup_component).

       <b>NOTE:</b> This is basically a core version of CatalystX::InjectComponent.  If you were using that you can now
       use this safely instead.  Going forward changes required to make this work will be synchronized with  the
       core method.

       <b>NOTE:</b> The 'traits' option is unique to the Catalyst::Utils version of this feature.

       <b>NOTE:</b> These injected components really need to be a Catalyst::Component and a Moose based class.

</pre><h4><b>PSGI</b> <b>Helpers</b></h4><pre>
       Utility functions to make it easier to work with PSGI applications under Catalyst

   <b>env_at_path_prefix</b>
       Localize $env under the current controller path prefix:

           package MyApp::Controller::User;

           use Catalyst::Utils;

           use base 'Catalyst::Controller';

           sub name :Local {
             my ($self, $c) = @_;
             my $env = $c-&gt;Catalyst::Utils::env_at_path_prefix;
           }

       Assuming you have a request like GET /user/name:

       In  the example case $env will have PATH_INFO of '/name' instead of '/user/name' and SCRIPT_NAME will now
       be '/user'.

   <b>env_at_action</b>
       Localize $env under the current action namespace.

           package MyApp::Controller::User;

           use Catalyst::Utils;

           use base 'Catalyst::Controller';

           sub name :Local {
             my ($self, $c) = @_;
             my $env = $c-&gt;Catalyst::Utils::env_at_action;
           }

       Assuming you have a request like GET /user/name:

       In the example case $env will have PATH_INFO of '/' instead of '/user/name' and SCRIPT_NAME will  now  be
       '/user/name'.

       Alternatively, assuming you have a request like GET /user/name/foo:

       In  this example case $env will have PATH_INFO of '/foo' instead of '/user/name/foo' and SCRIPT_NAME will
       now be '/user/name'.

       This is probably a common case where you want to mount a PSGI application under an  action  but  let  the
       Args fall through to the PSGI app.

   <b>env_at_request_uri</b>
       Localize $env under the current request URI:

           package MyApp::Controller::User;

           use Catalyst::Utils;

           use base 'Catalyst::Controller';

           sub name :Local <a href="../man1/Args.1.html">Args</a>(1) {
             my ($self, $c, $id) = @_;
             my $env = $c-&gt;Catalyst::Utils::env_at_request_uri
           }

       Assuming you have a request like GET /user/name/hello:

       In  the  example case $env will have PATH_INFO of '/' instead of '/user/name' and SCRIPT_NAME will now be
       '/user/name/hello'.

</pre><h4><b>AUTHORS</b></h4><pre>
       Catalyst Contributors, see Catalyst.pm

</pre><h4><b>COPYRIGHT</b></h4><pre>
       This library is free software. You can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.

perl v5.40.0                                       2024-11-15                               <u>Catalyst::<a href="../man3pm/Utils.3pm.html">Utils</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>