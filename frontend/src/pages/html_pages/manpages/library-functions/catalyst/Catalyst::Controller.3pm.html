<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Catalyst::Controller - Catalyst Controller base class</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcatalyst-perl">libcatalyst-perl_5.90132-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Catalyst::Controller - Catalyst Controller base class

</pre><h4><b>SYNOPSIS</b></h4><pre>
         package MyApp::Controller::Search
         use base qw/Catalyst::Controller/;

         sub foo : Local {
           my ($self,$c,@args) = @_;
           ...
         } # Dispatches to /search/foo

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Controllers are where the actions in the Catalyst framework reside. Each action is represented by a
       function with an attribute to identify what kind of action it is. See the Catalyst::Dispatcher for more
       info about how Catalyst dispatches to actions.

</pre><h4><b>CONFIGURATION</b></h4><pre>
       Like any other Catalyst::Component, controllers have a config hash, accessible through $self-&gt;config from
       the controller actions.  Some settings are in use by the Catalyst framework:

   <b>namespace</b>
       This specifies the internal namespace the controller should be bound to. By default the controller is
       bound to the URI version of the controller name. For instance controller 'MyApp::Controller::Foo::Bar'
       will be bound to 'foo/bar'. The default Root controller is an example of setting namespace to '' (the
       null string).

   <b>path</b>
       Sets 'path_prefix', as described below.

   <b>action</b>
       Allows you to set the attributes that the dispatcher creates actions out of.  This allows you to do
       'rails style routes', or override some of the attribute definitions of actions composed from Roles.  You
       can set arguments globally (for all actions of the controller) and specifically (for a single action).

           __PACKAGE__-&gt;config(
               action =&gt; {
                   '*' =&gt; { Chained =&gt; 'base', Args =&gt; 0  },
                   base =&gt; { Chained =&gt; '/', PathPart =&gt; '', CaptureArgs =&gt; 0 },
               },
            );

       In the case above every sub in the package would be made into a Chain endpoint with a URI the same as the
       sub name for each sub, chained to the sub named "base". Ergo dispatch to "/example" would call the "base"
       method, then the "example" method.

   <b>action_args</b>
       Allows you to set constructor arguments on your actions. You can set arguments globally and specifically
       (as above).  This is particularly useful when using "ActionRole"s (Catalyst::Controller::ActionRole) and
       custom "ActionClass"es.

           __PACKAGE__-&gt;config(
               action_args =&gt; {
                   '*' =&gt; { globalarg1 =&gt; 'hello', globalarg2 =&gt; 'goodbye' },
                   'specific_action' =&gt; { customarg =&gt; 'arg1' },
               },
            );

       In the case above the action class associated with "specific_action" would get passed the following
       arguments, in addition to the normal action constructor arguments, when it is instantiated:

         (globalarg1 =&gt; 'hello', globalarg2 =&gt; 'goodbye', customarg =&gt; 'arg1')

</pre><h4><b>METHODS</b></h4><pre>
   <b>BUILDARGS</b> <b>($app,</b> <b>@args)</b>
       From Catalyst::Component::ApplicationAttribute, stashes the application instance as $self-&gt;_application.

   <b>$self-&gt;action_for($action_name)</b>
       Returns the Catalyst::Action object (if any) for a given action in this controller or relative to it.
       You may refer to actions in controllers nested under the current controllers namespace, or in controllers
       'up' from the current controller namespace.  For example:

           package MyApp::Controller::One::Two;
           use base 'Catalyst::Controller';

           sub foo :Local {
             my ($self, $c) = @_;
             $self-&gt;action_for('foo'); # action 'foo' in Controller 'One::Two'
             $self-&gt;action_for('three/bar'); # action 'bar' in Controller 'One::Two::Three'
             $self-&gt;action_for('../boo'); # action 'boo' in Controller 'One'
           }

       This returns 'undef' if there is no action matching the requested action name (after any path
       normalization) so you should check for this as needed.

   <b>$self-&gt;action_namespace($c)</b>
       Returns the private namespace for actions in this component. Defaults to a value from the controller name
       (for e.g. MyApp::Controller::Foo::Bar becomes "foo/bar") or can be overridden from the "namespace" config
       key.

   <b>$self-&gt;path_prefix($c)</b>
       Returns the default path prefix for :PathPrefix, :Local and relative :Path actions in this component.
       Defaults to the action_namespace or can be overridden from the "path" config key.

   <b>$self-&gt;register_actions($c)</b>
       Finds all applicable actions for this component, creates Catalyst::Action objects (using
       $self-&gt;create_action) for them and registers them with $c-&gt;dispatcher.

   <b>$self-&gt;get_action_methods()</b>
       Returns a list of Moose::Meta::Method objects, doing the MooseX::MethodAttributes::Role::Meta::Method
       role, which are the set of action methods for this package.

   <b>$self-&gt;register_action_methods($c,</b> <b>@methods)</b>
       Creates action objects for a set of action methods using " create_action ", and registers them with the
       dispatcher.

   <b>$self-&gt;action_class(%args)</b>
       Used when a controller is creating an action to determine the correct base action class to use.

   <b>$self-&gt;create_action(%args)</b>
       Called with a hash of data to be use for construction of a new Catalyst::Action (or appropriate
       sub/alternative class) object.

   <b>$self-&gt;gather_action_roles(\%action_args)</b>
       Gathers the list of roles to apply to an action with the given %action_args.

   <b>$self-&gt;gather_default_action_roles(\%action_args)</b>
       returns a list of action roles to be applied based on core, builtin rules.  Currently only the
       Catalyst::ActionRole::HTTPMethods role is applied this way.

   <b>$self-&gt;_application</b>
   <b>$self-&gt;_app</b>
       Returns the application instance stored by new()

</pre><h4><b>ACTION</b> <b>SUBROUTINE</b> <b>ATTRIBUTES</b></h4><pre>
       Please see Catalyst::Manual::Intro for more details

       Think of action attributes as a sort of way to record metadata about an action, similar to how
       annotations work in other languages you might have heard of.  Generally Catalyst uses these to influence
       how the dispatcher sees your action and when it will run it in response to an incoming request.  They can
       also be used for other things.  Here's a summary, but you should refer to the linked manual page for
       additional help.

   <b>Global</b>
         sub homepage :Global { ... }

       A global action defined in any controller always runs relative to your root.  So the above is the same
       as:

         sub myaction :Path("/homepage") { ... }

   <b>Absolute</b>
       Status: Deprecated alias to "Global".

   <b>Local</b>
       Alias to "Path("$action_name").  The following two actions are the same:

         sub myaction :Local { ... }
         sub myaction :Path('myaction') { ... }

   <b>Relative</b>
       Status: Deprecated alias to "Local"

   <b>Path</b>
       Handle various types of paths:

         package MyApp::Controller::Baz {

           ...

           sub myaction1 :Path { ... }  # -&gt; /baz
           sub myaction2 :Path('foo') { ... } # -&gt; /baz/foo
           sub myaction2 :Path('/bar') { ... } # -&gt; /bar
         }

       This is a general toolbox for attaching your action to a given path.

   <b>Regex</b>
   <b>Regexp</b>
       <b>Status:</b> <b>Deprecated.</b>  Use Chained methods or other techniques.  If you really depend on this, install the
       standalone Catalyst::DispatchType::Regex distribution.

       A global way to match a give regular expression in the incoming request path.

   <b>LocalRegex</b>
   <b>LocalRegexp</b>
       <b>Status:</b> <b>Deprecated.</b>  Use Chained methods or other techniques.  If you really depend on this, install the
       standalone Catalyst::DispatchType::Regex distribution.

       Like "Regex" but scoped under the namespace of the containing controller

   <b>Chained</b>
   <b>ChainedParent</b>
   <b>PathPrefix</b>
   <b>PathPart</b>
   <b>CaptureArgs</b>
       Allowed values for CaptureArgs is a single integer (<b><a href="../man2/CaptureArgs.2.html">CaptureArgs</a></b>(2), meaning two allowed) or you can
       declare a Moose, MooseX::Types or Type::Tiny named constraint such as CaptureArgs(Int,Str) would require
       two args with the first being a Integer and the second a string.  You may declare your own custom type
       constraints and import them into the controller namespace:

           package MyApp::Controller::Root;

           use Moose;
           use MooseX::MethodAttributes;
           use MyApp::Types qw/Int/;

           extends 'Catalyst::Controller';

           sub chain_base :Chained(/) <a href="../man1/CaptureArgs.1.html">CaptureArgs</a>(1) { }

             sub any_priority_chain :Chained(chain_base) PathPart('') <a href="../man1/Args.1.html">Args</a>(1) { }

             sub int_priority_chain :Chained(chain_base) PathPart('') Args(Int) { }

       See Catalyst::RouteMatching for more.

       Please see Catalyst::DispatchType::Chained for more.

   <b>ActionClass</b>
       Set the base class for the action, defaults to "Catalyst::Action".  It is now preferred to use "Does".

   <b>MyAction</b>
       Set the ActionClass using a custom Action in your project namespace.

       The following is exactly the same:

           sub foo_action1 : Local ActionClass('+MyApp::Action::Bar') { ... }
           sub foo_action2 : Local MyAction('Bar') { ... }

   <b>Does</b>
           package MyApp::Controller::Zoo;

           sub foo  : Local Does('Buzz')  { ... } # Catalyst::ActionRole::
           sub bar  : Local Does('~Buzz') { ... } # MyApp::ActionRole::Buzz
           sub baz  : Local Does('+MyApp::ActionRole::Buzz') { ... }

   <b>GET</b>
   <b>POST</b>
   <b>PUT</b>
   <b>DELETE</b>
   <b>OPTION</b>
   <b>HEAD</b>
   <b>PATCH</b>
   <b>Method('...')</b>
       Sets the give action path to match the specified HTTP method, or via one of the broadly accepted methods
       of overriding the 'true' method (see Catalyst::ActionRole::HTTPMethods).

   <b>Args</b>
       When used with "Path" indicates the number of arguments expected in the path.  However if no Args value
       is set, assumed to 'slurp' all remaining path pars under this namespace.

       Allowed values for Args is a single integer (<b><a href="../man2/Args.2.html">Args</a></b>(2), meaning two allowed) or you can declare a Moose,
       MooseX::Types or Type::Tiny named constraint such as Args(Int,Str) would require two args with the first
       being a Integer and the second a string.  You may declare your own custom type constraints and import
       them into the controller namespace:

           package MyApp::Controller::Root;

           use Moose;
           use MooseX::MethodAttributes;
           use MyApp::Types qw/Tuple Int Str StrMatch UserId/;

           extends 'Catalyst::Controller';

           sub user :Local Args(UserId) {
             my ($self, $c, $int) = @_;
           }

           sub an_int :Local Args(Int) {
             my ($self, $c, $int) = @_;
           }

           sub many_ints :Local Args(ArrayRef[Int]) {
             my ($self, $c, @ints) = @_;
           }

           sub match :Local Args(StrMatch[qr{\d\d-\d\d-\d\d}]) {
             my ($self, $c, $int) = @_;
           }

       If you choose not to use imported type constraints (like Type::Tiny, or &lt;MooseX::Types&gt; you may use Moose
       'stringy' types however just like when you use these types in your declared attributes you must quote
       them:

           sub my_moose_type :Local Args('Int') { ... }

       If you use 'reference' type constraints (such as ArrayRef[Int]) that have an unknown number of allowed
       matches, we set this the same way "Args" is.  Please keep in mind that actions with an undetermined
       number of args match at lower precedence than those with a fixed number.  You may use reference types
       such as Tuple from Types::Standard that allows you to fix the number of allowed args.  For example
       Args(Tuple[Int,Int]) would be determined to be two args (or really the same as Args(Int,Int).)  You may
       find this useful for creating custom subtypes with complex matching rules that you wish to reuse over
       many actions.

       See Catalyst::RouteMatching for more.

       <b>Note</b>: It is highly recommended to use Type::Tiny for your type constraints over other options.
       Type::Tiny exposed a better meta data interface which allows us to do more and better types of
       introspection driving tests and debugging.

   <b>Consumes('...')</b>
       Matches the current action against the content-type of the request.  Typically this is used when the
       request is a POST or PUT and you want to restrict the submitted content type.  For example, you might
       have an HTML for that either returns classic url encoded form data, or JSON when Javascript is enabled.
       In this case you may wish to match either incoming type to one of two different actions, for properly
       processing.

       Examples:

           sub is_json       : Chained('start') Consumes('application/json') { ... }
           sub is_urlencoded : Chained('start') Consumes('application/x-www-form-urlencoded') { ... }
           sub is_multipart  : Chained('start') Consumes('multipart/form-data') { ... }

       To reduce boilerplate, we include the following content type shortcuts:

       Examples

             sub is_json       : Chained('start') Consume(JSON) { ... }
             sub is_urlencoded : Chained('start') Consumes(UrlEncoded) { ... }
             sub is_multipart  : Chained('start') Consumes(Multipart) { ... }

       You may specify more than one match:

             sub is_more_than_one
               : Chained('start')
               : Consumes('application/x-www-form-urlencoded')
               : Consumes('multipart/form-data')

             sub is_more_than_one
               : Chained('start')
               : Consumes(UrlEncoded)
               : Consumes(Multipart)

       Since it is a common case the shortcut "HTMLForm" matches both 'application/x-www-form-urlencoded' and
       'multipart/form-data'.  Here's the full list of available shortcuts:

           JSON =&gt; 'application/json',
           JS =&gt; 'application/javascript',
           PERL =&gt; 'application/perl',
           HTML =&gt; 'text/html',
           XML =&gt; 'text/XML',
           Plain =&gt; 'text/plain',
           UrlEncoded =&gt; 'application/x-www-form-urlencoded',
           Multipart =&gt; 'multipart/form-data',
           HTMLForm =&gt; ['application/x-www-form-urlencoded','multipart/form-data'],

       Please keep in mind that when dispatching, Catalyst will match the first most relevant case, so if you
       use the "Consumes" attribute, you should place your most accurate matches early in the Chain, and your
       'catchall' actions last.

       See Catalyst::ActionRole::ConsumesContent for more.

   <b>Scheme(...)</b>
       Allows you to specify a URI scheme for the action or action chain.  For example you can required that a
       given path be "https" or that it is a websocket endpoint "ws" or "wss".  For an action chain you may
       currently only have one defined Scheme.

           package MyApp::Controller::Root;

           use base 'Catalyst::Controller';

           sub is_http :Path(scheme) Scheme(http) <a href="../man0/Args.0.html">Args</a>(0) {
             my ($self, $c) = @_;
             $c-&gt;response-&gt;body("is_http");
           }

           sub is_https :Path(scheme) Scheme(https) <a href="../man0/Args.0.html">Args</a>(0)  {
             my ($self, $c) = @_;
             $c-&gt;response-&gt;body("is_https");
           }

       In the above example <a href="http://localhost/root/scheme">http://localhost/root/scheme</a> would match the first action (is_http) but
       https://localhost/root/scheme would match the second.

       As an added benefit, if an action or action chain defines a Scheme, when using $c-&gt;uri_for the scheme of
       the generated URL will use what you define in the action or action chain (the current behavior is to set
       the scheme based on the current incoming request).  This makes it easier to use uri_for on websites where
       some paths are secure and others are not.  You may also use this to other schemes like websockets.

       See Catalyst::ActionRole::Scheme for more.

</pre><h4><b>OPTIONAL</b> <b>METHODS</b></h4><pre>
   <b>_parse_[$name]_attr</b>
       Allows you to customize parsing of subroutine attributes.

           sub myaction1 :Path TwoArgs { ... }

           sub _parse_TwoArgs_attr {
             my ( $self, $c, $name, $value ) = @_;
             # $self -&gt; controller instance
             #
             return(Args =&gt; 2);
           }

       Please note that this feature does not let you actually assign new functions to actions via subroutine
       attributes, but is really more for creating useful aliases to existing core and extended attributes, and
       transforms based on existing information (like from configuration).  Code for actually doing something
       meaningful with the subroutine attributes will be located in the Catalyst::Action classes (or your
       subclasses), Catalyst::Dispatcher and in subclasses of Catalyst::DispatchType.  Remember these methods
       only get called basically once when the application is starting, not per request!

</pre><h4><b>AUTHORS</b></h4><pre>
       Catalyst Contributors, see Catalyst.pm

</pre><h4><b>COPYRIGHT</b></h4><pre>
       This library is free software. You can redistribute it and/or modify it under the same terms as Perl
       itself.

perl v5.40.0                                       2024-11-15                          <u>Catalyst::<a href="../man3pm/Controller.3pm.html">Controller</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>