<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mail::Message::Field - one line of a message header</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmail-message-perl">libmail-message-perl_3.017-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Mail::Message::Field - one line of a message header

</pre><h4><b>INHERITANCE</b></h4><pre>
        Mail::Message::Field
          is a Mail::Reporter

        Mail::Message::Field is extended by
          Mail::Message::Field::Fast
          Mail::Message::Field::Flex
          Mail::Message::Field::Full

</pre><h4><b>SYNOPSIS</b></h4><pre>
        my $field = Mail::Message::Field-&gt;new(From =&gt; '<a href="mailto:fish@tux.aq">fish@tux.aq</a>');
        print $field-&gt;name;
        print $field-&gt;body;
        print $field-&gt;comment;
        print $field-&gt;content;  # body &amp; comment
        $field-&gt;print(\*OUT);
        print $field-&gt;string;
        print "$field\n";
        print $field-&gt;attribute('charset') || 'us-ascii';

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This implementation follows the guidelines of rfc2822 as close as possible, and may there produce a
       different output than implementations based on the obsolete rfc822.  However, the old output will still
       be accepted.

       These objects each store one header line, and facilitates access routines to the information hidden in
       it.  Also, you may want to have a look at the added methods of a message:

        my @from    = $message-&gt;from;
        my $sender  = $message-&gt;sender;
        my $subject = $message-&gt;subject;
        my $msgid   = $message-&gt;messageId;

        my @to      = $message-&gt;to;
        my @cc      = $message-&gt;cc;
        my @bcc     = $message-&gt;bcc;
        my @dest    = $message-&gt;destinations;

        my $other   = $message-&gt;get('Reply-To');

       Extends "DESCRIPTION" in Mail::Reporter.

</pre><h4><b>OVERLOADED</b></h4><pre>
       overload: <b>""</b>
           (stringification)  produces  the  unfolded  body of the field, which may be what you expect.  This is
           what makes what  the  field  object  seems  to  be  a  simple  string.  The  string  is  produced  by
           <b>unfoldedBody()</b>.

           example:

            print $msg-&gt;get('subject');  # via overloading
            print $msg-&gt;get('subject')-&gt;unfoldedBody; # same

            my $subject = $msg-&gt;get('subject') || 'your mail';
            print "Re: $subject\n";

       overload: <b>0+</b>
           (numification)  When  the  field  is  numeric, the value will be returned.  The result is produced by
           <b>toInt()</b>.  If the value is not correct, a 0 is produced, to simplify calculations.

       overload: <b>&lt;=</b>&gt;
           (numeric comparison) Compare the integer field contents with something else.

           example:

            if($msg-&gt;get('Content-Length') &gt; 10000) ...
            if($msg-&gt;size &gt; 10000) ... ; # same, but better

       overload: <b>bool</b>
           Always true, to make it possible to say if($field).

       overload: <b>cmp</b>
           (string comparison) Compare the unfolded body of a field with another field or a  string,  using  the
           buildin "cmp".

</pre><h4><b>METHODS</b></h4><pre>
       Extends "METHODS" in Mail::Reporter.

   <b>Constructors</b>
       Extends "Constructors" in Mail::Reporter.

       $obj-&gt;<b>clone</b>()
           Create a copy of this field object.

       Mail::Message::Field-&gt;<b>new</b>($data)
           See         <b>Mail::Message::Field::Fast::new()</b>,         <b>Mail::Message::Field::Flex::new()</b>,         and
           <b>Mail::Message::Field::Full::new()</b>.  By default, a "Fast" field is produced.

            -Option--Defined in     --Default
             log     Mail::Reporter   'WARNINGS'
             trace   Mail::Reporter   'WARNINGS'

           log =&gt; LEVEL
           trace =&gt; LEVEL

   <b>The</b> <b>field</b>
       $obj-&gt;<b>isStructured</b>()
       Mail::Message::Field-&gt;<b>isStructured</b>()
           Some fields are described in the RFCs as being <u>structured</u>: having a  well  described  syntax.   These
           fields  have  common  ideas  about  comments  and  the like, what they do not share with unstructured
           fields, like the "Subject" field.

           example:

            my $field = Mail::Message::Field-&gt;new(From =&gt; 'me');
            if($field-&gt;isStructured)

            Mail::Message::Field-&gt;isStructured('From');

       $obj-&gt;<b>length</b>()
           Returns the total length of the field in characters,  which  includes  the  field's  name,  body  and
           folding characters.

       $obj-&gt;<b>nrLines</b>()
           Returns the number of lines needed to display this header-line.

       $obj-&gt;<b>print</b>( [$fh] )
           Print  the  whole  header-line  to  the  specified  file-handle. One line may result in more than one
           printed line, because of the folding of long lines.  The $fh defaults to the selected handle.

       $obj-&gt;<b>size</b>()
           Returns the number of bytes needed to display this header-line, Same as <b>length()</b>.

       $obj-&gt;<b>string</b>( [$wrap] )
           Returns the field as string.  By default, this returns the same as <b>folded()</b>.  However,  the  optional
           $wrap will cause to re-fold to take place (without changing the folding stored inside the field).

       $obj-&gt;<b>toDisclose</b>()
           Returns whether this field can be disclosed to other people, for instance when sending the message to
           another      party.      Returns     a     "true"     or     "false"     condition.      See     also
           <b>Mail::Message::Head::Complete::printUndisclosed()</b>.

   <b>Access</b> <b>to</b> <b>the</b> <b>name</b>
       $obj-&gt;<b>Name</b>()
           Returns the name of this field in original casing.  See <b>name()</b> as well.

       $obj-&gt;<b>name</b>()
           Returns the name of this field, with all characters lower-cased for ease of comparison.   See  <b>Name()</b>
           as well.

       $obj-&gt;<b>wellformedName</b>( [STRING] )
           (Instance  method  class  method) As instance method, the current field's name is correctly formatted
           and returned.  When a STRING is used, that one is formatted.

           example:

            print Mail::Message::Field-&gt;Name('content-type')
              # --&gt;  Content-Type

            my $field = $head-&gt;get('date');
            print $field-&gt;Name;
              # --&gt;  Date

   <b>Access</b> <b>to</b> <b>the</b> <b>body</b>
       $obj-&gt;<b>body</b>()
           This method may be what you want, but usually, the <b>foldedBody()</b> and <b>unfoldedBody()</b> are what  you  are
           looking for.  This method is cultural heritage, and should be avoided.

           Returns  the  body  of the field.  When this field is structured, it will be <b>stripped</b> from everything
           what is behind the first semi-color (";").  In any case, the string is unfolded.  Whether  the  field
           is structured is defined by <b>isStructured()</b>.

       $obj-&gt;<b>folded</b>()
           Returns  the  folded version of the whole header.  When the header is shorter than the wrap length, a
           list of one line is returned.  Otherwise more lines will be returned, all but the first starting with
           at least one blank.  See also <b>foldedBody()</b> to get the same information without the field's name.

           In scalar context, the lines are delived into one string, which is a little faster because that's the
           way they are stored internally...

           example:

            my @lines = $field-&gt;folded;
            print $field-&gt;folded;
            print scalar $field-&gt;folded; # faster

       $obj-&gt;<b>foldedBody</b>( [$body] )
           Returns the body as a set of lines. In scalar context, this will be one line containing newlines.  Be
           warned about the newlines when you do pattern matching on the result of this method.

           The optional $body argument changes the field's body.  The folding of the argument must be correct.

       $obj-&gt;<b>stripCFWS</b>( [STRING] )
       Mail::Message::Field-&gt;<b>stripCFWS</b>( [STRING] )
           Remove the <u>comments</u> and <u>folding</u> <u>white</u> <u>spaces</u> from the STRING.  Without string and  only  as  instance
           method, the <b>unfoldedBody()</b> is being stripped and returned.

           WARNING:  This  operation  is  only  allowed  for  structured header fields (which are defined by the
           various RFCs as being so.  You don't want parts within braces which are in the Subject header line to
           be removed, to give an example.

       $obj-&gt;<b>unfoldedBody</b>( [$body, [$wrap]] )
           Returns the body as one single line, where all folding information (if available) is  removed.   This
           line will also NOT end on a new-line.

           The  optional  $body  argument  changes  the  field's  body.   The  right folding is performed before
           assignment.  The $wrap may be specified to enforce a folding size.

           example:

            my $body = $field-&gt;unfoldedBody;
            print "$field";   # via overloading

   <b>Access</b> <b>to</b> <b>the</b> <b>content</b>
       $obj-&gt;<b>addresses</b>()
           Returns a list of Mail::Address objects, which represent the e-mail addresses found  in  this  header
           line.

           example:

            my @addr = $message-&gt;head-&gt;get('to')-&gt;addresses;
            my @addr = $message-&gt;to;

       $obj-&gt;<b>attribute</b>( $name, [$value] )
           Get  the  value  of an attribute, optionally after setting it to a new value.  Attributes are part of
           some header lines, and hide themselves in the comment field.  If the attribute does not  exist,  then
           "undef" is returned.  The attribute is still encoded.

           example:

            my $field = Mail::Message::Field-&gt;new(
             'Content-Type: text/plain; charset="us-ascii"');

            print $field-&gt;attribute('charset');
              # --&gt; us-ascii

            print $field-&gt;attribute('bitmap') || 'no'
              # --&gt; no

            $field-&gt;atrribute(filename =&gt; '/tmp/xyz');
            $field-&gt;print;
              # --&gt; Content-Type: text/plain; charset="us-ascii";
              #       filename="/tmp/xyz"
              # Automatically folded, and no doubles created.

       $obj-&gt;<b>attributes</b>()
           Returns  a  list of key-value pairs, where the values are not yet decoded.  Keys may appear more than
           once.

           example:

            my @pairs = $head-&gt;get('Content-Disposition')-&gt;attributes;

       $obj-&gt;<b>comment</b>( [STRING] )
           Returns the unfolded comment (part after a semi-colon) in a structureed header-line. optionally after
           setting it to a new STRING first.  When "undef" is specified  as  STRING,  the  comment  is  removed.
           Whether the field is structured is defined by <b>isStructured()</b>.

           The  <u>comment</u>  part  of  a  header  field  often  contains "attributes".  Often it is preferred to use
           <b>attribute()</b> on them.

       $obj-&gt;<b>study</b>()
           Study the header field in detail: turn on the full parsing and detailed understanding of the  content
           of the fields.  Mail::Message::Field::Fast and Mail::Message::Field::Fast objects will be transformed
           into any Mail::Message::Field::Full object.

           example:

            my $subject = $msg-&gt;head-&gt;get('subject')-&gt;study;
            my $subject = $msg-&gt;head-&gt;study('subject');  # same
            my $subject = $msg-&gt;study('subject');        # same

       $obj-&gt;<b>toDate</b>( [$time] )
       Mail::Message::Field-&gt;<b>toDate</b>( [$time] )
           Convert  a  timestamp into an rfc2822 compliant date format.  This differs from the default output of
           "localtime" in scalar context.  Without argument, the "localtime" is used to get  the  current  time.
           $time  can  be  specified  as  one  numeric (like the result of time()) and as list (like produced by
           c&lt;<b>localtime()</b>&gt; in list context).

           Be sure to have your timezone set right, especially when this script runs automatically.

           example:

            my $now = time;
            Mail::Message::Field-&gt;toDate($now);
            Mail::Message::Field-&gt;toDate(time);

            Mail::Message::Field-&gt;toDate(localtime);
            Mail::Message::Field-&gt;toDate;      # same
            # returns something like:
            #     Wed, 28 Aug 2002 10:40:25 +0200

       $obj-&gt;<b>toInt</b>()
           Returns the value which is related to this field as integer.  A check is performed  whether  this  is
           right.

   <b>Other</b> <b>methods</b>
       $obj-&gt;<b>dateToTimestamp</b>(STRING)
       Mail::Message::Field-&gt;<b>dateToTimestamp</b>(STRING)
           Convert  a STRING which represents and RFC compliant time string into a timestamp like is produced by
           the "time" function.

   <b>Internals</b>
       $obj-&gt;<b>consume</b>( $line | &lt;$name,&lt;$body|$objects&gt;&gt; )
           Accepts a whole field $line, or a pair with the field's $name and $body.  In  the  latter  case,  the
           $body  data  may  be  specified  as  array  of  $objects which are stringified.  Returned is a nicely
           formatted pair of two strings: the field's name and a folded body.

           This method is called by <b>new()</b>, and  usually  not  by  an  application  program.  The  details  about
           converting the $objects to a field content are explained in "Specifying field data".

       $obj-&gt;<b>defaultWrapLength</b>( [$length] )
           Any field from any header for any message will have this default wrapping.  This is maintained in one
           global variable.  Without a specified $length, the current value is returned.  The default is 78.

       $obj-&gt;<b>fold</b>( $name, $body, [$maxchars] )
       Mail::Message::Field-&gt;<b>fold</b>( $name, $body, [$maxchars] )
           Make  the  header  field  with  $name  fold  into multiple lines.  Wrapping is performed by inserting
           newlines before a blanks in the $body, such that no line exceeds the $maxchars and each  line  is  as
           long as possible.

           The  RFC requests for folding on nice spots, but this request is mainly ignored because it would make
           folding too slow.

       $obj-&gt;<b>setWrapLength</b>( [$length] )
           Force the wrapping of this field to the specified $length characters. The wrapping is performed  with
           <b>fold()</b> and the results stored within the field object.

           example: refolding the field

            $field-&gt;<a href="../man99/setWrapLength.99.html">setWrapLength</a>(99);

       $obj-&gt;<b>stringifyData</b>(STRING|ARRAY|$objects)
           This  method  implements  the translation of user supplied objects into ascii fields.  The process is
           explained in "Specifying field data".

       $obj-&gt;<b>unfold</b>(STRING)
           The reverse action of <b>fold()</b>: all lines which form the body  of  a  field  are  joined  into  one  by
           removing all line terminators (even the last).  Possible leading blanks on the first line are removed
           as well.

   <b>Error</b> <b>handling</b>
       Extends "Error handling" in Mail::Reporter.

       $obj-&gt;<b>AUTOLOAD</b>()
           Inherited, see "Error handling" in Mail::Reporter

       $obj-&gt;<b>addReport</b>($object)
           Inherited, see "Error handling" in Mail::Reporter

       $obj-&gt;<b>defaultTrace</b>( [$level]|[$loglevel, $tracelevel]|[$level, $callback] )
       Mail::Message::Field-&gt;<b>defaultTrace</b>( [$level]|[$loglevel, $tracelevel]|[$level, $callback] )
           Inherited, see "Error handling" in Mail::Reporter

       $obj-&gt;<b>errors</b>()
           Inherited, see "Error handling" in Mail::Reporter

       $obj-&gt;<b>log</b>( [$level, [$strings]] )
       Mail::Message::Field-&gt;<b>log</b>( [$level, [$strings]] )
           Inherited, see "Error handling" in Mail::Reporter

       $obj-&gt;<b>logPriority</b>($level)
       Mail::Message::Field-&gt;<b>logPriority</b>($level)
           Inherited, see "Error handling" in Mail::Reporter

       $obj-&gt;<b>logSettings</b>()
           Inherited, see "Error handling" in Mail::Reporter

       $obj-&gt;<b>notImplemented</b>()
           Inherited, see "Error handling" in Mail::Reporter

       $obj-&gt;<b>report</b>( [$level] )
           Inherited, see "Error handling" in Mail::Reporter

       $obj-&gt;<b>reportAll</b>( [$level] )
           Inherited, see "Error handling" in Mail::Reporter

       $obj-&gt;<b>trace</b>( [$level] )
           Inherited, see "Error handling" in Mail::Reporter

       $obj-&gt;<b>warnings</b>()
           Inherited, see "Error handling" in Mail::Reporter

   <b>Cleanup</b>
       Extends "Cleanup" in Mail::Reporter.

       $obj-&gt;<b>DESTROY</b>()
           Inherited, see "Cleanup" in Mail::Reporter

</pre><h4><b>DETAILS</b></h4><pre>
   <b>Field</b> <b>syntax</b>
       Fields  are  stored  in  the header of a message, which are represented by Mail::Message::Head objects. A
       field is a combination of a <u>name</u>, <u>body</u>,  and  <u>attributes</u>.   Especially  the  term  "body"  is  cause  for
       confusion: sometimes the attributes are considered to be part of the body.

       The  name of the field is followed by a colon ("":"", not preceded by blanks, but followed by one blank).
       Each attribute is preceded by a separate semi-colon ("";"").  Names of fields  are  case-insensitive  and
       cannot contain blanks.

       <b>.</b> <b>Example:</b> <b>of</b> <b>fields</b>

       Correct fields:

        Field: hi!
        Content-Type: text/html; charset=latin1

       Incorrect fields, but accepted:

        Field : wrong, blank before colon
        Field:                 # wrong, empty
        Field:not nice, blank preferred after colon
        One Two: wrong, blank in name

       <u>Folding</u> <u>fields</u>

       Fields  which are long can be folded to span more than one line.  The real limit for lines in messages is
       only at 998 characters, however such long lines are not easy to read without support of  an  application.
       Therefore  rfc2822  (which  defines  the message syntax) specifies explicitly that field lines can be re-
       formatted into multiple sorter lines without change of meaning, by  adding  new-line  characters  to  any
       field before any blank or tab.

       Usually, the lines are reformatted to create lines which are 78 characters maximum. Some applications try
       harder  to fold on nice spots, like before attributes.  Especially the "Received" field is often manually
       folded into some nice layout.  In most cases however, it is preferred to produce lines which are as  long
       as possible but max 78.

       BE WARNED that all fields can be subjected to folding, and that you usually want the unfolded value.

       <b>.</b> <b>Example:</b> <b>of</b> <b>field</b> <b>folding</b>

        Subject: this is a short line, and not folded

        Subject: this subject field is much longer, and therefore
         folded into multiple
         lines, although one more than needed.

       <u>Structured</u> <u>fields</u>

       The  rfc2822  describes a large number of header fields explicitly.  These fields have a defined meaning.
       For some of the fields, like the "Subject" field, the meaning is straight forward  the  contents  itself.
       These fields are the <u>Unstructured</u> <u>Fields</u>.

       Other  fields have a well defined internal syntax because their content is needed by e-mail applications.
       For instance, the "To" field contains addresses which must be understood by all applications in the  same
       way.  These are the <u>Structured</u> <u>Fields</u>, see <b>isStructured()</b>.

       <u>Comments</u> <u>in</u> <u>fields</u>

       Stuctured  fields can contain comments, which are pieces of text enclosed in parenthesis.  These comments
       can be placed close to anywhere in the line and must be ignored be the application.  Not all applications
       are capable of handling comments correctly in all circumstances.

       <b>.</b> <b>Example:</b> <b>of</b> <b>field</b> <b>comments</b>

        To: mailbox (Mail::Box mailinglist) &lt;<a href="mailto:mailbox@overmeer.net">mailbox@overmeer.net</a>&gt;
        Date: Thu, 13 Sep 2001 09:40:48 +0200 (CEST)
        Subject: goodbye (was: hi!)

       On the first line, the text  "Mail::Box  mailinglist"  is  used  as  comment.   Be  warned  that  rfc2822
       explicitly  states that comments in e-mail address specifications should not be considered to contain any
       usable information.

       On the second line, the timezone is specified as comment. The "Date" field format has no way to  indicate
       the timezone of the sender, but only contains the timezone difference to UTC, however one could decide to
       add this as comment.  Application must ignore this data because the "Date" field is structured.

       The last field is unstructured.  The text between parentheses is an integral part of the subject line.

   <b>Getting</b> <b>a</b> <b>field</b>
       As many programs as there are handling e-mail, as many variations on accessing the header information are
       requested.  Be careful which way you access the data: read the variations described here and decide which
       solution suites your needs best.

       <u>Using</u> <u><b>get()</b></u> <u>field</u>

       The  get()  interface  is  copied  from  other  Perl  modules  which  can  handle  e-mail messages.  Many
       applications which simply replace Mail::Internet objects  by  Mail::Message  objects  will  work  without
       modification.

       There   is  more  than  one  get  method.   The  exact  results  depend  on  which  get  you  use.   When
       <b>Mail::Message::get()</b> is called, you  will  get  the  unfolded,  stripped  from  comments,  stripped  from
       attributes contents of the field as <b>string</b>.  Character-set encodings will still be in the string.  If the
       same fieldname appears more than once in the header, only the last value is returned.

       When  <b>Mail::Message::Head::get()</b>  is  called in scalar context, the last field with the specified name is
       returned as field <b>object</b>.  This object strinigfies into the unfolded contents  of  the  field,  including
       attributes  and  comments.   In  list context, all appearances of the field in the header are returned as
       objects.

       BE WARNED that some lines seem unique, but are not according to the official  rfc.   For  instance,  "To"
       fields can appear more than once.  If your program calls get('to') in scalar context, some information is
       lost.

       <b>.</b> <b>Example:</b> <b>of</b> <b>using</b> <b>get()</b>

        print $msg-&gt;get('subject') || 'no subject';
        print $msg-&gt;head-&gt;get('subject') || 'no subject';

        my @to = $msg-&gt;head-&gt;get('to');

       <u>Using</u> <u><b>study()</b></u> <u>field</u>

       As  the  name  "study"  already  implies, this way of accessing the fields is much more thorough but also
       slower.  The "study" of a field is like a "get", but provides easy access to the content of the field and
       handles character-set decoding correctly.

       The  <b>Mail::Message::study()</b>  method  will  only  return  the  last  field  with  that  name  as   object.
       <b>Mail::Message::Head::study()</b>  and  <b>Mail::Message::Field::study()</b>  return  all  fields  when  used in list
       context.

       <b>.</b> <b>Example:</b> <b>of</b> <b>using</b> <b>study()</b>

        print $msg-&gt;study('subject') || 'no subject';
        my @rec  = $msg-&gt;head-&gt;study('Received');

        my $from = $msg-&gt;head-&gt;get('From')-&gt;study;
        my $from = $msg-&gt;head-&gt;study('From');  # same
        my @addr = $from-&gt;addresses;

       <u>Using</u> <u>resent</u> <u>groups</u>

       Some fields belong together in a group of fields.  For instance, a set of lines is  used  to  define  one
       step  in  the  mail  transport process.  Each step adds a "Received" line, and optionally some "Resent-*"
       lines and "Return-Path".  These groups of lines shall stay together and in order when the message  header
       is processed.

       The  "Mail::Message::Head::ResentGroup"  object  simplifies  the  access  to these related fields.  These
       resent groups can be deleted as a whole, or correctly constructed.

       <b>.</b> <b>Example:</b> <b>of</b> <b>using</b> <b>resent</b> <b>groups</b>

        my $rgs = $msg-&gt;head-&gt;resentGroups;
        $rgs[0]-&gt;delete if @rgs;

        $msg-&gt;head-&gt;removeResentGroups;

   <b>The</b> <b>field's</b> <b>data</b>
       There are many ways to get the fields info as object, and there are also many ways to process  this  data
       within the field.

       <u>Access</u> <u>to</u> <u>the</u> <u>field</u>

       •   <b>string()</b>

           Returns the text of the body exactly as will be printed to file when <b>print()</b> is called, so name, main
           body, and attributes.

       •   <b>foldedBody()</b>

           Returns the text of the body, like <b>string()</b>, but without the name of the field.

       •   <b>unfoldedBody()</b>

           Returns  the  text  of the body, like <b>foldedBody()</b>, but then with all new-lines removed.  This is the
           normal way to get the content of unstructured fields.   Character-set  encodings  will  still  be  in
           place.  Fields are stringified into their unfolded representation.

       •   <b>stripCFWS()</b>

           Returns  the  text  of  structured  fields, where new-lines and comments are removed from the string.
           This is a good start for parsing the field, for instance to find e-mail addresses in them.

       •   <b>Mail::Message::Field::Full::decodedBody()</b>

           Studied fields can produce the unfolded text  decoded  into  utf8  strings.   This  is  an  expensive
           process, but the only correct way to get the field's data.  More useful for people who are not living
           in ASCII space.

       •   Studied fields

           Studied  fields  have  powerful  methods  to  provide  ways  to  access  and  produce the contents of
           (structured) fields exactly as the involved rfcs prescribe.

       <u>Using</u> <u>simplified</u> <u>field</u> <u>access</u>

       Some fields are accessed that often that there are support methods to  provide  simplified  access.   All
       these methods are called upon a message directly.

       <b>.</b> <b>Example:</b> <b>of</b> <b>simplified</b> <b>field</b> <b>access</b>

        print $message-&gt;subject;
        print $message-&gt;get('subject') || '';  # same

        my @from = $message-&gt;from; # returns addresses
        $message-&gt;reply-&gt;send if $message-&gt;sender;

       The  "sender"  method  will return the address specified in the "Sender" field, or the first named in the
       "From" field.  It will return "undef" in case no address is known.

       <u>Specifying</u> <u>field</u> <u>data</u>

       Field data can be anything, strongly dependent on the type of field at hand. If you decide  to  construct
       the    fields    very    carefully    via    some    Mail::Message::Field::Full   extension   (like   via
       Mail::Message::Field::Addresses objects), then you will  have  protection  build-in.   However,  you  can
       bluntly create any Mail::Message::Field object based on some data.

       When  you  create  a field, you may specify a string, object, or an array of strings and objects.  On the
       moment, objects are only used to help the construction on e-mail addresses, however you may add  some  of
       your own.

       The following rules (implemented in <b>stringifyData()</b>) are obeyed given the argument is:

       •   a string

           The  string  must  be  following the (complicated) rules of the rfc2822, and is made field content as
           specified.  When the string is not terminated by a new-line ("\n") it will be folded according to the
           standard rules.

       •   a Mail::Address object

           The most used Perl object to parse and produce  address  lines.   This  object  does  not  understand
           character set encodings in phrases.

       •   a Mail::Identity object

           As  part of the User::Identity distribution, this object has full understanding of the meaning of one
           e-mail address, related to a person.  All features defined by rfc2822 are implemented.

       •   a User::Identity object

           A person is specified, which may have more than one Mail::Identity's  defined.   Some  methods,  like
           <b>Mail::Message::reply()</b> and <b>Mail::Message::forward()</b> try to select the right e-mail address smart (see
           their method descriptions), but in other cases the first e-mail address found is used.

       •   a User::Identity::Collection::Emails object

           All  Mail::Identity  objects  in  the collection will be included in the field as a group carying the
           name of the collection.

       •   any other object

           For all other objects, the stringification overload is used to produce the field content.

       •   an ARRAY

           You may also specify an array with a mixture of any of the above.  The elements  will  be  joined  as
           comma-separated  list.   If  you  do  not  want comma's inbetween, you will have to process the array
           yourself.

       <b>.</b> <b>Example:</b> <b>specifying</b> <b>simple</b> <b>field</b> <b>data</b>

        my $f = Mail::Message::Field-&gt;new(Subject =&gt; 'hi!');
        my $b = Mail::Message-&gt;build(Subject =&gt; 'monkey');

       <b>.</b> <b>Example:</b> <b>s</b> <b>specifying</b> <b>e-mail</b> <b>addresses</b> <b>for</b> <b>a</b> <b>field</b>

        use Mail::Address;
        my $fish = Mail::Address-&gt;new('Mail::Box', '<a href="mailto:fish@tux.aq">fish@tux.aq</a>');
        print $fish-&gt;format;   # ==&gt; Mail::Box &lt;<a href="mailto:fish@tux.aq">fish@tux.aq</a>&gt;
        my $exa  = Mail::Address-&gt;new(undef, '<a href="mailto:me@example.com">me@example.com</a>');
        print $exa-&gt;format;    # ==&gt; <a href="mailto:me@example.com">me@example.com</a>

        my $b = $msg-&gt;build(To =&gt; "<a href="mailto:you@example.com">you@example.com</a>");
        my $b = $msg-&gt;build(To =&gt; $fish);
        my $b = $msg-&gt;build(To =&gt; [ $fish, $exa ]);

        my @all = ($fish, "<a href="mailto:you@example.com">you@example.com</a>", $exa);
        my $b = $msg-&gt;build(To =&gt; \@all);
        my $b = $msg-&gt;build(To =&gt; [ "xyz", @all ]);

       <b>.</b> <b>Example:</b> <b>specifying</b> <b>identities</b> <b>for</b> <b>a</b> <b>field</b>

        use User::Identity;
        my $patrik = User::Identity-&gt;new
         ( name      =&gt; 'patrik'
         , full_name =&gt; "Patrik Fältström"  # from rfc
         , charset   =&gt; "ISO-8859-1"
         );
        $patrik-&gt;add
         ( email    =&gt; "<a href="mailto:him@home.net">him@home.net</a>"
         );

        my $b = $msg-&gt;build(To =&gt; $patrik);

        $b-&gt;get('To')-&gt;print;
          # ==&gt; =?ISO-8859-1?Q?Patrik_F=E4ltstr=F6m?=
          #     &lt;<a href="mailto:him@home.net">him@home.net</a>&gt;

   <b>Field</b> <b>class</b> <b>implementation</b>
       For performance reasons only, there are three types of fields: the  fast,  the  flexible,  and  the  full
       understander:

       •   Mail::Message::Field::Fast

           "Fast"  objects  are  not  derived  from a "Mail::Reporter".  The consideration is that fields are so
           often created, and such a small objects at the same time, that setting-up a logging for each  of  the
           objects  is  relatively expensive and not really useful.  The fast field implementation uses an array
           to store the data: that will be faster than using a hash.  Fast fields are  not  easily  inheritable,
           because the object creation and initiation is merged into one method.

       •   Mail::Message::Field::Flex

           The  flexible  implementation uses a hash to store the data.  The <b>new()</b> and "init" methods are split,
           so this object is extensible.

       •   Mail::Message::Field::Full

           With a full implementation of all applicable RFCs (about 5), the best understanding of the fields  is
           reached.   However,  this  comes  with  a  serious memory and performance penalty.  These objects are
           created from fast or flex header fields when <b>study()</b> is called.

</pre><h4><b>DIAGNOSTICS</b></h4><pre>
       Warning: Field content is not numerical: $content
           The numeric value of a field is requested (for instance the "Lines" or "Content-Length" fields should
           be numerical), however the data contains weird characters.

       Error: Field name too long (max $length), in '$name'
           It is not specified in the RFCs how long a field name can be,  but  at  least  it  should  be  a  few
           characters shorter than the line wrap.

       Warning: Illegal character in field name $name
           A  new  field  is  being created which does contain characters not permitted by the RFCs.  Using this
           field in messages may break other e-mail clients  or  transfer  agents,  and  therefore  mutulate  or
           extinguish your message.

       Error: Package $package does not implement $method.
           Fatal  error:  the specific package (or one of its superclasses) does not implement this method where
           it should. This message means that some other related classes do implement this  method  however  the
           class  at  hand does not.  Probably you should investigate this and probably inform the author of the
           package.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       This module is part of Mail-Message distribution  version  3.017,  built  on  April  18,  2025.  Website:
       <u><a href="http://perl.overmeer.net/CPAN/">http://perl.overmeer.net/CPAN/</a></u>

</pre><h4><b>LICENSE</b></h4><pre>
       Copyrights 2001-2025 by [Mark Overmeer &lt;<a href="mailto:markov@cpan.org">markov@cpan.org</a>&gt;]. For other contributors see ChangeLog.

       This  program  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself.  See <u><a href="http://dev.perl.org/licenses/">http://dev.perl.org/licenses/</a></u>

perl v5.40.1                                       2025-04-25                          <u>Mail::Message::<a href="../man3pm/Field.3pm.html">Field</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>