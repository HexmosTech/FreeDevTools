<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Locales - Methods for getting localized CLDR language/territory names (and a subset of other data)</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/liblocales-perl">liblocales-perl_0.34+ds-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Locales - Methods for getting localized CLDR language/territory names (and a subset of other data)

</pre><h4><b>VERSION</b></h4><pre>
       This document describes Locales version 0.33

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Locales;

           my $locale = Locales-&gt;new('en_gb');

           print $locale-&gt;get_locale(); # 'en_gb'
           print $locale-&gt;get_language(); # 'en'
           print $locale-&gt;get_territory(); # 'gb'

           print $locale-&gt;get_language_from_code('fr'); # 'French'
           print $locale-&gt;get_code_from_language('French'); # 'fr'

           print $locale-&gt;get_territory_from_code('us'); # 'United States'
           print $locale-&gt;get_code_from_territory('Australia'); # 'au'

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Locales lets you create an object for a certain locale that lets you access certain data harvested
       directly from CLDR.

       &lt;<a href="http://cldr.unicode.org/index/downloads">http://cldr.unicode.org/index/downloads</a>&gt;

       Currently the data/methods include translated locale names and territory names.

       For simplicity Locales does not work with or know about Variants or Scripts. It only knows about
       languages and territories.

       Also it does not contain all the data contained in CLDR. For example, DateTime’s localization already has
       all the calender/date/time info from CLDR. Other information has not had any demand yet.

       For consistency all data is written in utf-8. No conversion should be necessary if you are (wisely) using
       utf-8 as your character set everywhere (See &lt;<a href="http://drmuey.com">http://drmuey.com</a>\/?do=page&amp;id=57&gt; for more info on that.).

       Note: You probably [don't need to/should not] use utf8 in regards to the data contained herein.

</pre><h4><b>Based</b> <b>on</b> <b>CLDR</b></h4><pre>
       This module is based on CLDR v2.0.

       You can learn about the Unicode Common Locale Data Repository at &lt;<a href="http://cldr.unicode.org/">http://cldr.unicode.org/</a>&gt;.

</pre><h4><b>Supported</b> <b>Locale</b> <b>Criteria</b></h4><pre>
       The locale tags that can be objectified fit this criteria:

       the locale must have data in the CLDR
           As  noted  in “I am using a locale code that I know exists in the CLDR but I can't use it anywhere in
           Locales” in "BEFORE YOU SUBMIT A BUG REPORT".

       the locale must have an entry in CLDR’s en data
           As noted in “I am using a locale code that I know exists in the CLDR but I can't use it  anywhere  in
           Locales” in "BEFORE YOU SUBMIT A BUG REPORT".

       the locale can only have language and territory parts
           As noted in the "DESCRIPTION".

       the only exceptions are “soft locales”.
           As described in "Soft Locales".

</pre><h4><b>Soft</b> <b>Locales</b></h4><pre>
       As  “soft  locale”  is  a  language-territory  locale  that  does not fit the "Supported Locale Criteria"
       directly but its super does and the territory is known.

       For example “es-MX” does not fit the criteria but “es” does and “MX” is a valid territory code.

</pre><h4><b>To</b> <b>byte</b> <b>or</b> <b>not</b> <b>to</b> <b>byte,</b> <b>that</b> <b>is</b> <b>the</b> <b>question.</b> <b>Ok,</b> <b>I’ll</b> <b>byte</b> <b>…</b></h4><pre>
       The CLDR data is in bytes, specifically utf-8.

       By default this module simply passes along the strings as bytes, which works fine  in  applications  that
       don’t operate in character mode (i.e. that use utf8 byte strings instead of Unicode strings**).

       If you want Unicode strings instead you can do so by bringing in the module this way:

           use Locales unicode =&gt; 1;

       [**]   What   is   the  difference  between  Unicode  strings  and  utf-8  bytes  strings  you  ask?  See
       String::UnicodeUTF8 for more info.

</pre><h4><b>INTERFACE</b></h4><pre>
   <b>new()</b>
       Takes one argument, the locale tag whose CLDR data you want to use.

       No argument defaults to 'en'.

       It is an argument based singleton so you can call it more than once with out it  having  to  rebuild  the
       object every time.

       It returns false if a locale given is not available. $@ should have been set at that point by eval.

           my $en = Locales-&gt;new('en') or die $@;

   <b>Object</b> <b>methods</b>
       <u>Misc</u> <u>methods</u>

       <b>get_cldr_version()</b>
           Takes no arguments.

           Returns  the version of the CLDR any data it uses comes from. Can also be called as a class method or
           function.

       <b>get_locale()</b>
           Takes no arguments.

           Returns the normalized locale of the object, this is the same as the argument to <b>new()</b>

       <b>get_language()</b>
           Takes no arguments.

           Returns the language portion of the object’s locale.

       <b>get_territory()</b>
           Takes no arguments.

           Returns the territory portion of the object’s locale if any (e.g. 'en_au'), undef if  there  is  none
           (e.g. 'it').

       <b>get_soft_locale_fallback()</b>
           Takes no arguments.

           Returns  the  locale  that  the  object  is  based  on  in  the  case  that  the  given  locale (i.e.
           "<b>get_locale()</b>") is a soft locale.

           Note: If you do not want to have soft locale objects you should simply not call <b>new()</b> if it is soft:

               - my $loc = Locales-&gt;new($tag) || die $@;
               + my $loc = (Locales::tag_is_soft_locale($tag) ? undef : Locales-&gt;new($tag)) || die $@;

           This could be added to the constructor but for now I don't want to make it more complicated  only  to
           support something that seems odd. If you have a use case submit an rt w/ details. Thanks!

       <b>numf()</b>
           Note: As of v0.17 you probably want "<b>get_formatted_decimal()</b>" instead of <b>numf()</b>.

           Takes one optional boolean argument.

           Returns  1  if  the  object’ss  locale’s  number  format  is comma for thousand separator, period for
           decimal.

           Returns 2  if the object’s locale’s number  format  is  period  for  thousand  separator,  comma  for
           decimal.

           Otherwise  it  returns  a  reference  to  a 3 element array containing this CLDR data: number format,
           separator character, decimal character.

           The boolean argument, when true will do it’s best to determine and return a 1 or a 2.

       <u>Territory</u> <u>methods</u>

       <b>get_territory_codes()</b>
           Take no arguments.

           Returns an unsorted list of known territory codes.

       <b>get_territory_names()</b>
           Take no arguments.

           Returns an unsorted list of the display names for each known territory code.

       <b>get_territory_lookup()</b>
           Take no arguments.

           Returns a copy of the lookup hash of the display names for each known territory code.

       <b>get_territory_from_code()</b>
           Takes one argument, the locale code whose territory name you want to find. Defaults to the  territory
           of the of object’s locale, if any.

           Returns  the  name  of  the  given  tag’s territory or, if not found, the territory portion (if any),
           returns false otherwise.

           An optional second argument, when true, will force it to return the normalized tag  if  nothing  else
           can be figured out.

       <b>get_code_from_territory()</b>
           Takes one argument, the territory name whose locale you want to find.

           Returns the locale tag if found, false otherwise.

       <b>code2territory()</b>
           Alias for <b>get_territory_from_code()</b>

       <b>territory2code()</b>
           Alias for <b>get_code_from_territory()</b>

       <u>Language</u> <u>Methods</u>

       <b>get_language_codes()</b>
           Take no arguments.

           Returns an unsorted list of known language codes.

       <b>get_language_names()</b>
           Take no arguments.

           Returns an unsorted list of the display names for each known language code.

       <b>get_language_lookup()</b>
           Take no arguments.

           Returns a copy of the lookup hash of the display names for each known language code.

       <b>get_language_from_code()</b>
           Takes  one  argument,  the locale code whose language name you want to find. Defaults to the object’s
           locale.

           Returns the name of the given tag’s language, returns false otherwise.

           An optional second argument, when true, will force it to return  a  properly  formatted  CLDR  format
           display based on if we know the language and/or territory if nothing else can be figured out.

       <b>get_code_from_language()</b>
           Takes one argument, the language name whose locale you want to find.

           Returns the locale tag if found, false otherwise.

       <b>get_native_language_from_code()</b>
           Like <b>get_language_from_code()</b> except it returns the name in the given locale’s native language.

       <b>get_character_orientation_from_code()</b>
           Like  <b>get_language_from_code()</b>  except  it returns the character orientation identifier for the given
           locale. (defaulting to the locale of the object if non is given)

           Typically it will be the string “left-to-right” or “right-to-left”.

           See &lt;<a href="http://unicode.org/repos/cldr-tmp/trunk/diff/by_type/misc.layout.html">http://unicode.org/repos/cldr-tmp/trunk/diff/by_type/misc.layout.html</a>&gt; for more information.

       <b>get_character_orientation_from_code_fast()</b>
           Same as <b>get_character_orientation_from_code()</b> except it should use less-overhead. Can be called as  a
           function also so you can use it without creating an object.

       <b>get_locale_display_pattern_from_code()</b>
           Like <b>get_character_orientation_from_code()</b> except it returns the locale display pattern for the given
           locale. (defaulting to the locale of the object if non is given)

           Typically it will be something like '{0} ({1})'

           See  &lt;<a href="http://unicode.org/repos/cldr-tmp/trunk/diff/by_type/names.localeDisplayPattern.html">http://unicode.org/repos/cldr-tmp/trunk/diff/by_type/names.localeDisplayPattern.html</a>&gt;  for more
           information.

       <b>get_locale_display_pattern_from_code_fast()</b>
           Same as <b>get_locale_display_pattern_from_code()</b> except it should use less-overhead. Can be called as a
           function also so you can use it without creating an object.

       <b>get_cldr_number_symbol_decimal()</b>
           Returns the decimal point symbol for the object’s locale. Takes no arguments.

           For formatting numbers use <b>get_formatted_decimal()</b>.

       <b>get_cldr_number_symbol_group()</b>
           Returns the integer grouping symbol for the object’s locale. Takes no arguments.

           For formatting numbers use <b>get_formatted_decimal()</b>.

       <b>get_fallback_list()</b>
           Returns a fallback list of locales in the order they apply based on the object’s locale.

           The basic list will be: object’s locale, object’s super if any, the object’s CLDR  fallback  if  any,
           “special lookup” if any, 'en'

               my @list = $fr_ca-&gt;get_fallback_list();
               # fr_ca fr en

           "special lookup" is a code ref that can be passed in as the first optional arg.

           It  is  given  the  object’s locale when called and should return a list of locale tags (they will be
           normalized).

               my @list = $fr_ca-&gt;get_fallback_list(sub { return $_[0] =~ m/fr/ ? qw(i_yoda i_love_rhi) : () } );
               # fr_ca fr i_yoda i_love_rhi en

       <b>get_plural_form()</b>
           Takes a number and returns the plural category that the number fits under for the object’s locale.

           You can also add an array of items to return instead of the category name. For the  details  on  what
           arguments a given local needs see Locales::DB::Docs::PluralForms.

           The  array  should  be  the  same  length  of  the list of plural form categories for the locale. See
           <b>get_plural_form_categories()</b>.

           The  exception  to  that  is  when  you  specify  the   optional   "“Special   Zero”   Argument"   in
           Locales::DB::Docs::PluralForms.

           For example, 'en' has the plural categories “one” and “other”, so it'd work like this:

               my $cat = $en-&gt;<a href="../man0/get_plural_form.0.html">get_plural_form</a>(0); # 'other'
               my $str = $en-&gt;get_plural_form(0,'I am 1','I am other'); # I am other
               my $str = $en-&gt;get_plural_form(0,'I am 1','I am other','I am nothing'); # I am nothing

               my $cat = $en-&gt;<a href="../man1/get_plural_form.1.html">get_plural_form</a>(1); # 'one'
               my $str = $en-&gt;get_plural_form(1,'I am 1','I am other'); # I am 1
               my $str = $en-&gt;get_plural_form(1,'I am 1','I am other','I am nothing');  #I am 1

               my $cat = $en-&gt;<a href="../man2/get_plural_form.2.html">get_plural_form</a>(2); # 'other'
               my $str = $en-&gt;get_plural_form(2,'I am 1','I am other'); # I am other
               my $str = $en-&gt;get_plural_form(2,'I am 1','I am other','I am nothing'); # I am other

           In  array  context  the  second  value  is  a  boolean for if the return value is the "“Special Zero”
           Argument" in Locales::DB::Docs::PluralForms or not.

           This boolean value only has meaning when called with the additional array of items to return  instead
           of the category name.

           This method can <b>carp()</b> a few things:

           "Could not determine plural logic."
               The locale does not have plural logic data.

           "The number of given values (%d) does not match the number of categories (%d)."
               You passed too many or too few values after the initial numeric argument.

               You'll only see this if $locales_object-&gt;{'verbose'} is set to true.

           "The category (%s) is not used by this locale."
               The  locale’s  plural rules come up with a category that is not applicable to the locale. Default
               to “other” at this point.

       <b>get_plural_form_categories()</b>
           Returns an array of the CLDR plural rule category names that this locale uses.

           Their order corresponds to the position of the corresponding value that <b>get_plural_form()</b> uses.

       <b>supports_special_zeroth()</b>
           Takes no arguments, returns a boolean.

           It is true if the locale uses the "“Special Zero” Argument" in Locales::DB::Docs::PluralForms.

           False if it does not.

       <b>plural_category_count()</b>
           Takes no arguments.

           Returns the number of plural categories applicable to the object’s locale.

           Does not factor in support (or not) of the special zeroth category.

       <b>get_list_and()</b>
           Stringify an "and" list of items as defined in the CLDR for the object’s locale.

           Note:    <b>get_list_or()</b>    will    be    done    once    CLDR     defines     the     OR-list     data
           &lt;<a href="http://unicode.org/cldr/trac/ticket/4051">http://unicode.org/cldr/trac/ticket/4051</a>&gt;.

               $en-&gt;get_list_and() # nothing
               $en-&gt;<a href="../man1/get_list_and.1.html">get_list_and</a>(1) # 1
               $en-&gt;get_list_and(1,2) # 1 and 2
               $en-&gt;get_list_and(1,2,3) # 1, 2, and 3
               $en-&gt;get_list_and(1,2,3,4) # 1, 2, 3, and 3

               $es-&gt;get_list_and() # nothing
               $es-&gt;<a href="../man1/get_list_and.1.html">get_list_and</a>(1) # 1
               $es-&gt;get_list_and(1,2) # 1 y 2
               $es-&gt;get_list_and(1,2,3) # 1, 2 y 3
               $es-&gt;get_list_and(1,2,3,4) # 1, 2, 3 y 3

           To  help  disambiguate  ambiguous  arguments (none, undef, “”, all space/non-break-space) you can use
           $loc-&gt;{'misc'}{'list_quote_mode'}.

           The default value is “none”.

           Possible values:

           “all”
               <b>quote()</b> all values.

           “some”
               <b>quote()</b> only ambiguous values (none (as if it was “”), undef, “”, all space/non-break-space).

           “none”
               do not <b>quote()</b> any values

           If another value is given or the entry does not exist you'll get “none” behavior. If it is set to  an
           unknown value you'll get a <b>carp()</b> of “$self-&gt;{misc}{list_quote_mode} is set to an unknown value”.

       <b>get_list_or()</b>
           Stringify an "or" list of items as defined in the CLDR for the object’s locale.

           This is a stub until CLDR defines the OR-list data &lt;<a href="http://unicode.org/cldr/trac/ticket/4051">http://unicode.org/cldr/trac/ticket/4051</a>&gt;.

           Until  then it is essentially the same as "<b>get_list_and()</b>"except it uses English rules/grammer for or
           lists.

           Uses $loc-&gt;{'misc'}{'list_quote_mode'} the same way <b>get_list_and()</b> does.

       <b>get_formatted_ellipsis_initial()</b>
           Formats the given string per the initial ellipsis pattern.

           Truncating for length is the caller’s responsibility since knowing how to do that  correctly  depends
           on  what the string is (e.g. plain text needs to factor in the encoding or we might corrupt the text,
           HTML might have a broken or unclosed tag, ANSI might be unclosed or truncated, etc) so it is  outside
           of the scope of the CLDR.

               …foo

       <b>get_formatted_ellipsis_medial()</b>
           Formats the given string per the medial ellipsis pattern.

           Truncating  for  length is the caller’s responsibility since knowing how to do that correctly depends
           on what the string is (e.g. plain text needs to factor in the encoding or we might corrupt the  text,
           HTML  might have a broken or unclosed tag, ANSI might be unclosed or truncated, etc) so it is outside
           of the scope of the CLDR.

               foo…bar

       <b>get_formatted_ellipsis_final()</b>
           Formats the given string per the medial ellipsis pattern.

           Truncating for length is the caller’s responsibility since knowing how to do that  correctly  depends
           on  what the string is (e.g. plain text needs to factor in the encoding or we might corrupt the text,
           HTML might have a broken or includes tag, ANSI might be unclosed or truncated, etc) so it is  outside
           of the scope of the CLDR.

               foo…

       <b>quote()</b>
           Quotes the argument with the CLDR delimiters quotation_start and quotation_end.

       <b>quote_alt()</b>
           Quotes the argument with the CLDR delimiters alternate_quotation_start and alternate_quotation_end.

       <b>get_formatted_decimal()</b>
           Return the given number as a string formatted per the locale’s CLDR decimal format pattern.

           An  optional second argument defines a maximum length of decimal places (default is 6 perl %f, max is
           14, if you have a need for a larger max please open an rt w/ context and we may make the max settable
           in the object)

               $fr-&gt;get_formatted_decimal("1234567890.12345"); # 1 234 567 890,12345
               $fr-&gt;get_formatted_decimal("1234567890.12345",4); # 1 234 567 890,123
               $fr-&gt;get_formatted_decimal("1234567890.12345",3); # 1 234 567 890,1235

           Perl number stringification caveats:

           You can avoid most stringification of large integers issues by passing strings.
                    $l-&gt;get_formatted_decimal(99999999999999999983222787.1234); # returns 1e+26 since that is how it comes into the function
                    $l-&gt;get_formatted_decimal("99999999999999999983222787.1234"); # 99,999,999,999,999,999,983,222,787.1234

           You can avoid most formatting of large decimal parts issues by passing strings.
                    $l-&gt;get_formatted_decimal(10000000001.12345678911234,12); # 10,000,000,001.1235 since it is already truncated  when it comes into the function
                    $l-&gt;get_formatted_decimal("10000000001.12345678911234",12); # 10,000,000,001.123456789112

           If the abs integer is &gt; 10_000_000_000 and the decimal part alone stringify into an exponential
           number the rounding is not done.
               That is OK though, since this isn't intended to be used in math and you are already aware of  how
               large integers and decimals act oddly on computers right?

           In general very large integers and/or very large decimal places get wonky when you want to turn them
           into a string like [0-9]+.[0-9]+
               This is why we have a hard limit of 14 decimal places, to enforce some sense of sanity. You might
               consider only using the max decimal places argument to make it less than 6 digits long.

           This  method can <b>carp()</b> a few (hopefully self explanatory) things regarding CLDR number format syntax
           errors:

           "Format had more than 2 pos/neg sections. Using default pattern."
           "Format should have one decimal section. Using default pattern."
           "Format is empty. Using default pattern."
       <b>code2language()</b>
           Alias for <b>get_language_from_code()</b>

       <b>language2code()</b>
           Alias for <b>get_code_from_language()</b>

   <b>Utility</b> <b>functions</b>
       These are some functions used internally that you might find useful.

       <b>Locales::normalize_tag()</b>
           Takes a single argument, the locale tag to normalize.

           Returns the normalized tag.

              print Locales::normalize_tag("  en-GB\n "); # 'en_gb'

       <b>Locales::normalize_tag_for_datetime_locale()</b>
           Like <b>normalize_tag()</b> except the return value should be suitable for DateTime::Locale

              print Locales::normalize_tag_for_datetime_locale("  en-GB\n "); # 'en_GB'

       <b>Locales::normalize_tag_for_ietf()</b>
           Like <b>normalize_tag()</b> except the return value should be suitable for IETF.

           This is not a comprehensive IETF formatter, it is intended (for now at least) for the subset of  tags
           Locales.pm uses.

              print Locales::normalize_tag_for_ietf("  en_gb\n "); # 'en-GB'

       <b>Locales::split_tag()</b>
           Takes a single argument, the locale tag to split into language and territory parts.

           Returns the resulting array of 1 or 2 normalized (but not validated) items.

              my ($language, $territory) = Locales::split_tag("  en-GB\n "); # ('en','gb')

              my ($language, $territory) = Locales::split_tag('fr'); # ('fr');

              my ($language, $territory) = Locales::split_tag('sr_Cyrl_YU'); # ('sr','cyrl_yu'), yes 'cyrl_yu' is invalid here since Locales doesn't work with the Script variants, good catch

       <b>Locales::get_i_tag_for_string()</b>
           Takes a single argument, the locale tag string to transform into "i" notation.

           Returns the resulting normalized locale tag.

           The standard tag for strings/tags without a standard is an "i" notation tag.

           For example, the language "Yoda Speak" does not have an ISO code. You'd have to use i_yoda_speak.

               # assuming $string = "Yoda Speak"; you'd get into the if(), assuming it was 'Spanish' or 'es'
               if (!$en-&gt;get_language_from_code($string) &amp;&amp; !$en-&gt;get_code_from_language($string) ) {
                   # it is not a code or a language (at least in the language of $en) so lets create a tag for it:
                   _create_locale_files( Locales::get_i_tag_for_string($string) ); # i_yoda_speak
               }
               else {
                   # if it is a language name then we fetch the code otherwise, at this point, we know it is a code, so return a normailized version
                   _create_locale_files( $en-&gt;get_code_from_language($yoda) || Locales::normalize_tag($yoda) );
               }

       <b>Locales::tag_is_soft_locale()</b>
           Takes a single argument, the locale tag you want to check to see if it is &lt;soft locale|/Soft Locales&gt;
           or not.

           If  it  is  it  returns  the  super portion that an object would be based on. If it is not it returns
           false.

       <b>Locales::tag_is_loadable()</b>
           Returns true if the given tag can be loaded as a Locales object via <b>new()</b>. False otherwise.

       <b>Locales::territory_code_is_known()</b>
           Returns true if the given tag is a known territory. False otherwise.

       <b>Locales::get_loadable_language_codes()</b>
           Takes no arguments. Returns an unsorted list of codes that can be loaded  as  a  Locales  object  via
           <b>new()</b>.

       <b>Locales::non_locale_list()</b>
           Takes  no  arguments.  Returns  a list of locale tags that are not actually locales. e.g. 'mul' means
           “Multiple Languages”.

       <b>Locales::is_non_locale()</b>
           Takes  a  locale  tag  as  the  argument  and  returns  true  if  it  is  a  non-locale   code   (See
           "<b>Locales::non_locale_list()</b>"), false otherwise.

       Locales::typical_en_alias_list
           Takes no arguments. Returns a list of locale tags that are typically aliases of 'en'.

       Locales::is_typical_en_alias
           Takes  a  locale  tag  as  the  argument  and  returns  true if it is typically an alias of 'en' (See
           "<b>Locales::typical_en_alias_list()</b>"), false otherwise.

       <b>Locales::normalize_for_key_lookup()</b>
           Takes a single argument, the phrase string normalize in the same way the names  are  stored  in  each
           locale’s lookup hash.

           Returns the resulting normalized string.

           This  is  used internally to normalize a given name in the same manner the name-to-code hash keys are
           normalized.

           If said normalization is ever improved then using this function will ensure everything is  normalized
           consistently.

           That  allows  $en-&gt;get_code_from_language($name) to map to 'afa' if given these various variations of
           $arg:

             "Afro-Asiatic Language"
             "afroasiatic\tLanguage"
             "AFRO-Asiatic Language"
             "  Afro_Asiatic    Language"
             "afro.Asiatic Language\n"

       <b>Locales::get_cldr_plural_category_list()</b>
           Returns a list of plural categories that CLDR uses.

           With no argument, the order is what is appropriate for some noun quantifying localization methods.

           With a true argument, the order is the order it makes sense to check their corresponding rules in.

       <b>Locales::plural_rule_string_to_code()</b>
           This is used under the hood to facilitate <b>get_plural_form()</b>. That being the case there probably isn't
           much use for it to be used directly.

           This takes the plural rule string as found in the CLDR  XML  and  returns  an  <b>eval()</b>able  perl  code
           version of it.

           It will carp "Unknown plural rule syntax" and return; if it does not understand what you sent.

           A second, optional, argument is the value to return if the rule matches.

           If  you eval the returned string you'll have a code reference that returns true (or whatever you give
           it) if the rule matched the given number or not:

               my $perly = Locales::plural_rule_string_to_code("n is 42 or n mod 42 is not 7");
               my $check = eval $perly;
               my $plural_category = $check-&gt;(42);

       <b>Locales::plural_rule_hashref_to_code()</b>
           This is used under the hood to facilitate <b>get_plural_form()</b>. That being the case there probably isn't
           much use for it to be used directly.

           This takes a hashref that contains rules, puts them in the hash, and returns an overall code ref. Its
           pretty internal so if you really need the details have a gander at the source.

       Locales::plural_rule_string_to_javascript_code
           Same as <b>Locales::plural_rule_string_to_code()</b> except it returns javascript code instead of perl code.

           Used internally when building this distribution’s share/misc_info contents.

</pre><h4><b>DIAGNOSTICS</b></h4><pre>
       Throws no warning or errors of it’s own. If any function or method returns false then the arguments given
       (or not given) were invalid/not found.

       Deviations from this are documented per function/method.

</pre><h4><b>CONFIGURATION</b> <b>AND</b> <b>ENVIRONMENT</b></h4><pre>
       Locales requires no configuration files or environment variables.

</pre><h4><b>DEPENDENCIES</b></h4><pre>
       None.

</pre><h4><b>INCOMPATIBILITIES</b></h4><pre>
       None reported.

</pre><h4><b>TODO</b></h4><pre>
         - CLDR builder TODOs
         - more CLDR version/misc-info fetchers
         - generally improve get_code_from_* lookups
         - tests that misc info doesn't get odd structs from XML instead of a string
         - ? install share/ via L&lt;File::ShareDir&gt; mechanism ?
         - vet share/ &amp;&amp; document better

</pre><h4><b>DEPRECATED</b> <b>MODULES/INTERFACE</b></h4><pre>
       The original, non CLDR based,  '::Base' based modules/interface in this distribution were  deprecated  in
       version 0.06.

       These modules were removed in version 0.15.

</pre><h4><b>BUGS</b> <b>AND</b> <b>FEATURES</b></h4><pre>
       Please report any bugs or feature requests (and a pull request for bonus points)
        through the issue tracker at &lt;https://github.com/drmuey/p5-Locales/issues&gt;.

       Please     report     any     bugs    or    feature    requests    regarding    CLDR    data    as    per
       &lt;<a href="http://cldr.unicode.org/index/bug-reports">http://cldr.unicode.org/index/bug-reports</a>&gt;.

   <b>BEFORE</b> <b>YOU</b> <b>SUBMIT</b> <b>A</b> <b>BUG</b> <b>REPORT</b>
       Please read TODO, DESCRIPTION, and the information below thoroughly to see if  your  thought  is  already
       addressed.

       •   A non-English object returns English names.

           Data that is not defined in a locale’s CLDR data falls back to English.

           Please report the missing data to the CLDR as per &lt;<a href="http://cldr.unicode.org/index/bug-reports">http://cldr.unicode.org/index/bug-reports</a>&gt;.

       •   I am using a locale code that I know exists in the CLDR but I can't use it anywhere in Locales

           Only  locales  and  territory  codes that 'en' knows about are used. Only locales that have their own
           data set in CLDR are able to be objectified.

           Additions or updates can be request as per &lt;<a href="http://cldr.unicode.org/index/bug-reports">http://cldr.unicode.org/index/bug-reports</a>&gt;.

       •   A name is misformatted, incorrect, etc.

           The data is automatically harvested from CLDR. So if there is really a problem you'll have to  report
           the problem to them. (as per &lt;<a href="http://cldr.unicode.org/index/bug-reports">http://cldr.unicode.org/index/bug-reports</a>&gt;)

           Here are some things to check before submitting a report:

           •   Corrupt text

               •   Is your charset correct?

                   For example, viewing UTF-8 characters on a latin1 web page will result in garbled characters.

               •   It still looks corrupt!

                   Some locale’s require special fonts to be installed on your system to view them properly.

                   For       example       Bengali       (bn)       is       like       this.       As       per
                   &lt;<a href="http://www.unicode.org/help/display_problems.html">http://www.unicode.org/help/display_problems.html</a>&gt; if you install the proper font it renders
                   correctly.

           •   Incorrect data or formatting

               •   Is it really inaccurate?

                   It could simply be an incomplete understanding of the context of the data, for example:

                   In English we capitalize proper names (e.g. French).

                   In other languages it may be perfectly acceptable for a language or  territory  name  to  not
                   start with upper case letters.

                   In  that  case  a  report  about  names  not being capitalized like we do in English would be
                   unwarranted.

               •   Is it really mis-formatted?

                   Sometimes something might look strange to us and we'd be tempted to report the problem.  Keep
                   in  mind  though  that sometimes locale nuances can cause things to render in a way that non-
                   native speakers may not understand.

                   For example Arabic’s (ar) right-to-left text direction can seem strange when mixed with latin
                   text. It's simply not wrong. You may be able to improve it by using  the  direction  data  to
                   render it better (e.g. CSS or HTML attributes if the output is HTML).

                   Also, CLDR pattern formats can differ per locale.

                   In cases like this a report would be unwarranted.

</pre><h4><b>AUTHOR</b></h4><pre>
       Daniel Muey  "&lt;<a href="http://drmuey.com/cpan_contact.pl">http://drmuey.com/cpan_contact.pl</a>&gt;"

</pre><h4><b>LICENCE</b> <b>AND</b> <b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2009, Daniel Muey "&lt;<a href="http://drmuey.com/cpan_contact.pl">http://drmuey.com/cpan_contact.pl</a>&gt;". All rights reserved.

       This  module  is  free  software;  you  can redistribute it and/or modify it under the same terms as Perl
       itself. See perlartistic.

</pre><h4><b>DISCLAIMER</b> <b>OF</b> <b>WARRANTY</b></h4><pre>
       BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR THE SOFTWARE,  TO  THE  EXTENT
       PERMITTED  BY  APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER
       PARTIES PROVIDE THE SOFTWARE "AS  IS"  WITHOUT  WARRANTY  OF  ANY  KIND,  EITHER  EXPRESSED  OR  IMPLIED,
       INCLUDING,  BUT  NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
       PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF  THE  SOFTWARE  IS  WITH  YOU.  SHOULD  THE
       SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR, OR CORRECTION.

       IN  NO  EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY
       OTHER PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE  LIABLE
       TO  YOU  FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF
       THE USE OR INABILITY TO USE THE SOFTWARE (INCLUDING BUT NOT  LIMITED  TO  LOSS  OF  DATA  OR  DATA  BEING
       RENDERED  INACCURATE  OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE SOFTWARE TO OPERATE
       WITH ANY OTHER SOFTWARE), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF  SUCH
       DAMAGES.

perl v5.36.0                                       2022-11-19                                       <u><a href="../man3pm/Locales.3pm.html">Locales</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>