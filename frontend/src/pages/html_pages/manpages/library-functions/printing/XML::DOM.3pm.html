<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XML::DOM - A perl module for building DOM Level 1 compliant document structures</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libxml-dom-perl">libxml-dom-perl_1.46-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       XML::DOM - A perl module for building DOM Level 1 compliant document structures

</pre><h4><b>SYNOPSIS</b></h4><pre>
        use XML::DOM;

        my $parser = new XML::DOM::Parser;
        my $doc = $parser-&gt;parsefile ("file.xml");

        # print all HREF attributes of all CODEBASE elements
        my $nodes = $doc-&gt;getElementsByTagName ("CODEBASE");
        my $n = $nodes-&gt;getLength;

        for (my $i = 0; $i &lt; $n; $i++)
        {
            my $node = $nodes-&gt;item ($i);
            my $href = $node-&gt;getAttributeNode ("HREF");
            print $href-&gt;getValue . "\n";
        }

        # Print doc file
        $doc-&gt;printToFile ("out.xml");

        # Print to string
        print $doc-&gt;toString;

        # Avoid memory leaks - cleanup circular references for garbage collection
        $doc-&gt;dispose;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module extends the XML::Parser module by Clark Cooper.  The XML::Parser module is built on top of
       XML::Parser::Expat, which is a lower level interface to James Clark's expat library.

       XML::DOM::Parser is derived from XML::Parser. It parses XML strings or files and builds a data structure
       that conforms to the API of the Document Object Model as described at
       <a href="http://www.w3.org/TR/REC-DOM-Level-1">http://www.w3.org/TR/REC-DOM-Level-1</a>.  See the XML::Parser manpage for other available features of the
       XML::DOM::Parser class.  Note that the 'Style' property should not be used (it is set internally.)

       The XML::Parser <u>NoExpand</u> option is more or less supported, in that it will generate EntityReference
       objects whenever an entity reference is encountered in character data. I'm not sure how useful this is.
       Any comments are welcome.

       As described in the synopsis, when you create an XML::DOM::Parser object, the parse and parsefile methods
       create an <u>XML::DOM::Document</u> object from the specified input. This Document object can then be examined,
       modified and written back out to a file or converted to a string.

       When using XML::DOM with XML::Parser version 2.19 and up, setting the XML::DOM::Parser option <u>KeepCDATA</u>
       to 1 will store CDATASections in CDATASection nodes, instead of converting them to Text nodes.
       Subsequent CDATASection nodes will be merged into one. Let me know if this is a problem.

       When using XML::Parser 2.27 and above, you can suppress expansion of parameter entity references (e.g.
       %pent;) in the DTD, by setting <u>ParseParamEnt</u> to 1 and <u>ExpandParamEnt</u> to 0. See Hidden Nodes for details.

       A Document has a tree structure consisting of <u>Node</u> objects. A Node may contain other nodes, depending on
       its type.  A Document may have Element, Text, Comment, and CDATASection nodes.  Element nodes may have
       Attr, Element, Text, Comment, and CDATASection nodes.  The other nodes may not have any child nodes.

       This module adds several node types that are not part of the DOM spec (yet.)  These are: ElementDecl (for
       &lt;!ELEMENT ...&gt; declarations), AttlistDecl (for &lt;!ATTLIST ...&gt; declarations), XMLDecl (for &lt;?xml ...?&gt;
       declarations) and AttDef (for attribute definitions in an AttlistDecl.)

</pre><h4><b>XML::DOM</b> <b>Classes</b></h4><pre>
       The XML::DOM module stores XML documents in a tree structure with a root node of type XML::DOM::Document.
       Different nodes in tree represent different parts of the XML file. The DOM Level 1 Specification defines
       the following node types:

       •   XML::DOM::Node - Super class of all node types

       •   XML::DOM::Document - The root of the XML document

       •   XML::DOM::DocumentType - Describes the document structure: &lt;!DOCTYPE root [ ... ]&gt;

       •   XML::DOM::Element - An XML element: &lt;elem attr="val"&gt; ... &lt;/elem&gt;

       •   XML::DOM::Attr - An XML element attribute: name="value"

       •   XML::DOM::CharacterData - Super class of Text, Comment and CDATASection

       •   XML::DOM::Text - Text in an XML element

       •   XML::DOM::CDATASection - Escaped block of text: &lt;![CDATA[ text ]]&gt;

       •   XML::DOM::Comment - An XML comment: &lt;!-- comment --&gt;

       •   XML::DOM::EntityReference - Refers to an ENTITY: &amp;ent; or %ent;

       •   XML::DOM::Entity - An ENTITY definition: &lt;!ENTITY ...&gt;

       •   XML::DOM::ProcessingInstruction - &lt;?PI target&gt;

       •   XML::DOM::DocumentFragment - Lightweight node for cut &amp; paste

       •   XML::DOM::Notation - An NOTATION definition: &lt;!NOTATION ...&gt;

       In  addition,  the  XML::DOM  module  contains  the  following nodes that are not part of the DOM Level 1
       Specification:

       •   XML::DOM::ElementDecl - Defines an element: &lt;!ELEMENT ...&gt;

       •   XML::DOM::AttlistDecl - Defines one or more attributes in an &lt;!ATTLIST ...&gt;

       •   XML::DOM::AttDef - Defines one attribute in an &lt;!ATTLIST ...&gt;

       •   XML::DOM::XMLDecl - An XML declaration: &lt;?xml version="1.0" ...&gt;

       Other classes that are part of the DOM Level 1 Spec:

       •   XML::DOM::Implementation - Provides information about this implementation. Currently  it  doesn't  do
           much.

       •   XML::DOM::NodeList   -   Used   internally   to   store  a  node's  child  nodes.  Also  returned  by
           getElementsByTagName.

       •   XML::DOM::NamedNodeMap - Used internally to store an element's attributes.

       Other classes that are not part of the DOM Level 1 Spec:

       •   XML::DOM::Parser - An non-validating XML parser that creates XML::DOM::Documents

       •   XML::DOM::ValParser - A validating XML parser that creates XML::DOM::Documents. It uses  XML::Checker
           to check against the DocumentType (DTD)

       •   XML::Handler::BuildDOM - A PerlSAX handler that creates XML::DOM::Documents.

</pre><h4><b>XML::DOM</b> <b>package</b></h4><pre>
       Constant definitions
           The following predefined constants indicate which type of node it is.

        UNKNOWN_NODE (0)                The node type is unknown (not part of DOM)

        ELEMENT_NODE (1)                The node is an Element.
        ATTRIBUTE_NODE (2)              The node is an Attr.
        TEXT_NODE (3)                   The node is a Text node.
        CDATA_SECTION_NODE (4)          The node is a CDATASection.
        ENTITY_REFERENCE_NODE (5)       The node is an EntityReference.
        ENTITY_NODE (6)                 The node is an Entity.
        PROCESSING_INSTRUCTION_NODE (7) The node is a ProcessingInstruction.
        COMMENT_NODE (8)                The node is a Comment.
        DOCUMENT_NODE (9)               The node is a Document.
        DOCUMENT_TYPE_NODE (10)         The node is a DocumentType.
        DOCUMENT_FRAGMENT_NODE (11)     The node is a DocumentFragment.
        NOTATION_NODE (12)              The node is a Notation.

        ELEMENT_DECL_NODE (13)          The node is an ElementDecl (not part of DOM)
        ATT_DEF_NODE (14)               The node is an AttDef (not part of DOM)
        XML_DECL_NODE (15)              The node is an XMLDecl (not part of DOM)
        ATTLIST_DECL_NODE (16)          The node is an AttlistDecl (not part of DOM)

        Usage:

          if ($node-&gt;getNodeType == ELEMENT_NODE)
          {
              print "It's an Element";
          }

       <b>Not</b>  <b>In</b>  <b>DOM</b>  <b>Spec</b>:  The  DOM  Spec  does  not  mention UNKNOWN_NODE and, quite frankly, you should never
       encounter it. The last 4 node types were added to support the 4 added node classes.

   <b>Global</b> <b>Variables</b>
       $VERSION
           The variable $XML::DOM::VERSION contains the version number of this implementation, e.g. "1.43".

   <b>METHODS</b>
       These methods are not part of the DOM Level 1 Specification.

       getIgnoreReadOnly and ignoreReadOnly (readOnly)
           The DOM Level 1 Spec does not  allow  you  to  edit  certain  sections  of  the  document,  e.g.  the
           DocumentType,     so     by     default    this    implementation    throws    DOMExceptions    (i.e.
           NO_MODIFICATION_ALLOWED_ERR) when you try to edit a readonly node.   These  readonly  checks  can  be
           disabled by (temporarily) setting the global IgnoreReadOnly flag.

           The  ignoreReadOnly  method  sets  the global IgnoreReadOnly flag and returns its previous value. The
           getIgnoreReadOnly method simply returns its current value.

            my $oldIgnore = XML::DOM::ignoreReadOnly (1);
            eval {
            ... do whatever you want, catching any other exceptions ...
            };
            XML::DOM::ignoreReadOnly ($oldIgnore);     # restore previous value

           Another way to do it, using a local variable:

            { # start new scope
               local $XML::DOM::IgnoreReadOnly = 1;
               ... do whatever you want, don't worry about exceptions ...
            } # end of scope ($IgnoreReadOnly is set back to its previous value)

       isValidName (name)
           Whether the specified name is a valid "Name" as specified in the XML spec.  Characters  with  Unicode
           values &gt; 127 are now also supported.

       getAllowReservedNames and allowReservedNames (boolean)
           The first method returns whether reserved names are allowed.  The second takes a boolean argument and
           sets whether reserved names are allowed.  The initial value is 1 (i.e. allow reserved names.)

           The  XML  spec  states  that  "Names"  starting  with  (X|x)(M|m)(L|l)  are  reserved for future use.
           (Amusingly enough, the XML version of the XML spec (REC-xml-19980210.xml) breaks that  very  rule  by
           defining  an  ENTITY with the name 'xmlpio'.)  A "Name" in this context means the Name token as found
           in the BNF rules in the XML spec.

           XML::DOM only checks for errors when you modify the DOM tree, not when the DOM tree is built  by  the
           XML::DOM::Parser.

       setTagCompression (funcref)
           There are 3 possible styles for printing empty Element tags:

           Style 0
                &lt;empty/&gt; or &lt;empty attr="val"/&gt;

               XML::DOM uses this style by default for all Elements.

           Style 1
                 &lt;empty&gt;&lt;/empty&gt; or &lt;empty attr="val"&gt;&lt;/empty&gt;

           Style 2
                 &lt;empty /&gt; or &lt;empty attr="val" /&gt;

               This  style  is  sometimes desired when using XHTML.  (Note the extra space before the slash "/")
               See &lt;<a href="http://www.w3.org/TR/xhtml1">http://www.w3.org/TR/xhtml1</a>&gt; Appendix C for more details.

           By default XML::DOM compresses all empty Element tags (style 0.)  You can control which style is used
           for a particular Element by calling XML::DOM::setTagCompression with a reference to a  function  that
           takes 2 arguments. The first is the tag name of the Element, the second is the XML::DOM::Element that
           is  being  printed.   The  function should return 0, 1 or 2 to indicate which style should be used to
           print the empty tag. E.g.

            XML::DOM::setTagCompression (\&amp;my_tag_compression);

            sub my_tag_compression
            {
               my ($tag, $elem) = @_;

               # Print empty br, hr and img tags like this: &lt;br /&gt;
               return 2 if $tag =~ /^(br|hr|img)$/;

               # Print other empty tags like this: &lt;empty&gt;&lt;/empty&gt;
               return 1;
            }

</pre><h4><b>IMPLEMENTATION</b> <b>DETAILS</b></h4><pre>
       •   Perl Mappings

           The value undef was used when the DOM Spec said null.

           The DOM Spec says: Applications must encode DOMString  using  UTF-16  (defined  in  Appendix  C.3  of
           [UNICODE]  and  Amendment  1  of  [ISO-10646]).  In this implementation we use plain old Perl strings
           encoded in UTF-8 instead of UTF-16.

       •   Text and CDATASection nodes

           The Expat parser expands EntityReferences and CDataSection sections  to  raw  strings  and  does  not
           indicate  where it was found.  This implementation does therefore convert both to Text nodes at parse
           time.  CDATASection and EntityReference nodes that are added to an existing Document  (by  the  user)
           will be preserved.

           Also,  subsequent  Text nodes are always merged at parse time. Text nodes that are added later can be
           merged with the normalize method. Consider using the addText method when adding Text nodes.

       •   Printing and toString

           When printing (and converting an XML Document to a string) the strings have  to  encoded  differently
           depending on where they occur. E.g. in a CDATASection all substrings are allowed except for "]]&gt;". In
           regular  text,  certain  characters  are  not allowed, e.g. "&gt;" has to be converted to "&amp;gt;".  These
           routines should be verified by someone who knows the details.

       •   Quotes

           Certain sections in XML are quoted, like attribute values in an Element.   XML::Parser  strips  these
           quotes  and  the  print methods in this implementation always uses double quotes, so when parsing and
           printing a document, single quotes may be converted  to  double  quotes.  The  default  value  of  an
           attribute definition (AttDef) in an AttlistDecl, however, will maintain its quotes.

       •   AttlistDecl

           Attribute declarations for a certain Element are always merged into a single AttlistDecl object.

       •   Comments

           Comments  in the DOCTYPE section are not kept in the right place. They will become child nodes of the
           Document.

       •   Hidden Nodes

           Previous versions of XML::DOM would  expand  parameter  entity  references  (like  <b>%pent;</b>),  so  when
           printing the DTD, it would print the contents of the external entity, instead of the parameter entity
           reference.   With  this  release (1.27), you can prevent this by setting the XML::DOM::Parser options
           ParseParamEnt =&gt; 1 and ExpandParamEnt =&gt; 0.

           When it is parsing the contents of the external entities, it  *DOES*  still  add  the  nodes  to  the
           DocumentType,  but  it  marks  these  nodes by setting the 'Hidden' property. In addition, it adds an
           EntityReference node to the DocumentType node.

           When printing the DocumentType node (or when using <b>to_expat()</b> or <b>to_sax()</b>), the  'Hidden'  nodes  are
           suppressed,  so  you  will see the parameter entity reference instead of the contents of the external
           entities. See test case t/dom_extent.t for an example.

           The reason for adding the 'Hidden' nodes to the DocumentType node, is  that  the  nodes  may  contain
           &lt;!ENTITY&gt;  definitions  that  are referenced further in the document. (Simply not adding the nodes to
           the DocumentType could cause such entity references to be expanded incorrectly.)

           Note that you need XML::Parser 2.27 or higher for this to work correctly.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       XML::DOM::XPath

       The    Japanese    version    of    this    document     by     Takanori     Kawai     (Hippo2000)     at
       &lt;<a href="http://member.nifty.ne.jp/hippo2000/perltips/xml/dom.htm">http://member.nifty.ne.jp/hippo2000/perltips/xml/dom.htm</a>&gt;

       The DOM Level 1 specification at &lt;<a href="http://www.w3.org/TR/REC-DOM-Level-1">http://www.w3.org/TR/REC-DOM-Level-1</a>&gt;

       The XML spec (Extensible Markup Language 1.0) at &lt;<a href="http://www.w3.org/TR/REC-xml">http://www.w3.org/TR/REC-xml</a>&gt;

       The XML::Parser and XML::Parser::Expat manual pages.

       XML::LibXML  also  provides  a DOM Parser, and is significantly faster than XML::DOM, and is under active
       development.  It requires that you download the Gnome libxml library.

       XML::GDOME will provide the DOM Level 2 Core API, and should be as fast as XML::LibXML, but more  robust,
       since    it   uses   the   memory   management   functions   of   libgdome.    For   more   details   see
       &lt;<a href="http://tjmather.com/xml-gdome/">http://tjmather.com/xml-gdome/</a>&gt;

</pre><h4><b>CAVEATS</b></h4><pre>
       The method <b>getElementsByTagName()</b> does not return a "live" NodeList.  Whether this is an actual caveat is
       debatable, but a few people on the www-dom mailing list seemed to think so. I haven't decided yet. It's a
       pain to implement, it slows things down and the benefits seem marginal.  Let me know what you think.

</pre><h4><b>AUTHOR</b></h4><pre>
       Enno Derksen is the original author.

       Send patches to T.J. Mather at &lt;<u><a href="mailto:tjmather@maxmind.com">tjmather@maxmind.com</a></u>&gt;.

       Paid  support  is  available  from  directly  from  the  maintainers  of  this   package.    Please   see
       &lt;<a href="http://www.maxmind.com/app/opensourceservices">http://www.maxmind.com/app/opensourceservices</a>&gt; for more details.

       Thanks to Clark Cooper for his help with the initial version.

perl v5.36.0                                       2022-10-14                                      <u>XML::<a href="../man3pm/DOM.3pm.html">DOM</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>