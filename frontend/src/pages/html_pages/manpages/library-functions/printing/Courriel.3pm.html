<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Courriel - High level email parsing and manipulation</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcourriel-perl">libcourriel-perl_0.49-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Courriel - High level email parsing and manipulation

</pre><h4><b>VERSION</b></h4><pre>
       version 0.49

</pre><h4><b>SYNOPSIS</b></h4><pre>
           my $email = Courriel-&gt;parse( text =&gt; $raw_email );

           print $email-&gt;subject;

           print $_-&gt;address for $email-&gt;participants;

           print $email-&gt;datetime-&gt;year;

           if ( my $part = $email-&gt;plain_body_part ) {
               print $part-&gt;content;
           }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This class exists to provide a high level API for working with emails, particular for processing incoming
       email. It is primarily a wrapper around the other classes in the Courriel distro, especially
       Courriel::Headers, Courriel::Part::Single, and Courriel::Part::Multipart. If you need lower level
       information about an email, it should be available from one of these classes.

</pre><h4><b>API</b></h4><pre>
       This class provides the following methods:

   <b>Courriel-&gt;parse(</b> <b>text</b> <b>=&gt;</b> <b>$raw_email,</b> <b>is_character</b> <b>=&gt;</b> <b>0|1</b> <b>)</b>
       This parses the given text and returns a new Courriel object. The text can be provided as a string or a
       reference to a string.

       If you pass a reference, then the scalar underlying the reference <u>will</u> be modified, so don't pass in
       something you don't want modified.

       By default, Courriel expects that content passed in text is binary data. This means that it has not been
       decoded into utf-8 with "Encode::decode()" or by using a ":encoding(UTF-8)" IO layer.

       In practice, this doesn't matter for most emails, since they either contain only ASCII data or they
       actually do contain binary (non-character) data.  However, if an email is using the 8bit Content-
       Transfer-Encoding, then this does matter.

       If the email has already been decoded, you must set "is_character" to a true value.

       It's safest to simply pass binary data to Courriel and let it handle decoding internally.

   <b>$email-&gt;parts()</b>
       Returns an array (not a reference) of the parts this email contains.

   <b>$email-&gt;part_count()</b>
       Returns the number of parts this email contains.

   <b>$email-&gt;is_multipart()</b>
       Returns true if the top-level part is a multipart part, false otherwise.

   <b>$email-&gt;top_level_part()</b>
       Returns the actual top level part for the object. You're probably better off just calling
       "$email-&gt;parts()" most of the time, since when the email is multipart, the top level part is just a
       container.

   <b>$email-&gt;subject()</b>
       Returns the email's Subject header value, or "undef" if it doesn't have one.

   <b>$email-&gt;datetime()</b>
       Returns a DateTime object for the email. The DateTime object is always in the "UTC" time zone.

       This uses the Date header by default one. Otherwise it looks at the date in each Received header, and
       then it looks for a Resent-Date header. If none of these exists, it just returns "DateTime-&gt;now()".

   <b>$email-&gt;from()</b>
       This returns a single Email::Address::XS object based on the From header of the email. If the email has
       no From header or if the From header is broken, it returns "undef".

   <b>$email-&gt;participants()</b>
       This returns a list of Email::Address::XS objects, one for each unique participant in the email. This
       includes any address in the From, To, or CC headers.

       Just like with the From header, broken addresses will not be included.

   <b>$email-&gt;recipients()</b>
       This returns a list of Email::Address::XS objects, one for each unique recipient in the email. This
       includes any address in the To or CC headers.

       Just like with the From header, broken addresses will not be included.

   <b>$email-&gt;to()</b>
       This returns a list of Email::Address::XS objects, one for each unique address in the To header.

       Just like with the From header, broken addresses will not be included.

   <b>$email-&gt;cc()</b>
       This returns a list of Email::Address::XS objects, one for each unique address in the CC header.

       Just like with the From header, broken addresses will not be included.

   <b>$email-&gt;plain_body_part()</b>
       This returns the first Courriel::Part::Single object in the email with a mime type of "text/plain" and an
       inline disposition, if one exists.

   <b>$email-&gt;html_body_part()</b>
       This returns the first Courriel::Part::Single object in the email with a mime type of "text/html" and an
       inline disposition, if one exists.

   <b>$email-&gt;clone_without_attachments()</b>
       Returns a new Courriel object that only contains inline parts from the original email, effectively
       removing all attachments.

   <b>$email-&gt;first_part_matching(</b> <b>sub</b> <b>{</b> <b>...</b> <b>}</b> <b>)</b>
       Given a subroutine reference, this method calls that subroutine for each part in the email, in a depth-
       first search.

       The subroutine receives the part as its only argument. If it returns true, this method returns that part.

   <b>$email-&gt;all_parts_matching(</b> <b>sub</b> <b>{</b> <b>...</b> <b>}</b> <b>)</b>
       Given a subroutine reference, this method calls that subroutine for each part in the email, in a depth-
       first search.

       The subroutine receives the part as its only argument. If it returns true, this method includes that
       part.

       This method returns all of the parts that match the subroutine.

   <b>$email-&gt;content_type()</b>
       Returns the Courriel::Header::ContentType object associated with the email.

   <b>$email-&gt;headers()</b>
       Returns the Courriel::Headers object for this email.

   <b>$email-&gt;stream_to(</b> <b>output</b> <b>=&gt;</b> <b>$output</b> <b>)</b>
       This method will send the stringified email to the specified output. The output can be a subroutine
       reference, a filehandle, or an object with a "print()" method. The output may be sent as a single string,
       as a list of strings, or via multiple calls to the output.

       For large emails, streaming can be much more memory efficient than generating a single string in memory.

   <b>$email-&gt;as_string()</b>
       Returns the email as a string, along with its headers. Lines will be terminated with "\r\n".

</pre><h4><b>ROBUSTNESS</b> <b>PRINCIPLE</b></h4><pre>
       Courriel aims to respect the common Internet robustness principle (aka Postel's law). Courriel is
       conservative in the output it generates, and liberal in what it accepts.

       When parsing, the goal is to never die and always return as much information as possible. Any input that
       causes the "Courriel-&gt;parse()" to die means there's a bug in the parser. Please report these bugs.

       Conversely, Courriel aims to respect all relevant RFCs in its output, except when it preserves the
       original data in a parsed email. If you're using Courriel::Builder to create emails from scratch, any
       output that isn't RFC-compliant is a bug.

</pre><h4><b>FUTURE</b> <b>PLANS</b></h4><pre>
       This release is still rough, and I have some plans for additional features:

   <b>More</b> <b>methods</b> <b>for</b> <b>walking</b> <b>all</b> <b>parts</b>
       Some more methods for walking/collecting multiple parts would be useful.

   <b>More?</b>
       Stay tuned for details.

</pre><h4><b>WHY</b> <b>DID</b> <b>I</b> <b>WRITE</b> <b>THIS</b> <b>MODULE?</b></h4><pre>
       There a lot of email modules/distros on CPAN. Why didn't I use/fix one of them?

       •   Mail::Box

           This  one  probably  does  everything  this  module  does  and  more, but it's really, really big and
           complicated, forcing the end user to make a lot of choices just to get started. If you need it,  it's
           great, but I generally find it to be too much module for me.

       •   Email::Simple and Email::MIME

           These  are surprisingly <b>not</b> simple. They suffer from a problematic API (too high level in some spots,
           too low in others), and a poor separation of concerns. I've hacked on these enough to know that I can
           never make them do what I want.

       •   Everything Else

           There's a lot of other email modules on CPAN, but none of them really seem any better than  the  ones
           mentioned above.

</pre><h4><b>CREDITS</b></h4><pre>
       This module rips some chunks of code from a few other places, notably several of the Email suite modules.

</pre><h4><b>BUGS</b></h4><pre>
       Please report any bugs or feature requests to "<a href="mailto:bug-courriel@rt.cpan.org">bug-courriel@rt.cpan.org</a>", or through the web interface at
       &lt;<a href="http://rt.cpan.org">http://rt.cpan.org</a>&gt;.   I will be notified, and then you'll automatically be notified of progress on your
       bug as I make changes.

       Bugs may be submitted at &lt;https://github.com/houseabsolute/Courriel/issues&gt;.

       I am also usually active on IRC as 'autarch' on "irc://irc.perl.org".

</pre><h4><b>SOURCE</b></h4><pre>
       The source code repository for Courriel can be found at &lt;https://github.com/houseabsolute/Courriel&gt;.

</pre><h4><b>DONATIONS</b></h4><pre>
       If you'd like to thank me for the work I've done on this module, please consider making a  "donation"  to
       me  via PayPal. I spend a lot of free time creating free software, and would appreciate any support you'd
       care to offer.

       Please note that <b>I</b> <b>am</b> <b>not</b> <b>suggesting</b> <b>that</b> <b>you</b> <b>must</b> <b>do</b> <b>this</b> in order for me to continue  working  on  this
       particular  software.  I  will  continue  to  do  so,  inasmuch  as I have in the past, for as long as it
       interests me.

       Similarly, a donation made in this way will probably not make me work on this software much more,  unless
       I  get so many donations that I can consider working on free software full time (let's all have a chuckle
       at that together).

       To  donate,  log  into  PayPal  and  send   money   to   <a href="mailto:autarch@urth.org">autarch@urth.org</a>,   or   use   the   button   at
       &lt;https://www.urth.org/fs-donation.html&gt;.

</pre><h4><b>AUTHOR</b></h4><pre>
       Dave Rolsky &lt;<a href="mailto:autarch@urth.org">autarch@urth.org</a>&gt;

</pre><h4><b>CONTRIBUTORS</b></h4><pre>
       •   Gregory Oschwald &lt;<a href="mailto:goschwald@maxmind.com">goschwald@maxmind.com</a>&gt;

       •   Ricardo Signes &lt;<a href="mailto:rjbs@users.noreply.github.com">rjbs@users.noreply.github.com</a>&gt;

       •   Vitaly Gimly &lt;<a href="mailto:vgimly@gmail.com">vgimly@gmail.com</a>&gt;

       •   Zbigniew Łukasiak &lt;<a href="mailto:zzbbyy@gmail.com">zzbbyy@gmail.com</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is Copyright (c) 2021 by Dave Rolsky.

       This is free software, licensed under:

         The Artistic License 2.0 (GPL Compatible)

       The full text of the license can be found in the <u>LICENSE</u> file included with this distribution.

perl v5.32.1                                       2021-08-22                                      <u><a href="../man3pm/Courriel.3pm.html">Courriel</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>