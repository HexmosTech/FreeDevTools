<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lingua::EN::Inflect - Convert singular to plural. Select "a" or "an".</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/liblingua-en-inflect-perl">liblingua-en-inflect-perl_1.905-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Lingua::EN::Inflect - Convert singular to plural. Select "a" or "an".

</pre><h4><b>VERSION</b></h4><pre>
       This document describes version 1.905 of Lingua::EN::Inflect

</pre><h4><b>SYNOPSIS</b></h4><pre>
        use Lingua::EN::Inflect qw ( PL PL_N PL_V PL_ADJ NO NUM
                         PL_eq PL_N_eq PL_V_eq PL_ADJ_eq
                         A AN
                         PART_PRES
                         ORD NUMWORDS
                         WORDLIST
                         inflect classical
                         def_noun def_verb def_adj def_a def_an );

        # UNCONDITIONALLY FORM THE PLURAL

             print "The plural of ", $word, " is ", PL($word), "\n";

        # CONDITIONALLY FORM THE PLURAL

             print "I saw $cat_count ", PL("cat",$cat_count), "\n";

        # FORM PLURALS FOR SPECIFIC PARTS OF SPEECH

             print PL_N("I",$N1), PL_V("saw",$N1),
               PL_ADJ("my",$N2), PL_N("saw",$N2), "\n";

        # DEAL WITH "0/1/N" -&gt; "no/1/N" TRANSLATION:

             print "There ", PL_V("was",$errors), NO(" error",$errors), "\n";

        # USE DEFAULT COUNTS:

             print NUM($N1,""), PL("I"), PL_V(" saw"), NUM($N2), PL_N(" saw");
             print "There ", NUM($errors,''), PL_V("was"), NO(" error"), "\n";

        # COMPARE TWO WORDS "NUMBER-INSENSITIVELY":

             print "same\n"      if PL_eq($word1, $word2);
             print "same noun\n" if PL_N_eq($word1, $word2);
             print "same verb\n" if PL_V_eq($word1, $word2);
             print "same adj.\n" if PL_ADJ_eq($word1, $word2);

        # ADD CORRECT "a" OR "an" FOR A GIVEN WORD:

             print "Did you want ", A($thing), " or ", AN($idea), "\n";

        # CONVERT NUMERALS INTO ORDINALS (i.e. 1-&gt;1st, 2-&gt;2nd, 3-&gt;3rd, etc.)

             print "It was", ORD($position), " from the left\n";

        # CONVERT NUMERALS TO WORDS (i.e. 1-&gt;"one", 101-&gt;"one hundred and one", etc.)
        # IN A SCALAR CONTEXT: GET BACK A SINGLE STRING...

           $words = <a href="../man1234/NUMWORDS.1234.html">NUMWORDS</a>(1234);      # "one thousand, two hundred and thirty-four"
           $words = NUMWORDS(<a href="../man1234/ORD.1234.html">ORD</a>(1234)); # "one thousand, two hundred and thirty-fourth"

        # IN A LIST CONTEXT: GET BACK A LIST OF STRINGSi, ONE FOR EACH "CHUNK"...

           @words = <a href="../man1234/NUMWORDS.1234.html">NUMWORDS</a>(1234);    # ("one thousand","two hundred and thirty-four")

        # OPTIONAL PARAMETERS CHANGE TRANSLATION:

           $words = NUMWORDS(12345, group=&gt;1);
                       # "one, two, three, four, five"

           $words = NUMWORDS(12345, group=&gt;2);
                       # "twelve, thirty-four, five"

           $words = NUMWORDS(12345, group=&gt;3);
                       # "one twenty-three, forty-five"

           $words = NUMWORDS(1234, 'and'=&gt;'');
                       # "one thousand, two hundred thirty-four"

           $words = NUMWORDS(1234, 'and'=&gt;', plus');
                       # "one thousand, two hundred, plus thirty-four"

           $words = NUMWORDS(555_1202, group=&gt;1, zero=&gt;'oh');
                       # "five, five, five, one, two, oh, two"

           $words = NUMWORDS(555_1202, group=&gt;1, one=&gt;'unity');
                       # "five, five, five, unity, two, zero, two"

           $words = NUMWORDS(123.456, group=&gt;1, decimal=&gt;'mark');
                       # "one two three mark four five six"

        # LITERAL STYLE ONLY NAMES NUMBERS LESS THAN A CERTAIN THRESHOLD...

           $words = NUMWORDS(   9, threshold=&gt;10);    # "nine"
           $words = NUMWORDS(  10, threshold=&gt;10);    # "ten"
           $words = NUMWORDS(  11, threshold=&gt;10);    # "11"
           $words = NUMWORDS(1000, threshold=&gt;10);    # "1,000"

        # JOIN WORDS INTO A LIST:

           $list = WORDLIST("apple", "banana", "carrot");
                       # "apple, banana, and carrot"

           $list = WORDLIST("apple", "banana");
                       # "apple and banana"

           $list = WORDLIST("apple", "banana", "carrot", {final_sep=&gt;""});
                       # "apple, banana and carrot"

        # REQUIRE "CLASSICAL" PLURALS (EG: "focus"-&gt;"foci", "cherub"-&gt;"cherubim")

             classical;          # USE ALL CLASSICAL PLURALS

             classical 1;           #  USE ALL CLASSICAL PLURALS
             classical 0;           #  USE ALL MODERN PLURALS (DEFAULT)

             classical 'zero';      #  "no error" INSTEAD OF "no errors"
             classical zero=&gt;1;     #  "no error" INSTEAD OF "no errors"
             classical zero=&gt;0;     #  "no errors" INSTEAD OF "no error"

             classical 'herd';      #  "2 buffalo" INSTEAD OF "2 buffalos"
             classical herd=&gt;1;     #  "2 buffalo" INSTEAD OF "2 buffalos"
             classical herd=&gt;0;     #  "2 buffalos" INSTEAD OF "2 buffalo"

             classical 'persons';   # "2 chairpersons" INSTEAD OF "2 chairpeople"
             classical persons=&gt;1;  # "2 chairpersons" INSTEAD OF "2 chairpeople"
             classical persons=&gt;0;  # "2 chairpeople" INSTEAD OF "2 chairpersons"

             classical 'ancient';   # "2 formulae" INSTEAD OF "2 formulas"
             classical ancient=&gt;1;  # "2 formulae" INSTEAD OF "2 formulas"
             classical ancient=&gt;0;  # "2 formulas" INSTEAD OF "2 formulae"

        # INTERPOLATE "PL()", "PL_N()", "PL_V()", "PL_ADJ()", A()", "AN()"
        # "NUM()" AND "ORD()" WITHIN STRINGS:

             print inflect("The plural of $word is PL($word)\n");
             print inflect("I saw $cat_count PL(cat,$cat_count)\n");
             print inflect("PL(I,$N1) PL_V(saw,$N1) PL(a,$N2) PL_N(saw,$N2)\n");
             print inflect("NUM($N1,)PL(I) PL_V(saw) NUM($N2,)PL(a) PL_N(saw)\n");
             print inflect("I saw NUM($cat_count) PL(cat)\n");
             print inflect("There PL_V(was,$errors) NO(error,$errors)\n");
             print inflect("There NUM($errors,)PL_V(was) NO(error)\n");
             print inflect("Did you want A($thing) or AN($idea)\n");
             print inflect("It was ORD($position) from the left\n");

        # ADD USER-DEFINED INFLECTIONS (OVERRIDING INBUILT RULES):

             def_noun  "VAX"  =&gt; "VAXen";  # SINGULAR =&gt; PLURAL

             def_verb  "will" =&gt; "shall",  # 1ST PERSON SINGULAR =&gt; PLURAL
                       "will" =&gt; "will",   # 2ND PERSON SINGULAR =&gt; PLURAL
                       "will" =&gt; "will";   # 3RD PERSON SINGULAR =&gt; PLURAL

             def_adj   "hir"  =&gt; "their";  # SINGULAR =&gt; PLURAL

             def_a     "h";                # "AY HALWAYS SEZ 'HAITCH'!"

             def_an    "horrendous.*";     # "AN HORRENDOUS AFFECTATION"

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>[</b><u><b>Note:</b></u> <b>This</b> <b>module</b> <b>is</b> <b>strictly</b> <b>in</b> <b>maintenance</b> <b>mode</b> <b>now.</b>  <b>Take</b> <b>a</b> <b>look</b> <b>at</b> <b>the</b> <b>newer</b> <b>Lingua::EN::Inflexion</b>
       <b>module,</b> <b>which</b> <b>offers</b> <b>a</b> <b>cleaner</b> <b>and</b> <b>more</b> <b>convenient</b> <b>interface,</b> <b>has</b> <b>many</b> <b>more</b> <b>features</b> <b>(including</b>
       <b>plural-&gt;singular</b> <b>inflexions),</b> <b>and</b> <b>is</b> <b>also</b> <b>much</b> <b>better</b> <b>tested.</b>  <b>If</b> <b>you</b> <b>have</b> <b>existing</b> <b>code</b> <b>that</b> <b>relies</b> <b>on</b>
       <b>Lingua::EN::Inflect,</b> <b>see</b> <b>the</b> <b>section</b> <b>of</b> <b>the</b> <b>documentation</b> <b>entitled</b> <b>"CONVERTING</b> <b>FROM</b> <b>LINGUA::EN::INFLECT".</b>
       <b>]</b>

       The exportable subroutines of Lingua::EN::Inflect provide plural inflections, "a"/"an" selection for
       English words, and manipulation of numbers as words

       Plural forms of all nouns, most verbs, and some adjectives are provided. Where appropriate, "classical"
       variants (for example: "brother" -&gt; "brethren", "dogma" -&gt; "dogmata", etc.) are also provided.

       Pronunciation-based "a"/"an" selection is provided for all English words, and most initialisms.

       It is also possible to inflect numerals (1,2,3) to ordinals (1st, 2nd, 3rd) and to English words ("one",
       "two", "three).

       In generating these inflections, Lingua::EN::Inflect follows the Oxford English Dictionary and the
       guidelines in Fowler's Modern English Usage, preferring the former where the two disagree.

       The module is built around standard British spelling, but is designed to cope with common American
       variants as well. Slang, jargon, and other English dialects are <u>not</u> explicitly catered for.

       Where two or more inflected forms exist for a single word (typically a "classical" form and a "modern"
       form), Lingua::EN::Inflect prefers the more common form (typically the "modern" one), unless "classical"
       processing has been specified (see "MODERN VS CLASSICAL INFLECTIONS").

</pre><h4><b>FORMING</b> <b>PLURALS</b></h4><pre>
   <b>Inflecting</b> <b>Plurals</b>
       All of the "PL_..." plural inflection subroutines take the word to be inflected as their first argument
       and return the corresponding inflection.  Note that all such subroutines expect the <u>singular</u> form of the
       word. The results of passing a plural form are undefined (and unlikely to be correct).

       The "PL_..." subroutines also take an optional second argument, which indicates the grammatical "number"
       of the word (or of another word with which the word being inflected must agree). If the "number" argument
       is supplied and is not 1 (or "one" or "a", or some other adjective that implies the singular), the plural
       form of the word is returned. If the "number" argument <u>does</u> indicate singularity, the (uninflected) word
       itself is returned. If the number argument is omitted, the plural form is returned unconditionally.

       The various subroutines are:

       "PL_N($;$)"
               The  exportable  subroutine  "PL_N()"  takes  a  <u>singular</u> English noun or pronoun and returns its
               plural. Pronouns in the nominative ("I" -&gt; "we") and accusative ("me" -&gt; "us") cases are handled,
               as are possessive pronouns ("mine" -&gt; "ours").

       "PL_V($;$)"
               The exportable subroutine "PL_V()" takes the <u>singular</u> form of a conjugated  verb  (that  is,  one
               which  is  already  in  the  correct  "person"  and  "mood") and returns the corresponding plural
               conjugation.

       "PL_ADJ($;$)"
               The exportable subroutine "PL_ADJ()" takes the <u>singular</u> form of certain types of  adjectives  and
               returns   the  corresponding  plural  form.   Adjectives  that  are  correctly  handled  include:
               "numerical" adjectives ("a" -&gt; "some"), demonstrative adjectives ("this" -&gt;  "these",  "that"  -&gt;
               "those"), and possessives ("my" -&gt; "our", "cat's" -&gt; "cats'", "child's" -&gt; "childrens'", etc.)

       "PL($;$)"
               The  exportable  subroutine "PL()" takes a <u>singular</u> English noun, pronoun, verb, or adjective and
               returns its plural form. Where a word has more than one  inflection  depending  on  its  part  of
               speech (for example, the noun "thought" inflects to "thoughts", the verb "thought" to "thought"),
               the (singular) noun sense is preferred to the (singular) verb sense.

               Hence  "PL("knife")"  will  return  "knives"  ("knife"  having  been treated as a singular noun),
               whereas "PL("knifes")" will return "knife" ("knifes" having been treated as a 3rd person singular
               verb).

               The inherent ambiguity of such cases suggests that, where the part of speech  is  known,  "PL_N",
               "PL_V", and "PL_ADJ" should be used in preference to "PL".

       Note  that all these subroutines ignore any whitespace surrounding the word being inflected, but preserve
       that whitespace when the result is returned. For example, "PL(" cat  ")" returns " cats  ".

   <b>Numbered</b> <b>plurals</b>
       The "PL_..." subroutines return only the inflected word, not the count that was used to inflect it. Thus,
       in order to produce "I saw 3 ducks", it is necessary to use:

           print "I saw $N ", PL_N($animal,$N), "\n";

       Since  the  usual  purpose  of  producing  a  plural  is  to  make  it  agree  with  a  preceding  count,
       Lingua::EN::Inflect  provides  an exportable subroutine ("NO($;$)") which, given a word and a(n optional)
       count, returns the count followed by the correctly inflected word. Hence  the  previous  example  can  be
       rewritten:

           print "I saw ", NO($animal,$N), "\n";

       In  addition,  if  the count is zero (or some other term which implies zero, such as "zero", "nil", etc.)
       the count is replaced by the word "no". Hence, if $N had the value zero, the previous example would print
       the somewhat more elegant:

           I saw no animals

       rather than:

           I saw 0 animals

       Note that the name of the subroutine is a pun: the subroutine returns either a number (a <u>No.</u>) or a  "no",
       in front of the inflected word.

       <u>Wordy</u> <u>and</u> <u>comma'd</u> <u>plurals</u>

       The  "NO()"  subroutine  takes  an  optional  third  argument: a hash of named options that configure its
       behaviour.

       The 'words_below' option informs "NO()" what other numbers (i.e.  apart from zero) it should  convert  to
       words. For example:S

           for my $count (0..12) {
               print NO('cat', $count, {words_below =&gt; 10}), "\n";
           }

       would print:

           no cats
           one cat
           two cats
           three cats
           four cats
           five cats
           six cats
           seven cats
           eight cats
           nine cats
           10 cats
           11 cats
           12 cats

       The 'comma' and 'comma_every' options determine whether or not the numbers produced by "NO()" have commas
       in them. That is:

           2001 space odysseys

       versus:

           2,001 space odysseys

       Normally,  numbers are produced without commas, but if 'comma' or 'comma_every' is specified, then commas
       are added as requested.

       The 'comma' option specifies which character to use as a comma.  It defaults to ',', but may  be  set  to
       anything convenient:

           print NO('Euro', $amount, {comma=&gt;'.'});

           # prints:  1.000.000 Euros

       The  'comma_every' option specifies how many characters between commas.  It defaults to 3, but may be set
       to any positive number:

           print NO('Euro', $amount, {comma_every=&gt;4});

           # prints:  100,0000 Euros

       Note that you can set both options at once, if you wish:

           print NO('Euro', $amount, {comma_every=&gt;2, comma=&gt;'_'});

           # prints:  1_00_00_00 Euros

   <b>Reducing</b> <b>the</b> <b>number</b> <b>of</b> <b>counts</b> <b>required</b>
       In some contexts, the need to supply an explicit count to the  various  "PL_..."  subroutines  makes  for
       tiresome repetition. For example:

           print PL_ADJ("This",$errors), PL_N(" error",$errors),
                 PL_V(" was",$errors), " fatal.\n";

       Lingua::EN::Inflect  therefore  provides  an exportable subroutine ("NUM($;$)") that may be used to set a
       persistent "default number" value. If such a value is set, it is subsequently used whenever  an  optional
       second  "number"  argument  is omitted. The default value thus set can subsequently be removed by calling
       "NUM()" with no arguments.  Hence we could rewrite the previous example:

           NUM($errors);
           print PL_ADJ("This"), PL_N(" error"), PL_V(" was"), "fatal.\n";
           NUM();

       Normally, "NUM()" returns its first argument, so that it may also be "inlined" in contexts like:

           print NUM($errors), PL_N(" error"), PL_V(" was"), " detected.\n"
           print PL_ADJ("This"), PL_N(" error"), PL_V(" was"), "fatal.\n"
               if $severity &gt; 1;

       However, in certain contexts (see "INTERPOLATING INFLECTIONS IN STRINGS") it is preferable  that  "NUM()"
       return  an empty string. Hence "NUM()" provides an optional second argument. If that argument is supplied
       (that is, if it is defined) and evaluates to false, "NUM" returns an empty string instead  of  its  first
       argument. For example:

           print NUM($errors,0), NO("error"), PL_V(" was"), " detected.\n";
           print PL_ADJ("This"), PL_N(" error"), PL_V(" was"), "fatal.\n"
               if $severity &gt; 1;

   <b>Number-insensitive</b> <b>equality</b>
       Lingua::EN::Inflect  also  provides  a  solution to the problem of comparing words of differing plurality
       through the exportable subroutines "PL_eq($$)", "PL_N_eq($$)", "PL_V_eq($$)", and "PL_ADJ_eq($$)".   Each
       of  these  subroutines  takes  two  strings, and  compares them using the corresponding plural-inflection
       subroutine ("PL()", "PL_N()", "PL_V()", and "PL_ADJ()" respectively).

       The comparison returns true if:

       •       the strings are "eq"-equal, or

       •       one string is "eq"-equal to a plural form of the other, or

       •       the strings are two different plural forms of the one word.

       Hence all of the following return true:

           PL_eq("index","index")      # RETURNS "eq"
           PL_eq("index","indexes")    # RETURNS "s:p"
           PL_eq("index","indices")    # RETURNS "s:p"
           PL_eq("indexes","index")    # RETURNS "p:s"
           PL_eq("indices","index")    # RETURNS "p:s"
           PL_eq("indices","indexes")  # RETURNS "p:p"
           PL_eq("indexes","indices")  # RETURNS "p:p"
           PL_eq("indices","indices")  # RETURNS "eq"

       As indicated by the comments in the previous example, the actual value returned by  the  various  "PL_eq"
       subroutines  encodes  which  of  the three equality rules succeeded: "eq" is returned if the strings were
       identical, "s:p" if the strings were singular and plural respectively, "p:s" for plural and singular, and
       "p:p" for two distinct plurals.  Inequality is indicated by returning an empty string.

       It should be noted that two distinct singular words which happen to take the same  plural  form  are  <u>not</u>
       considered equal, nor are cases where one (singular) word's plural is the other (plural) word's singular.
       Hence all of the following return false:

           PL_eq("base","basis")       # ALTHOUGH BOTH -&gt; "bases"
           PL_eq("syrinx","syringe")   # ALTHOUGH BOTH -&gt; "syringes"
           PL_eq("she","he")       # ALTHOUGH BOTH -&gt; "they"

           PL_eq("opus","operas")      # ALTHOUGH "opus" -&gt; "opera" -&gt; "operas"
           PL_eq("taxi","taxes")       # ALTHOUGH "taxi" -&gt; "taxis" -&gt; "taxes"

       Note  too  that,  although  the  comparison  is "number-insensitive" it is <u>not</u> case-insensitive (that is,
       "PL("time","Times")" returns false. To obtain both number and case insensitivity, prefix  both  arguments
       with "lc" (that is, "PL(lc "time", lc "Times")" returns true).

</pre><h4><b>OTHER</b> <b>VERB</b> <b>FORMS</b></h4><pre>
   <b>Present</b> <b>participles</b>
       "Lingua::EN::Inflect" also provides the "PART_PRES" subroutine, which can take a 3rd person singular verb
       and correctly inflect it to its present participle:

           PART_PRES("runs")   # "running"
           PART_PRES("loves")  # "loving"
           PART_PRES("eats")   # "eating"
           PART_PRES("bats")   # "batting"
           PART_PRES("spies")  # "spying"

</pre><h4><b>PROVIDING</b> <b>INDEFINITE</b> <b>ARTICLES</b></h4><pre>
   <b>Selecting</b> <b>indefinite</b> <b>articles</b>
       Lingua::EN::Inflect  provides  two  exportable  subroutines ("A($;$)" and "AN($;$)") which will correctly
       prepend the appropriate indefinite article to a word, depending on its pronunciation. For example:

           A("cat")        # -&gt; "a cat"
           AN("cat")       # -&gt; "a cat"
           A("euphemism")      # -&gt; "a euphemism"
           A("Euler number")   # -&gt; "an Euler number"
           A("hour")       # -&gt; "an hour"
           A("houri")      # -&gt; "a houri"

       The two subroutines are <u>identical</u> in function and may be used interchangeably. The only reason  that  two
       versions are provided is to enhance the readability of code such as:

           print "That is ", AN($errortype), " error\n;
           print "That is ", A($fataltype), " fatal error\n;

       Note  that  in  both  cases  the  actual  article provided depends <u>only</u> on the pronunciation of the first
       argument, <u>not</u> on the name of the subroutine.

       "A()" and "AN()" will ignore any indefinite article that already exists at the start of the string. Thus:

           @half_arked = (
               "a elephant",
               "a giraffe",
               "an ewe",
               "a orangutan",
           );

           print A($_), "\n" for @half_arked;

           # prints:
           #     an elephant
           #     a giraffe
           #     a ewe
           #     an orangutan

       "A()" and "AN()" both take an optional second argument. As with the  "PL_..."  subroutines,  this  second
       argument is a "number" specifier. If its value is 1 (or some other value implying singularity), "A()" and
       "AN()"  insert  "a"  or "an" as appropriate. If the number specifier implies plurality, ("A()" and "AN()"
       insert the actual second argument instead.  For example:

           A("cat",1)      # -&gt; "a cat"
           A("cat",2)      # -&gt; "2 cat"
           A("cat","one")      # -&gt; "one cat"
           A("cat","no")       # -&gt; "no cat"

       Note that, as implied by the previous examples, "A()" and "AN()" both assume that their job is merely  to
       provide  the  correct qualifier for a word (that is: "a", "an", or the specified count).  In other words,
       they assume that the word they are given has already been correctly inflected for plurality. Hence, if $N
       has the value 2, then:

             print A("cat",$N);

       prints "2 cat", instead of "2 cats". The correct approach is to use:

             print A(PL("cat",$N),$N);

       or, better still:

             print NO("cat",$N);

       Note too that, like the various "PL_..." subroutines, whenever "A()" and "AN()" are called with only  one
       argument  they  are  subject  to  the  effects  of any preceding call to "NUM()". Hence, another possible
       solution is:

             NUM($N);
             print A(PL("cat"));

   <b>Indefinite</b> <b>articles</b> <b>and</b> <b>initialisms</b>
       "Initialisms" (sometimes inaccurately called "acronyms") are  terms  which  have  been  formed  from  the
       initial letters of words in a phrase (for example, "NATO", "NBL", "S.O.S.", "SCUBA", etc.)

       Such  terms  present a particular challenge when selecting between "a" and "an", since they are sometimes
       pronounced as if they were a single word ("nay-tow", "sku-ba") and sometimes as a series of letter  names
       ("en-eff-ell", "ess-oh-ess").

       "A()" and "AN()" cope with this dichotomy using a series of inbuilt rules, which may be summarized as:

       1.      If  the  word  starts  with a single letter, followed by a period or dash (for example, "R.I.P.",
               "C.O.D.", "e-mail", "X-ray", "T-square"), then choose the appropriate article for  the  <u>sound</u>  of
               the first letter ("an R.I.P.", "a C.O.D.", "an e-mail", "an X-ray", "a T-square").

       2.      If  the first two letters of the word are capitals, consonants, and do not appear at the start of
               any known English word, (for example, "LCD", "XML", "YWCA"), then once again choose "a"  or  "an"
               depending on the <u>sound</u> of the first letter ("an LCD", "an XML", "a YWCA").

       3.      Otherwise,  assume  the  string is a capitalized word or a pronounceable initialism (for example,
               "LED", "OPEC", "FAQ", "UNESCO"), and therefore takes "a" or  "an"  according  to  the  (apparent)
               pronunciation of the entire word ("a LED", "an OPEC", "a FAQ", "a UNESCO").

       Note  that  rules  1  and  3  together  imply  that the presence or absence of punctuation may change the
       selection of indefinite article for a particular initialism (for example, "a FAQ" but "an F.A.Q.").

   <b>Indefinite</b> <b>articles</b> <b>and</b> <b>"soft</b> <b>H's"</b>
       Words beginning in the letter 'H' present another type of difficulty when selecting a suitable indefinite
       article. In a few such words (for example, "hour", "honour", "heir") the 'H' is not voiced at all, and so
       such words inflect with "an". The remaining cases ("voiced H's") may  be  divided  into  two  categories:
       "hard  H's"  (such  as  "hangman",  "holograph",  "hat",  etc.)  and  "soft  H's"  (such as "hysterical",
       "horrendous", "holy", etc.)

       Hard H's always take "a" as their indefinite article, and soft H's normally  do  so  as  well.  But  <u>some</u>
       English  speakers  prefer  "an"  for  soft  H's  (although  the  practice  is now generally considered an
       affectation, rather than a legitimate grammatical alternative).

       At present, the "A()" and "AN()" subroutines ignore soft H's and use "a" for any voiced 'H'.  The  author
       would, however, welcome feedback on this decision (envisaging a possible future "soft H" mode).

</pre><h4><b>INFLECTING</b> <b>ORDINALS</b></h4><pre>
       Occasionally  it  is  useful  to  present  an  integer  value as an ordinal rather than as a numeral. For
       example:

           Enter password (1st attempt): ********
           Enter password (2nd attempt): *********
           Enter password (3rd attempt): *********
           No 4th attempt. Access denied.

       To this end, Lingua::EN::Inflect provides the "ORD()" subroutine.  &lt;<b>ORD()</b>&gt; takes a  single  argument  and
       forms its ordinal equivalent.  If the argument isn't a numerical integer, it just adds "-th".

</pre><h4><b>CONVERTING</b> <b>NUMBERS</b> <b>TO</b> <b>WORDS</b></h4><pre>
       The  exportable  subroutine  "NUMWORDS"  takes  a  number  (cardinal  or  ordinal) and returns an English
       representation of that number. In a scalar context a string is returned. Hence:

           use Lingua::EN::Inflect qw( NUMWORDS );

           $words = <a href="../man1234567/NUMWORDS.1234567.html">NUMWORDS</a>(1234567);

       puts the string:

           "one million, two hundred and thirty-four thousand, five hundred and sixty-seven"

       into $words.

       In a list context each comma-separated chunk is returned as a separate element.  Hence:

           @words = <a href="../man1234567/NUMWORDS.1234567.html">NUMWORDS</a>(1234567);

       puts the list:

           ("one million",
            "two hundred and thirty-four thousand",
            "five hundred and sixty-seven")

       into @words.

       Note that this also means that:

           print <a href="../man1234567/NUMWORDS.1234567.html">NUMWORDS</a>(1234567);

       will (misprint) print:

           one milliontwo hundred and thirty-four thousandfive hundred and sixty-seven

       To get readable output, make sure the call in in scalar context:

           print scalar <a href="../man1234567/NUMWORDS.1234567.html">NUMWORDS</a>(1234567);

       Non-digits (apart from an optional leading plus or minus sign, any decimal points, and  ordinal  suffixes
       -- see below) are silently ignored, so the following all produce identical results:

               <a href="../man5551202/NUMWORDS.5551202.html">NUMWORDS</a>(5551202);
               <a href="../man5_551_202/NUMWORDS.5_551_202.html">NUMWORDS</a>(5_551_202);
               NUMWORDS("5,551,202");
               NUMWORDS("555-1202");

       That  last  case  is a little awkward since it's almost certainly a phone number, and "five million, five
       hundred and fifty-one thousand, two hundred and two" probably isn't what's wanted.

       To overcome this, "NUMWORDS()" takes an optional named argument, 'group', which changes how  numbers  are
       translated. The argument must be a positive integer less than four, which indicated how the digits of the
       number are to be grouped. If the argument is 1, then each digit is translated separately. If the argument
       is  2,  pairs  of  digits (starting from the <u>left</u>) are grouped together. If the argument is 3, triples of
       numbers (again, from the <u>left</u>) are grouped. Hence:

               NUMWORDS("555-1202", group=&gt;1)

       returns "five, five, five, one, two, zero, two", whilst:

               NUMWORDS("555-1202", group=&gt;2)

       returns "fifty-five, fifty-one, twenty, two", and:

               NUMWORDS("555-1202", group=&gt;3)

       returns "five fifty-five, one twenty, two".

       Phone numbers are often written in words as "five..five..five..one..two..zero..two", which is  also  easy
       to achieve:

               join '..', NUMWORDS("555-1202", group=&gt;1)

       "NUMWORDS" also handles decimal fractions. Hence:

               NUMWORDS("1.2345")

       returns     "one     point     two     three     four     five"     in     a     scalar    context    and
       "("one","point","two","three","four","five")") in an array context.  Exponent form  ("1.234e56")  is  not
       yet handled.

       Multiple decimal points are only translated in one of the "grouping" modes.  Hence:

               NUMWORDS(101.202.303)

       returns "one hundred and one point two zero two three zero three", whereas:

               NUMWORDS(101.202.303, group=&gt;1)

       returns "one zero one point two zero two point three zero three".

       The  digit  '0' is unusual in that in may be translated to English as "zero", "oh", or "nought". To cater
       for this diversity, "NUMWORDS" may be passed a named argument, 'zero', which may be set  to  the  desired
       translation of '0'. For example:

               print join "..", NUMWORDS("555-1202", group=&gt;3, zero=&gt;'oh')

       prints "five..five..five..one..two..oh..two".  By default, zero is rendered as "zero".

       Likewise,  the  digit  '1'  may  be  rendered  as  "one" or "a/an" (or very occasionally other variants),
       depending on the context. So there is a 'one' argument as well:

               print NUMWORDS($_, one=&gt;'a solitary', zero=&gt;'no more'),
                     PL(" bottle of beer on the wall\n", $_)
                          for (3,2,1,0);

               # prints:
               #     three bottles of beer on the wall
               #     two bottles of beer on the wall
               #     a solitary bottle of beer on the wall
               #     no more bottles of beer on the wall

       Care is needed if the word "a/an" is to be used as a 'one' value.  Unless  the  next  word  is  known  in
       advance, it's almost always necessary to use the "A" function as well:

               print A( NUMWORDS(1, one=&gt;'a') . " $_\n")
                for qw(cat aardvark ewe hour);

           # prints:
           #     a cat
           #     an aardvark
           #     a ewe
           #     an hour

       Another major regional variation in number translation is the use of "and" in certain contexts. The named
       argument 'and' allows the programmer to specify how "and" should be handled. Hence:

               print scalar NUMWORDS("765", 'and'=&gt;'')

       prints  "seven  hundred sixty-five", instead of "seven hundred and sixty-five".  By default, the "and" is
       included.

       The translation of the decimal point is also subject to variation (with  "point",  "dot",  and  "decimal"
       being the favorites).  The named argument 'decimal' allows the programmer to how the decimal point should
       be rendered. Hence:

               print scalar NUMWORDS("666.124.64.101", group=&gt;3, decimal=&gt;'dot')

       prints  "six sixty-six, dot, one twenty-four, dot, sixty-four, dot, one zero one" By default, the decimal
       point is rendered as "point".

       "NUMWORDS" also handles the ordinal forms of numbers. So:

               print scalar NUMWORDS('1st');
               print scalar NUMWORDS('3rd');
               print scalar NUMWORDS('202nd');
               print scalar NUMWORDS('1000000th');

       print:

               first
               third
               two hundred and twenty-second
               one millionth

       Two common idioms in this regard are:

               print scalar NUMWORDS(ORD($number));

       and:

               print scalar ORD(NUMWORDS($number));

       These are identical in effect, except when $number contains a decimal:

               $number = 99.09;
               print scalar NUMWORDS(ORD($number));    # ninety-ninth point zero nine
               print scalar ORD(NUMWORDS($number));    # ninety-nine point zero ninth

       Use whichever you feel is most appropriate.

</pre><h4><b>CONVERTING</b> <b>LISTS</b> <b>OF</b> <b>WORDS</b> <b>TO</b> <b>PHRASES</b></h4><pre>
       When creating a list of words, commas are used between  adjacent  items,  except  if  the  items  contain
       commas,  in  which case semicolons are used.  But if there are less than two items, the commas/semicolons
       are omitted entirely. The final item also has a conjunction  (usually  "and"  or  "or")  before  it.  And
       although  it's  technically  incorrect  (and  sometimes misleading), some people prefer to omit the comma
       before that final conjunction, even when there are more than two items.

       That's complicated enough to warrant its own subroutine: "WORDLIST()".  This subroutine expects a list of
       words, possibly with one or more hash references containing options. It returns a string that  joins  the
       list together in the normal English usage. For example:

           print "You chose ", WORDLIST(@selected_items), "\n";
           # You chose barley soup, roast beef, and Yorkshire pudding

           print "You chose ", WORDLIST(@selected_items, {final_sep=&gt;""}), "\n";
           # You chose barley soup, roast beef and Yorkshire pudding

           print "Please chose ", WORDLIST(@side_orders, {conj=&gt;"or"}), "\n";
           # Please chose salad, vegetables, or ice-cream

       The available options are:

           Option named    Specifies                Default value

           conj            Final conjunction        "and"
           sep             Inter-item separator     ","
           last_sep        Final separator          value of 'sep' option

</pre><h4><b>INTERPOLATING</b> <b>INFLECTIONS</b> <b>IN</b> <b>STRINGS</b></h4><pre>
       By  far  the  commonest  use  of  the  inflection  subroutines  is to produce message strings for various
       purposes. For example:

               print NUM($errors), PL_N(" error"), PL_V(" was"), " detected.\n";
               print PL_ADJ("This"), PL_N(" error"), PL_V(" was"), "fatal.\n"
                       if $severity &gt; 1;

       Unfortunately the need to separate each subroutine call detracts significantly from  the  readability  of
       the  resulting  code.  To  ameliorate  this  problem,  Lingua::EN::Inflect provides an exportable string-
       interpolating subroutine (inflect($)), which recognizes  calls  to  the  various  inflection  subroutines
       within a string and interpolates them appropriately.

       Using "inflect" the previous example could be rewritten:

               print inflect "NUM($errors) PL_N(error) PL_V(was) detected.\n";
               print inflect "PL_ADJ(This) PL_N(error) PL_V(was) fatal.\n"
                       if $severity &gt; 1;

       Note  that  "inflect"  also  correctly  handles  calls to the "NUM()" subroutine (whether interpolated or
       antecedent). The "inflect()" subroutine has a related extra feature, in that it <u>automatically</u> cancels any
       "default number" value before it returns its interpolated string. This means that calls to "NUM()"  which
       are  embedded  in  an  "inflect()"-interpolated  string  do  not  "escape"  and interfere with subsequent
       inflections.

</pre><h4><b>MODERN</b> <b>VS</b> <b>CLASSICAL</b> <b>INFLECTIONS</b></h4><pre>
       Certain words, mainly of Latin or Ancient Greek origin,  can  form  plurals  either  using  the  standard
       English "-s" suffix, or with their original Latin or Greek inflections. For example:

               PL("stigma")            # -&gt; "stigmas" or "stigmata"
               PL("torus")             # -&gt; "toruses" or "tori"
               PL("index")             # -&gt; "indexes" or "indices"
               PL("millennium")        # -&gt; "millenniums" or "millennia"
               PL("ganglion")          # -&gt; "ganglions" or "ganglia"
               PL("octopus")           # -&gt; "octopuses" or "octopodes"

       Lingua::EN::Inflect  caters  to  such  words  by  providing  an  "alternate state" of inflection known as
       "classical mode".  By default, words are inflected using  their  contemporary  English  plurals,  but  if
       classical mode is invoked, the more traditional plural forms are returned instead.

       The  exportable  subroutine  "classical()"  controls  this  feature.   If "classical()" is called with no
       arguments, it unconditionally invokes classical mode. If it is called with a single  argument,  it  turns
       all classical inflects on or off (depending on whether the argument is true or false). If called with two
       or more arguments, those arguments specify which aspects of classical behaviour are to be used.

       Thus:

               classical;                  # SWITCH ON CLASSICAL MODE
               print PL("formula");        # -&gt; "formulae"

               classical 0;                # SWITCH OFF CLASSICAL MODE
               print PL("formula");        # -&gt; "formulas"

               classical $cmode;           # CLASSICAL MODE IFF $cmode
               print PL("formula");        # -&gt; "formulae" (IF $cmode)
                                           # -&gt; "formulas" (OTHERWISE)

               classical herd=&gt;1;          # SWITCH ON CLASSICAL MODE FOR "HERD" NOUNS
               print PL("wilderbeest");    # -&gt; "wilderbeest"

               classical names=&gt;1;         # SWITCH ON CLASSICAL MODE FOR NAMES
               print PL("sally");          # -&gt; "sallies"
               print PL("Sally");          # -&gt; "Sallys"

       Note however that "classical()" has no effect on the inflection of words which are now fully assimilated.
       Hence:

               PL("forum")             # ALWAYS -&gt; "forums"
               PL("criterion")         # ALWAYS -&gt; "criteria"

       LEI assumes that a capitalized word is a person's name. So it forms the plural according to the rules for
       names  (which  is  that you don't inflect, you just add -s or -es). You can choose to turn that behaviour
       off  (it's  on  by  the  default,  even  when  the  module  isn't   in   classical   mode)   by   calling
       "classical(names=&gt;0)".

</pre><h4><b>USER-DEFINED</b> <b>INFLECTIONS</b></h4><pre>
   <b>Adding</b> <b>plurals</b> <b>at</b> <b>run-time</b>
       Lingua::EN::Inflect  provides  five  exportable  subroutines  which  allow the programmer to override the
       module's behaviour for specific cases:

       "def_noun($$)"
               The "def_noun" subroutine takes a pair of string arguments: the singular and plural forms of  the
               noun   being   specified.   The  singular  form  specifies  a  pattern  to  be  interpolated  (as
               "m/^(?:$first_arg)$/i").  Any noun matching this pattern is then replaced by the  string  in  the
               second  argument.  The  second  argument specifies a string which is interpolated after the match
               succeeds, and is then used as the plural form. For example:

                     def_noun  'cow'        =&gt; 'kine';
                     def_noun  '(.+i)o'     =&gt; '$1i';
                     def_noun  '<a href="../manmer/spam.mer.html">spam</a>(mer)?' =&gt; '\\$\\%\\@#\\$\\@#!!';

               Note that both arguments should usually be specified in single  quotes,  so  that  they  are  not
               interpolated  when  they are specified, but later (when words are compared to them). As indicated
               by the last example, care also needs to be taken with certain characters in the second  argument,
               to ensure that they are not unintentionally interpolated during comparison.

               The  second argument string may also specify a second variant of the plural form, to be used when
               "classical" plurals have been requested. The beginning of the second variant is marked by  a  '|'
               character:

                     def_noun  'cow'        =&gt; 'cows|kine';
                     def_noun  '(.+i)o'     =&gt; '$1os|$1i';
                     def_noun  '<a href="../manmer/spam.mer.html">spam</a>(mer)?' =&gt; '\\$\\%\\@#\\$\\@#!!|varmints';

               If  no  classical  variant  is  given,  the  specified  plural  form  is  used in both normal and
               "classical" modes.

               If the second argument is "undef" instead of a string, then the current user definition  for  the
               first argument is removed, and the standard plural inflection(s) restored.

               Note  that  in all cases, later plural definitions for a particular singular form replace earlier
               definitions of the same form. For example:

                     # FIRST, HIDE THE MODERN FORM....
                     def_noun  'aviatrix' =&gt; 'aviatrices';

                     # LATER, HIDE THE CLASSICAL FORM...
                     def_noun  'aviatrix' =&gt; 'aviatrixes';

                     # FINALLY, RESTORE THE DEFAULT BEHAVIOUR...
                     def_noun  'aviatrix' =&gt; undef;

               Special care is also required when defining general patterns and associated specific  exceptions:
               put the more specific cases <u>after</u> the general pattern. For example:

                     def_noun  '(.+)us' =&gt; '$1i';      # EVERY "-us" TO "-i"
                     def_noun  'bus'    =&gt; 'buses';    # EXCEPT FOR "bus"

               This  "try-most-recently-defined-first"  approach  to matching user-defined words is also used by
               "def_verb", "def_a" and "def_an".

       "def_verb($$$$$$)"
               The "def_verb" subroutine takes three pairs of  string  arguments  (that  is,  six  arguments  in
               total),  specifying  the  singular  and  plural  forms  of  the  three "persons" of verb. As with
               "def_noun", the singular forms are specifications of run-time-interpolated patterns,  whilst  the
               plural forms are specifications of (up to two) run-time-interpolated strings:

                      def_verb 'am'       =&gt; 'are',
                               'are'      =&gt; 'are|art',
                               'is'       =&gt; 'are';

                      def_verb 'have'     =&gt; 'have',
                               'have'     =&gt; 'have',
                               'ha(s|th)' =&gt; 'have';

               Note  that  as with "def_noun", modern/classical variants of plurals may be separately specified,
               subsequent definitions replace previous ones, and "undef"'ed plural forms revert to the  standard
               behaviour.

       "def_adj($$)"
               The  "def_adj" subroutine takes a pair of string arguments, which specify the singular and plural
               forms of the adjective being defined.  As with "def_noun" and "def_adj", the singular  forms  are
               specifications  of  run-time-interpolated patterns, whilst the plural forms are specifications of
               (up to two) run-time-interpolated strings:

                      def_adj  'this'     =&gt; 'these',
                      def_adj  'red'      =&gt; 'red|gules',

               As previously, modern/classical variants of  plurals  may  be  separately  specified,  subsequent
               definitions replace previous ones, and "undef"'ed plural forms revert to the standard behaviour.

       def_a($) and def_an($)
               The "def_a" and "def_an" subroutines each take a single argument, which specifies a pattern. If a
               word  passed  to "A()" or "AN()" matches this pattern, it will be prefixed (unconditionally) with
               the corresponding indefinite article. For example:

                     def_a  'error';
                     def_a  'in.+';

                     def_an 'mistake';
                     def_an 'error';

               As with the other "def_..." subroutines, such redefinitions are sequential  in  effect  so  that,
               after the above example, "error" will be inflected with "an".

   <b>The</b> <u>$HOME<b>/.inflectrc</b></u> <b>file</b>
       When  it  is  imported,  Lingua::EN::Inflect  executes  (as  Perl  code)  the  contents of any file named
       <u>.inflectrc</u> which it finds in the in the directory where <u>Lingua/EN/Inflect.pm</u>  is  installed,  or  in  the
       current  home  directory  ($ENV{HOME}),  or  in  both.   Note  that  the  code  is  executed  within  the
       Lingua::EN::Inflect namespace.

       Hence the user or the local Perl guru can make appropriate calls to "def_noun", "def_verb", etc.  in  one
       of these <u>.inflectrc</u> files, to permanently and universally modify the behaviour of the module. For example

             &gt; cat /usr/local/lib/perl5/Text/Inflect/.inflectrc

             def_noun  "UNIX"  =&gt; "UN*X|UNICES";

             def_verb  "teco"  =&gt; "teco",      # LITERALLY: "to edit with TECO"
                       "teco"  =&gt; "teco",
                       "tecos" =&gt; "teco";

             def_a     "Euler.*";              # "Yewler" TURNS IN HIS GRAVE

       Note that calls to the "def_..." subroutines from within a program will take precedence over the contents
       of  the  home  directory  <u>.inflectrc</u> file, which in turn takes precedence over the system-wide <u>.inflectrc</u>
       file.

</pre><h4><b>DIAGNOSTICS</b></h4><pre>
       On loading, if the Perl code in a <u>.inflectrc</u> file is invalid (syntactically or otherwise), an appropriate
       fatal error is issued.  A common problem is not ending the file with something that evaluates to true (as
       the five "def_..." subroutines do).

       Using the five "def_..." subroutines directly in a program may also result in  fatal  diagnostics,  if  a
       (singular) pattern or an interpolated (plural) string is somehow invalid.

       Specific diagnostics related to user-defined inflections are:

       "Bad user-defined singular pattern:\n\t %s"
               The singular form of a user-defined noun or verb (as defined by a call to "def_noun", "def_verb",
               "def_adj",  "def_a"  or  "def_an")  is not a valid Perl regular expression. The actual Perl error
               message is also given.

       "Bad user-defined plural string: '%s'"
               The plural form(s) of a user-defined noun or verb (as defined by a call to "def_noun", "def_verb"
               or "def_adj") is not a valid Perl interpolated  string  (usually  because  it  interpolates  some
               undefined variable).

       "Bad .inflectrc file (%s):\n %s"
               Some  other problem occurred in loading the named local or global <u>.inflectrc</u> file. The Perl error
               message (including the line number) is also given.

       There are <u>no</u> diagnosable  run-time  error  conditions  for  the  actual  inflection  subroutines,  except
       "NUMWORDS"  and  hence no run-time diagnostics. If the inflection subroutines are unable to form a plural
       via a user-definition or an inbuilt rule, they just "guess" the commonest English inflection: adding "-s"
       for nouns, removing "-s" for verbs, and no inflection for adjectives.

       "Lingua::EN::Inflect::NUMWORDS()" can "die" with the following messages:

       "Bad grouping option: %s"
               The optional argument to "NUMWORDS()" wasn't 1, 2 or 3.

       "Number out of range"
               "NUMWORDS()" was passed a number larger than the number represented by  3006  consecutive  nines.
               The  words  representing  that number are 63,681 characters long, including commas and spaces. If
               you're interested in the actual value, see t/numwords.t.

               The reference for the names is <a href="http://en.wikipedia.org/wiki/Names_of_large_numbers">http://en.wikipedia.org/wiki/Names_of_large_numbers</a>

               There are no names for any higher numbers.

</pre><h4><b>OTHER</b> <b>ISSUES</b></h4><pre>
   <b>2nd</b> <b>Person</b> <b>precedence</b>
       If a verb has identical 1st and 2nd person singular forms, but different 1st and 2nd person plural forms,
       then when its plural is constructed, the 2nd person plural form is always preferred.

       The author is not currently aware of any such verbs in English, but  is  not  quite  arrogant  enough  to
       assume <u>ipso</u> <u>facto</u> that none exist.

   <b>Nominative</b> <b>precedence</b>
       The  singular  pronoun "it" presents a special problem because its plural form can vary, depending on its
       "case". For example:

               It ate my homework       -&gt;  They ate my homework
               It ate it                -&gt;  They ate them
               I fed my homework to it  -&gt;  I fed my homework to them

       As a consequence of this ambiguity, "PL()" or "PL_N" have been implemented so that they always return the
       <u>nominative</u> plural (that is, "they").

       However, when asked  for  the  plural  of  an  unambiguously  <u>accusative</u>  "it"  (namely,  "PL("to  it")",
       "PL_N("from  it")",  "PL("with it")", etc.), both subroutines will correctly return the accusative plural
       ("to them", "from them", "with them", etc.)

   <b>The</b> <b>plurality</b> <b>of</b> <b>zero</b>
       The rules governing the choice between:

             There were no errors.

       and

             There was no error.

       are complex and often depend more on <u>intent</u> rather than <u>content</u>.  Hence it is infeasible to specify  such
       rules algorithmically.

       Therefore,  Lingua::EN::Text  contents  itself  with the following compromise: If the governing number is
       zero, inflections always return the plural form unless  the  appropriate  "classical"  inflection  is  in
       effect, in which case the singular form is always returned.

       Thus, the sequence:

             <a href="../man0/NUM.0.html">NUM</a>(0);
             print inflect "There PL(was) NO(choice)";

       produces "There were no choices", whereas:

             classical 'zero';     # or: classical(zero=&gt;1);
             <a href="../man0/NUM.0.html">NUM</a>(0);
             print inflect "There PL(was) NO(choice)";

       it will print "There was no choice".

   <b>Homographs</b> <b>with</b> <b>heterogeneous</b> <b>plurals</b>
       Another  context  in  which intent (and not content) sometimes determines plurality is where two distinct
       meanings of a word require different plurals. For example:

             Three basses were stolen from the band's equipment trailer.
             Three bass were stolen from the band's aquarium.

             I put the mice next to the cheese.
             I put the mouses next to the computers.

             Several thoughts about leaving crossed my mind.
             Several thought about leaving across my lawn.

       Lingua::EN::Inflect handles such words in two ways:

       •       If both meanings of the word are the <u>same</u> part of speech (for example, "bass" is a noun  in  both
               sentences  above),  then  one  meaning  is chosen as the "usual" meaning, and only that meaning's
               plural is ever returned by any of the inflection subroutines.

       •       If each meaning of the word is a different part of speech (for example, "thought" is both a  noun
               and  a  verb), then the noun's plural is returned by "PL()" and "PL_N()" and the verb's plural is
               returned only by "PL_V()".

       Such contexts are, fortunately, uncommon (particularly "same-part-of-speech" examples). An informal study
       of nearly 600 "difficult plurals" indicates that "PL()" can be relied upon to "get it right" about 98% of
       the time (although, of course, ichthyophilic guitarists or cyber-behaviouralists  may  experience  higher
       rates of confusion).

       If  the  choice of a particular "usual inflection" is considered inappropriate, it can always be reversed
       with a preliminary call to the corresponding "def_..." subroutine.

</pre><h4><b>NOTE</b></h4><pre>
       I'm not taking any further correspondence on:

       "octopi".
           Despite the populist pandering of certain New World dictionaries, the plural is "octopuses"  or  (for
           the  pedantic  classicist)  "octopodes".  The  suffix  "-pus"  is  Greek, not Latin, so the plural is
           "-podes", not "pi".

       "virus".
           Had no plural in Latin (possibly because it was a mass noun).  The  only  plural  is  the  Anglicized
           "viruses".

</pre><h4><b>AUTHOR</b></h4><pre>
       Damian Conway (<a href="mailto:damian@conway.org">damian@conway.org</a>)

</pre><h4><b>BUGS</b> <b>AND</b> <b>IRRITATIONS</b></h4><pre>
       The endless inconsistencies of English.

       (<u>Please</u>  report  words  for  which  the  correct  plural or indefinite article is not formed, so that the
       reliability of Lingua::EN::Inflect can be improved.)

</pre><h4><b>COPYRIGHT</b></h4><pre>
        Copyright (c) 1997-2009, Damian Conway. All Rights Reserved.
        This module is free software. It may be used, redistributed
            and/or modified under the same terms as Perl itself.

perl v5.36.0                                       2022-10-21                           <u>Lingua::EN::<a href="../man3pm/Inflect.3pm.html">Inflect</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>