<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>logger - API module for Logger, the standard logging facility</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       logger - API module for Logger, the standard logging facility
           in Erlang/OTP.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  module  implements  the  main  API  for  logging  in Erlang/OTP. To create a log event, use the API
       functions or the log macros, for example:

       ?LOG_ERROR("error happened because: ~p", [Reason]).   % With macro
       logger:error("error happened because: ~p", [Reason]). % Without macro

       To configure the Logger backend, use Kernel configuration parameters or configuration  functions  in  the
       Logger API.

       By  default,  the  Kernel  application  installs  one  log handler at system start. This handler is named
       <u>default</u>. It receives and processes standard log events produced by the Erlang  runtime  system,  standard
       behaviours and different Erlang/OTP applications. The log events are by default printed to the terminal.

       If  you want your systems logs to be printed to a file instead, you must configure the default handler to
       do so. The simplest way is to include the following in your <u>sys.config</u>:

       [{kernel,
         [{logger,
           [{handler, default, logger_std_h,
             #{config =&gt; #{file =&gt; "path/to/file.log"}}}]}]}].

       For more information about:

         * the Logger facility in general, see the User's Guide.

         * how to configure Logger, see the Configuration section in the User's Guide.

         * the built-in handlers, see logger_std_h and logger_disk_log_h.

         * the built-in formatter, see logger_formatter.

         * built-in filters, see logger_filters.

   <b>Note:</b>
       Since Logger is new in Erlang/OTP 21.0, we do reserve the right to introduce changes to  the  Logger  API
       and  functionality  in  patches  following  this  release.  These changes might or might not be backwards
       compatible with the initial version.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>filter()</b> =
           {fun((log_event(), filter_arg()) -&gt; filter_return()),
            filter_arg()}

              A filter which can be installed as a handler filter, or as a primary filter in Logger.

       <b>filter_arg()</b> = term()

              The second argument to the filter fun.

       <b>filter_id()</b> = atom()

              A unique identifier for a filter.

       <b>filter_return()</b> = stop | ignore | log_event()

              The return value from the filter fun.

       <b>formatter_config()</b> = #{atom() =&gt; term()}

              Configuration data for the formatter. See <u><a href="../man3erl/logger_formatter.3erl.html">logger_formatter</a>(3erl)</u> for an  example  of  a  formatter
              implementation.

       <b>handler_config()</b> =
           #{id =&gt; handler_id(),
             config =&gt; term(),
             level =&gt; level() | all | none,
             module =&gt; module(),
             filter_default =&gt; log | stop,
             filters =&gt; [{filter_id(), filter()}],
             formatter =&gt; {module(), formatter_config()}}

              Handler configuration data for Logger. The following default values apply:

                * <u>level</u> <u>=&gt;</u> <u>all</u>

                * <u>filter_default</u> <u>=&gt;</u> <u>log</u>

                * <u>filters</u> <u>=&gt;</u> <u>[]</u>

                * <u>formatter</u> <u>=&gt;</u> <u>{logger_formatter,</u> <u>DefaultFormatterConfig</u>}

              In addition to these, the following fields are automatically inserted by Logger, values taken from
              the two first parameters to <u>add_handler/3</u>:

                * <u>id</u> <u>=&gt;</u> <u>HandlerId</u>

                * <u>module</u> <u>=&gt;</u> <u>Module</u>

              These are read-only and cannot be changed in runtime.

              Handler specific configuration data is inserted by the handler callback itself, in a sub structure
              associated  with  the  field  named <u>config</u>. See the <u><a href="../man3erl/logger_std_h.3erl.html">logger_std_h</a>(3erl)</u> and <u><a href="../man3erl/logger_disk_log_h.3erl.html">logger_disk_log_h</a>(3erl)</u>
              manual pages for information about the specific configuration for these handlers.

              See the <u><a href="../man3erl/logger_formatter.3erl.html">logger_formatter</a>(3erl)</u> manual page for information about  the  default  configuration  for
              this formatter.

       <b>handler_id()</b> = atom()

              A unique identifier for a handler instance.

       <b>level()</b> =
           emergency | alert | critical | error | warning | notice |
           info | debug

              The severity level for the message to be logged.

       <b>log_event()</b> =
           #{level := level(),
             msg :=
                 {io:format(), [term()]} |
                 {report, report()} |
                 {string, unicode:chardata()},
             meta := metadata()}

       <b>metadata()</b> =
           #{pid =&gt; pid(),
             gl =&gt; pid(),
             time =&gt; timestamp(),
             mfa =&gt; {module(), atom(), integer() &gt;= 0},
             file =&gt; file:filename(),
             line =&gt; integer() &gt;= 0,
             domain =&gt; [atom()],
             report_cb =&gt; report_cb(),
             atom() =&gt; term()}

              Metadata for the log event.

              Logger adds the following metadata to each log event:

                * <u>pid</u> <u>=&gt;</u> <u>self()</u>

                * <u>gl</u> <u>=&gt;</u> <u>group_leader()</u>

                * <u>time</u> <u>=&gt;</u> <u>logger:timestamp()</u>

              When a log macro is used, Logger also inserts location information:

                * <u>mfa</u> <u>=&gt;</u> <u>{?MODULE,</u> <u>?FUNCTION_NAME,</u> <u>?FUNCTION_ARITY}</u>

                * <u>file</u> <u>=&gt;</u> <u>?FILE</u>

                * <u>line</u> <u>=&gt;</u> <u>?LINE</u>

              You can add custom metadata, either by:

                * specifying a map as the last parameter to any of the log macros or the logger API functions.

                * setting process metadata with <u>set_process_metadata/1</u> or <u>update_process_metadata/1</u>.

                * setting  primary  metadata  with  <u>set_primary_config/1</u>  or  through  the  kernel configuration
                  parameter  logger_metadata

          <b>Note:</b>
              When adding custom metadata, make sure not to use any of the keys  mentioned  above  as  that  may
              cause a lot of confusion about the log events.

              Logger  merges  all the metadata maps before forwarding the log event to the handlers. If the same
              keys occur, values from the log call overwrite process  metadata,  which  overwrites  the  primary
              metadata, which in turn overwrite values set by Logger.

              The following custom metadata keys have special meaning:

                <u>domain</u>:
                  The  value  associated  with  this  key is used by filters for grouping log events originating
                  from, for example, specific functional areas. See <u>logger_filters:domain/2</u> for a description of
                  how this field can be used.

                <u>report_cb</u>:
                  If the log message is specified as a <u>report()</u>, the <u>report_cb</u> key can be associated with a  fun
                  (report  callback) that converts the report to a format string and arguments, or directly to a
                  string. See the type definition of <u>report_cb()</u>, and section Log Message in  the  User's  Guide
                  for more information about report callbacks.

       <b>msg_fun()</b> =
           fun((term()) -&gt;
                   msg_fun_return() | {msg_fun_return(), metadata()})

       <b>msg_fun_return()</b> =
           {io:format(), [term()]} |
           report() |
           unicode:chardata() |
           ignore

       <b>olp_config()</b> =
           #{sync_mode_qlen =&gt; integer() &gt;= 0,
             drop_mode_qlen =&gt; integer() &gt;= 1,
             flush_qlen =&gt; integer() &gt;= 1,
             burst_limit_enable =&gt; boolean(),
             burst_limit_max_count =&gt; integer() &gt;= 1,
             burst_limit_window_time =&gt; integer() &gt;= 1,
             overload_kill_enable =&gt; boolean(),
             overload_kill_qlen =&gt; integer() &gt;= 1,
             overload_kill_mem_size =&gt; integer() &gt;= 1,
             overload_kill_restart_after =&gt; integer() &gt;= 0 | infinity}

       <b>primary_config()</b> =
           #{level =&gt; level() | all | none,
             metadata =&gt; metadata(),
             filter_default =&gt; log | stop,
             filters =&gt; [{filter_id(), filter()}]}

              Primary configuration data for Logger. The following default values apply:

                * <u>level</u> <u>=&gt;</u> <u>info</u>

                * <u>filter_default</u> <u>=&gt;</u> <u>log</u>

                * <u>filters</u> <u>=&gt;</u> <u>[]</u>

       <b>report()</b> = map() | [{atom(), term()}]

       <b>report_cb()</b> =
           fun((report()) -&gt; {io:format(), [term()]}) |
           fun((report(), report_cb_config()) -&gt; unicode:chardata())

              A  fun  which  converts  a <u>report()</u> to a format string and arguments, or directly to a string. See
              section Log Message in the User's Guide for more information.

       <b>report_cb_config()</b> =
           #{depth := integer() &gt;= 1 | unlimited,
             chars_limit := integer() &gt;= 1 | unlimited,
             single_line := boolean()}

       <b>timestamp()</b> = integer()

              A timestamp produced with <u>logger:timestamp()</u>.

</pre><h4><b>MACROS</b></h4><pre>
       The following macros are defined in <u>logger.hrl</u>, which is included in a module with the directive

           -include_lib("kernel/include/logger.hrl").

         * <u>?LOG_EMERGENCY(StringOrReport[,Metadata])</u>

         * <u>?LOG_EMERGENCY(FunOrFormat,Args[,Metadata])</u>

         * <u>?LOG_ALERT(StringOrReport[,Metadata])</u>

         * <u>?LOG_ALERT(FunOrFormat,Args[,Metadata])</u>

         * <u>?LOG_CRITICAL(StringOrReport[,Metadata])</u>

         * <u>?LOG_CRITICAL(FunOrFormat,Args[,Metadata])</u>

         * <u>?LOG_ERROR(StringOrReport[,Metadata])</u>

         * <u>?LOG_ERROR(FunOrFormat,Args[,Metadata])</u>

         * <u>?LOG_WARNING(StringOrReport[,Metadata])</u>

         * <u>?LOG_WARNING(FunOrFormat,Args[,Metadata])</u>

         * <u>?LOG_NOTICE(StringOrReport[,Metadata])</u>

         * <u>?LOG_NOTICE(FunOrFormat,Args[,Metadata])</u>

         * <u>?LOG_INFO(StringOrReport[,Metadata])</u>

         * <u>?LOG_INFO(FunOrFormat,Args[,Metadata])</u>

         * <u>?LOG_DEBUG(StringOrReport[,Metadata])</u>

         * <u>?LOG_DEBUG(FunOrFormat,Args[,Metadata])</u>

         * <u>?LOG(Level,StringOrReport[,Metadata])</u>

         * <u>?LOG(Level,FunOrFormat,Args[,Metadata])</u>

       All macros expand to a call to Logger, where <u>Level</u> is taken from  the  macro  name,  or  from  the  first
       argument  in  the  case  of the <u>?LOG</u> macro. Location data is added to the metadata as described under the
       <u>metadata()</u> type definition.

       The call is wrapped in a case statement and will be evaluated only if <u>Level</u> is  equal  to  or  below  the
       configured log level.

</pre><h4><b>LOGGING</b> <b>API</b> <b>FUNCTIONS</b></h4><pre>
</pre><h4><b>EXPORTS</b></h4><pre>
       <b>emergency(StringOrReport[,Metadata])</b>
       <b>emergency(Format,Args[,Metadata])</b>
       <b>emergency(Fun,FunArgs[,Metadata])</b>

              Equivalent to <u>log(emergency,...)</u>.

       <b>alert(StringOrReport[,Metadata])</b>
       <b>alert(Format,Args[,Metadata])</b>
       <b>alert(Fun,FunArgs[,Metadata])</b>

              Equivalent to <u>log(alert,...)</u>.

       <b>critical(StringOrReport[,Metadata])</b>
       <b>critical(Format,Args[,Metadata])</b>
       <b>critical(Fun,FunArgs[,Metadata])</b>

              Equivalent to <u>log(critical,...)</u>.

       <b>error(StringOrReport[,Metadata])</b>
       <b>error(Format,Args[,Metadata])</b>
       <b>error(Fun,FunArgs[,Metadata])</b>

              Equivalent to <u>log(error,...)</u>.

       <b>warning(StringOrReport[,Metadata])</b>
       <b>warning(Format,Args[,Metadata])</b>
       <b>warning(Fun,FunArgs[,Metadata])</b>

              Equivalent to <u>log(warning,...)</u>.

       <b>notice(StringOrReport[,Metadata])</b>
       <b>notice(Format,Args[,Metadata])</b>
       <b>notice(Fun,FunArgs[,Metadata])</b>

              Equivalent to <u>log(notice,...)</u>.

       <b>info(StringOrReport[,Metadata])</b>
       <b>info(Format,Args[,Metadata])</b>
       <b>info(Fun,FunArgs[,Metadata])</b>

              Equivalent to <u>log(info,...)</u>.

       <b>debug(StringOrReport[,Metadata])</b>
       <b>debug(Format,Args[,Metadata])</b>
       <b>debug(Fun,FunArgs[,Metadata])</b>

              Equivalent to <u>log(debug,...)</u>.

       <b>log(Level,</b> <b>StringOrReport)</b> <b>-&gt;</b> <b>ok</b>

       <b>log(Level,</b> <b>StringOrReport,</b> <b>Metadata)</b> <b>-&gt;</b> <b>ok</b>

       <b>log(Level,</b> <b>Format,</b> <b>Args)</b> <b>-&gt;</b> <b>ok</b>

       <b>log(Level,</b> <b>Fun,</b> <b>FunArgs)</b> <b>-&gt;</b> <b>ok</b>

       <b>log(Level,</b> <b>Format,</b> <b>Args,</b> <b>Metadata)</b> <b>-&gt;</b> <b>ok</b>

       <b>log(Level,</b> <b>Fun,</b> <b>FunArgs,</b> <b>Metadata)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Level = level()
                 StringOrReport = unicode:chardata() | report()
                 Format = io:format()
                 Args = [term()]
                 Fun = msg_fun()
                 FunArgs = term()
                 Metadata = metadata()

              Create  a  log  event  at  the  given log level, with the given message to be logged and <u>metadata</u>.
              Examples:

              %% A plain string
              logger:log(info, "Hello World").
              %% A plain string with metadata
              logger:log(debug, "Hello World", #{ meta =&gt; data }).
              %% A format string with arguments
              logger:log(warning, "The roof is on ~ts",[Cause]).
              %% A report
              logger:log(warning, #{ what =&gt; roof, cause =&gt; Cause }).

              The message and metadata can either be given directly in the arguments, or returned  from  a  fun.
              Passing  a  fun  instead  of  the  message/metadata  directly  is  useful  in  scenarios  when the
              message/metadata is very expensive to compute. This is because the fun is only evaluted  when  the
              message/metadata is actually needed, which may be not at all if the log event is not to be logged.
              Examples:

              %% A plain string with expensive metadata
              logger:info(fun([]) -&gt; {"Hello World", #{ meta =&gt; expensive() }} end,[]).
              %% An expensive report
              logger:debug(fun(What) -&gt; #{ what =&gt; What, cause =&gt; expensive() } end,roof).
              %% A plain string with expensive metadata and normal metadata
              logger:debug(fun([]) -&gt; {"Hello World", #{ meta =&gt; expensive() }} end,[],
                           #{ meta =&gt; data }).

              When  metadata  is  given  both as an argument and returned from the fun they are merged. If equal
              keys exists the values are taken from the metadata returned by the fun.

</pre><h4><b>CONFIGURATION</b> <b>API</b> <b>FUNCTIONS</b></h4><pre>
</pre><h4><b>EXPORTS</b></h4><pre>
       <b>add_handler(HandlerId,</b> <b>Module,</b> <b>Config)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>term()}</b>

              Types:

                 HandlerId = handler_id()
                 Module = module()
                 Config = handler_config()

              Add a handler with the given configuration.

              <u>HandlerId</u> is a unique identifier which must be used in all  subsequent  calls  referring  to  this
              handler.

       <b>add_handler_filter(HandlerId,</b> <b>FilterId,</b> <b>Filter)</b> <b>-&gt;</b>
                             ok | {error, term()}

              Types:

                 HandlerId = handler_id()
                 FilterId = filter_id()
                 Filter = filter()

              Add a filter to the specified handler.

              The  filter  fun  is  called  with  the  log  event  as  the  first  parameter,  and the specified
              <u>filter_args()</u> as the second parameter.

              The return value of the fun specifies if a log event is  to  be  discarded  or  forwarded  to  the
              handler callback:

                <u>log_event()</u>:
                  The  filter  <u>passed</u>. The next handler filter, if any, is applied. If no more filters exist for
                  this handler, the log event is forwarded to the handler callback.

                <u>stop</u>:
                  The filter <u>did</u> <u>not</u> <u>pass</u>, and the log event is immediately discarded.

                <u>ignore</u>:
                  The filter has no knowledge of the log event. The next handler filter, if any, is applied.  If
                  no  more  filters  exist  for  this  handler,  the  value  of the <u>filter_default</u> configuration
                  parameter for the handler specifies if the log event shall be discarded or  forwarded  to  the
                  handler callback.

              See section Filters in the User's Guide for more information about filters.

              Some built-in filters exist. These are defined in <u><a href="../man3erl/logger_filters.3erl.html">logger_filters</a>(3erl)</u>.

       <b>add_handlers(Application)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>term()}</b>

              Types:

                 Application = atom()

              Reads the application configuration parameter <u>logger</u> and calls <u>add_handlers/1</u> with its contents.

       <b>add_handlers(HandlerConfig)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>term()}</b>

              Types:

                 HandlerConfig = [config_handler()]
                 <b>config_handler()</b> =
                     {handler, handler_id(), module(), handler_config()}

              This  function should be used by custom Logger handlers to make configuration consistent no matter
              which handler the system uses. Normal usage is to add a call to <u>logger:add_handlers/1</u>  just  after
              the  processes that the handler needs are started, and pass the application's <u>logger</u> configuration
              as the argument. For example:

              -behaviour(application).
              start(_, []) -&gt;
                  case supervisor:start_link({local, my_sup}, my_sup, []) of
                      {ok, Pid} -&gt;
                          ok = logger:<a href="../manmy_app/add_handlers.my_app.html">add_handlers</a>(my_app),
                          {ok, Pid, []};
                      Error -&gt; Error
                   end.

              This reads the  <u>logger</u>  configuration  parameter  from  the  <u>my_app</u>  application  and  starts  the
              configured  handlers.  The  contents of the configuration use the same rules as the logger handler
              configuration.

              If the handler is meant to replace the default handler, the Kernel's default handler  have  to  be
              disabled  before  the new handler is added. A <u>sys.config</u> file that disables the Kernel handler and
              adds a custom handler could look like this:

              [{kernel,
                [{logger,
                  %% Disable the default Kernel handler
                  [{handler, default, undefined}]}]},
               {my_app,
                [{logger,
                  %% Enable this handler as the default
                  [{handler, default, my_handler, #{}}]}]}].

       <b>add_primary_filter(FilterId,</b> <b>Filter)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>term()}</b>

              Types:

                 FilterId = filter_id()
                 Filter = filter()

              Add a primary filter to Logger.

              The filter fun  is  called  with  the  log  event  as  the  first  parameter,  and  the  specified
              <u>filter_args()</u> as the second parameter.

              The  return  value  of  the  fun  specifies  if a log event is to be discarded or forwarded to the
              handlers:

                <u>log_event()</u>:
                  The filter <u>passed</u>. The next primary filter, if any, is applied. If  no  more  primary  filters
                  exist,  the  log  event  is forwarded to the handler part of Logger, where handler filters are
                  applied.

                <u>stop</u>:
                  The filter <u>did</u> <u>not</u> <u>pass</u>, and the log event is immediately discarded.

                <u>ignore</u>:
                  The filter has no knowledge of the log event. The next primary filter, if any, is applied.  If
                  no more primary filters exist, the value of the primary <u>filter_default</u> configuration parameter
                  specifies if the log event shall be discarded or forwarded to the handler part.

              See section  Filters in the User's Guide for more information about filters.

              Some built-in filters exist. These are defined in <u><a href="../man3erl/logger_filters.3erl.html">logger_filters</a>(3erl)</u>.

       <b>get_config()</b> <b>-&gt;</b>
                     #{primary =&gt; primary_config(),
                       handlers =&gt; [handler_config()],
                       proxy =&gt; olp_config(),
                       module_levels =&gt;
                           [{module(), level() | all | none}]}

              Look up all current Logger configuration, including primary, handler, and proxy configuration, and
              module level settings.

       <b>get_handler_config()</b> <b>-&gt;</b> <b>[Config]</b>

              Types:

                 Config = handler_config()

              Look up the current configuration for all handlers.

       <b>get_handler_config(HandlerId)</b> <b>-&gt;</b> <b>{ok,</b> <b>Config}</b> <b>|</b> <b>{error,</b> <b>term()}</b>

              Types:

                 HandlerId = handler_id()
                 Config = handler_config()

              Look up the current configuration for the given handler.

       <b>get_handler_ids()</b> <b>-&gt;</b> <b>[HandlerId]</b>

              Types:

                 HandlerId = handler_id()

              Look up the identities for all installed handlers.

       <b>get_primary_config()</b> <b>-&gt;</b> <b>Config</b>

              Types:

                 Config = primary_config()

              Look up the current primary configuration for Logger.

       <b>get_proxy_config()</b> <b>-&gt;</b> <b>Config</b>

              Types:

                 Config = olp_config()

              Look up the current configuration for the Logger proxy.

              For more information about the proxy, see section Logger Proxy in the Kernel User's Guide.

       <b>get_module_level()</b> <b>-&gt;</b> <b>[{Module,</b> <b>Level}]</b>

              Types:

                 Module = module()
                 Level = level() | all | none

              Look  up  all current module levels. Returns a list containing one <u>{Module,Level}</u> element for each
              module for which the module level was previously set with <u>set_module_level/2</u>.

       <b>get_module_level(Modules)</b> <b>-&gt;</b> <b>[{Module,</b> <b>Level}]</b>

              Types:

                 Modules = [Module] | Module
                 Module = module()
                 Level = level() | all | none

              Look up the current level for the given modules. Returns  a  list  containing  one  <u>{Module,Level}</u>
              element  for  each  of  the  given  modules  for  which  the  module level was previously set with
              <u>set_module_level/2</u>.

       <b>get_process_metadata()</b> <b>-&gt;</b> <b>Meta</b> <b>|</b> <b>undefined</b>

              Types:

                 Meta = metadata()

              Retrieve data set with <u>set_process_metadata/1</u> or <u>update_process_metadata/1</u>.

       <b>i()</b> <b>-&gt;</b> <b>ok</b>

       <b>i(What)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 What = primary | handlers | proxy | modules | handler_id()

              Pretty print the Logger configuration.

       <b>remove_handler(HandlerId)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>term()}</b>

              Types:

                 HandlerId = handler_id()

              Remove the handler identified by <u>HandlerId</u>.

       <b>remove_handler_filter(HandlerId,</b> <b>FilterId)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>term()}</b>

              Types:

                 HandlerId = handler_id()
                 FilterId = filter_id()

              Remove the filter identified by <u>FilterId</u> from the handler identified by <u>HandlerId</u>.

       <b>remove_primary_filter(FilterId)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>term()}</b>

              Types:

                 FilterId = filter_id()

              Remove the primary filter identified by <u>FilterId</u> from Logger.

       <b>set_application_level(Application,</b> <b>Level)</b> <b>-&gt;</b>
                                ok | {error, not_loaded}

              Types:

                 Application = atom()
                 Level = level() | all | none

              Set the log level for all the modules of the specified application.

              This function is a convenience function  that  calls  logger:set_module_level/2  for  each  module
              associated with an application.

       <b>set_handler_config(HandlerId,</b> <b>Config)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>term()}</b>

              Types:

                 HandlerId = handler_id()
                 Config = handler_config()

              Set   configuration   data  for  the  specified  handler.  This  overwrites  the  current  handler
              configuration.

              To modify the existing configuration, use <u>update_handler_config/2</u>, or, if a more complex merge  is
              needed, read the current configuration with <u>get_handler_config/1</u>, then do the merge before writing
              the new configuration back with this function.

              If  a  key  is  removed compared to the current configuration, and the key is known by Logger, the
              default value is used. If it is a custom key, then it is up to the handler implementation  if  the
              value is removed or a default value is inserted.

       <b>set_handler_config(HandlerId,</b> <b>Key</b> <b>::</b> <b>level,</b> <b>Level)</b> <b>-&gt;</b> <b>Return</b>

       <b>set_handler_config(HandlerId,</b>
                          Key :: filter_default,
                          FilterDefault) -&gt;
                             Return

       <b>set_handler_config(HandlerId,</b> <b>Key</b> <b>::</b> <b>filters,</b> <b>Filters)</b> <b>-&gt;</b> <b>Return</b>

       <b>set_handler_config(HandlerId,</b> <b>Key</b> <b>::</b> <b>formatter,</b> <b>Formatter)</b> <b>-&gt;</b>
                             Return

       <b>set_handler_config(HandlerId,</b> <b>Key</b> <b>::</b> <b>config,</b> <b>Config)</b> <b>-&gt;</b> <b>Return</b>

              Types:

                 HandlerId = handler_id()
                 Level = level() | all | none
                 FilterDefault = log | stop
                 Filters = [{filter_id(), filter()}]
                 Formatter = {module(), formatter_config()}
                 Config = term()
                 Return = ok | {error, term()}

              Add  or  update configuration data for the specified handler. If the given <u>Key</u> already exists, its
              associated value will be changed to the given value. If it does not exist, it will be added.

              If the value is incomplete, which for example can be the case for the <u>config</u> key, it is up to  the
              handler  implementation  how  the  unspecified  parts  are  set.  For  all  handlers in the Kernel
              application, unspecified data for the <u>config</u>  key  is  set  to  default  values.  To  update  only
              specified data, and keep the existing configuration for the rest, use <u>update_handler_config/3</u>.

              See  the  definition  of  the  <u>handler_config()</u>  type  for  more  information  about the different
              parameters.

       <b>set_primary_config(Config)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>term()}</b>

              Types:

                 Config = primary_config()

              Set primary configuration data for Logger. This overwrites the current configuration.

              To modify the existing configuration, use <u>update_primary_config/1</u>, or, if a more complex merge  is
              needed, read the current configuration with <u>get_primary_config/0</u>, then do the merge before writing
              the new configuration back with this function.

              If a key is removed compared to the current configuration, the default value is used.

       <b>set_primary_config(Key</b> <b>::</b> <b>level,</b> <b>Level)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>term()}</b>

       <b>set_primary_config(Key</b> <b>::</b> <b>filter_default,</b> <b>FilterDefault)</b> <b>-&gt;</b>
                             ok | {error, term()}

       <b>set_primary_config(Key</b> <b>::</b> <b>filters,</b> <b>Filters)</b> <b>-&gt;</b>
                             ok | {error, term()}

       <b>set_primary_config(Key</b> <b>::</b> <b>metadata,</b> <b>Meta)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>term()}</b>

              Types:

                 Level = level() | all | none
                 FilterDefault = log | stop
                 Filters = [{filter_id(), filter()}]
                 Meta = metadata()

              Add  or  update  primary  configuration  data  for  Logger.  If  the given <u>Key</u> already exists, its
              associated value will be changed to the given value. If it does not exist, it will be added.

       <b>set_proxy_config(Config)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>term()}</b>

              Types:

                 Config = olp_config()

              Set configuration data for the Logger proxy. This overwrites the current proxy configuration. Keys
              that are not specified in the <u>Config</u> map gets default values.

              To modify the existing configuration, use <u>update_proxy_config/1</u>, or, if a more  complex  merge  is
              needed,  read  the current configuration with <u>get_proxy_config/0</u>, then do the merge before writing
              the new configuration back with this function.

              For more information about the proxy, see section Logger Proxy in the Kernel User's Guide.

       <b>set_module_level(Modules,</b> <b>Level)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>term()}</b>

              Types:

                 Modules = [module()] | module()
                 Level = level() | all | none

              Set the log level for the specified modules.

              The log level for a module overrides the primary log level of Logger for  log  events  originating
              from  the  module  in question. Notice, however, that it does not override the level configuration
              for any handler.

              For example: Assume that the primary log level for Logger is <u>info</u>, and there is one  handler,  <u>h1</u>,
              with level <u>info</u> and one handler, <u>h2</u>, with level <u>debug</u>.

              With  this  configuration,  no  debug  messages  will be logged, since they are all stopped by the
              primary log level.

              If the level for <u>mymodule</u> is now set to <u>debug</u>, then debug events from this module will  be  logged
              by the handler <u>h2</u>, but not by handler <u>h1</u>.

              Debug events from other modules are still not logged.

              To change the primary log level for Logger, use <u>set_primary_config(level,</u> <u>Level)</u>.

              To change the log level for a handler, use <u>set_handler_config(HandlerId,</u> <u>level,</u> <u>Level)</u>.

          <b>Note:</b>
              The originating module for a log event is only detected if the key <u>mfa</u> exists in the metadata, and
              is  associated  with  <u>{Module,</u>  <u>Function,</u>  <u>Arity}</u>.  When  log macros are used, this association is
              automatically added to all log events. If an API function is  called  directly,  without  using  a
              macro,  the  logging  client  must explicitly add this information if module levels shall have any
              effect.

       <b>set_process_metadata(Meta)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Meta = metadata()

              Set metadata which Logger shall automatically insert in all log events  produced  on  the  current
              process.

              Location  data  produced by the log macros, and/or metadata given as argument to the log call (API
              function or macro), are merged with the process metadata. If the same keys occur, values from  the
              metadata  argument  to  the  log  call  overwrite  values from the process metadata, which in turn
              overwrite values from the location data.

              Subsequent calls to this function overwrites previous data set. To update existing data instead of
              overwriting it, see <u>update_process_metadata/1</u>.

       <b>unset_application_level(Application)</b> <b>-&gt;</b>
                                  ok | {error, {not_loaded, Application}}

              Types:

                 Application = atom()

              Unset the log level for all the modules of the specified application.

              This function is a  utility  function  that  calls  logger:unset_module_level/2  for  each  module
              associated with an application.

       <b>unset_module_level()</b> <b>-&gt;</b> <b>ok</b>

              Remove module specific log settings. After this, the primary log level is used for all modules.

       <b>unset_module_level(Modules)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Modules = [module()] | module()

              Remove  module  specific log settings. After this, the primary log level is used for the specified
              modules.

       <b>unset_process_metadata()</b> <b>-&gt;</b> <b>ok</b>

              Delete data set with <u>set_process_metadata/1</u> or <u>update_process_metadata/1</u>.

       <b>update_formatter_config(HandlerId,</b> <b>FormatterConfig)</b> <b>-&gt;</b>
                                  ok | {error, term()}

              Types:

                 HandlerId = handler_id()
                 FormatterConfig = formatter_config()

              Update the formatter configuration for the specified handler.

              The new configuration is merged with the existing formatter configuration.

              To overwrite the existing configuration without any merge, use

              set_handler_config(HandlerId, formatter, {FormatterModule, FormatterConfig}).

       <b>update_formatter_config(HandlerId,</b> <b>Key,</b> <b>Value)</b> <b>-&gt;</b>
                                  ok | {error, term()}

              Types:

                 HandlerId = handler_id()
                 Key = atom()
                 Value = term()

              Update the formatter configuration for the specified handler.

              This is equivalent to

              update_formatter_config(HandlerId, #{Key =&gt; Value})

       <b>update_handler_config(HandlerId,</b> <b>Config)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>term()}</b>

              Types:

                 HandlerId = handler_id()
                 Config = handler_config()

              Update configuration data  for  the  specified  handler.  This  function  behaves  as  if  it  was
              implemented as follows:

              {ok, {_, Old}} = logger:get_handler_config(HandlerId),
              logger:set_handler_config(HandlerId, maps:merge(Old, Config)).

              To overwrite the existing configuration without any merge, use <u>set_handler_config/2</u>.

       <b>update_handler_config(HandlerId,</b> <b>Key</b> <b>::</b> <b>level,</b> <b>Level)</b> <b>-&gt;</b> <b>Return</b>

       <b>update_handler_config(HandlerId,</b>
                             Key :: filter_default,
                             FilterDefault) -&gt;
                                Return

       <b>update_handler_config(HandlerId,</b> <b>Key</b> <b>::</b> <b>filters,</b> <b>Filters)</b> <b>-&gt;</b>
                                Return

       <b>update_handler_config(HandlerId,</b> <b>Key</b> <b>::</b> <b>formatter,</b> <b>Formatter)</b> <b>-&gt;</b>
                                Return

       <b>update_handler_config(HandlerId,</b> <b>Key</b> <b>::</b> <b>config,</b> <b>Config)</b> <b>-&gt;</b> <b>Return</b>

              Types:

                 HandlerId = handler_id()
                 Level = level() | all | none
                 FilterDefault = log | stop
                 Filters = [{filter_id(), filter()}]
                 Formatter = {module(), formatter_config()}
                 Config = term()
                 Return = ok | {error, term()}

              Add  or  update configuration data for the specified handler. If the given <u>Key</u> already exists, its
              associated value will be changed to the given value. If it does not exist, it will be added.

              If the value is incomplete, which for example can be the case for the <u>config</u> key, it is up to  the
              handler  implementation  how  the  unspecified  parts  are  set.  For  all  handlers in the Kernel
              application, unspecified data for the <u>config</u> key is not changed.  To  reset  unspecified  data  to
              default values, use <u>set_handler_config/3</u>.

              See  the  definition  of  the  <u>handler_config()</u>  type  for  more  information  about the different
              parameters.

       <b>update_primary_config(Config)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>term()}</b>

              Types:

                 Config = primary_config()

              Update primary configuration data for Logger. This function behaves as if it  was  implemented  as
              follows:

              Old = logger:get_primary_config(),
              logger:set_primary_config(maps:merge(Old, Config)).

              To overwrite the existing configuration without any merge, use <u>set_primary_config/1</u>.

       <b>update_process_metadata(Meta)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Meta = metadata()

              Set or update metadata to use when logging from current process

              If process metadata exists for the current process, this function behaves as if it was implemented
              as follows:

              logger:set_process_metadata(maps:merge(logger:get_process_metadata(), Meta)).

              If no process metadata exists, the function behaves as <u>set_process_metadata/1</u>.

       <b>update_proxy_config(Config)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>term()}</b>

              Types:

                 Config = olp_config()

              Update  configuration data for the Logger proxy. This function behaves as if it was implemented as
              follows:

              Old = logger:get_proxy_config(),
              logger:set_proxy_config(maps:merge(Old, Config)).

              To overwrite the existing configuration without any merge, use <u>set_proxy_config/1</u>.

              For more information about the proxy, see section Logger Proxy in the Kernel User's Guide.

</pre><h4><b>MISCELLANEOUS</b> <b>API</b> <b>FUNCTIONS</b></h4><pre>
</pre><h4><b>EXPORTS</b></h4><pre>
       <b>compare_levels(Level1,</b> <b>Level2)</b> <b>-&gt;</b> <b>eq</b> <b>|</b> <b>gt</b> <b>|</b> <b>lt</b>

              Types:

                 Level1 = Level2 = level() | all | none

              Compare the severity of two log levels. Returns <u>gt</u> if <u>Level1</u> is more severe  than  <u>Level2</u>,  <u>lt</u>  if
              <u>Level1</u> is less severe, and <u>eq</u> if the levels are equal.

       <b>format_report(Report)</b> <b>-&gt;</b> <b>FormatArgs</b>

              Types:

                 Report = report()
                 FormatArgs = {io:format(), [term()]}

              Convert  a  log message on report form to <u>{Format,</u> <u>Args}</u>. This is the default report callback used
              by <u><a href="../man3erl/logger_formatter.3erl.html">logger_formatter</a>(3erl)</u> when no custom report callback is found. See section Log Message in  the
              Kernel User's Guide for information about report callbacks and valid forms of log messages.

              The  function  produces lines of <u>Key:</u> <u>Value</u> from key-value lists. Strings are printed with <u>~ts</u> and
              other terms with <u>~tp</u>.

              If <u>Report</u> is a map, it is converted to a key-value list before formatting as such.

       <b>timestamp()</b> <b>-&gt;</b> <b>timestamp()</b>

              Return a timestamp that can be inserted as the <u>time</u> field in the meta data for a log event. It  is
              produced with <u>os:<a href="../manmicrosecond/system_time.microsecond.html">system_time</a>(microsecond)</u>.

              Notice  that  Logger  automatically inserts a timestamp in the meta data unless it already exists.
              This function is exported for the rare case when the timestamp must be taken at a different  point
              in time than when the log event is issued.

       <b>reconfigure()</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>term()}</b>

              Reconfigure  Logger  using  updated <u>kernel</u> configuration that was set after <u>kernel</u> application was
              loaded.

              Beware, that this is meant to be run only by the build  tools,  not  manually  during  application
              lifetime, as this may cause missing log entries.

</pre><h4><b>HANDLER</b> <b>CALLBACK</b> <b>FUNCTIONS</b></h4><pre>
       The following functions are to be exported from a handler callback module.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>HModule:adding_handler(Config1)</b> <b>-&gt;</b> <b>{ok,</b> <b>Config2}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Config1 = Config2 = handler_config()
                 Reason = term()

              This callback function is optional.

              The function is called on a temporary process when a new handler is about to be added. The purpose
              is to verify the configuration and initiate all resources needed by the handler.

              The handler identity is associated with the <u>id</u> key in <u>Config1</u>.

              If  everything  succeeds,  the callback function can add possible default values or internal state
              values to the configuration, and return the adjusted map in <u>{ok,Config2}</u>.

              If the configuration is faulty, or if the initiation fails,  the  callback  function  must  return
              <u>{error,Reason}</u>.

       <b>HModule:changing_config(SetOrUpdate,</b> <b>OldConfig,</b> <b>NewConfig)</b> <b>-&gt;</b> <b>{ok,</b> <b>Config}</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 SetOrUpdate = set | update
                 OldConfig = NewConfig = Config = handler_config()
                 Reason = term()

              This callback function is optional.

              The  function  is  called  on a temporary process when the configuration for a handler is about to
              change. The purpose is to verify and act on the new configuration.

              <u>OldConfig</u> is the existing configuration and <u>NewConfig</u> is the new configuration.

              The handler identity is associated with the <u>id</u> key in <u>OldConfig</u>.

              <u>SetOrUpdate</u>  has  the  value  <u>set</u>  if  the  configuration  change  originates  from  a   call   to
              <u>set_handler_config/2,3</u>,  and  <u>update</u>  if it originates from <u>update_handler_config/2,3</u>. The handler
              can use this parameter to decide how to update the value of the <u>config</u> field, that is, the handler
              specific configuration data. Typically, if <u>SetOrUpdate</u> equals <u>set</u>, values that are  not  specified
              must  be  given  their default values. If <u>SetOrUpdate</u> equals <u>update</u>, the values found in <u>OldConfig</u>
              must be used instead.

              If everything succeeds, the callback function must return a  possibly  adjusted  configuration  in
              <u>{ok,Config}</u>.

              If the configuration is faulty, the callback function must return <u>{error,Reason}</u>.

       <b>HModule:filter_config(Config)</b> <b>-&gt;</b> <b>FilteredConfig</b>

              Types:

                 Config = FilteredConfig = handler_config()

              This callback function is optional.

              The function is called when one of the Logger API functions for fetching the handler configuration
              is called, for example <u>logger:get_handler_config/1</u>.

              It  allows  the  handler  to  remove internal data fields from its configuration data before it is
              returned to the caller.

       <b>HModule:log(LogEvent,</b> <b>Config)</b> <b>-&gt;</b> <b>void()</b>

              Types:

                 LogEvent = log_event()
                 Config = handler_config()

              This callback function is mandatory.

              The function is called when all primary filters  and  all  handler  filters  for  the  handler  in
              question  have  passed  for  the given log event. It is called on the client process, that is, the
              process that issued the log event.

              The handler identity is associated with the <u>id</u> key in <u>Config</u>.

              The handler must log the event.

              The return value from this function is ignored by Logger.

       <b>HModule:removing_handler(Config)</b> <b>-&gt;</b> <b>ok</b>

              Types:

                 Config = handler_config()

              This callback function is optional.

              The function is called on a temporary process when a handler is about to be removed.  The  purpose
              is to release all resources used by the handler.

              The handler identity is associated with the <u>id</u> key in <u>Config</u>.

              The return value is ignored by Logger.

</pre><h4><b>FORMATTER</b> <b>CALLBACK</b> <b>FUNCTIONS</b></h4><pre>
       The following functions are to be exported from a formatter callback module.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>FModule:check_config(FConfig)</b> <b>-&gt;</b> <b>ok</b> <b>|</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 FConfig = formatter_config()
                 Reason = term()

              This callback function is optional.

              The  function is called by a Logger when formatter configuration is set or modified. The formatter
              must validate the given configuration and return <u>ok</u> if it is correct, and <u>{error,Reason}</u> if it  is
              faulty.

              The following Logger API functions can trigger this callback:

                * <u>logger:add_handler/3</u>

                * <u>logger:set_handler_config/2,3</u>

                * <u>logger:update_handler_config/2,3</u>

                * <u>logger:update_formatter_config/2</u>

              See  <u><a href="../man3erl/logger_formatter.3erl.html">logger_formatter</a>(3erl)</u>  for  an  example  implementation.  <u>logger_formatter</u>  is  the  default
              formatter used by Logger.

       <b>FModule:format(LogEvent,</b> <b>FConfig)</b> <b>-&gt;</b> <b>FormattedLogEntry</b>

              Types:

                 LogEvent = log_event()
                 FConfig = formatter_config()
                 FormattedLogEntry = unicode:chardata()

              This callback function is mandatory.

              The function can be called by a log handler to convert a log event term to a printable string. The
              returned value can, for example, be printed as a  log  entry  to  the  console  or  a  file  using
              <u>io:put_chars/1,2</u>.

              See  <u><a href="../man3erl/logger_formatter.3erl.html">logger_formatter</a>(3erl)</u>  for  an  example  implementation.  <u>logger_formatter</u>  is  the  default
              formatter used by Logger.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man5/config.5.html">config</a>(5)</u>, <u><a href="../man3erl/erlang.3erl.html">erlang</a>(3erl)</u>, <u><a href="../man3erl/io.3erl.html">io</a>(3erl)</u>, <u><a href="../man3erl/logger_disk_log_h.3erl.html">logger_disk_log_h</a>(3erl)</u>, <u><a href="../man3erl/logger_filters.3erl.html">logger_filters</a>(3erl)</u>, <u><a href="../man3erl/logger_formatter.3erl.html">logger_formatter</a>(3erl)</u>,
       <u><a href="../man3erl/logger_std_h.3erl.html">logger_std_h</a>(3erl)</u>, <u><a href="../man3erl/unicode.3erl.html">unicode</a>(3erl)</u>

Ericsson AB                                        kernel 8.2                                       <u><a href="../man3erl/logger.3erl.html">logger</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>