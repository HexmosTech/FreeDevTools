<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>file_sorter - File sorter.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       file_sorter - File sorter.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  module  contains  functions  for sorting terms on files, merging already sorted files, and checking
       files for sortedness. Chunks containing binary terms are read from a sequence of files, sorted internally
       in memory and written on temporary files, which are merged producing one sorted file as  output.  Merging
       is  provided  as  an optimization; it is faster when the files are already sorted, but it always works to
       sort instead of merge.

       On a file, a term is represented by a header and a binary. Two options define  the  format  of  terms  on
       files:

         <u>{header,</u> <u>HeaderLength}</u>:
           <u>HeaderLength</u>  determines  the  number of bytes preceding each binary and containing the length of the
           binary in bytes. Defaults to 4. The order of the header bytes is defined as follows: if <u>B</u> is a binary
           containing a header only, size <u>Size</u> of the binary is calculated as <u>&lt;&lt;Size:HeaderLength/unit:8&gt;&gt;</u> <u>=</u> <u>B</u>.

         <u>{format,</u> <u>Format}</u>:
           Option <u>Format</u> determines the function that is applied to binaries to create the terms to  be  sorted.
           Defaults  to  <u>binary_term</u>, which is equivalent to <u>fun</u> <u>binary_to_term/1</u>. Value <u>binary</u> is equivalent to
           <u>fun(X)</u> <u>-&gt;</u> <u>X</u> <u>end</u>, which means that the binaries are sorted as they are. This is the fastest format. If
           <u>Format</u> is <u>term</u>, <u>io:read/2</u> is called to read terms. In that case, only the  default  value  of  option
           <u>header</u> is allowed.

           Option  <u>format</u>  also  determines  what  is written to the sorted output file: if <u>Format</u> is <u>term</u>, then
           <u>io:format/3</u> is called to write each term, otherwise the binary  prefixed  by  a  header  is  written.
           Notice  that  the  binary  written is the same binary that was read; the results of applying function
           <u>Format</u> are thrown away when the terms have been sorted. Reading and writing terms using the <u>io</u> module
           is much slower than reading and writing binaries.

       Other options are:

         <u>{order,</u> <u>Order}</u>:
           The default is to sort terms in ascending order, but that can be changed by value  <u>descending</u>  or  by
           specifying  an  ordering  function <u>Fun</u>. An ordering function is antisymmetric, transitive, and total.
           <u>Fun(A,</u> <u>B)</u> is to return <u>true</u> if <u>A</u> comes before <u>B</u> in the ordering, otherwise <u>false</u>.  An  example  of  a
           typical  ordering  function is less than or equal to, <u>=&lt;/2</u>. Using an ordering function slows down the
           sort considerably. Functions <u>keysort</u>, <u>keymerge</u> and <u>keycheck</u> do not accept ordering functions.

         <u>{unique,</u> <u>boolean()}</u>:
           When sorting or merging files, only the first of a sequence of  terms  that  compare  equal  (<u>==</u>)  is
           output  if  this  option is set to <u>true</u>. Defaults to <u>false</u>, which implies that all terms that compare
           equal are output. When checking files for sortedness, a check  that  no  pair  of  consecutive  terms
           compares equal is done if this option is set to <u>true</u>.

         <u>{tmpdir,</u> <u>TempDirectory}</u>:
           The  directory  where temporary files are put can be chosen explicitly. The default, implied by value
           <u>""</u>, is to put temporary files on the same directory as  the  sorted  output  file.  If  output  is  a
           function  (see  below),  the  directory  returned  by  <u>file:get_cwd()</u>  is  used instead. The names of
           temporary files are derived from the Erlang nodename (<u>node()</u>), the process identifier of the  current
           Erlang  emulator  (<u>os:getpid()</u>),  and a unique integer (<u>erlang:unique_integer([positive])</u>). A typical
           name is <u><a href="mailto:fs_mynode@myhost_1763_4711.17">fs_mynode@myhost_1763_4711.17</a></u>, where <u>17</u> is a sequence number. Existing files are overwritten.
           Temporary files are deleted unless some uncaught <u>EXIT</u> signal occurs.

         <u>{compressed,</u> <u>boolean()}</u>:
           Temporary files and the output file can be compressed. Defaults <u>false</u>,  which  implies  that  written
           files  are  not compressed. Regardless of the value of option <u>compressed</u>, compressed files can always
           be read. Notice that reading and writing compressed files are significantly slower than  reading  and
           writing uncompressed files.

         <u>{size,</u> <u>Size}</u>:
           By default about 512*1024 bytes read from files are sorted internally. This option is rarely needed.

         <u>{no_files,</u> <u>NoFiles}</u>:
           By default 16 files are merged at a time. This option is rarely needed.

       As  an  alternative  to  sorting files, a function of one argument can be specified as input. When called
       with argument <u>read</u>, the function is assumed to return either of the following:

         * <u>end_of_input</u> or <u>{end_of_input,</u> <u>Value}}</u> when there is no more input (<u>Value</u> is explained below).

         * <u>{Objects,</u> <u>Fun}</u>, where <u>Objects</u> is a list of binaries or terms depending on the format, and  <u>Fun</u>  is  a
           new input function.

       Any  other  value  is  immediately  returned  as value of the current call to <u>sort</u> or <u>keysort</u>. Each input
       function is called exactly once. If an error occurs, the last function is called with argument <u>close</u>, the
       reply of which is ignored.

       A function of one argument can be specified as output. The results of sorting or  merging  the  input  is
       collected  in a non-empty sequence of variable length lists of binaries or terms depending on the format.
       The output function is called with one list at a time, and is assumed to return a  new  output  function.
       Any  other  return  value  is  immediately  returned  as  value  of the current call to the sort or merge
       function. Each output function is called exactly once. When some output function has been applied to  all
       of  the  results  or  an  error occurs, the last function is called with argument <u>close</u>, and the reply is
       returned as value of the current call to the sort or merge function.

       If a function is specified as input and the  last  input  function  returns  <u>{end_of_input,</u>  <u>Value}</u>,  the
       function  specified  as output is called with argument <u>{value,</u> <u>Value}</u>. This makes it easy to initiate the
       sequence of output functions with a value calculated by the input functions.

       As an example, consider sorting the terms on a disk log file. A function that reads chunks from the  disk
       log and returns a list of binaries is used as input. The results are collected in a list of terms.

       sort(Log) -&gt;
           {ok, _} = disk_log:open([{name,Log}, {mode,read_only}]),
           Input = input(Log, start),
           Output = output([]),
           Reply = file_sorter:sort(Input, Output, {format,term}),
           ok = disk_log:close(Log),
           Reply.

       input(Log, Cont) -&gt;
           fun(close) -&gt;
                   ok;
              (read) -&gt;
                   case disk_log:chunk(Log, Cont) of
                       {error, Reason} -&gt;
                           {error, Reason};
                       {Cont2, Terms} -&gt;
                           {Terms, input(Log, Cont2)};
                       {Cont2, Terms, _Badbytes} -&gt;
                           {Terms, input(Log, Cont2)};
                       eof -&gt;
                           end_of_input
                   end
           end.

       output(L) -&gt;
           fun(close) -&gt;
                   lists:append(lists:reverse(L));
              (Terms) -&gt;
                   output([Terms | L])
           end.

       For  more  examples  of  functions  as  input and output, see the end of the <u>file_sorter</u> module; the <u>term</u>
       format is implemented with functions.

       The possible values of <u>Reason</u> returned when an error occurs are:

         * <u>bad_object</u>, <u>{bad_object,</u> <u>FileName}</u> - Applying the format function failed  for  some  binary,  or  the
           key(s) could not be extracted from some term.

         * <u>{bad_term,</u> <u>FileName}</u> - <u>io:read/2</u> failed to read some term.

         * <u>{file_error,</u> <u>FileName,</u> <u>file:posix()}</u> - For an explanation of <u>file:posix()</u>, see <u><a href="../man3erl/file.3erl.html">file</a>(3erl)</u>.

         * <u>{premature_eof,</u> <u>FileName}</u> - End-of-file was encountered inside some binary term.

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       <b>file_name()</b> = file:name()

       <b>file_names()</b> = [file:name()]

       <b>i_command()</b> = read | close

       <b>i_reply()</b> =
           end_of_input |
           {end_of_input, value()} |
           {[object()], infun()} |
           input_reply()

       <b>infun()</b> = fun((i_command()) -&gt; i_reply())

       <b>input()</b> = file_names() | infun()

       <b>input_reply()</b> = term()

       <b>o_command()</b> = {value, value()} | [object()] | close

       <b>o_reply()</b> = outfun() | output_reply()

       <b>object()</b> = term() | binary()

       <b>outfun()</b> = fun((o_command()) -&gt; o_reply())

       <b>output()</b> = file_name() | outfun()

       <b>output_reply()</b> = term()

       <b>value()</b> = term()

       <b>options()</b> = [option()] | option()

       <b>option()</b> =
           {compressed, boolean()} |
           {header, header_length()} |
           {format, format()} |
           {no_files, no_files()} |
           {order, order()} |
           {size, size()} |
           {tmpdir, tmp_directory()} |
           {unique, boolean()}

       <b>format()</b> = binary_term | term | binary | format_fun()

       <b>format_fun()</b> = fun((binary()) -&gt; term())

       <b>header_length()</b> = integer() &gt;= 1

       <b>key_pos()</b> = integer() &gt;= 1 | [integer() &gt;= 1]

       <b>no_files()</b> = integer() &gt;= 1

       <b>order()</b> = ascending | descending | order_fun()

       <b>order_fun()</b> = fun((term(), term()) -&gt; boolean())

       <b>size()</b> = integer() &gt;= 0

       <b>tmp_directory()</b> = [] | file:name()

       <b>reason()</b> =
           bad_object |
           {bad_object, file_name()} |
           {bad_term, file_name()} |
           {file_error,
            file_name(),
            file:posix() | badarg | system_limit} |
           {premature_eof, file_name()}

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>check(FileName)</b> <b>-&gt;</b> <b>Reply</b>

       <b>check(FileNames,</b> <b>Options)</b> <b>-&gt;</b> <b>Reply</b>

              Types:

                 FileNames = file_names()
                 Options = options()
                 Reply = {ok, [Result]} | {error, reason()}
                 Result = {FileName, TermPosition, term()}
                 FileName = file_name()
                 TermPosition = integer() &gt;= 1

              Checks  files for sortedness. If a file is not sorted, the first out-of-order element is returned.
              The first term on a file has position 1.

              <u>check(FileName)</u> is equivalent to <u>check([FileName],</u> <u>[])</u>.

       <b>keycheck(KeyPos,</b> <b>FileName)</b> <b>-&gt;</b> <b>Reply</b>

       <b>keycheck(KeyPos,</b> <b>FileNames,</b> <b>Options)</b> <b>-&gt;</b> <b>Reply</b>

              Types:

                 KeyPos = key_pos()
                 FileNames = file_names()
                 Options = options()
                 Reply = {ok, [Result]} | {error, reason()}
                 Result = {FileName, TermPosition, term()}
                 FileName = file_name()
                 TermPosition = integer() &gt;= 1

              Checks files for sortedness. If a file is not sorted, the first out-of-order element is  returned.
              The first term on a file has position 1.

              <u>keycheck(KeyPos,</u> <u>FileName)</u> is equivalent to <u>keycheck(KeyPos,</u> <u>[FileName],</u> <u>[])</u>.

       <b>keymerge(KeyPos,</b> <b>FileNames,</b> <b>Output)</b> <b>-&gt;</b> <b>Reply</b>

       <b>keymerge(KeyPos,</b> <b>FileNames,</b> <b>Output,</b> <b>Options)</b> <b>-&gt;</b> <b>Reply</b>

              Types:

                 KeyPos = key_pos()
                 FileNames = file_names()
                 Output = output()
                 Options = options()
                 Reply = ok | {error, reason()} | output_reply()

              Merges tuples on files. Each input file is assumed to be sorted on key(s).

              <u>keymerge(KeyPos,</u> <u>FileNames,</u> <u>Output)</u> is equivalent to <u>keymerge(KeyPos,</u> <u>FileNames,</u> <u>Output,</u> <u>[])</u>.

       <b>keysort(KeyPos,</b> <b>FileName)</b> <b>-&gt;</b> <b>Reply</b>

              Types:

                 KeyPos = key_pos()
                 FileName = file_name()
                 Reply = ok | {error, reason()} | input_reply() | output_reply()

              Sorts tuples on files.

              <u>keysort(N,</u> <u>FileName)</u> is equivalent to <u>keysort(N,</u> <u>[FileName],</u> <u>FileName)</u>.

       <b>keysort(KeyPos,</b> <b>Input,</b> <b>Output)</b> <b>-&gt;</b> <b>Reply</b>

       <b>keysort(KeyPos,</b> <b>Input,</b> <b>Output,</b> <b>Options)</b> <b>-&gt;</b> <b>Reply</b>

              Types:

                 KeyPos = key_pos()
                 Input = input()
                 Output = output()
                 Options = options()
                 Reply = ok | {error, reason()} | input_reply() | output_reply()

              Sorts  tuples on files. The sort is performed on the element(s) mentioned in <u>KeyPos</u>. If two tuples
              compare equal (<u>==</u>) on one element, the next element according to <u>KeyPos</u> is compared. The  sort  is
              stable.

              <u>keysort(N,</u> <u>Input,</u> <u>Output)</u> is equivalent to <u>keysort(N,</u> <u>Input,</u> <u>Output,</u> <u>[])</u>.

       <b>merge(FileNames,</b> <b>Output)</b> <b>-&gt;</b> <b>Reply</b>

       <b>merge(FileNames,</b> <b>Output,</b> <b>Options)</b> <b>-&gt;</b> <b>Reply</b>

              Types:

                 FileNames = file_names()
                 Output = output()
                 Options = options()
                 Reply = ok | {error, reason()} | output_reply()

              Merges terms on files. Each input file is assumed to be sorted.

              <u>merge(FileNames,</u> <u>Output)</u> is equivalent to <u>merge(FileNames,</u> <u>Output,</u> <u>[])</u>.

       <b>sort(FileName)</b> <b>-&gt;</b> <b>Reply</b>

              Types:

                 FileName = file_name()
                 Reply = ok | {error, reason()} | input_reply() | output_reply()

              Sorts terms on files.

              <u>sort(FileName)</u> is equivalent to <u>sort([FileName],</u> <u>FileName)</u>.

       <b>sort(Input,</b> <b>Output)</b> <b>-&gt;</b> <b>Reply</b>

       <b>sort(Input,</b> <b>Output,</b> <b>Options)</b> <b>-&gt;</b> <b>Reply</b>

              Types:

                 Input = input()
                 Output = output()
                 Options = options()
                 Reply = ok | {error, reason()} | input_reply() | output_reply()

              Sorts terms on files.

              <u>sort(Input,</u> <u>Output)</u> is equivalent to <u>sort(Input,</u> <u>Output,</u> <u>[])</u>.

Ericsson AB                                        stdlib 3.17                                 <u><a href="../man3erl/file_sorter.3erl.html">file_sorter</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>