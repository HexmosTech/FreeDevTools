<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>dgr - Datagram Retransmission system library</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/ion-doc">ion-doc_3.2.1+dfsg-1.1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       dgr - Datagram Retransmission system library

</pre><h4><b>SYNOPSIS</b></h4><pre>
           #include "dgr.h"

           [see description for available functions]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The DGR library is an alternative implementation of a subset of LTP, intended for use over UDP/IP in the
       Internet; unlike ION's canonical LTP implementation it includes a congestion control mechanism that
       interprets LTP block transmission failure as an indication of network congestion (not data corruption)
       and reduces data transmission rate in response.

       As such, DGR differs from many reliable-UDP systems in two main ways:

               It uses adaptive timeout interval computation techniques
               borrowed from TCP to try to avoid introducing congestion
               into the network.

               It borrows the concurrent-session model of transmission
               from LTP (and ultimately from CFDP), rather than waiting
               for one datagram to be acknowledged before sending the next,
               to improve bandwidth utilization.

       At this time DGR is interoperable with other implementations of LTP only when each block it receives is
       transmitted in a single LTP data segment encapsulated in a single UDP datagram.  More complex LTP
       behavior may be implemented in the future.

       int dgr_open(uvast ownEngineId, unsigned in clientSvcId, unsigned short ownPortNbr, unsigned int
       ownIpAddress, char *memmgrName, Dgr *dgr, DgrRC *rc)
           Establishes the application's access to DGR communication service.

           <u>ownEngineId</u>  is  the sending LTP engine ID that will characterize segments issued by this DGR service
           access point.  In order to prevent erroneous system behavior, never assign the same LTP engine ID  to
           any two interoperating DGR SAPs.

           <u>clientSvcId</u>  identifies  the  LTP client service to which all LTP segments issued by this DGR service
           access point will be directed.

           <u>ownPortNbr</u> is the port number to use for DGR service.  If zero, a system-assigned UDP port number  is
           used.

           <u>ownIpAddress</u>  is the Internet address of the network interface to use for DGR service.  If zero, this
           argument defaults to the address of the interface identified by the local machine's host name.

           <u>memmgrName</u> is the name of the memory manager (see <u><a href="../man3/memmgr.3.html">memmgr</a></u>(3)) to use for dynamic memory management  in
           DGR.  If NULL, defaults to the standard system <u>malloc()</u> and <u>free()</u> functions.

           <u>dgr</u>  is the location in which to store the service access pointer that must be supplied on subsequent
           DGR function invocations.

           <u>rc</u> is the location in which to store the DGR return code resulting from  the  attempt  to  open  this
           service access point (always DgrOpened).

           On any failure, returns -1.  On success, returns zero.

       void dgr_getsockname(Dgr dgr, unsigned short *portNbr, unsigned int *ipAddress)
           States the port number and IP address of the UDP socket used for this DGR service access point.

       void dgr_close(Dgr dgr)
           Reverses <u>dgr_open()</u>, releasing resources where possible.

       int dgr_send(Dgr dgr, unsigned short toPortNbr, unsigned int toIpAddress, int notificationFlags, char
       *content, int length, DgrRC *rc)
           Sends  the  indicated  content,  of  length  as  indicated,  to  the  remote DGR service access point
           identified by <u>toPortNbr</u> and <u>toIpAddress</u>.  The message will be retransmitted as necessary until either
           it is acknowledged or DGR determines that it cannot be delivered.

           <u>notificationFlags</u>, if non-zero, is the logical OR of the notification behaviors  requested  for  this
           datagram.  Available behaviors are DGR_NOTE_FAILED (a notice of datagram delivery failure will issued
           if  delivery of the datagram fails) and DGR_NOTE_ACKED (a notice of datagram delivery success will be
           issued if delivery of the datagram succeeds).  Notices are issued  via  <u>dgr_receive()</u>  that  is,  the
           thread  that  calls  <u>dgr_receive()</u>  on  this  DGR  service  access  point  will receive these notices
           interspersed with inbound datagram contents.

           <u>length</u> of content must be greater than zero and may be as great as 65535, but  lengths  greater  than
           8192  may not be supported by the local underlying UDP implementation; to minimize the chance of data
           loss when transmitting over the internet, length should not exceed 512.

           <u>rc</u> is the location in which to store the DGR return code resulting  from  the  attempt  to  send  the
           content.

           On any failure, returns -1 and sets <u>*rc</u> to DgrFailed.  On success, returns zero.

       int dgr_receive(Dgr dgr, unsigned short *fromPortNbr, unsigned int *fromIpAddress, char *content, int
       *length, int *errnbr, int timeoutSeconds, DgrRC *rc)
           Delivers the oldest undelivered DGR event queued for delivery.

           DGR  events  are  of  two  type: (a) messages received from a remote DGR service access point and (b)
           notices of previously sent messages that DGR has determined either have been or cannot be  delivered,
           as  requested  in  the  <u>notificationFlags</u> parameters provided to the <u>dgr_send()</u> calls that sent those
           messages.

           In the former case, <u>dgr_receive()</u> will place the content of  the  inbound  message  in  <u>content</u>,  its
           length  in <u>length</u>, and the IP address and port number of the sender in <u>fromIpAddress</u> and <u>fromPortNbr</u>,
           and it will set <u>*rc</u> to DgrDatagramReceived and return zero.

           In the latter case, <u>dgr_receive()</u> will place the content of the affected <b>outbound</b> message in  <u>content</u>
           and  its  length  in <u>length</u> and return zero.  If the event being reported is a delivery success, then
           DgrDatagramAcknowledged will be placed in <u>*rc</u>.  Otherwise, DgrDatagramNotAcknowledged will be  placed
           in <u>*rc</u> and the relevant errno (if any) will be placed in <u>*errnbr</u>.

           The  <u>content</u> buffer should be at least 65535 bytes in length to enable delivery of the content of the
           received or delivered/undeliverable message.

           <u>timeoutSeconds</u>  controls  blocking  behavior.   If  <u>timeoutSeconds</u>  is   DGR_BLOCKING   (i.e.,   -1),
           <u>dgr_receive()</u>  will not return until (a) there is either an inbound message to deliver or an outbound
           message delivery result to report, or (b) the function is interrupted by  means  of  <u>dgr_interrupt()</u>.
           If  <u>timeoutSeconds</u> is DGR_POLL (i.e., zero), <u>dgr_receive()</u> returns immediately; if there is currently
           no inbound message to deliver and no outbound message delivery result to report,  the  function  sets
           <u>*rc</u>  to  DgrTimedOut and returns zero.  For any other positive value of <u>timeoutSeconds</u>, <u>dgr_receive()</u>
           returns after the indicated number of seconds have lapsed (in which case the returned value of <u>*rc</u> is
           DgrTimedOut), or when there is a message to deliver or a delivery  result  to  report,  or  when  the
           function  is  interrupted  by  means  of  <u>dgr_interrupt()</u>, whichever occurs first.  When the function
           returns due to interruption by <u>dgr_interrupt()</u>, the value placed in <u>*rc</u> is DgrInterrupted instead  of
           DgrDatagramReceived.

           <u>rc</u>  is  the  location  in  which  to  store the DGR return code resulting from the attempt to receive
           content.

           On any I/O error or other unrecoverable system error, returns -1.   Otherwise  always  returns  zero,
           placing DgrFailed in <u>*rc</u> and writing a failure message in the event of an operating error.

       void dgr_interrupt(Dgr dgr)
           Interrupts a <u>dgr_receive()</u> invocation that is currently blocked.  Designed to be called from a signal
           handler; for this purpose, <u>dgr</u> may need to be obtained from a static variable.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man3/ltp.3.html">ltp</a></u>(3), <u><a href="../man1/file2dgr.1.html">file2dgr</a></u>(1), <u><a href="../man1/dgr2file.1.html">dgr2file</a></u>(1)

perl v5.24.1                                       2016-07-07                             <u>dgr::doc::pod3::<a href="../man3/dgr.3.html">dgr</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>