<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ck_cohort — generalized interface for lock cohorts</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libck-dev">libck-dev_0.7.2-5ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ck_cohort — generalized interface for lock cohorts

</pre><h4><b>LIBRARY</b></h4><pre>
       Concurrency Kit (libck, -lck)

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;ck_cohort.h&gt;</b>

       <b>CK_COHORT_PROTOTYPE</b>(<u>COHORT_NAME</u>  <u>cohort_name</u>, <u>LOCK_FXN</u> <u>global_lock_method</u>, <u>LOCK_FXN</u> <u>global_unlock_method</u>,
           <u>LOCK_FXN</u> <u>local_lock_method</u>, <u>LOCK_FXN</u> <u>local_unlock_method</u>);

       <b>CK_COHORT_TRYLOCK_PROTOTYPE</b>(<u>COHORT_NAME</u>         <u>cohort_name</u>,         <u>LOCK_FXN</u>         <u>global_lock_method</u>,
           <u>LOCK_FXN</u>             <u>global_unlock_method</u>,             <u>BOOL_LOCK_FXN</u>            <u>global_locked_method</u>,
           <u>BOOL_LOCK_FXN</u>  <u>global_trylock_method</u>,  <u>LOCK_FXN</u>  <u>local_lock_method</u>,   <u>LOCK_FXN</u>   <u>local_unlock_method</u>,
           <u>BOOL_LOCK_FXN</u> <u>local_locked_method</u>, <u>BOOL_LOCK_FXN</u> <u>local_trylock_method</u>);

       <b>CK_COHORT_INSTANCE</b>(<u>COHORT_NAME</u> <u>cohort_name</u>);

       <b>CK_COHORT_INIT</b>(<u>COHORT_NAME</u>   <u>cohort_name</u>,   <u>ck_cohort</u>   <u>*cohort</u>,  <u>void</u>  <u>*global_lock</u>,  <u>void</u>  <u>*local_lock</u>,
           <u>unsigned</u> <u>int</u> <u>pass_limit</u>);

       <b>CK_COHORT_LOCK</b>(<u>COHORT_NAME</u> <u>cohort_name</u>, <u>ck_cohort</u> <u>*cohort</u>, <u>void</u> <u>*global_context</u>, <u>void</u> <u>*local_context</u>);

       <b>CK_COHORT_UNLOCK</b>(<u>COHORT_NAME</u> <u>cohort_name</u>, <u>ck_cohort</u> <u>*cohort</u>, <u>void</u> <u>*global_context</u>, <u>void</u> <u>*local_context</u>);

       Where LOCK_FXN refers to a method with the signature
       void(void *lock, void *context)
       BOOL_LOCK_FXN refers to a method with the signature
       bool(void *lock, void *context)

       The <u>context</u>
       argument in each signature is used to pass along any additional information that the lock might need  for
       its  lock,  unlock  and  trylock  methods.   The  values  for  this argument are provided to each call to
       <u><a href="../man3/CK_COHORT_LOCK.3.html">CK_COHORT_LOCK</a></u>(3), <u><a href="../man3/CK_COHORT_UNLOCK.3.html">CK_COHORT_UNLOCK</a></u>(3), <u><a href="../man3/CK_COHORT_LOCKED.3.html">CK_COHORT_LOCKED</a></u>(3), and <u><a href="../man3/CK_COHORT_TRYLOCK.3.html">CK_COHORT_TRYLOCK</a></u>(3)

</pre><h4><b>DESCRIPTION</b></h4><pre>
       ck_cohort.h provides an interface for defining lock cohorts with arbitrary lock  types.   Cohorts  are  a
       mechanism  for  coordinating  threads on NUMA architectures in order to reduce the frequency with which a
       lock is passed between threads on different clusters.

       Before using a cohort, the user must define a cohort type using either the <b>CK_COHORT_PROTOTYPE</b>()  or  the
       <b>CK_COHORT_TRYLOCK_PROTOTYPE</b>()  macros.  These macros allow the user to specify the lock methods that they
       would like the cohort to use.  See  the  <u><a href="../man3/CK_COHORT_PROTOTYPE.3.html">CK_COHORT_PROTOTYPE</a></u>(3)  and  <u><a href="../man3/CK_COHORT_TRYLOCK_PROTOTYPE.3.html">CK_COHORT_TRYLOCK_PROTOTYPE</a></u>(3)  man
       pages for more details.

</pre><h4><b>EXAMPLE</b></h4><pre>
             #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
             #include &lt;<a href="file:/usr/include/pthread.h">pthread.h</a>&gt;

             #include &lt;ck_pr.h&gt;
             #include &lt;ck_cohort.h&gt;
             #include &lt;ck_spinlock.h&gt;

             /*
              * Create cohort methods with signatures that match
              * the required signature
              */
             static void
             ck_spinlock_lock_with_context(ck_spinlock_t *lock, void *context)
             {
                     (void)context;
                     ck_spinlock_lock(lock);
                     return;
             }

             static void
             ck_spinlock_unlock_with_context(ck_spinlock_t *lock, void *context)
             {
                     (void)context;
                     ck_spinlock_unlock(lock);
                     return;
             }

             static bool
             ck_spinlock_locked_with_context(ck_spinlock_t *lock, void *context)
             {
                     (void)context;
                     return ck_spinlock_locked(lock);
             }

             /*
              * define a cohort type named "test_cohort" that will use
              * the above methods for both its global and local locks
              */
             CK_COHORT_PROTOTYPE(test_cohort,
                     ck_spinlock_lock_with_context, ck_spinlock_unlock_with_context, ck_spinlock_locked_with_context,
                     ck_spinlock_lock_with_context, ck_spinlock_unlock_with_context, ck_spinlock_locked_with_context)

             static ck_spinlock_t global_lock = CK_SPINLOCK_INITIALIZER;
             static unsigned int ready;

             static void *
             function(void *context)
             {
                     CK_COHORT_INSTANCE(test_cohort) *cohort = context;

                     while (ready == 0);

                     while (ready &gt; 0) {
                             /*
                              * acquire the cohort lock before performing critical section.
                              * note that we pass NULL for both the global and local context
                              * arguments because neither the lock nor unlock functions
                              * will use them.
                              */
                             CK_COHORT_LOCK(test_cohort, cohort, NULL, NULL);

                             /* perform critical section */

                             /* relinquish cohort lock */
                             CK_COHORT_UNLOCK(test_cohort, cohort, NULL, NULL);
                     }

                     return NULL;
             }

             int
             main(void)
             {
                     unsigned int nthr = 4;
                     unsigned int n_cohorts = 2;
                     unsigned int i;

                     /* allocate 2 cohorts of the defined type */
                     CK_COHORT_INSTANCE(test_cohort) *cohorts =
                         calloc(n_cohorts, sizeof(CK_COHORT_INSTANCE(test_cohort)));

                     /* create local locks to use with each cohort */
                     ck_spinlock_t *local_locks =
                             calloc(n_cohorts, sizeof(ck_spinlock_t));

                     pthread_t *threads =
                             calloc(nthr, sizeof(pthread_t));

                     /* initialize each of the cohorts before using them */
                     for (i = 0 ; i &lt; n_cohorts ; ++i) {
                             CK_COHORT_INIT(test_cohort, cohorts + i, &amp;global_lock, local_locks + i,
                                     CK_COHORT_DEFAULT_LOCAL_PASS_LIMIT);
                     }

                     /* start each thread and assign cohorts equally */
                     for (i = 0 ; i &lt; nthr ; ++i) {
                             pthread_create(threads + i, NULL, function, cohorts + (i % n_cohorts));
                     }

                     ck_pr_store_uint(&amp;ready, 1);
                     <a href="../man10/sleep.10.html">sleep</a>(10);
                     ck_pr_store_uint(&amp;ready, 0);

                     for (i = 0 ; i &lt; nthr ; ++i) {
                             pthread_join(threads[i], NULL);
                     }

                     return 0;
             }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man3/CK_COHORT_PROTOTYPE.3.html">CK_COHORT_PROTOTYPE</a></u>(3),  <u><a href="../man3/CK_COHORT_TRYLOCK_PROTOTYPE.3.html">CK_COHORT_TRYLOCK_PROTOTYPE</a></u>(3), <u><a href="../man3/CK_COHORT_INSTANCE.3.html">CK_COHORT_INSTANCE</a></u>(3), <u><a href="../man3/CK_COHORT_INITIALIZER.3.html">CK_COHORT_INITIALIZER</a></u>(3),
       <u><a href="../man3/CK_COHORT_INIT.3.html">CK_COHORT_INIT</a></u>(3), <u><a href="../man3/CK_COHORT_LOCK.3.html">CK_COHORT_LOCK</a></u>(3), <u><a href="../man3/CK_COHORT_UNLOCK.3.html">CK_COHORT_UNLOCK</a></u>(3), <u><a href="../man3/CK_COHORT_LOCKED.3.html">CK_COHORT_LOCKED</a></u>(3), <u><a href="../man3/CK_COHORT_TRYLOCK.3.html">CK_COHORT_TRYLOCK</a></u>(3),

       Additional information available at <a href="http://concurrencykit.org/">http://concurrencykit.org/</a>

                                               February 24, 2013.                                   <u><a href="../man3/ck_cohort.3.html">ck_cohort</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>