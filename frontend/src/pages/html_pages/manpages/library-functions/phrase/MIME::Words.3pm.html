<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MIME::Words - deal with RFC 2047 encoded words</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmime-tools-perl">libmime-tools-perl_5.515-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       MIME::Words - deal with RFC 2047 encoded words

</pre><h4><b>SYNOPSIS</b></h4><pre>
       Before reading further, you should see MIME::Tools to make sure that you understand where this module
       fits into the grand scheme of things.  Go on, do it now.  I'll wait.

       Ready?  Ok...

           use MIME::Words qw(:all);

           ### Decode the string into another string, forgetting the charsets:
           $decoded = decode_mimewords(
                 'To: =?ISO-8859-1?Q?Keld_J=F8rn_Simonsen?= &lt;<a href="mailto:keld@dkuug.dk">keld@dkuug.dk</a>&gt;',
                 );

           ### Split string into array of decoded [DATA,CHARSET] pairs:
           @decoded = decode_mimewords(
                 'To: =?ISO-8859-1?Q?Keld_J=F8rn_Simonsen?= &lt;<a href="mailto:keld@dkuug.dk">keld@dkuug.dk</a>&gt;',
                 );

           ### Encode a single unsafe word:
           $encoded = encode_mimeword("\xABFran\xE7ois\xBB");

           ### Encode a string, trying to find the unsafe words inside it:
           $encoded = encode_mimewords("Me and \xABFran\xE7ois\xBB in town");

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Fellow Americans, you probably won't know what the hell this module is for.  Europeans, Russians, et al,
       you probably do.  ":-)".

       For example, here's a valid MIME header you might get:

             From: =?US-ASCII?Q?Keith_Moore?= &lt;<a href="mailto:moore@cs.utk.edu">moore@cs.utk.edu</a>&gt;
             To: =?ISO-8859-1?Q?Keld_J=F8rn_Simonsen?= &lt;<a href="mailto:keld@dkuug.dk">keld@dkuug.dk</a>&gt;
             CC: =?ISO-8859-1?Q?Andr=E9_?= Pirard &lt;<a href="mailto:PIRARD@vm1.ulg.ac.be">PIRARD@vm1.ulg.ac.be</a>&gt;
             Subject: =?ISO-8859-1?B?SWYgeW91IGNhbiByZWFkIHRoaXMgeW8=?=
              =?ISO-8859-2?B?dSB1bmRlcnN0YW5kIHRoZSBleGFtcGxlLg==?=
              =?US-ASCII?Q?.._cool!?=

       The fields basically decode to (sorry, I can only approximate the Latin characters with 7 bit sequences
       /o and 'e):

             From: Keith Moore &lt;<a href="mailto:moore@cs.utk.edu">moore@cs.utk.edu</a>&gt;
             To: Keld J/orn Simonsen &lt;<a href="mailto:keld@dkuug.dk">keld@dkuug.dk</a>&gt;
             CC: Andr'e  Pirard &lt;<a href="mailto:PIRARD@vm1.ulg.ac.be">PIRARD@vm1.ulg.ac.be</a>&gt;
             Subject: If you can read this you understand the example... cool!

</pre><h4><b>PUBLIC</b> <b>INTERFACE</b></h4><pre>
       decode_mimewords ENCODED
           <u>Function.</u>   Go  through  the string looking for RFC 2047-style "Q" (quoted-printable, sort of) or "B"
           (base64) encoding, and decode them.

           <b>In</b> <b>an</b> <b>array</b> <b>context,</b> splits the ENCODED string into a list of decoded "[DATA,  CHARSET]"  pairs,  and
           returns  that  list.   Unencoded data are returned in a 1-element array "[DATA]", giving an effective
           CHARSET of "undef".

               $enc = '=?ISO-8859-1?Q?Keld_J=F8rn_Simonsen?= &lt;<a href="mailto:keld@dkuug.dk">keld@dkuug.dk</a>&gt;';
               foreach (decode_mimewords($enc)) {
                   print "", ($_-&gt;[1] || 'US-ASCII'), ": ", $_-&gt;[0], "\n";
               }

           <b>In</b> <b>a</b> <b>scalar</b> <b>context,</b> joins the "data"  elements  of  the  above  list  together,  and  returns  that.
           <u>Warning:</u> <u>this</u> <u>is</u> <u>information-lossy,</u> and probably <u>not</u> what you want, but if you know that all charsets
           in  the  ENCODED  string  are identical, it might be useful to you.  (Before you use this, please see
           "unmime" in MIME::WordDecoder, which is probably what you want.)

           In the event of a syntax error, $@ will be set to a  description  of  the  error,  but  parsing  will
           continue  as  best as possible (so as to get <u>something</u> back when decoding headers).  $@ will be false
           if no error was detected.

           Any arguments past the ENCODED string are taken to define a hash of options:

       encode_mimeword RAW, [ENCODING], [CHARSET]
           <u>Function.</u>  Encode a single RAW "word" that has unsafe characters.  The "word" will be encoded in  its
           entirety.

               ### Encode "&lt;&lt;Franc,ois&gt;&gt;":
               $encoded = encode_mimeword("\xABFran\xE7ois\xBB");

           You may specify the ENCODING ("Q" or "B"), which defaults to "Q".  You may specify the CHARSET, which
           defaults to "iso-8859-1".

       encode_mimewords RAW, [OPTS]
           <u>Function.</u>  Given a RAW string, try to find and encode all "unsafe" sequences of characters:

               ### Encode a string with some unsafe "words":
               $encoded = encode_mimewords("Me and \xABFran\xE7ois\xBB");

           Returns the encoded string.  Any arguments past the RAW string are taken to define a hash of options:

           Charset
               Encode all unsafe stuff with this charset.  Default is 'ISO-8859-1', a.k.a. "Latin-1".

           Encoding
               The encoding to use, "q" or "b".  The default is "q".

           <b>Warning:</b>  this  is  a  quick-and-dirty solution, intended for character sets which overlap ASCII.  <b>It</b>
           <b>does</b> <b>not</b> <b>comply</b> <b>with</b> <b>the</b> <b>RFC</b> <b>2047</b> <b>rules</b> <b>regarding</b> <b>the</b> <b>use</b> <b>of</b> <b>encoded</b> <b>words</b> <b>in</b> <b>message</b>  <b>headers</b>.   You
           may  want  to  roll  your  own variant, using encode_mimeword(), for your application.  <u>Thanks</u> <u>to</u> <u>Jan</u>
           <u>Kasprzak</u> <u>for</u> <u>reminding</u> <u>me</u> <u>about</u> <u>this</u> <u>problem.</u>

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       MIME::Base64, MIME::QuotedPrint, MIME::Tools

       For other implementations of this or similar functionality (particularly, ones with proper UTF8 support),
       see:

       Encode::MIME::Header, MIME::EncWords, MIME::AltWords

       At some future point, one of these implementations will likely replace MIME::Words and  MIME::Words  will
       become deprecated.

</pre><h4><b>NOTES</b></h4><pre>
       Exports its principle functions by default, in keeping with MIME::Base64 and MIME::QuotedPrint.

</pre><h4><b>AUTHOR</b></h4><pre>
       Eryq (<u><a href="mailto:eryq@zeegee.com">eryq@zeegee.com</a></u>), ZeeGee Software Inc (<u><a href="http://www.zeegee.com">http://www.zeegee.com</a></u>).  Dianne Skoll (<a href="mailto:dianne@skoll.ca">dianne@skoll.ca</a>)

       All  rights  reserved.  This program is free software; you can redistribute it and/or modify it under the
       same terms as Perl itself.

       Thanks also to...

             Kent Boortz        For providing the idea, and the baseline
                                RFC-1522-decoding code!
             KJJ at PrimeNet    For requesting that this be split into
                                its own module.
             Stephane Barizien  For reporting a nasty bug.

perl v5.38.2                                       2024-04-27                                   <u>MIME::<a href="../man3pm/Words.3pm.html">Words</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>