<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>unicode_wb_init, unicode_wb_next, unicode_wb_next_cnt, unicode_wb_end, unicode_wbscan_init,</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcourier-unicode-dev">libcourier-unicode-dev_2.3.2-1ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       unicode_wb_init, unicode_wb_next, unicode_wb_next_cnt, unicode_wb_end, unicode_wbscan_init,
       unicode_wbscan_next, unicode_wbscan_end, unicode_word_break - calculate word breaks

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;courier-unicode.h&gt;</b>

       <b>unicode_wb_info_t</b> <b>unicode_wb_init(int</b> <b>(*</b><u>cb_func</u><b>)(int,</b> <b>void</b> <b>*),</b> <b>void</b> <b>*</b><u>cb_arg</u><b>);</b>

       <b>int</b> <b>unicode_wb_next(unicode_wb_info_t</b> <u>wb</u><b>,</b> <b>char32_t</b> <u>c</u><b>);</b>

       <b>int</b> <b>unicode_wb_next_cnt(unicode_wb_info_t</b> <u>wb</u><b>,</b> <b>const</b> <b>char32_t</b> <b>*</b><u>cptr</u><b>,</b> <b>size_t</b> <u>cnt</u><b>);</b>

       <b>int</b> <b>unicode_wb_end(unicode_wb_info_t</b> <u>wb</u><b>);</b>

       <b>unicode_wbscan_info_t</b> <b>unicode_wbscan_init(void);</b>

       <b>int</b> <b>unicode_wbscan_next(unicode_wbscan_info_t</b> <u>wbs</u><b>,</b> <b>char32_t</b> <u>c</u><b>);</b>

       <b>size_t</b> <b>unicode_wbscan_end(unicode_wbscan_info_t</b> <u>wbs</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       These functions implement the unicode word breaking algorithm. Invoke <b>unicode_wb_init</b>() to initialize the
       word breaking algorithm. The first parameter is a callback function. The second parameter is an opaque
       pointer. The callback function gets invoked with two parameters. The second parameter is the opaque
       pointer that was given to <b>unicode_wb_init</b>(); and the opaque pointer is not subject to any further
       interpretation by these functions.

       <b>unicode_wb_init</b>() returns an opaque handle. Repeated invocations of <b>unicode_wb_next</b>(), passing the
       handle, and one unicode character defines a sequence of unicode characters over which the word breaking
       algorithm calculation takes place.  <b>unicode_wb_next_cnt</b>() is a shortcut for invoking <b>unicode_wb_next</b>()
       repeatedly over an array cptr containing cnt unicode characters.

       <b>unicode_wb_end</b>() denotes the end of the unicode character sequence. After the call to <b>unicode_wb_end</b>()
       the word breaking unicode_wb_info_t handle is no longer valid.

       Between the call to <b>unicode_wb_init</b>() and <b>unicode_wb_end</b>(), the callback function gets invoked exactly
       once for each unicode character given to <b>unicode_wb_next</b>() or <b>unicode_wb_next_cnt</b>(). Usually each call to
       <b>unicode_wb_next</b>() results in the callback function getting invoked immediately, but it does not have to
       be. It's possible that a call to <b>unicode_wb_next</b>() returns without invoking the callback function, and
       some subsequent call to <b>unicode_wb_next</b>() (or <b>unicode_wb_end</b>()) invokes the callback function more than
       once, to catch things up. The contract is that before <b>unicode_wb_end</b>() returns, the callback function
       gets invoked the exact number of times as the number of characters in the unicode sequence defined by the
       intervening calls to <b>unicode_wb_next</b>() and <b>unicode_wb_next_cnt</b>(), unless an error occurs.

       Each call to the callback function reports the calculated wordbreaking status of the corresponding
       character in the unicode character sequence. If the parameter to the callback function is non zero, a
       word break is permitted <u>before</u> the corresponding character. A zero value indicates that a word break is
       prohibited <u>before</u> the corresponding character.

       The callback function should return 0. A non-zero value indicates to the word breaking algorithm that an
       error has occurred.  <b>unicode_wb_next</b>() and <b>unicode_wb_next_cnt</b>() return zero either if they never invoked
       the callback function, or if each call to the callback function returned zero. A non zero return from the
       callback function results in <b>unicode_wb_next</b>() and <b>unicode_wb_next_cnt</b>() immediately returning the same
       value.

       <b>unicode_wb_end</b>() must be invoked to destroy the word breaking handle even if <b>unicode_wb_next</b>() and
       <b>unicode_wb_next_cnt</b>() returned an error indication. It's also possible that, under normal circumstances,
       <b>unicode_wb_end</b>() invokes the callback function one or more times. The return value from <b>unicode_wb_end</b>()
       has the same meaning as from <b>unicode_wb_next</b>() and <b>unicode_wb_next_cnt</b>(); however in all cases after
       <b>unicode_wb_end</b>() returns the line breaking handle is no longer valid.

   <b>Word</b> <b>scan</b>
       <b>unicode_wbscan_init</b>(), <b>unicode_wbscan_next</b>() and <b>unicode_wbscan_end</b> scan for the next word boundary in a
       unicode character sequence.  <b>unicode_wbscan_init</b>() obtains a handle, then <b>unicode_wbscan_next</b>() gets
       repeatedly invoked to define the unicode character sequence.  <b>unicode_wbscan_end</b>() deallocates the handle
       and returns the number of leading characters in the unicode character sequence up to the first word
       break.

       A non-0 return value from <b>unicode_wbscan_next</b>() indicates that the word boundary is already known, and
       any further calls to <b>unicode_wbscan_next</b>() will be ignored.  <b>unicode_wbscan_end</b>() must still be called,
       to obtain the unicode character count.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b>TR-29</b>[1], <b><a href="../man7/courier-unicode.7.html">courier-unicode</a></b>(7), <b>unicode::<a href="../man3/wordbreak.3.html">wordbreak</a></b>(3), <b><a href="../man3/unicode_convert_tocase.3.html">unicode_convert_tocase</a></b>(3), <b><a href="../man3/unicode_line_break.3.html">unicode_line_break</a></b>(3),
       <b><a href="../man3/unicode_grapheme_break.3.html">unicode_grapheme_break</a></b>(3).

</pre><h4><b>AUTHOR</b></h4><pre>
       <b>Sam</b> <b>Varshavchik</b>
           Author

</pre><h4><b>NOTES</b></h4><pre>
        1. TR-29
           https://www.unicode.org/reports/tr29/tr29-43.html

Courier Unicode Library                            05/18/2024                              <u><a href="../man3/UNICODE_WORD_BREAK.3.html">UNICODE_WORD_BREAK</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>