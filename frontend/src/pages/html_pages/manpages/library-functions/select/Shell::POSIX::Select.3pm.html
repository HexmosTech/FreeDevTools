<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shell::POSIX::Select - The POSIX Shell's "select" loop for Perl</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libshell-posix-select-perl">libshell-posix-select-perl_0.09-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Shell::POSIX::Select - The POSIX Shell's "select" loop for Perl

</pre><h4><b>PURPOSE</b></h4><pre>
       This module implements the "select" loop of the "POSIX" shells (Bash, Korn, and derivatives) for Perl.
       That loop is unique in two ways: it's by far the friendliest feature of any UNIX shell, and it's the <u>only</u>
       UNIX shell loop that's missing from the Perl language.  Until now!

       What's so great about this loop? It automates the generation of a numbered menu of choices, prompts for a
       choice, proofreads that choice and complains if it's invalid (at least in this enhanced implementation),
       and executes a code-block with a variable set to the chosen value.  That saves a lot of coding for
       interactive programs -- especially if the menu consists of many values!

       The benefit of bringing this loop to Perl is that it obviates the need for future programmers to reinvent
       the <u>Choose-From-A-Menu</u> wheel.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       select [ [my|local|our] scalar_var ] ( [LIST] ) { [CODE] }

       In the above, the enclosing square brackets <u>(not</u> <u>typed)</u> identify optional elements, and vertical bars
       separate mutually-exclusive choices:

       The required elements are the keyword "select", the <u>parentheses</u>, and the <u>curly</u> <u>braces</u>.  See "SYNTAX" for
       details.

</pre><h4><b>ELEMENTARY</b> <b>EXAMPLES</b></h4><pre>
       NOTE: All non-trivial programming examples shown in this document are distributed with this module, in
       the <b>Scripts</b> directory.  "ADDITIONAL EXAMPLES", covering more features, are shown below.

   <b>ship2me.plx</b>
           use Shell::POSIX::Select;

           select $shipper ( 'UPS', 'FedEx' ) {
               print "\nYou chose: $shipper\n";
               last;
           }
           ship ($shipper, $ARGV[0]);  # prints confirmation message

       <b>Screen</b>

           ship2me.plx  '42 hemp toothbrushes'  # program invocation

           1) UPS   2) FedEx

           Enter number of choice: 2

           You chose: FedEx
           Your order has been processed.  Thanks for your business!

   <b>ship2me2.plx</b>
       This variation on the preceding example shows how to use a custom menu-heading and interactive prompt.
       It also presents all menus in one column.

           use Shell::POSIX::Select qw($Heading $Prompt $MaxColumns);

           $Heading = 'Select a Shipper' ;
           $Prompt = 'Enter Vendor Number: ' ;
           $MaxColumns = 1;
           select $shipper ( 'UPS', 'FedEx' ) {
             print "\nYou chose: $shipper\n";
             last;
           }
           ship ($shipper, $ARGV[0]);  # prints confirmation message

       <b>Screen</b>

           ship2me2.plx '42 hemp toothbrushes'

           Select a Shipper

           1) UPS   2) FedEx

           Enter Vendor Number: 2

           You chose: FedEx
           Your order has been processed.  Thanks for your business!

</pre><h4><b>SYNTAX</b></h4><pre>
   <b>Loop</b> <b>Structure</b>
       Supported invocation formats include the following:

        use Shell::POSIX::Select ;

        select                 ()      { }         # Form 0
        select                 ()      { CODE }    # Form 1
        select                 (LIST)  { CODE }    # Form 2
        select         $var    (LIST)  { CODE }    # Form 3
        select my      $var    (LIST)  { CODE }    # Form 4
        select our     $var    (LIST)  { CODE }    # Form 5
        select local   $var    (LIST)  { CODE }    # Form 6

       If the loop variable is omitted (as in <u>Forms</u> <u>0</u>, <u>1</u> and <u>2</u> above), it defaults to $_, "local"ized to the
       loop's scope.  If the LIST is omitted (as in <u>Forms</u> <u>0</u> and <u>1</u>), @ARGV is used by default, unless the loop
       occurs within a subroutine, in which case @_ is used instead.  If CODE is omitted (as in <u>Form</u> <u>0</u>, it
       defaults to a statement that <b>prints</b> the loop variable.

       The cases shown above are merely examples; all reasonable permutations are permitted, including:

        select       $var    (    )  { CODE }
        select local $var    (LIST)  {      }

       The only form that's <u>not</u> allowed is one that specifies the loop-variable's declarator without naming the
       loop variable, as in:

        select our () { } # WRONG!  Must name variable with declarator!

   <b>The</b> <b>Loop</b> <b>variable</b>
       See "SCOPING ISSUES" for full details about the implications of different types of declarations for the
       loop variable.

   <b>The</b> <b>$Reply</b> <b>Variable</b>
       When the interactive user responds to the "select" loop's prompt with a valid input (i.e., a number in
       the correct range), the variable $Reply is set within the loop to that number.  Of course, the actual
       item selected is usually of great interest than its number in the menu, but there are cases in which
       access to this number is useful (see "menu_ls.plx" for an example).

</pre><h4><b>OVERVIEW</b></h4><pre>
       This loop is syntactically similar to Perl's "foreach" loop, and functionally related, so we'll describe
       it in those terms.

        foreach $var  ( LIST ) { CODE }

       The job of "foreach" is to run one iteration of CODE for each LIST-item, with the current item's value
       placed in "local"ized $var (or if the variable is missing, "local"ized $_).

        select  $var  ( LIST ) { CODE }

       In contrast, the "select" loop displays a numbered menu of LIST-items on the screen, prompts for
       (numerical) input, and then runs an iteration with $var being set that number's LIST-item.

       In other words, "select" is like an interactive, multiple-choice version of a "foreach" loop.  And that's
       cool!  What's <u>not</u> so cool is that "select" is also the <u>only</u> UNIX shell loop that's been left out of the
       Perl language.  <u>Until</u> <u>now!</u>

       This module implements the "select" loop of the Korn and Bash ("POSIX") shells for Perl.  It accomplishes
       this through Filter::Simple's <u>Source</u> <u>Code</u> <u>Filtering</u> service, allowing the programmer to blithely proceed
       as if this control feature existed natively in Perl.

       The Bash and Korn shells differ slightly in their handling of "select" loops, primarily with respect to
       the layout of the on-screen menu.  This implementation currently follows the Korn shell version most
       closely (but see "TODO-LIST" for notes on planned enhancements).

</pre><h4><b>ENHANCEMENTS</b></h4><pre>
       Although the shell doesn't allow the loop variable to be omitted, for compliance with Perlish
       expectations, the "select" loop uses "local"ized $_ by default (as does the native "foreach" loop).  See
       "SYNTAX" for details.

       The interface and behavior of the Shell versions has been retained where deemed desirable, and sensibly
       modified along Perlish lines elsewhere.  Accordingly, the (primary) default LIST is <b>@ARGV</b> (paralleling
       the Shell's <b>"$@"</b>), menu prompts can be customized by having the script import and set <b>$Prompt</b>
       (paralleling the Shell's <b>$PS3</b>), and the user's response to the prompt appears in the variable <b>$Reply</b>
       (paralleling the Shell's <b>$REPLY</b>), "local"ized to the loop.

       A deficiency of the shell implementation is the inability of the user to provide a <u>heading</u> for each
       "select" menu.  Sure, the shell programmer can <b>echo</b> a heading before the loop is entered and the menu is
       displayed, but that approach doesn't help when an <u>Outer</u> <u>loop</u> is reentered on departure from an <u>Inner</u>
       <u>loop</u>, because the <b>echo</b> preceding the <u>Outer</u> <u>loop</u> won't be re-executed.

       A similar deficiency surrounds the handling of a custom prompt string, and the need to automatically
       display it on moving from an inner loop to an outer one.

       To address these deficiencies, this implementation provides the option of having a heading and prompt
       bound to each "select" loop.  See "IMPORTS AND OPTIONS" for details.

       Headings and prompts are displayed in reverse video on the terminal, if possible, to make them more
       visually distinct.

       Some shell versions simply ignore bad input, such as the entry of a number outside the menu's valid
       range, or alphabetic input.  I can't imagine any argument in favor of this behavior being desirable when
       input is coming from a terminal, so this implementation gives clear warning messages for such cases by
       default (see "Warnings" for details).

       After a menu's initial prompt is issued, some shell versions don't show it again unless the user enters
       an empty line.  This is desirable in cases where the menu is sufficiently large as to cause preceding
       output to scroll off the screen, and undesirable otherwise.  Accordingly, an option is provided to enable
       or disable automatic prompting (see "Prompts").

       This implementation always issues a fresh prompt when a terminal user submits EOF as input to a nested
       "select" loop.  In such cases, experience shows it's critical to reissue the menu of the outer loop
       before accepting any more input.

</pre><h4><b>SCOPING</b> <b>ISSUES</b></h4><pre>
       If the loop variable is named and provided with a <u>declarator</u> ("my", "our", or "local"), the variable is
       scoped within the loop using that type of declaration.  But if the variable is named but lacks a
       declarator, no declaration is applied to the variable.

       This allows, for example, a variable declared as private <u>above</u> <u>the</u> <u>loop</u> to be accessible from within the
       loop, and beyond it, and one declared as private <u>for</u> <u>the</u> <u>loop</u> to be confined to it:

           select my $loopvar ( ) { }
           print "$loopvar DOES NOT RETAIN last value from loop here\n";
           -------------------------------------------------------------
           my $loopvar;
           select $loopvar ( ) { }
           print "$loopvar RETAINS last value from loop here\n";

       With this design, "select" behaves differently than the native "foreach" loop, which nowadays employs
       automatic localization.

           foreach $othervar ( ) { } # variable localized automatically
           print "$othervar DOES NOT RETAIN last value from loop here\n";

           select $othervar ( ) { } # variable in scope, or global
           print "$othervar RETAINS last value from loop here\n";

       This difference in the treatment of variables is intentional, and appropriate.  That's because the whole
       point of "select" is to let the user choose a value from a list, so it's often critically important to be
       able to see, even outside the loop, the value assigned to the loop variable.

       In contrast, it's usually considered undesirable and unnecessary for the value of the "foreach" loop's
       variable to be visible outside the loop, because in most cases it will simply be that of the last element
       in the list.

       Of course, in situations where the "foreach"-like behavior of implicit "local"ization is desired, the
       programmer has the option of declaring the "select" loop's variable as "local".

       Another deficiency of the Shell versions is that it's difficult for the programmer to differentiate
       between a "select" loop being exited via "last", versus the loop detecting EOF on input.  To correct this
       situation, the variable $Eof can be imported and checked for a <u>TRUE</u> value upon exit from a "select" loop
       (see "Eof Detection").

</pre><h4><b>IMPORTS</b> <b>AND</b> <b>OPTIONS</b></h4><pre>
   <b>Syntax</b>
        use Shell::POSIX::Select (
            '$Prompt',      # to customize per-menu prompt
            '$Heading',     # to customize per-menu heading
            '$MaxColumns',  # to limit visual number of columns of choices
            '$Eof',         # T/F for Eof detection
         # Variables must come first, then key/value options
            prompt   =&gt; 'Enter number of choice:',  # or 'whatever:'
            style    =&gt; 'Bash',     # or 'Korn'
            warnings =&gt; 1,          # or 0
            debug    =&gt; 0,          # or 1-5
            logging  =&gt; 0,          # or 1
            testmode =&gt; &lt;unset&gt;,    # or 'make', or 'foreach'
        );

       <u>NOTE:</u> The values shown for options are the defaults, except for "testmode", which doesn't have one.

   <b>Prompts</b>
       There are two ways to customize the prompt used to solicit choices from "select" menus; through use of
       the prompt <u>option</u>, which applies to all loops, or the $Prompt variable, which can be set independently
       for each loop.

       <u>The</u> <u>prompt</u> <u>option</u>

       The "prompt" option is intended for use in programs that either contain a single "select" loop, or are
       content to use the same prompt for every loop.  It allows a custom interactive prompt to be set in the
       <b>use</b> statement.

       The prompt string should not end in a whitespace character, because that doesn't look nice when the
       prompt is highlighted for display (usually in <u>reverse</u> <u>video</u>).  To offset the cursor from the prompt's
       end, <u>one</u> <u>space</u> is inserted automatically after display highlighting has been turned off.

       If the environment variable $ENV{Shell_POSIX_Select_prompt} is present, its value overrides the one in
       the <b>use</b> statement.

       The default prompt is "Enter number of choice:".  To get the same prompt as provided by the Korn or Bash
       shell, use "prompt =&gt;&gt; Korn" or "prompt =&gt; Bash".

       <u>The</u> <u>$Prompt</u> <u>variable</u>

       The programmer may also modify the prompt during execution, which may be desirable with nested loops that
       require different user instructions.  This is accomplished by importing the $Prompt variable, and setting
       it to the desired prompt string before entering the loop.  Note that imported variables have to be listed
       as the initial arguments to the "use" directive, and properly quoted.  See "order.plx" for an example.

       NOTE: If the program's input channel is not connected to a terminal, prompting is automatically disabled
       (since there's no point in soliciting input from a <u>pipe</u>!).

   <b>$Heading</b>
       The programmer has the option of binding a heading to each loop's menu, by importing $Heading and setting
       it just before entering the associated loop.  See "order.plx" for an example.

   <b>$Eof</b>
       A common concern with the Shell's "select" loop is distinguishing between cases where a loop ends due to
       EOF detection, versus the execution of "break" (like Perl's "last").  Although the Shell programmer can
       check the $REPLY variable to make this distinction, this implementation localizes its version of that
       variable ($Reply) to the loop, obviating that possibility.

       Therefore, to make EOF detection as convenient and easy as possible, the programmer may import $Eof and
       check it for a <u>TRUE</u> value after a "select" loop.  See "lc_filename.plx" for a programming example.

   <b>Number</b> <b>of</b> <b>Columns</b>
       By default, the visual length of each option is examined, and the list is spread across as many columns
       as will reasonably fit in the terminal.  You can override this behavior by importing and setting
       $MaxColumns to the maximum number of columns you wish to display.  See Scripts/max_columns_1.plx in the
       distribution as an example.

   <b>Styles</b>
       The "style" options <u>Korn</u> and <u>Bash</u> can be used to request a more Kornish or Bashlike style of behavior.
       Currently, the only difference is that the former disables, and the latter enables, prompting for every
       input.  A value can be provided for the "style" option using an argument of the form "style =&gt; 'Korn'" to
       the "use" directive.  The default setting is "Bash".  If the environment variable
       $ENV{Shell_POSIX_Select_style} is set to "Korn" or "Bash", its value overrides the one provided with the
       <b>use</b> statement.

   <b>Warnings</b>
       The "warnings" option, whose values range from 0 to 1, enables informational messages meant to help the
       interactive user provide correct inputs.  The default setting is 1, which provides warnings about
       incorrect responses to menu prompts (<u>non-numeric</u>, <u>out</u> <u>of</u> <u>range</u>, etc.).  Level 0 turns these off.

       If the environment variable $ENV{Shell_POSIX_Select_warnings} is present, its value takes precedence.

   <b>Logging</b>
       The "logging" option, whose value ranges from 0 to 1, causes informational messages and source code to be
       saved in temporary files (primarily for debugging purposes).

       The default setting is 0, which disables logging.

       If the environment variable $ENV{Shell_POSIX_Select_logging} is present, its value takes precedence.

   <b>Debug</b>
       The "debug" option, whose values range from 0 to 9, enables informational messages to aid in identifying
       bugs.  If the environment variable $ENV{Shell_POSIX_Select_debug} is present, and set to one of the
       acceptable values, it takes precedence.

       This option is primarly intended for the author's use, but users who find bugs may want to enable it and
       email the output to "AUTHOR".  But before concluding that the problem is truly a bug in this module,
       please confirm that the program runs correctly with the option "testmode =&gt; foreach" enabled (see
       "Testmode").

   <b>Testmode</b>
       The "testmode" option, whose values are 'make' and 'foreach', changes the way the program is executed.
       The 'make' option is used during the module's installation, and causes the program to dump the modified
       source code and screen display to files, and then stop (rather than interacting with the user).

       If the environment variable $ENV{Shell_POSIX_Select_testmode} is present, and set to one of the
       acceptable values, it takes precedence.

       With the "foreach" option enabled, the program simply translates occurrences of "select" into "foreach",
       which provides a useful method for checking that the program is syntactically correct before any serious
       filtering has been applied (which can introduce syntax errors).  This works because the two loops, in
       their <u>full</u> <u>forms</u>, have identical syntax.

       Note that before you use "testmode =&gt; foreach", you <u>must</u> fill in any missing parts that are required by
       "foreach".

       For instance,

       "    select () {}"

       must be rewritten as follows, to explicitly show "@ARGV" (assuming it's not in a subroutine) and "print":

       "    foreach (@ARGV) { print; }"

</pre><h4><b>ADDITIONAL</b> <b>EXAMPLES</b></h4><pre>
       NOTE: All non-trivial programming examples shown in this document are distributed with this module, in
       the <b>Scripts</b> directory.  See "ELEMENTARY EXAMPLES" for simpler uses of "select".

   <b>pick_file.plx</b>
       This program lets the user choose filenames to be sent to the output.  It's sort of like an interactive
       Perl "grep" function, with a live user providing the filtering service.  As illustrated below, it could
       be used with Shell command substitution to provide selected arguments to a command.

           use Shell::POSIX::Select  (
               prompt =&gt; 'Pick File(s):' ,
               style =&gt; 'Korn'  # for automatic prompting
           );
           select ( &lt;*&gt; ) { }

       <b>Screen</b>

           lp `pick_file`&gt;   # Using UNIX-like OS

           1) memo1.txt   2) memo2.txt   3) memo3.txt
           4) junk1.txt   5) junk2.txt   6) junk3.txt

           Pick File(s): 4
           Pick File(s): 2
           Pick File(s): ^D

           request id is yumpy@guru+587

   <b>browse_images.plx</b>
       Here's a simple yet highly useful script.   It displays a menu of all the image files in the current
       directory, and then displays the chosen ones on-screen using a backgrounded image viewer.  It uses Perl's
       "grep" to filter-out filenames that don't end in the desired extensions.

           use Shell::POSIX::Select ;

           $viewer='xv';  # Popular image viewer

           select ( grep /\.(jpg|gif|tif|png)$/i, &lt;*&gt; ) {
               system "$viewer $_ &amp;" ;     # run viewer in background
           }

   <b>perl_man.plx</b>
       Back in the olden days, we only had one Perl man-page. It was voluminous, but at least you knew what
       argument to give the <b>man</b> command to get the documentaton.

       Now we have over a hundred Perl man pages, with unpredictable names that are difficult to remember.
       Here's the program I use that allows me to select the man-page of interest from a menu.

        use Shell::POSIX::Select ;

        # Extract man-page names from the TOC portion of the output of "perldoc perl"
        select $manpage ( sort ( `perldoc perl` =~ /^\s+(perl\w+)\s/mg) ) {
            system "perldoc $manpage" ;
        }

       <b>Screen</b>

         1) perl5004delta     2) perl5005delta     3) perl561delta
         4) perl56delta       5) perl570delta      6) perl571delta
        . . .

       <u>(This</u> <u>large</u> <u>menu</u> <u>spans</u> <u>multiple</u> <u>screens,</u> <u>but</u> <u>all</u> <u>parts</u> <u>can</u> <u>be</u> <u>accessed</u>
        <u>using</u> <u>your</u> <u>normal</u> <u>terminal</u> <u>scrolling</u> <u>facility.)</u>

        Enter number of choice: 6

        <a href="../man1/PERL571DELTA.1.html">PERL571DELTA</a>(1)       Perl Programmers Reference Guide

        NAME
               perl571delta - what's new for perl v5.7.1

        DESCRIPTION
               This document describes differences between the 5.7.0
               release and the 5.7.1 release.
        . . .

   <b>pick.plx</b>
       This more general "pick"-ing program lets the user make selections from <u>arguments</u>, if they're present, or
       else <u>input</u>, in the spirit of Perl's "-n" invocation option and "&lt;&gt;" input operator.

        use Shell::POSIX::Select ;

        BEGIN {
            if (@ARGV) {
                @choices=@ARGV ;
            }
            else { # if no args, get choices from input
                @choices=&lt;STDIN&gt;  or  die "$0: No data\n";
                chomp @choices ;
                # STDIN already returned EOF, so must reopen
                # for terminal before menu interaction
                open STDIN, "/dev/tty"  or
                    die "$0: Failed to open STDIN, $!" ;  # UNIX example
            }
        }
        select ( @choices ) { }   # prints selections to output

       <b>Sample</b> <b>invocations</b> <b>(UNIX-like</b> <b>system)</b>

           lp `pick *.txt`    # same output as shown for "pick_file"

           find . -name '*.plx' -print | pick | xargs lp  # includes sub-dirs

           who |
               awk '{ print $1 }' |        # isolate user names
                   pick |                  # select user names
                       Mail -s 'Promote these people!'  boss

   <b>delete_file.plx</b>
       In this program, the user selects a filename to be deleted.  The outer loop is used to refresh the list,
       so the file deleted on the previous iteration gets removed from the next menu.  The outer loop is <u>labeled</u>
       (as "OUTER"), so that the inner loop can refer to it when necessary.

        use Shell::POSIX::Select (
            '$Eof',   # for ^D detection
            prompt=&gt;'Choose file for deletion:'
        ) ;

        OUTER:
            while ( @files=&lt;*.py&gt; ) { # collect serpentine files
                select ( @files ) {   # prompt for deletions
                    print STDERR  "Really delete $_? [y/n]: " ;
                    my $answer = &lt;STDIN&gt; ;     # ^D sets $Eof below
                    defined $answer  or  last OUTER ;  # exit on ^D
                    $answer eq "y\n"  and  unlink  and  last ;
                }
                $Eof and last;
        }

   <b>lc_filename.plx</b>
       This example shows the benefit of importing $Eof, so the outer loop can be exited when the user supplies
       "^D" to the inner one.

       Here's how it works.  If the rename succeeds in the inner loop, execution of "last" breaks out of the
       "select" loop; $Eof will then be evaluated as <u>FALSE</u>, and the "while" loop will start a new "select" loop,
       with a (depleted) filename menu.  But if the user presses "^D" to the menu prompt, $Eof will test as
       <u>TRUE</u>, triggering the exit from the "while" loop.

        use Shell::POSIX::Select (
            '$Eof' ,
            prompt =&gt; 'Enter number (^D to exit):'
            style =&gt; 'Korn'  # for automatic prompting
        );

        # Rename selected files from current dir to lowercase
        while ( @files=&lt;*[A-Z]*&gt; ) {   # refreshes select's menu
            select ( @files ) { # skip fully lower-case names
                if (rename $_, "\L$_") {
                    last ;
                }
                else {
                    warn "$0: rename failed for $_: $!\n";
                }
            }
            $Eof  and  last ;   # Handle ^D to menu prompt
        }

       <b>Screen</b>

        lc_filename.plx

        1) Abe.memo   2) Zeke.memo
        Enter number (^D to exit): 1

        1) Zeke.memo
        Enter number (^D to exit): ^D

   <b>order.plx</b>
       This program sets a custom prompt and heading for each of its two loops, and shows the use of a label on
       the outer loop.

        use Shell::POSIX::Select qw($Prompt $Heading);

        $Heading="\n\nQuantity Menu:";
        $Prompt="Choose Quantity:";

        OUTER:
          select my $quantity (1..4) {
             $Heading="\nSize Menu:" ;
             $Prompt='Choose Size:' ;

             select my $size ( qw (L XL) ) {
                 print "You chose $quantity units of size $size\n" ;
                 last OUTER ;    # Order is complete
             }
          }

       <b>Screen</b>

        order.plx

        Quantity Menu:
        1)  1    2)  2    3)  3    4)  4
        Choose Quantity: 4

        Size Menu:
        1) L   2) XL
        Choose Size: ^D       (changed my mind about the quantity)

        Quantity Menu:
        1)  1    2)  2    3)  3    4)  4
        Choose Quantity: 2

        Size Menu:
        1)  L    2)  XL
        Choose Size: 2
        You chose 2 units of size XL

   <b>browse_records.plx</b>
       This program shows how you can implement a "record browser", that builds a menu from the designated field
       of each record, and then shows the record associated with the selected field.

       To use a familiar example, we'll browse the UNIX password file by user-name.

        use Shell::POSIX::Select ( style =&gt; 'Korn' );

        if (@ARGV != 2  and  @ARGV != 3) {
            die "Usage: $0 fieldnum filename [delimiter]" ;
        }

        # Could also use Getopt:* module for option parsing
        ( $field, $file, $delim) = @ARGV ;
        if ( ! defined $delim ) {
            $delim='[\040\t]+' # SP/TAB sequences
        }

        $field-- ;  # 2-&gt;1, 1-&gt;0, etc., for 0-based indexing

        foreach ( `cat "$file"` ) {
            # field is the key in the hash, value is entire record
            $f2r{ (split /$delim/, $_)[ $field ] } = $_ ;
        }

        # Show specified fields in menu, and display associated records
        select $record ( sort keys %f2r ) {
            print "$f2r{$record}\n" ;
        }

       <b>Screen</b>

        browsrec.plx  '1'  <a href="file:/etc/passwd">/etc/passwd</a>  ':'

         1) at     2) bin       3) contix   4) daemon  5) ftp     6) games
         7) lp     8) mail      9) man     10) named  11) news   12) nobody
        13) pop   14) postfix  15) root    16) spug   17) sshd   18) tim

        Enter number of choice: 18

        tim:x:213:100:Tim Maher:/home/tim:<a href="file:/bin/bash">/bin/bash</a>

        Enter number of choice: ^D

   <b>menu_ls.plx</b>
       This program shows a prototype for a menu-oriented front end to a UNIX command, that prompts the user for
       command-option choices, assembles the requested command, and then runs it.

       It employs the user's numeric choice, stored in the $Reply variable, to extract from an array the command
       option associated with each option description.

        use Shell::POSIX::Select qw($Heading $Prompt $Eof) ;

        # following avoids used-only once warning
        my ($type, $format) ;

        # Would be more Perlish to associate choices with options
        # via a Hash, but this approach demonstrates $Reply variable

        @formats = ( 'regular', 'long' ) ;
        @fmt_opt = ( '',        '-l'   ) ;

        @types   = ( 'only non-hidden', 'all files' ) ;
        @typ_opt = ( '',                '-a' ,      ) ;

        print "** LS-Command Composer **\n\n" ;

        $Heading="\n**** Style Menu ****" ;
        $Prompt= "Choose listing style:" ;
        OUTER:
          select $format ( @formats ) {
              $user_format=$fmt_opt[ $Reply - 1 ] ;

              $Heading="\n**** File Menu ****" ;
              $Prompt="Choose files to list:" ;
              select $type ( @types ) {   # ^D restarts OUTER
                  $user_type=$typ_opt[ $Reply - 1 ] ;
                  last OUTER ;    # leave loops once final choice obtained
              }
          }
        $Eof  and  exit ;   # handle ^D to OUTER

        # Now construct user's command
        $command="ls  $user_format  $user_type" ;

        # Show command, for educational value
        warn "\nPress &lt;ENTER&gt; to execute \"$command\"\n" ;

        # Now wait for input, then run command
        defined &lt;&gt;  or  print "\n"  and  exit ;

        system $command ;    # finally, run the command

       <b>Screen</b>

        menu_ls.plx

        ** LS-Command Composer **

        1) regular    2) long
        Choose listing format: 2

        1) only non-hidden   2) all files
        Choose files to list:  2

        Press &lt;ENTER&gt; to execute "ls -l -a" &lt;ENTER&gt;

        total 13439
        -rw-r--r--    1 yumpy   gurus    1083 Feb  4 15:41 README
        -rw-rw-r--    6 yumpy   gurus     277 Dec 17 14:36 .exrc.mmkeys
        -rw-rw-r--    7 yumpy   gurus     285 Jan 16 18:45 .exrc.podkeys
        $

</pre><h4><b>BUGS</b></h4><pre>
   <b>UNIX</b> <b>Orientation</b>
       I've been a UNIX programmer since 1976, and a Linux proponent since 1992, so it's most natural for me to
       program for those platforms.  Accordingly, this early release has some minor features that are only
       allowed, or perhaps only entirely functional, on UNIX-like systems.  I'm open to suggestions on how to
       implement some of these features in a more portable manner.

       Some of the programming examples are also UNIX oriented, but it should be easy enough for those
       specializing on other platforms to make the necessary adapations. 8-}

   <b>Terminal</b> <b>Display</b> <b>Modes</b>
       These have been tested under UNIX/Linux, and work as expected, using <b>tput</b>.  When time permits, I'll
       convert to a portable implementation that will support other OSs.

   <b>Incorrect</b> <b>Line</b> <b>Numbers</b> <b>in</b> <b>Warnings</b>
       Because this module inserts new source code into your program, Perl messages that reference line numbers
       will refer to a different source file than you wrote.  For this reason, only messages referring to lines
       before the first "select" loop in your program will be correct.

       If you're on a UNIX-like system, by enabling the "debugging" and "logging" options (see "Debug" and
       "Logging"), you can get an on-screen report of the proper offset to apply to interpret the line numbers
       of the source code that gets dumped to the <u>/tmp/SELECT_source</u> file.  Of course, if everything works
       correctly, you'll have little reason to look at the source. 8-}

   <b>Please</b> <b>Report</b> <b>Bugs!</b>
       This is a non-trivial program, that does some fairly complex parsing and data munging, so I'm sure there
       are some latent bugs awaiting your discovery.  Please share them with me, by emailing the offending code,
       and/or the diagnostic messages enabled by the <u>debug</u> option setting (see "IMPORTS AND OPTIONS").

</pre><h4><b>TODO-LIST</b></h4><pre>
   <b>More</b> <b>Shell-like</b> <b>Menus</b>
       In a future release, there could be options for more accurately emulating Bash and Korn-style behavior,
       if anybody cares (the main difference is in how the items are ordered in the menus).

   <b>More</b> <b>Extensive</b> <b>Test</b> <b>Suite</b>
       More tests are needed, especially for the complex and tricky cases.

</pre><h4><b>MODULE</b> <b>DEPENDENCIES</b></h4><pre>
        File::Spec::Functions
        Text::Balanced
        Filter::Simple

</pre><h4><b>EXPORTS:</b> <b>Default</b></h4><pre>
        $Reply

       This variable is "local"ized to each "select" loop, and provides the menu-number of the most recent valid
       selection.  For an example of its use, see "menu_ls.plx".

</pre><h4><b>EXPORTS:</b> <b>Optional</b></h4><pre>
        $Heading
        $Prompt
        $MaxColumns
        $Eof

       See "IMPORTS AND OPTIONS" for details.

</pre><h4><b>SCRIPTS</b></h4><pre>
        browse_images
        browse_jpeg
        browse_records
        delete_file
        lc_filename
        long_listem
        menu_ls
        order
        perl_man
        pick
        pick_file

</pre><h4><b>AUTHOR</b></h4><pre>
         Tim Maher

</pre><h4><b>MAINTAINER</b></h4><pre>
         Martin Thurn
         <a href="mailto:mthurn@cpan.org">mthurn@cpan.org</a>

</pre><h4><b>ACKNOWLEDGEMENTS</b></h4><pre>
       I probably never would have even attempted to write this module if it weren't for the provision of
       Filter::Simple by Damian Conway, which I ruthlessly exploited to make a hard job easy.

       <u>The</u> <u>Damian</u> also gave useful tips during the module's development, for which I'm grateful.

       I <u>definitely</u> wouldn't have ever written this module, if I hadn't found myself writing a chapter on
       <u>Looping</u> for my upcoming <b>Manning</b> <b>Publications</b> book, and once again lamenting the fact that the most
       friendly Shell loop was still missing from Perl.  So in a fit of zeal, I vowed to rectify that oversight!

       I hope you find this module as useful as I do! 8-}

       For more examples of how this loop can be used in Perl programs, watch for my upcoming book, <u>Minimal</u>
       <u>Perl:</u> <u>for</u> <u>Shell</u> <u>Users</u> <u>and</u> <u>Programmers</u> (see &lt;<a href="http://teachmeperl.com/mp4sh.html">http://teachmeperl.com/mp4sh.html</a>&gt;) in early fall, 2003.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
        man ksh     # on UNIX or UNIX-like systems

        man bash    # on UNIX or UNIX-like systems

</pre><h4><b>DON'T</b> <b>SEE</b> <b>ALSO</b></h4><pre>
       <b>perldoc</b> <b>-f</b> <b>select</b>, which has nothing to do with this module (the names just happen to match up).

</pre><h4><b>VERSION</b></h4><pre>
       This document describes version 0.08.

</pre><h4><b>LICENSE</b></h4><pre>
       Copyright (C) 2002-2003, Timothy F. Maher.  All rights reserved.

       This module is free software; you can redistribute it and/or modify it under the same terms as Perl
       itself.

perl v5.36.0                                       2023-08-18                          <u>Shell::POSIX::<a href="../man3pm/Select.3pm.html">Select</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>