<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PPIx::Utils::Traversal - Utility functions for traversing PPI documents</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libppix-utils-perl">libppix-utils-perl_0.003-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       PPIx::Utils::Traversal - Utility functions for traversing PPI documents

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use PPIx::Utils::Traversal ':all';

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This package is a component of PPIx::Utils that contains functions for traversal of PPI documents.

</pre><h4><b>FUNCTIONS</b></h4><pre>
       All functions can be imported by name, or with the tag ":all".

   <b>first_arg</b>
           my $first_arg = first_arg($element);

       Given a PPI::Element that is presumed to be a function call (which is usually a PPI::Token::Word), return
       the first argument.  This is similar of "parse_arg_list" and follows the same logic.  Note that for the
       code:

           int($x + 0.5)

       this function will return just the $x, not the whole expression.  This is different from the behavior of
       "parse_arg_list".  Another caveat is:

           int(($x + $y) + 0.5)

       which returns "($x + $y)" as a PPI::Structure::List instance.

   <b>parse_arg_list</b>
           my @args = parse_arg_list($element);

       Given a PPI::Element that is presumed to be a function call (which is usually a PPI::Token::Word), splits
       the argument expressions into arrays of tokens.  Returns a list containing references to each of those
       arrays.  This is useful because parentheses are optional when calling a function, and PPI parses them
       very differently.  So this method is a poor-man's parse tree of PPI nodes.  It's not bullet-proof because
       it doesn't respect precedence. In general, I don't like the way this function works, so don't count on it
       to be stable (or even present).

   <b>split_nodes_on_comma</b>
           my @args = split_nodes_on_comma(@nodes);

       This has the same return type as "parse_arg_list" but expects to be passed the nodes that represent the
       interior of a list, like:

           'foo', 1, 2, 'bar'

   <b>get_next_element_in_same_simple_statement</b>
           my $element = get_next_element_in_same_simple_statement($element);

       Given a PPI::Element, this subroutine returns the next element in the same simple statement as defined by
       "is_ppi_simple_statement" in PPIx::Utils::Classification. If no next element can be found, this
       subroutine simply returns "undef".

       If the $element is undefined or unblessed, we simply return "undef".

       If the $element satisfies "is_ppi_simple_statement" in PPIx::Utils::Classification, we return "undef",
       <b>unless</b> it has a parent which is a PPI::Structure::List.

       If the $element is the last significant element in its PPI::Node, we replace it with its parent and
       iterate again.

       Otherwise, we return "$element-&gt;snext_sibling()".

   <b>get_previous_module_used_on_same_line</b>
           my $element = get_previous_module_used_on_same_line($element);

       Given a PPI::Element, returns the PPI::Element representing the name of the module included by the
       previous "use" or "require" on the same line as the $element. If none is found, simply returns "undef".

       For example, with the line

           use version; our $VERSION = ...;

       given the PPI::Token::Symbol instance for $VERSION, this will return "version".

       If the given element is in a "use" or &lt;require&gt;, the return is from the previous "use" or "require" on
       the line, if any.

   <b>get_constant_name_elements_from_declaring_statement</b>
           my @constants = get_constant_name_elements_from_declaring_statement($statement);

       Given a PPI::Statement, if the statement is a Readonly, ReadonlyX, or Const::Fast declaration statement
       or a "use constant", returns the names of the things being defined.

       Given

           use constant 1.16 FOO =&gt; 'bar';

       this will return the PPI::Token::Word containing 'FOO'.  Given

           use constant 1.16 { FOO =&gt; 'bar', 'BAZ' =&gt; 'burfle' };

       this will return a list of the PPI::Tokens containing 'FOO' and 'BAZ'.  Similarly, given

           Readonly::Hash my %FOO =&gt; ( bar =&gt; 'baz' );

       or

           const my %FOO =&gt; ( bar =&gt; 'baz' );

       this will return the PPI::Token::Symbol containing '%FOO'.

   <b>split_ppi_node_by_namespace</b>
           my $subtrees = split_ppi_node_by_namespace($node);

       Returns the sub-trees for each namespace in the node as a reference to a hash of references to arrays of
       PPI::Nodes.  Say we've got the following code:

           #!perl

           my $x = blah();

           package Foo;

           my $y = blah_blah();

           {
               say 'Whee!';

               package Bar;

               something();
           }

           thingy();

           package Baz;

           da_da_da();

           package Foo;

           foreach ( blrfl() ) {
               ...
           }

       Calling this function on a PPI::Document for the above returns a value that looks like this, using multi-
       line string literals for the actual code parts instead of PPI trees to make this easier to read:

           {
               main    =&gt; [
                   q&lt;
                       #!perl

                       my $x = blah();
                   &gt;,
               ],
               Foo     =&gt; [
                   q&lt;
                       package Foo;

                       my $y = blah_blah();

                       {
                           say 'Whee!';

                       }

                       thingy();
                   &gt;,
                   q&lt;
                       package Foo;

                       foreach ( blrfl() ) {
                           ...
                       }
                   &gt;,
               ],
               Bar     =&gt; [
                   q&lt;
                       package Bar;

                       something();
                   &gt;,
               ],
               Baz     =&gt; [
                   q&lt;
                       package Baz;

                       da_da_da();
                   &gt;,
               ],
           }

       Note that the return value contains copies of the original nodes, and not the original nodes themselves
       due to the need to handle namespaces that are not file-scoped.  (Notice how the first element for "Foo"
       above differs from the original code.)

</pre><h4><b>BUGS</b></h4><pre>
       Report any issues on the public bugtracker.

</pre><h4><b>AUTHOR</b></h4><pre>
       Dan Book &lt;<a href="mailto:dbook@cpan.org">dbook@cpan.org</a>&gt;

       Code originally from Perl::Critic::Utils by Jeffrey Ryan Thalhammer &lt;<a href="mailto:jeff@imaginative-software.com">jeff@imaginative-software.com</a>&gt;,
       Perl::Critic::Utils::PPI and PPIx::Utilities::Node by Elliot Shank &lt;<a href="mailto:perl@galumph.com">perl@galumph.com</a>&gt;, and
       PPIx::Utilities::Statement by Thomas R. Wyant, III &lt;<a href="mailto:wyant@cpan.org">wyant@cpan.org</a>&gt;

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2005-2011 Imaginative Software Systems, 2007-2011 Elliot Shank, 2009-2010
       Thomas R. Wyant, III, 2017 Dan Book.

       This is free software; you can redistribute it and/or modify it under the same terms as the Perl 5
       programming language system itself.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Perl::Critic::Utils, Perl::Critic::Utils::PPI, PPIx::Utilities

perl v5.32.1                                       2021-09-29                        <u>PPIx::Utils::<a href="../man3pm/Traversal.3pm.html">Traversal</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>