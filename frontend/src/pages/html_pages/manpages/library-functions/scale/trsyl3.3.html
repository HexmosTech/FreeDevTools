<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>trsyl3 - trsyl3: Sylvester equation, level 3</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/liblapack-doc">liblapack-doc_3.12.1-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       trsyl3 - trsyl3: Sylvester equation, level 3

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Functions</b>
       subroutine <b>ctrsyl3</b> (trana, tranb, isgn, m, n, a, lda, b, ldb, c, ldc, scale, swork, ldswork, info)
           <b>CTRSYL3</b>
       subroutine <b>dtrsyl3</b> (trana, tranb, isgn, m, n, a, lda, b, ldb, c, ldc, scale, iwork, liwork, swork,
           ldswork, info)
           <b>DTRSYL3</b>
       subroutine <b>strsyl3</b> (trana, tranb, isgn, m, n, a, lda, b, ldb, c, ldc, scale, iwork, liwork, swork,
           ldswork, info)
           <b>STRSYL3</b>
       subroutine <b>ztrsyl3</b> (trana, tranb, isgn, m, n, a, lda, b, ldb, c, ldc, scale, swork, ldswork, info)
           <b>ZTRSYL3</b>

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>subroutine</b> <b>ctrsyl3</b> <b>(character</b> <b>trana,</b> <b>character</b> <b>tranb,</b> <b>integer</b> <b>isgn,</b> <b>integer</b> <b>m,</b> <b>integer</b> <b>n,</b> <b>complex,</b> <b>dimension(</b>
       <b>lda,</b> <b>*</b> <b>)</b> <b>a,</b> <b>integer</b> <b>lda,</b> <b>complex,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>b,</b> <b>integer</b> <b>ldb,</b> <b>complex,</b> <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>c,</b>
       <b>integer</b> <b>ldc,</b> <b>real</b> <b>scale,</b> <b>real,</b> <b>dimension(</b> <b>ldswork,</b> <b>*</b> <b>)</b> <b>swork,</b> <b>integer</b> <b>ldswork,</b> <b>integer</b> <b>info)</b>
       <b>CTRSYL3</b>

       <b>Purpose:</b>

             CTRSYL3 solves the complex Sylvester matrix equation:

                op(A)*X + X*op(B) = scale*C or
                op(A)*X - X*op(B) = scale*C,

             where op(A) = A or A**H, and  A and B are both upper triangular. A is
             M-by-M and B is N-by-N; the right hand side C and the solution X are
             M-by-N; and scale is an output scale factor, set &lt;= 1 to avoid
             overflow in X.

             This is the block version of the algorithm.

       <b>Parameters</b>
           <u>TRANA</u>

                     TRANA is CHARACTER*1
                     Specifies the option op(A):
                     = 'N': op(A) = A    (No transpose)
                     = 'C': op(A) = A**H (Conjugate transpose)

           <u>TRANB</u>

                     TRANB is CHARACTER*1
                     Specifies the option op(B):
                     = 'N': op(B) = B    (No transpose)
                     = 'C': op(B) = B**H (Conjugate transpose)

           <u>ISGN</u>

                     ISGN is INTEGER
                     Specifies the sign in the equation:
                     = +1: solve op(A)*X + X*op(B) = scale*C
                     = -1: solve op(A)*X - X*op(B) = scale*C

           <u>M</u>

                     M is INTEGER
                     The order of the matrix A, and the number of rows in the
                     matrices X and C. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix B, and the number of columns in the
                     matrices X and C. N &gt;= 0.

           <u>A</u>

                     A is COMPLEX array, dimension (LDA,M)
                     The upper triangular matrix A.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A. LDA &gt;= max(1,M).

           <u>B</u>

                     B is COMPLEX array, dimension (LDB,N)
                     The upper triangular matrix B.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B. LDB &gt;= max(1,N).

           <u>C</u>

                     C is COMPLEX array, dimension (LDC,N)
                     On entry, the M-by-N right hand side matrix C.
                     On exit, C is overwritten by the solution matrix X.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C. LDC &gt;= max(1,M)

           <u>SCALE</u>

                     SCALE is REAL
                     The scale factor, scale, set &lt;= 1 to avoid overflow in X.

           <u>SWORK</u>

                     SWORK is REAL array, dimension (MAX(2, ROWS), MAX(1,COLS)).
                     On exit, if INFO = 0, <a href="../man1/SWORK.1.html">SWORK</a>(1) returns the optimal value ROWS
                     and <a href="../man2/SWORK.2.html">SWORK</a>(2) returns the optimal COLS.

           <u>LDSWORK</u>

                     LDSWORK is INTEGER
                     LDSWORK &gt;= MAX(2,ROWS), where ROWS = ((M + NB - 1) / NB + 1)
                     and NB is the optimal block size.

                     If LDSWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal dimensions of the SWORK matrix,
                     returns these values as the first and second entry of the SWORK
                     matrix, and no error message related LWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0: successful exit
                     &lt; 0: if INFO = -i, the i-th argument had an illegal value
                     = 1: A and B have common or very close eigenvalues; perturbed
                          values were used to solve the equation (but the matrices
                          A and B are unchanged).

   <b>subroutine</b> <b>dtrsyl3</b> <b>(character</b> <b>trana,</b> <b>character</b> <b>tranb,</b> <b>integer</b> <b>isgn,</b> <b>integer</b> <b>m,</b> <b>integer</b> <b>n,</b> <b>double</b> <b>precision,</b>
       <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>a,</b> <b>integer</b> <b>lda,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>b,</b> <b>integer</b> <b>ldb,</b> <b>double</b>
       <b>precision,</b> <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>c,</b> <b>integer</b> <b>ldc,</b> <b>double</b> <b>precision</b> <b>scale,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>iwork,</b>
       <b>integer</b> <b>liwork,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldswork,</b> <b>*</b> <b>)</b> <b>swork,</b> <b>integer</b> <b>ldswork,</b> <b>integer</b> <b>info)</b>
       <b>DTRSYL3</b>

       <b>Purpose:</b>

             DTRSYL3 solves the real Sylvester matrix equation:

                op(A)*X + X*op(B) = scale*C or
                op(A)*X - X*op(B) = scale*C,

             where op(A) = A or A**T, and  A and B are both upper quasi-
             triangular. A is M-by-M and B is N-by-N; the right hand side C and
             the solution X are M-by-N; and scale is an output scale factor, set
             &lt;= 1 to avoid overflow in X.

             A and B must be in Schur canonical form (as returned by DHSEQR), that
             is, block upper triangular with 1-by-1 and 2-by-2 diagonal blocks;
             each 2-by-2 diagonal block has its diagonal elements equal and its
             off-diagonal elements of opposite sign.

             This is the block version of the algorithm.

       <b>Parameters</b>
           <u>TRANA</u>

                     TRANA is CHARACTER*1
                     Specifies the option op(A):
                     = 'N': op(A) = A    (No transpose)
                     = 'T': op(A) = A**T (Transpose)
                     = 'C': op(A) = A**H (Conjugate transpose = Transpose)

           <u>TRANB</u>

                     TRANB is CHARACTER*1
                     Specifies the option op(B):
                     = 'N': op(B) = B    (No transpose)
                     = 'T': op(B) = B**T (Transpose)
                     = 'C': op(B) = B**H (Conjugate transpose = Transpose)

           <u>ISGN</u>

                     ISGN is INTEGER
                     Specifies the sign in the equation:
                     = +1: solve op(A)*X + X*op(B) = scale*C
                     = -1: solve op(A)*X - X*op(B) = scale*C

           <u>M</u>

                     M is INTEGER
                     The order of the matrix A, and the number of rows in the
                     matrices X and C. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix B, and the number of columns in the
                     matrices X and C. N &gt;= 0.

           <u>A</u>

                     A is DOUBLE PRECISION array, dimension (LDA,M)
                     The upper quasi-triangular matrix A, in Schur canonical form.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A. LDA &gt;= max(1,M).

           <u>B</u>

                     B is DOUBLE PRECISION array, dimension (LDB,N)
                     The upper quasi-triangular matrix B, in Schur canonical form.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B. LDB &gt;= max(1,N).

           <u>C</u>

                     C is DOUBLE PRECISION array, dimension (LDC,N)
                     On entry, the M-by-N right hand side matrix C.
                     On exit, C is overwritten by the solution matrix X.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C. LDC &gt;= max(1,M)

           <u>SCALE</u>

                     SCALE is DOUBLE PRECISION
                     The scale factor, scale, set &lt;= 1 to avoid overflow in X.

           <u>IWORK</u>

                     IWORK is INTEGER array, dimension (MAX(1,LIWORK))
                     On exit, if INFO = 0, <a href="../man1/IWORK.1.html">IWORK</a>(1) returns the optimal LIWORK.

           <u>LIWORK</u>

                     IWORK is INTEGER
                     The dimension of the array IWORK. LIWORK &gt;=  ((M + NB - 1) / NB + 1)
                     + ((N + NB - 1) / NB + 1), where NB is the optimal block size.

                     If LIWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal dimension of the IWORK array,
                     returns this value as the first entry of the IWORK array, and
                     no error message related to LIWORK is issued by XERBLA.

           <u>SWORK</u>

                     SWORK is DOUBLE PRECISION array, dimension (MAX(2, ROWS),
                     MAX(1,COLS)).
                     On exit, if INFO = 0, <a href="../man1/SWORK.1.html">SWORK</a>(1) returns the optimal value ROWS
                     and <a href="../man2/SWORK.2.html">SWORK</a>(2) returns the optimal COLS.

           <u>LDSWORK</u>

                     LDSWORK is INTEGER
                     LDSWORK &gt;= MAX(2,ROWS), where ROWS = ((M + NB - 1) / NB + 1)
                     and NB is the optimal block size.

                     If LDSWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal dimensions of the SWORK matrix,
                     returns these values as the first and second entry of the SWORK
                     matrix, and no error message related LWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0: successful exit
                     &lt; 0: if INFO = -i, the i-th argument had an illegal value
                     = 1: A and B have common or very close eigenvalues; perturbed
                          values were used to solve the equation (but the matrices
                          A and B are unchanged).

   <b>subroutine</b> <b>strsyl3</b> <b>(character</b> <b>trana,</b> <b>character</b> <b>tranb,</b> <b>integer</b> <b>isgn,</b> <b>integer</b> <b>m,</b> <b>integer</b> <b>n,</b> <b>real,</b> <b>dimension(</b>
       <b>lda,</b> <b>*</b> <b>)</b> <b>a,</b> <b>integer</b> <b>lda,</b> <b>real,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>b,</b> <b>integer</b> <b>ldb,</b> <b>real,</b> <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>c,</b> <b>integer</b>
       <b>ldc,</b> <b>real</b> <b>scale,</b> <b>integer,</b> <b>dimension(</b> <b>*</b> <b>)</b> <b>iwork,</b> <b>integer</b> <b>liwork,</b> <b>real,</b> <b>dimension(</b> <b>ldswork,</b> <b>*</b> <b>)</b> <b>swork,</b>
       <b>integer</b> <b>ldswork,</b> <b>integer</b> <b>info)</b>
       <b>STRSYL3</b>

       <b>Purpose:</b>

             STRSYL3 solves the real Sylvester matrix equation:

                op(A)*X + X*op(B) = scale*C or
                op(A)*X - X*op(B) = scale*C,

             where op(A) = A or A**T, and  A and B are both upper quasi-
             triangular. A is M-by-M and B is N-by-N; the right hand side C and
             the solution X are M-by-N; and scale is an output scale factor, set
             &lt;= 1 to avoid overflow in X.

             A and B must be in Schur canonical form (as returned by SHSEQR), that
             is, block upper triangular with 1-by-1 and 2-by-2 diagonal blocks;
             each 2-by-2 diagonal block has its diagonal elements equal and its
             off-diagonal elements of opposite sign.

             This is the block version of the algorithm.

       <b>Parameters</b>
           <u>TRANA</u>

                     TRANA is CHARACTER*1
                     Specifies the option op(A):
                     = 'N': op(A) = A    (No transpose)
                     = 'T': op(A) = A**T (Transpose)
                     = 'C': op(A) = A**H (Conjugate transpose = Transpose)

           <u>TRANB</u>

                     TRANB is CHARACTER*1
                     Specifies the option op(B):
                     = 'N': op(B) = B    (No transpose)
                     = 'T': op(B) = B**T (Transpose)
                     = 'C': op(B) = B**H (Conjugate transpose = Transpose)

           <u>ISGN</u>

                     ISGN is INTEGER
                     Specifies the sign in the equation:
                     = +1: solve op(A)*X + X*op(B) = scale*C
                     = -1: solve op(A)*X - X*op(B) = scale*C

           <u>M</u>

                     M is INTEGER
                     The order of the matrix A, and the number of rows in the
                     matrices X and C. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix B, and the number of columns in the
                     matrices X and C. N &gt;= 0.

           <u>A</u>

                     A is REAL array, dimension (LDA,M)
                     The upper quasi-triangular matrix A, in Schur canonical form.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A. LDA &gt;= max(1,M).

           <u>B</u>

                     B is REAL array, dimension (LDB,N)
                     The upper quasi-triangular matrix B, in Schur canonical form.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B. LDB &gt;= max(1,N).

           <u>C</u>

                     C is REAL array, dimension (LDC,N)
                     On entry, the M-by-N right hand side matrix C.
                     On exit, C is overwritten by the solution matrix X.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C. LDC &gt;= max(1,M)

           <u>SCALE</u>

                     SCALE is REAL
                     The scale factor, scale, set &lt;= 1 to avoid overflow in X.

           <u>IWORK</u>

                     IWORK is INTEGER array, dimension (MAX(1,LIWORK))
                     On exit, if INFO = 0, <a href="../man1/IWORK.1.html">IWORK</a>(1) returns the optimal LIWORK.

           <u>LIWORK</u>

                     IWORK is INTEGER
                     The dimension of the array IWORK. LIWORK &gt;=  ((M + NB - 1) / NB + 1)
                     + ((N + NB - 1) / NB + 1), where NB is the optimal block size.

                     If LIWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal dimension of the IWORK array,
                     returns this value as the first entry of the IWORK array, and
                     no error message related to LIWORK is issued by XERBLA.

           <u>SWORK</u>

                     SWORK is REAL array, dimension (MAX(2, ROWS),
                     MAX(1,COLS)).
                     On exit, if INFO = 0, <a href="../man1/SWORK.1.html">SWORK</a>(1) returns the optimal value ROWS
                     and <a href="../man2/SWORK.2.html">SWORK</a>(2) returns the optimal COLS.

           <u>LDSWORK</u>

                     LDSWORK is INTEGER
                     LDSWORK &gt;= MAX(2,ROWS), where ROWS = ((M + NB - 1) / NB + 1)
                     and NB is the optimal block size.

                     If LDSWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal dimensions of the SWORK matrix,
                     returns these values as the first and second entry of the SWORK
                     matrix, and no error message related LWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0: successful exit
                     &lt; 0: if INFO = -i, the i-th argument had an illegal value
                     = 1: A and B have common or very close eigenvalues; perturbed
                          values were used to solve the equation (but the matrices
                          A and B are unchanged).

   <b>subroutine</b> <b>ztrsyl3</b> <b>(character</b> <b>trana,</b> <b>character</b> <b>tranb,</b> <b>integer</b> <b>isgn,</b> <b>integer</b> <b>m,</b> <b>integer</b> <b>n,</b> <b>complex*16,</b>
       <b>dimension(</b> <b>lda,</b> <b>*</b> <b>)</b> <b>a,</b> <b>integer</b> <b>lda,</b> <b>complex*16,</b> <b>dimension(</b> <b>ldb,</b> <b>*</b> <b>)</b> <b>b,</b> <b>integer</b> <b>ldb,</b> <b>complex*16,</b>
       <b>dimension(</b> <b>ldc,</b> <b>*</b> <b>)</b> <b>c,</b> <b>integer</b> <b>ldc,</b> <b>double</b> <b>precision</b> <b>scale,</b> <b>double</b> <b>precision,</b> <b>dimension(</b> <b>ldswork,</b> <b>*</b> <b>)</b>
       <b>swork,</b> <b>integer</b> <b>ldswork,</b> <b>integer</b> <b>info)</b>
       <b>ZTRSYL3</b>

       <b>Purpose:</b>

             ZTRSYL3 solves the complex Sylvester matrix equation:

                op(A)*X + X*op(B) = scale*C or
                op(A)*X - X*op(B) = scale*C,

             where op(A) = A or A**H, and  A and B are both upper triangular. A is
             M-by-M and B is N-by-N; the right hand side C and the solution X are
             M-by-N; and scale is an output scale factor, set &lt;= 1 to avoid
             overflow in X.

             This is the block version of the algorithm.

       <b>Parameters</b>
           <u>TRANA</u>

                     TRANA is CHARACTER*1
                     Specifies the option op(A):
                     = 'N': op(A) = A    (No transpose)
                     = 'C': op(A) = A**H (Conjugate transpose)

           <u>TRANB</u>

                     TRANB is CHARACTER*1
                     Specifies the option op(B):
                     = 'N': op(B) = B    (No transpose)
                     = 'C': op(B) = B**H (Conjugate transpose)

           <u>ISGN</u>

                     ISGN is INTEGER
                     Specifies the sign in the equation:
                     = +1: solve op(A)*X + X*op(B) = scale*C
                     = -1: solve op(A)*X - X*op(B) = scale*C

           <u>M</u>

                     M is INTEGER
                     The order of the matrix A, and the number of rows in the
                     matrices X and C. M &gt;= 0.

           <u>N</u>

                     N is INTEGER
                     The order of the matrix B, and the number of columns in the
                     matrices X and C. N &gt;= 0.

           <u>A</u>

                     A is COMPLEX*16 array, dimension (LDA,M)
                     The upper triangular matrix A.

           <u>LDA</u>

                     LDA is INTEGER
                     The leading dimension of the array A. LDA &gt;= max(1,M).

           <u>B</u>

                     B is COMPLEX*16 array, dimension (LDB,N)
                     The upper triangular matrix B.

           <u>LDB</u>

                     LDB is INTEGER
                     The leading dimension of the array B. LDB &gt;= max(1,N).

           <u>C</u>

                     C is COMPLEX*16 array, dimension (LDC,N)
                     On entry, the M-by-N right hand side matrix C.
                     On exit, C is overwritten by the solution matrix X.

           <u>LDC</u>

                     LDC is INTEGER
                     The leading dimension of the array C. LDC &gt;= max(1,M)

           <u>SCALE</u>

                     SCALE is DOUBLE PRECISION
                     The scale factor, scale, set &lt;= 1 to avoid overflow in X.

           <u>SWORK</u>

                     SWORK is DOUBLE PRECISION array, dimension (MAX(2, ROWS),
                     MAX(1,COLS)).
                     On exit, if INFO = 0, <a href="../man1/SWORK.1.html">SWORK</a>(1) returns the optimal value ROWS
                     and <a href="../man2/SWORK.2.html">SWORK</a>(2) returns the optimal COLS.

           <u>LDSWORK</u>

                     LDSWORK is INTEGER
                     LDSWORK &gt;= MAX(2,ROWS), where ROWS = ((M + NB - 1) / NB + 1)
                     and NB is the optimal block size.

                     If LDSWORK = -1, then a workspace query is assumed; the routine
                     only calculates the optimal dimensions of the SWORK matrix,
                     returns these values as the first and second entry of the SWORK
                     matrix, and no error message related LWORK is issued by XERBLA.

           <u>INFO</u>

                     INFO is INTEGER
                     = 0: successful exit
                     &lt; 0: if INFO = -i, the i-th argument had an illegal value
                     = 1: A and B have common or very close eigenvalues; perturbed
                          values were used to solve the equation (but the matrices
                          A and B are unchanged).

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for LAPACK from the source code.

Version 3.12.0                              Sun Jul 20 2025 01:40:05                                   <u><a href="../man3/trsyl3.3.html">trsyl3</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>