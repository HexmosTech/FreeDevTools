<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DBD::SQLite::Cookbook - The DBD::SQLite Cookbook</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdbd-sqlite3-perl">libdbd-sqlite3-perl_1.76-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       DBD::SQLite::Cookbook - The DBD::SQLite Cookbook

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This is the DBD::SQLite cookbook.

       It is intended to provide a place to keep a variety of functions and formals for use in callback APIs in
       DBD::SQLite.

</pre><h4><b>AGGREGATE</b> <b>FUNCTIONS</b></h4><pre>
   <b>Variance</b>
       This is a simple aggregate function which returns a variance. It is adapted from an example
       implementation in pysqlite.

         package variance;

         sub new { bless [], shift; }

         sub step {
             my ( $self, $value ) = @_;

             push @$self, $value;
         }

         sub finalize {
             my $self = $_[0];

             my $n = @$self;

             # Variance is NULL unless there is more than one row
             return undef unless $n || $n == 1;

             my $mu = 0;
             foreach my $v ( @$self ) {
                 $mu += $v;
             }
             $mu /= $n;

             my $sigma = 0;
             foreach my $v ( @$self ) {
                 $sigma += ($v - $mu)**2;
             }
             $sigma = $sigma / ($n - 1);

             return $sigma;
         }

         # NOTE: If you use an older DBI (&lt; 1.608),
         # use $dbh-&gt;func(..., "create_aggregate") instead.
         $dbh-&gt;sqlite_create_aggregate( "variance", 1, 'variance' );

       The function can then be used as:

         SELECT group_name, variance(score)
         FROM results
         GROUP BY group_name;

   <b>Variance</b> <b>(Memory</b> <b>Efficient)</b>
       A more efficient variance function, optimized for memory usage at the expense of precision:

         package variance2;

         sub new { bless {sum =&gt; 0, count=&gt;0, hash=&gt; {} }, shift; }

         sub step {
             my ( $self, $value ) = @_;
             my $hash = $self-&gt;{hash};

             # by truncating and hashing, we can comsume many more data points
             $value = int($value); # change depending on need for precision
                                   # use sprintf for arbitrary fp precision
             if (exists $hash-&gt;{$value}) {
                 $hash-&gt;{$value}++;
             } else {
                 $hash-&gt;{$value} = 1;
             }
             $self-&gt;{sum} += $value;
             $self-&gt;{count}++;
         }

         sub finalize {
             my $self = $_[0];

             # Variance is NULL unless there is more than one row
             return undef unless $self-&gt;{count} &gt; 1;

             # calculate avg
             my $mu = $self-&gt;{sum} / $self-&gt;{count};

             my $sigma = 0;
             while (my ($h, $v) = each %{$self-&gt;{hash}}) {
                 $sigma += (($h - $mu)**2) * $v;
             }
             $sigma = $sigma / ($self-&gt;{count} - 1);

             return $sigma;
         }

       The function can then be used as:

         SELECT group_name, variance2(score)
         FROM results
         GROUP BY group_name;

   <b>Variance</b> <b>(Highly</b> <b>Scalable)</b>
       A third variable implementation, designed for arbitrarily large data sets:

         package variance3;

         sub new { bless {mu=&gt;0, count=&gt;0, S=&gt;0}, shift; }

         sub step {
             my ( $self, $value ) = @_;
             $self-&gt;{count}++;
             my $delta = $value - $self-&gt;{mu};
             $self-&gt;{mu} += $delta/$self-&gt;{count};
             $self-&gt;{S} += $delta*($value - $self-&gt;{mu});
         }

         sub finalize {
             my $self = $_[0];
             return $self-&gt;{S} / ($self-&gt;{count} - 1);
         }

       The function can then be used as:

         SELECT group_name, variance3(score)
         FROM results
         GROUP BY group_name;

</pre><h4><b>SUPPORT</b></h4><pre>
       Bugs should be reported via the CPAN bug tracker at

       &lt;<a href="http://rt.cpan.org/NoAuth/ReportBug.html">http://rt.cpan.org/NoAuth/ReportBug.html</a>?Queue=DBD-SQLite&gt;

</pre><h4><b>TO</b> <b>DO</b></h4><pre>
       •   Add  more  and  varied  cookbook  recipes,  until  we  have  enough to turn them into a separate CPAN
           distribution.

       •   Create a series of tests scripts that validate the cookbook recipes.

</pre><h4><b>AUTHOR</b></h4><pre>
       Adam Kennedy &lt;<a href="mailto:adamk@cpan.org">adamk@cpan.org</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2009 - 2012 Adam Kennedy.

       This program is free software; you can redistribute it and/or modify it under  the  same  terms  as  Perl
       itself.

       The full text of the license can be found in the LICENSE file included with this module.

perl v5.40.0                                       2024-10-28                         <u>DBD::SQLite::<a href="../man3pm/Cookbook.3pm.html">Cookbook</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>