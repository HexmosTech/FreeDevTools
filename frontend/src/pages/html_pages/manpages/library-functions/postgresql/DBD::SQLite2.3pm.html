<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DBD::SQLite2 - Self Contained RDBMS in a DBI Driver (sqlite 2.x)</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/libdbd-sqlite2-perl">libdbd-sqlite2-perl_0.38-2build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       DBD::SQLite2 - Self Contained RDBMS in a DBI Driver (sqlite 2.x)

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use DBI;
         my $dbh = DBI-&gt;connect("dbi:SQLite2:dbname=dbfile","","");

</pre><h4><b>DESCRIPTION</b></h4><pre>
       SQLite is a public domain RDBMS database engine that you can find at <a href="http://www.sqlite.org/">http://www.sqlite.org/</a>.

       Rather than ask you to install SQLite first, because SQLite is public domain, DBD::SQLite2 includes the
       entire thing in the distribution. So in order to get a fast transaction capable RDBMS working for your
       perl project you simply have to install this module, and <b>nothing</b> else.

       For real work please use the updated DBD::SQLite driver with the up-to-date sqlite3 backend.  SQLite2
       supports the following features:

       Implements a large subset of SQL92
           See <a href="http://www.sqlite.org/lang.html">http://www.sqlite.org/lang.html</a> for details.

       A complete DB in a single disk file
           Everything  for your database is stored in a single disk file, making it easier to move things around
           than with DBD::CSV.

       Atomic commit and rollback
           Yes, DBD::SQLite2 is small and light, but it supports full transactions

       Extensible
           User-defined aggregate or regular functions can be registered with the SQL parser.

       There's lots more to it, so please refer to the docs on the  SQLite  web  page,  listed  above,  for  SQL
       details. Also refer to DBI for details on how to use DBI itself.

</pre><h4><b>CONFORMANCE</b> <b>WITH</b> <b>DBI</b> <b>SPECIFICATION</b></h4><pre>
       The API works like every DBI module does. Please see DBI for more details about core features.

       Currently  many  statement  attributes  are  not implemented or are limited by the typeless nature of the
       SQLite2 database.

</pre><h4><b>DRIVER</b> <b>PRIVATE</b> <b>ATTRIBUTES</b></h4><pre>
   <b>Database</b> <b>Handle</b> <b>Attributes</b>
       sqlite_version
           Returns the version of the SQLite library which DBD::SQLite2 is using, i.e, "2.8.15".

       sqlite_encoding
           Returns either "UTF-8" or "iso8859" to indicate how the SQLite library was compiled.

       sqlite_handle_binary_nulls
           Set this attribute to 1 to transparently handle binary nulls in quoted and returned data.

           <b>NOTE:</b> This will cause all backslash characters ("\") to be doubled up in all  columns  regardless  of
           whether  or  not  they  contain  binary  data or not. This may break your database if you use it from
           another application. This does not use the built in "sqlite_encode_binary" and "sqlite_decode_binary"
           functions, which may be considered a bug.

</pre><h4><b>DRIVER</b> <b>PRIVATE</b> <b>METHODS</b></h4><pre>
   <b>$dbh-&gt;func('last_insert_rowid')</b>
       This method returns the last inserted rowid. If you specify an INTEGER PRIMARY KEY as the first column in
       your table, that is the column that is returned.  Otherwise, it is  the  hidden  ROWID  column.  See  the
       sqlite docs for details.

   <b>$dbh-&gt;func(</b> <b>$name,</b> <b>$argc,</b> <b>$func_ref,</b> <b>"create_function"</b> <b>)</b>
       This method will register a new function which will be useable in SQL query. The method's parameters are:

       $name
           The name of the function. This is the name of the function as it will be used from SQL.

       $argc
           The number of arguments taken by the function. If this number is -1, the function can take any number
           of arguments.

       $func_ref
           This should be a reference to the function's implementation.

       For example, here is how to define a <b>now()</b> function which returns the current number of seconds since the
       epoch:

           $dbh-&gt;func( 'now', 0, sub { return time }, 'create_function' );

       After this, it could be use from SQL as:

           INSERT INTO mytable ( now() );

   <b>$dbh-&gt;func(</b> <b>$name,</b> <b>$argc,</b> <b>$pkg,</b> <b>'create_aggregate'</b> <b>)</b>
       This  method will register a new aggregate function which can then used from SQL. The method's parameters
       are:

       $name
           The name of the aggregate function, this is the name under which the function will be available  from
           SQL.

       $argc
           This  is  an integer which tells the SQL parser how many arguments the function takes. If that number
           is -1, the function can take any number of arguments.

       $pkg
           This is the package which implements the aggregator interface.

       The aggregator interface consists of defining three methods:

       <b>new()</b>
           This method will be called once to create an object which should be used to aggregate the rows  in  a
           particular  group.  The <b>step()</b> and <b>finalize()</b> methods will be called upon the reference return by the
           method.

       step(@_)
           This method will be called once for each rows in the aggregate.

       <b>finalize()</b>
           This method will be called once all rows in the aggregate were processed and  it  should  return  the
           aggregate  function's result. When there is no rows in the aggregate, <b>finalize()</b> will be called right
           after <b>new()</b>.

       Here is a simple aggregate function which returns the variance (example adapted from pysqlite):

           package variance;

           sub new { bless [], shift; }

           sub step {
               my ( $self, $value ) = @_;

               push @$self, $value;
           }

           sub finalize {
               my $self = $_[0];

               my $n = @$self;

               # Variance is NULL unless there is more than one row
               return undef unless $n || $n == 1;

               my $mu = 0;
               foreach my $v ( @$self ) {
                   $mu += $v;
               }
               $mu /= $n;

               my $sigma = 0;
               foreach my $v ( @$self ) {
                   $sigma += ($x - $mu)**2;
               }
               $sigma = $sigma / ($n - 1);

               return $sigma;
           }

           $dbh-&gt;func( "variance", 1, 'variance', "create_aggregate" );

       The aggregate function can then be used as:

           SELECT group_name, variance(score) FROM results
           GROUP BY group_name;

</pre><h4><b>NOTES</b></h4><pre>
       To access the database from the command line, try using dbish which comes with the DBI module. Just type:

         dbish dbi:SQLite:foo.db

       On the command line to access the file <u>foo.db</u>.

       Alternatively you can install SQLite from the link above without conflicting with  DBD::SQLite2  and  use
       the supplied "sqlite" command line tool.

</pre><h4><b>PERFORMANCE</b></h4><pre>
       SQLite  is  fast,  very fast. I recently processed my 72MB log file with it, inserting the data (400,000+
       rows) by using transactions and only committing every 1000 rows (otherwise the insertion is quite  slow),
       and then performing queries on the data.

       Queries  like count(*) and avg(bytes) took fractions of a second to return, but what surprised me most of
       all was:

         SELECT url, count(*) as count FROM access_log
           GROUP BY url
           ORDER BY count desc
           LIMIT 20

       To discover the top 20 hit URLs on the site (<a href="http://axkit.org">http://axkit.org</a>), and it returned  within  2  seconds.  I'm
       seriously considering switching my log analysis code to use this little speed demon!

       Oh yeah, and that was with no indexes on the table, on a 400MHz PIII.

       For  best performance be sure to tune your hdparm settings if you are using linux. Also you might want to
       set:

         PRAGMA default_synchronous = OFF

       Which will prevent sqlite from doing fsync's when writing  (which  slows  down  non-transactional  writes
       significantly) at the expense of some peace of mind. Also try playing with the cache_size pragma.

</pre><h4><b>BUGS</b></h4><pre>
       Likely to be many, please use <a href="http://rt.cpan.org/">http://rt.cpan.org/</a> for reporting bugs.

</pre><h4><b>AUTHOR</b></h4><pre>
       Matt Sergeant, <a href="mailto:matt@sergeant.org">matt@sergeant.org</a>

       Perl extension functions contributed by Francis J. Lacoste &lt;<a href="mailto:flacoste@logreport.org">flacoste@logreport.org</a>&gt; and Wolfgang Sourdeau
       &lt;<a href="mailto:wolfgang@logreport.org">wolfgang@logreport.org</a>&gt;.  Maintenance help by Reini Urban &lt;<a href="mailto:rurban@cpan.org">rurban@cpan.org</a>&gt;

</pre><h4><b>LICENSE</b></h4><pre>
       This module is available under the same licences as perl, the Artistic license and the GPL.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       DBD::SQLite, DBI.

perl v5.34.0                                       2022-02-06                                  <u>DBD::<a href="../man3pm/SQLite2.3pm.html">SQLite2</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>