<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mojo::SQLite::Database - Database</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmojo-sqlite-perl">libmojo-sqlite-perl_3.009-2build1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Mojo::SQLite::Database - Database

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Mojo::SQLite::Database;

         my $db = Mojo::SQLite::Database-&gt;new(sqlite =&gt; $sql, dbh =&gt; $dbh);
         $db-&gt;query('select * from foo')
           -&gt;hashes-&gt;map(sub { $_-&gt;{bar} })-&gt;join("\n")-&gt;say;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Mojo::SQLite::Database is a container for DBD::SQLite database handles used by Mojo::SQLite.

</pre><h4><b>ATTRIBUTES</b></h4><pre>
       Mojo::SQLite::Database implements the following attributes.

   <b>dbh</b>
         my $dbh = $db-&gt;dbh;
         $db     = $db-&gt;dbh($dbh);

       DBD::SQLite database handle used for all queries.

         # Use DBI utility methods
         my $quoted = $db-&gt;dbh-&gt;quote_identifier('foo.bar');

   <b>results_class</b>
         my $class = $db-&gt;results_class;
         $db       = $db-&gt;results_class('MyApp::Results');

       Class to be used by "query", defaults to Mojo::SQLite::Results. Note that this class needs to have
       already been loaded before "query" is called.

   <b>sqlite</b>
         my $sql = $db-&gt;sqlite;
         $db     = $db-&gt;sqlite(Mojo::SQLite-&gt;new);

       Mojo::SQLite object this database belongs to.

</pre><h4><b>METHODS</b></h4><pre>
       Mojo::SQLite::Database inherits all methods from Mojo::Base and implements the following new ones.

   <b>begin</b>
         my $tx = $db-&gt;begin;
         my $tx = $db-&gt;begin('exclusive');

       Begin transaction and return Mojo::SQLite::Transaction object, which will automatically roll back the
       transaction unless "commit" in Mojo::SQLite::Transaction has been called before it is destroyed.

         # Insert rows in a transaction
         eval {
           my $tx = $db-&gt;begin;
           $db-&gt;insert('frameworks', {name =&gt; 'Catalyst'});
           $db-&gt;insert('frameworks', {name =&gt; 'Mojolicious'});
           $tx-&gt;commit;
         };
         say $@ if $@;

       A transaction locking behavior of "deferred", "immediate", or "exclusive" may optionally be passed; the
       default in DBD::SQLite is currently "immediate". See "Transaction and Database Locking" in DBD::SQLite
       and &lt;https://sqlite.org/lang_transaction.html&gt; for more details.

   <b>delete</b>
         my $results = $db-&gt;delete($table, \%where);

       Generate a "DELETE" statement with "abstract" in Mojo::SQLite (usually an SQL::Abstract::Pg object) and
       execute it with "query". You can also append a callback for API compatibility with Mojo::Pg; the query is
       still executed in a blocking manner.

         $db-&gt;delete(some_table =&gt; sub ($db, $err, $results) {
           ...
         });
         Mojo::IOLoop-&gt;start unless Mojo::IOLoop-&gt;is_running;

       Use all the same argument variations you would pass to the "delete" method of SQL::Abstract.

         # "delete from some_table"
         $db-&gt;delete('some_table');

         # "delete from some_table where foo = 'bar'"
         $db-&gt;delete('some_table', {foo =&gt; 'bar'});

         # "delete from some_table where foo like '%test%'"
         $db-&gt;delete('some_table', {foo =&gt; {-like =&gt; '%test%'}});

   <b>delete_p</b>
         my $promise = $db-&gt;delete_p($table, \%where, \%options);

       Same as "delete" but returns a Mojo::Promise object instead of accepting a callback. For API
       compatibility with Mojo::Pg; the query is still executed in a blocking manner.

         $db-&gt;delete_p('some_table')-&gt;then(sub ($results) {
           ...
         })-&gt;catch(sub ($err) {
           ...
         })-&gt;wait;

   <b>disconnect</b>
         $db-&gt;disconnect;

       Disconnect "dbh" and prevent it from getting reused.

   <b>insert</b>
         my $results = $db-&gt;insert($table, \@values || \%fieldvals, \%options);

       Generate an "INSERT" statement with "abstract" in Mojo::SQLite (usually an SQL::Abstract::Pg object) and
       execute it with "query". You can also append a callback for API compatibility with Mojo::Pg; the query is
       still executed in a blocking manner.

         $db-&gt;insert(some_table =&gt; {foo =&gt; 'bar'} =&gt; sub ($db, $err, $results) {
           ...
         });
         Mojo::IOLoop-&gt;start unless Mojo::IOLoop-&gt;is_running;

       Use all the same argument variations you would pass to the "insert" method of SQL::Abstract.

         # "insert into some_table (foo, baz) values ('bar', 'yada')"
         $db-&gt;insert('some_table', {foo =&gt; 'bar', baz =&gt; 'yada'});

   <b>insert_p</b>
         my $promise = $db-&gt;insert_p($table, \@values || \%fieldvals, \%options);

       Same as "insert" but returns a Mojo::Promise object instead of accepting a callback. For API
       compatibility with Mojo::Pg; the query is still executed in a blocking manner.

         $db-&gt;insert_p(some_table =&gt; {foo =&gt; 'bar'})-&gt;then(sub ($results) {
           ...
         })-&gt;catch(sub ($err) {
           ...
         })-&gt;wait;

   <b>ping</b>
         my $bool = $db-&gt;ping;

       Check database connection.

   <b>query</b>
         my $results = $db-&gt;query('select * from foo');
         my $results = $db-&gt;query('insert into foo values (?, ?, ?)', @values);
         my $results = $db-&gt;query('select ? as img', {type =&gt; SQL_BLOB, value =&gt; slurp 'img.jpg'});
         my $results = $db-&gt;query('select ? as foo', {json =&gt; {bar =&gt; 'baz'}});

       Execute a blocking SQL &lt;<a href="http://www.postgresql.org/docs/current/static/sql.html">http://www.postgresql.org/docs/current/static/sql.html</a>&gt; statement and return a
       results object based on "results_class" (which is usually Mojo::SQLite::Results) with the query results.
       The DBD::SQLite statement handle will be automatically reused when it is not active anymore, to increase
       the performance of future queries. You can also append a callback for API compatibility with Mojo::Pg;
       the query is still executed in a blocking manner.

         $db-&gt;query('insert into foo values (?, ?, ?)' =&gt; @values =&gt; sub ($db, $err, $results) {
           ...
         });
         Mojo::IOLoop-&gt;start unless Mojo::IOLoop-&gt;is_running;

       Hash reference arguments containing "type" and "value" elements will use the specified bind type for the
       parameter, using types from "DBI Constants" in DBI; see "Blobs" in DBD::SQLite and the subsequent section
       for more information.

       Hash reference arguments containing a value named "json" or "-json" will be encoded to JSON text
       &lt;<a href="http://sqlite.org/json1.html">http://sqlite.org/json1.html</a>&gt; with "to_json" in Mojo::JSON. To accomplish the reverse, you can use the
       method "expand" in Mojo::SQLite::Results to decode JSON text fields to Perl values with "from_json" in
       Mojo::JSON.

         # "I ♥ SQLite!"
         $db-&gt;query('select ? as foo', {json =&gt; {bar =&gt; 'I ♥ SQLite!'}})
           -&gt;expand(json =&gt; 'foo')-&gt;hash-&gt;{foo}{bar};

   <b>query_p</b>
         my $promise = $db-&gt;query_p('SELECT * FROM foo');

       Same as "query" but returns a Mojo::Promise object instead of accepting a callback. For API compatibility
       with Mojo::Pg; the query is still executed in a blocking manner.

         $db-&gt;query_p('INSERT INTO foo VALUES (?, ?, ?)' =&gt; @values)-&gt;then(sub ($results) {
           ...
         })-&gt;catch(sub ($err) {
           ...
         })-&gt;wait;

   <b>select</b>
         my $results = $db-&gt;select($source, $fields, $where, $order);

       Generate a "SELECT" statement with "abstract" in Mojo::SQLite (usually an SQL::Abstract::Pg object) and
       execute it with "query". You can also append a callback for API compatibility with Mojo::Pg; the query is
       still executed in a blocking manner.

         $db-&gt;select(some_table =&gt; ['foo'] =&gt; {bar =&gt; 'yada'} =&gt; sub ($db, $err, $results) {
           ...
         });
         Mojo::IOLoop-&gt;start unless Mojo::IOLoop-&gt;is_running;

       Use all the same argument variations you would pass to the "select" method of SQL::Abstract.

         # "select * from some_table"
         $db-&gt;select('some_table');

         # "select id, foo from some_table"
         $db-&gt;select('some_table', ['id', 'foo']);

         # "select * from some_table where foo = 'bar'"
         $db-&gt;select('some_table', undef, {foo =&gt; 'bar'});

         # "select * from some_table where foo = 'bar' order by id desc"
         $db-&gt;select('some_table', undef, {foo =&gt; 'bar'}, {-desc =&gt; 'id'});

         # "select * from some_table where foo like '%test%'"
         $db-&gt;select('some_table', undef, {foo =&gt; {-like =&gt; '%test%'}});

   <b>select_p</b>
         my $promise = $db-&gt;select_p($source, $fields, $where, \%options);

       Same as "select" but returns a Mojo::Promise object instead of accepting a callback. For API
       compatibility with Mojo::Pg; the query is still executed in a blocking manner.

         $db-&gt;select_p(some_table =&gt; ['foo'] =&gt; {bar =&gt; 'yada'})-&gt;then(sub ($results) {
           ...
         })-&gt;catch(sub ($err) {
           ...
         })-&gt;wait;

   <b>tables</b>
         my $tables = $db-&gt;tables;

       Return table and view names for this database, that are visible to the current user and not internal, as
       an array reference. Names will be quoted and prefixed by a schema name of "main" for standard tables,
       "temp" for temporary tables, and the appropriate schema name for attached databases
       &lt;<a href="http://sqlite.org/lang_attach.html">http://sqlite.org/lang_attach.html</a>&gt;.

         # Names of all tables
         say for @{$db-&gt;tables};

   <b>update</b>
         my $results = $db-&gt;update($table, \%fieldvals, \%where);

       Generate an "UPDATE" statement with "abstract" in Mojo::SQLite (usually an SQL::Abstract::Pg object) and
       execute it with "query". You can also append a callback for API compatibility with Mojo::Pg; the query is
       still executed in a blocking manner.

         $db-&gt;update(some_table =&gt; {foo =&gt; 'baz'} =&gt; {foo =&gt; 'bar'} =&gt; sub ($db, $err, $results) {
           ...
         });
         Mojo::IOLoop-&gt;start unless Mojo::IOLoop-&gt;is_running;

       Use all the same argument variations you would pass to the "update" method of SQL::Abstract.

         # "update some_table set foo = 'bar' where id = 23"
         $db-&gt;update('some_table', {foo =&gt; 'bar'}, {id =&gt; 23});

         # "update some_table set foo = 'bar' where foo like '%test%'"
         $db-&gt;update('some_table', {foo =&gt; 'bar'}, {foo =&gt; {-like =&gt; '%test%'}});

   <b>update_p</b>
         my $promise = $db-&gt;update_p($table, \%fieldvals, \%where, \%options);

       Same as "update" but returns a Mojo::Promise object instead of accepting a callback. For API
       compatibility with Mojo::Pg; the query is still executed in a blocking manner.

         $db-&gt;update_p(some_table =&gt; {foo =&gt; 'baz'} =&gt; {foo =&gt; 'bar'})-&gt;then(sub ($results) {
           ...
         })-&gt;catch(sub ($err) {
           ...
         })-&gt;wait;

</pre><h4><b>BUGS</b></h4><pre>
       Report any issues on the public bugtracker.

</pre><h4><b>AUTHOR</b></h4><pre>
       Dan Book, "<a href="mailto:dbook@cpan.org">dbook@cpan.org</a>"

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright 2015, Dan Book.

       This library is free software; you may redistribute it and/or modify it under the terms of the Artistic
       License version 2.0.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Mojo::SQLite

perl v5.40.1                                       2025-02-18                        <u>Mojo::SQLite::<a href="../man3pm/Database.3pm.html">Database</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>