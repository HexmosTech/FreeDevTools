<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>fcft_from_name - instantiate a new font</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libfcft-doc">libfcft-doc_3.3.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       fcft_from_name - instantiate a new font

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;fcft/fcft.h&gt;</b>

       <b>struct</b> <b>fcft_font</b> <b>*fcft_from_name(</b>
           <b>size_t</b> <u>count</u><b>,</b> <b>const</b> <b>char</b> <b>*</b><u>names</u><b>[static</b> <u>count</u><b>],</b> <b>const</b> <b>char</b> <b>*</b><u>attributes</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>fcft_from_name</b>()  instantiates a new fcft font object from the FontConfig formatted font names. The first
       element in <u>names</u> is the primary font, and the remaining elements (if any) are fallback fonts.

       You <b>must</b> supply at least one font name.

       All aspects of the font (size, DPI, variant etc) are  configured  through  the  font  <u>name</u>,  using  colon
       separated <b>attribute=value</b> pairs (e.g. <b>"Serif:size=26:slant=italic"</b>).

       <u>attributes</u>  is  a  convenient  way  to apply a set of attributes to all fonts in <u>names</u>. <u>attributes</u> may be
       NULL, in which case no extra attributes are appended to the strings in <u>names</u>.

       The font size is set as part of the font name: e.g. <b>Helvetica:size=12</b>, or <b>Helvetica:pixelsize=12</b>.

       To implement desktop scaling, simply multiply the font's size with the desktop scaling factor.

       The primary font will be instantiated immediately, and any failure to do so  will  result  in  an  error.
       Fallback fonts are instantiated on demand, and any failure to do so will result in the that fallback font
       being ignored, and the next one in the list is tried instead.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On  success,  <b>fcft_from_name</b>()  returns  a  pointer  to  an allocated <b>fcft_font</b> object. On error, NULL is
       returned.

           struct fcft_font {
               int height;
               int descent;
               int ascent;

               struct {
                   int x;
                   int y;
               } max_advance;

               struct {
                   int x;
                   int y;
               } space_advance;

               struct {
                   int position;
                   int thickness;
               } underline;

               struct {
                   int position;
                   int thickness;
               } strikeout;
           };

       <u>height</u> is the line height, in pixels.

       <u>descent</u> is the distance between the baseline and the font's lowest descending glyph, in pixels. In fcft's
       case, it is generally positive (a negative value means the <u>descent</u> stretches <b>up</b> from the baseline).

       <u>ascent</u> is the distance between the baseline and the font's highest ascending glyph, in pixels.  Generally
       a positive number (a negative value means the <u>ascent</u> stretches <b>down</b> below the baseline).

       <u>ascent</u> + <u>descent</u> is often the same as <u>height</u>, but not necessarily. <u>height</u> may be larger, meaning the font
       intentionally  adds  extra  (vertical)  space  between  lines.  Or it may be smaller, in which case lines
       overlap.

       <u>max_advance</u> is the amount, in pixels, the font's  widest  glyph  advances  the  pen  position;  <u>x</u>  for  a
       horizontal layout, and <u>y</u> for a vertical layout.

       <u>space_advance</u>  is  the  amount,  in pixels, the glyph for <b>space</b> (0x20) advances the pen position; <u>x</u> for a
       horizontal layout, and <u>y</u> for a vertical layout.

       <u>underline</u> describes how to render underlines. <u>position</u> is the distance, in pixels, from the  baseline.  A
       positive  value means <b>above</b> the baseline, and a negative value means <b>below</b> the baseline. <u>thickness</u> is the
       line's thickness, in pixels.

       <u>strikeout</u> describes how to render strikeouts. See <u>underline</u> for a description of its members.

</pre><h4><b>EXAMPLE</b></h4><pre>
       In this example, we instantiate <u>Times</u> <u>New</u> <u>Roman</u> at a point size of 8 as the primary font.

       We also tell it to use <u>Serif</u> <u>Bold</u> (point size 10) as a fallback font (note that it is usually  better  to
       let FontConfig handle fallback to generic fonts like this).

       Furthermore, both fonts will be <u>Italic</u>, and will be using DPI=140.

       We  then proceed to render the string <u>hello</u> <u>world</u>. You are assumed to know how to create and use a pixman
       image. This example only shows how one can use fcft to instantiate a  font,  rasterize  glyphs  and  then
       blend them onto a target pixman image.

           #include &lt;<a href="file:/usr/include/stdlib.h">stdlib.h</a>&gt;
           #include &lt;<a href="file:/usr/include/uchar.h">uchar.h</a>&gt;
           #include &lt;fcft/fcft.h&gt;

           int
           main(void)
           {
               setlocale(LC_CTYPE, "en_US.UTF-8");

               if (!fcft_set_scaling_filter(FCFT_SCALING_FILTER_LANCZOS3))
                  return EXIT_FAILURE;

               struct fcft_font *font = fcft_from_name(
                   2,
                   (const char *[]){
                       "Times New Roman:size=8",
                       "Serif:size=10:weight=bold",
                   },
                   "slant=italic:dpi=140");

               if (font == NULL)
                   return EXIT_FAILURE;

               /* Here you need to instantiate a 'target' pixman image, to blend
                  with */
               pixman_image_t *canvas = ...;

               /* String to print */
               static const char32_t const hello[] = U"hello world";

               /*
                * Pen position in canvas. The numbers chosen here are more or less
                * random. Note however, that the composite calls below assume 'y'
                * is the font's baseline (and thus the glyphs will be rendered
                * above 'y')
                */
               struct {
                   int x;
                   int y;
               } pen = {.x = 25, .y = 50};

               /* Glyphs will be rendered in white */
               pixman_image_t *color = pixman_image_create_solid_fill(
                   &amp;(struct pixman_color_t){
                       .red = 0xffff,
                       .green = 0xffff,
                       .blue = 0xffff,
                       .alpha = 0xffff,
                   });

               for (size_t i = 0; i &lt; sizeof(hello) / sizeof(hello[0]) - 1; i++) {
                   const struct fcft_glyph *glyph = fcft_codepoint_rasterize(
                       font, hello[i], FCFT_SUBPIXEL_DEFAULT);

                   if (glyph == NULL)
                       continue;

                   /* Kerning */
                   long x_kern = 0;
                   if (i &gt; 0) {
                       fcft_kerning(font, hello[i - 1], hello[i], &amp;x_kern, NULL);

                   pen.x += x_kern;

                   if (glyph-&gt;is_color_glyph) {
                       /* Glyph is a pre-rendered image; typically a color emoji */
                       pixman_image_composite32(
                           PIXMAP_OP_OVER, glyph-&gt;pix, NULL, canvas, 0, 0, 0, 0,
                           pen.x + glyph-&gt;x, pen.y + font-&gt;ascent - glyph-&gt;y,
                           glyph-&gt;width, glyph-&gt;height);
                   }

                   else {
                       /* Glyph is an alpha mask */
                       pixman_image_composite32(
                           PIXMAN_OP_OVER, color, glyph-&gt;pix, canvas, 0, 0, 0, 0,
                           pen.x + glyph-&gt;x, pen.y + font-&gt;ascent - glyph-&gt;y,
                           glyph-&gt;width, glyph-&gt;height);
                   }

                   /* Advance pen position */
                   pen.x += glyph-&gt;advance.x;
               }

               pixman_image_unref(src);

               fcft_destroy(font);
               return EXIT_SUCCESS;
           }

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b>fcft_from_name2</b>(), <b>fcft_clone</b>(), <b>fcft_destroy</b>(), <b>fcft_codepoint_rasterize</b>(), <b>fcft_kerning</b>()

3.3.1                                              2025-03-22                                  <u><a href="../man3/fcft_from_name.3.html">fcft_from_name</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>