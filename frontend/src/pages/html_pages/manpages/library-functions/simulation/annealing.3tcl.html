<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>simulation::annealing - Simulated annealing</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcllib">tcllib_2.0+dfsg-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       simulation::annealing - Simulated annealing

</pre><h4><b>SYNOPSIS</b></h4><pre>
       package require <b>Tcl</b> <b>?8.5</b> <b>9?</b>

       package require <b>simulation::annealing</b> <b>0.3</b>

       <b>::simulation::annealing::getOption</b> <u>keyword</u>

       <b>::simulation::annealing::hasOption</b> <u>keyword</u>

       <b>::simulation::annealing::setOption</b> <u>keyword</u> <u>value</u>

       <b>::simulation::annealing::findMinimum</b> <u>args</u>

       <b>::simulation::annealing::findCombinatorialMinimum</b> <u>args</u>

________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The technique of <u>simulated</u> <u>annealing</u> provides methods to estimate the global optimum of a function. It is
       described in some detail on the Wiki <u><a href="http://wiki.tcl.tk/">http://wiki.tcl.tk/</a>...</u>. The idea is simple:

       •      randomly select points within a given search space

       •      evaluate  the  function to be optimised for each of these points and select the point that has the
              lowest (or highest) function value or - sometimes - accept a point that has a less optimal  value.
              The chance by which such a non-optimal point is accepted diminishes over time.

       •      Accepting  less  optimal points means the method does not necessarily get stuck in a local optimum
              and theoretically it is capable of finding the global optimum within the search space.

       The method resembles the cooling of material, hence the name.

       The package <u>simulation::annealing</u> offers the command <u>findMinimum</u>:

                  puts [::simulation::annealing::findMinimum  -trials 300  -parameters {x -5.0 5.0 y -5.0 5.0}  -function {$x*$x+$y*$y+sin(10.0*$x)+4.0*cos(20.0*$y)}]

       prints the estimated minimum value of the  function  f(x,y)  =  <u>x**2+y**2+sin(10*x)+4*cos(20*y)</u>  and  the
       values of x and y where the minimum was attained:

              result -4.9112922923 x -0.181647676593 y 0.155743646974

</pre><h4><b>PROCEDURES</b></h4><pre>
       The package defines the following auxiliary procedures:

       <b>::simulation::annealing::getOption</b> <u>keyword</u>
              Get the value of an option given as part of the <u>findMinimum</u> command.

              string <u>keyword</u>
                     Given keyword (without leading minus)

       <b>::simulation::annealing::hasOption</b> <u>keyword</u>
              Returns 1 if the option is available, 0 if not.

              string <u>keyword</u>
                     Given keyword (without leading minus)

       <b>::simulation::annealing::setOption</b> <u>keyword</u> <u>value</u>
              Set the value of the given option.

              string <u>keyword</u>
                     Given keyword (without leading minus)

              string <u>value</u>
                     (New) value for the option

       The main procedures are <u>findMinimum</u> and <u>findCombinatorialMinimum</u>:

       <b>::simulation::annealing::findMinimum</b> <u>args</u>
              Find the minimum of a function using simulated annealing. The function and the method's parameters
              is given via a list of keyword-value pairs.

              int <u>n</u>  List  of  keyword-value  pairs,  all  of  which  are available during the execution via the
                     <u>getOption</u> command.

       <b>::simulation::annealing::findCombinatorialMinimum</b> <u>args</u>
              Find the minimum of a function of discrete variables using simulated annealing. The  function  and
              the method's parameters is given via a list of keyword-value pairs.

              int <u>n</u>  List  of  keyword-value  pairs,  all  of  which  are available during the execution via the
                     <u>getOption</u> command.

       The <u>findMinimum</u> command predefines the following options:

       •      <u>-parameters</u> <u>list</u>: triples defining parameters and ranges

       •      <u>-function</u> <u>expr</u>: expression defining the function

       •      <u>-code</u> <u>body</u>: body of code to define the function (takes precedence over <u>-function</u>). The code should
              set the variable "result"

       •      <u>-init</u> <u>code</u>: code to be run at start up <u>-final</u> <u>code</u>: code to be run at the end <u>-trials</u> <u>n</u>: number of
              trials before reducing the temperature <u>-reduce</u> <u>factor</u>:  reduce  the  temperature  by  this  factor
              (between  0  and 1) <u>-initial-temp</u> <u>t</u>: initial temperature <u>-scale</u> <u>s</u>: scale of the function (order of
              magnitude of the values) <u>-estimate-scale</u> <u>y/n</u>: estimate the scale (only if <u>-scale</u> is  not  present)
              <u>-verbose</u> <u>y/n</u>: print detailed information on progress to the report file (1) or not (0) <u>-reportfile</u>
              <u>file</u>: opened file to print to (defaults to stdout)

       Any  other  options  can  be  used via the getOption procedure in the body.  The <u>findCombinatorialMinimum</u>
       command predefines the following options:

       •      <u>-number-params</u> <u>n</u>: number of binary parameters (the solution space consists of lists of 1s and 0s).
              This is a required option.

       •      <u>-initial-values</u>: list of 1s and 0s constituting the start of the search.

       The other predefined options are identical to those of <u>findMinimum</u>.

</pre><h4><b>TIPS</b></h4><pre>
       The procedure <u>findMinimum</u> works by constructing a temporary procedure that does the actual work. It loops
       until the point representing the estimated optimum does not change anymore within  the  given  number  of
       trials.  As  the  temperature  gets  lower  and lower the chance of accepting a point with a higher value
       becomes lower too, so the procedure will in practice terminate.

       It is possible to optimise over a non-rectangular region, but some care must be taken:

       •      If the point is outside the region of interest, you can specify a very high value.

       •      This does mean that the automatic determination of a scale factor is out of  the  question  -  the
              high function values that force the point inside the region would distort the estimation.

       Here is an example of finding an optimum inside a circle:

                  puts [::simulation::annealing::findMinimum  -trials 3000  -reduce 0.98  -parameters {x -5.0 5.0 y -5.0 5.0}  -code {
                          if { hypot($x-5.0,$y-5.0) &lt; 4.0 } {
                              set result [expr {$x*$x+$y*$y+sin(10.0*$x)+4.0*cos(20.0*$y)}]
                          } else {
                              set result 1.0e100
                          }
                      }]

       The  method is theoretically capable of determining the global optimum, but often you need to use a large
       number of trials and a slow reduction of temperature to get reliable and repeatable estimates.

       You can use the <u>-final</u> option to use a deterministic optimization method, once you are sure you are  near
       the required optimum.

       The <u>findCombinatorialMinimum</u> procedure is suited for situations where the parameters have the values 0 or
       1 (and there can be many of them). Here is an example:

       •      We have a function that attains an absolute minimum if the first ten numbers are 1 and the rest is
              0:

              proc cost {params} {
                  set cost 0
                  foreach p [lrange $params 0 9] {
                      if { $p == 0 } {
                          incr cost
                      }
                  }
                  foreach p [lrange $params 10 end] {
                      if { $p == 1 } {
                          incr cost
                      }
                  }
                  return $cost
              }

       •      We  want  to  find the solution that gives this minimum for various lengths of the solution vector
              <u>params</u>:

              foreach n {100 1000 10000} {
                  break
                  puts "Problem size: $n"
                  puts [::simulation::annealing::findCombinatorialMinimum  -trials 300  -verbose 0  -number-params $n  -code {set result [cost $params]}]
              }

       •      As the vector grows, the computation time increases, but the procedure will stop if some  kind  of
              equilibrium  is  reached. To achieve a useful solution you may want to try different values of the
              trials parameter for instance. Also ensure that the function to be minimized  depends  on  all  or
              most parameters - see the source code for a counter example and run that.

</pre><h4><b>KEYWORDS</b></h4><pre>
       math, optimization, simulated annealing

</pre><h4><b>CATEGORY</b></h4><pre>
       Mathematics

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2008 Arjen Markus &lt;<a href="mailto:arjenmarkus@users.sourceforge.net">arjenmarkus@users.sourceforge.net</a>&gt;

tcllib                                                 0.3                           <u>simulation::<a href="../man3tcl/annealing.3tcl.html">annealing</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>