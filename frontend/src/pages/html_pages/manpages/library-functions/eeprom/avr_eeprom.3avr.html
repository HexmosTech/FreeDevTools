<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>avr_eeprom - <avr/eeprom.h>: EEPROM handling</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/avr-libc">avr-libc_2.2.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       avr_eeprom - &lt;avr/eeprom.h&gt;: EEPROM handling

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Macros</b>
       #define <b>EEMEM</b>   __attribute__((__section__('.eeprom')))
       #define <b>eeprom_is_ready</b>()
       #define <b>eeprom_busy_wait</b>()   do {} while (!<b>eeprom_is_ready</b>())

   <b>Functions</b>
       <b>uint8_t</b> <b>eeprom_read_byte</b> (const <b>uint8_t</b> *__p)
       <b>uint16_t</b> <b>eeprom_read_word</b> (const <b>uint16_t</b> *__p)
       <b>uint32_t</b> <b>eeprom_read_dword</b> (const <b>uint32_t</b> *__p)
       <b>uint64_t</b> <b>eeprom_read_qword</b> (const <b>uint64_t</b> *__p)
       float <b>eeprom_read_float</b> (const float *__p)
       double <b>eeprom_read_double</b> (const double *__p)
       long double <b>eeprom_read_long_double</b> (const long double *__p)
       void <b>eeprom_read_block</b> (void *__dst, const void *__src, size_t __n)
       void <b>eeprom_write_byte</b> (<b>uint8_t</b> *__p, <b>uint8_t</b> __value)
       void <b>eeprom_write_word</b> (<b>uint16_t</b> *__p, <b>uint16_t</b> __value)
       void <b>eeprom_write_dword</b> (<b>uint32_t</b> *__p, <b>uint32_t</b> __value)
       void <b>eeprom_write_qword</b> (<b>uint64_t</b> *__p, <b>uint64_t</b> __value)
       void <b>eeprom_write_float</b> (float *__p, float __value)
       void <b>eeprom_write_double</b> (double *__p, double __value)
       void <b>eeprom_write_long_double</b> (long double *__p, long double __value)
       void <b>eeprom_write_block</b> (const void *__src, void *__dst, size_t __n)
       void <b>eeprom_update_byte</b> (<b>uint8_t</b> *__p, <b>uint8_t</b> __value)
       void <b>eeprom_update_word</b> (<b>uint16_t</b> *__p, <b>uint16_t</b> __value)
       void <b>eeprom_update_dword</b> (<b>uint32_t</b> *__p, <b>uint32_t</b> __value)
       void <b>eeprom_update_qword</b> (<b>uint64_t</b> *__p, <b>uint64_t</b> __value)
       void <b>eeprom_update_float</b> (float *__p, float __value)
       void <b>eeprom_update_double</b> (double *__p, double __value)
       void <b>eeprom_update_long_double</b> (long double *__p, long double __value)
       void <b>eeprom_update_block</b> (const void *__src, void *__dst, size_t __n)

   <b>IAR</b> <b>C</b> <b>compatibility</b> <b>defines</b>
       #define <b>_EEPUT</b>(addr,  val)   <b>eeprom_write_byte</b> ((<b>uint8_t</b> *)(addr), (<b>uint8_t</b>)(val))
       #define <b>__EEPUT</b>(addr,  val)   <b>eeprom_write_byte</b> ((<b>uint8_t</b> *)(addr), (<b>uint8_t</b>)(val))
       #define <b>_EEGET</b>(var,  addr)   (var) = <b>eeprom_read_byte</b> ((const <b>uint8_t</b> *)(addr))
       #define <b>__EEGET</b>(var,  addr)   (var) = <b>eeprom_read_byte</b> ((const <b>uint8_t</b> *)(addr))

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       #include &lt;avr/eeprom.h&gt;

       This header file declares the interface to some simple library routines suitable for handling the data
       EEPROM contained in the AVR microcontrollers. The implementation uses a simple polled mode interface.
       Applications that require interrupt-controlled EEPROM access to ensure that no time will be wasted in
       spinloops will have to deploy their own implementation.

       <b>Notes:</b>

       • In  addition  to the write functions there is a set of update ones. This functions read each byte first
         and skip the burning if the old value is the same with new. The scaning direction is from high  address
         to low, to obtain quick return in common cases.

       • All  of  the  read/write  functions  first make sure the EEPROM is ready to be accessed. Since this may
         cause long delays if a write operation is still pending, time-critical applications should  first  poll
         the  EEPROM e. g. using <b>eeprom_is_ready()</b> before attempting any actual I/O. But this functions does not
         wait until SELFPRGEN in SPMCSR becomes zero. Do this manually, if  your  softwate  contains  the  Flash
         burning.

       • As  these  functions modify IO registers, they are known to be non-reentrant. If any of these functions
         are used from both, standard and interrupt context, the  applications  must  ensure  proper  protection
         (e.g. by disabling interrupts before accessing them).

       • All write functions force erase_and_write programming mode.

       • For Xmega the EEPROM start address is 0, like other architectures. The reading functions add the 0x2000
         value to use EEPROM mapping into data space.

</pre><h4><b>Macro</b> <b>Definition</b> <b>Documentation</b></h4><pre>
   <b>#define</b> <b>__EEGET(var,</b> <b>addr)</b>   <b>(var)</b> <b>=</b> <b>eeprom_read_byte</b> <b>((const</b> <b>uint8_t</b> <b>*)(addr))</b>
       Read a byte from EEPROM. Compatibility define for IAR C.

   <b>#define</b> <b>__EEPUT(addr,</b> <b>val)</b>   <b>eeprom_write_byte</b> <b>((uint8_t</b> <b>*)(addr),</b> <b>(uint8_t)(val))</b>
       Write a byte to EEPROM. Compatibility define for IAR C.

   <b>#define</b> <b>_EEGET(var,</b> <b>addr)</b>   <b>(var)</b> <b>=</b> <b>eeprom_read_byte</b> <b>((const</b> <b>uint8_t</b> <b>*)(addr))</b>
       Read a byte from EEPROM. Compatibility define for IAR C.

   <b>#define</b> <b>_EEPUT(addr,</b> <b>val)</b>   <b>eeprom_write_byte</b> <b>((uint8_t</b> <b>*)(addr),</b> <b>(uint8_t)(val))</b>
       Write a byte to EEPROM. Compatibility define for IAR C.

   <b>#define</b> <b>EEMEM</b>   <b>__attribute__((__section__('.eeprom')))</b>
       Attribute expression causing a variable to be allocated within the .eeprom section.

   <b>#define</b> <b>eeprom_busy_wait()</b>   <b>do</b> <b>{}</b> <b>while</b> <b>(!eeprom_is_ready())</b>
       Loops until the eeprom is no longer busy.

       <b>Returns</b>
           Nothing.

   <b>#define</b> <b>eeprom_is_ready()</b>
       <b>Returns</b>
           1 if EEPROM is ready for a new read/write operation, 0 if not.

</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>void</b> <b>eeprom_read_block</b> <b>(void</b> <b>*</b> <b>__dst,</b> <b>const</b> <b>void</b> <b>*</b> <b>__src,</b> <b>size_t</b> <b>__n)</b>
       Read a block of <b>__</b><u>n</u> bytes from EEPROM address <b>__</b><u>src</u> to SRAM <b>__</b><u>dst</u>.

   <b>uint8_t</b> <b>eeprom_read_byte</b> <b>(const</b> <b>uint8_t</b> <b>*</b> <b>__p)</b>
       Read one byte from EEPROM address <b>__</b><u>p</u>.

   <b>double</b> <b>eeprom_read_double</b> <b>(const</b> <b>double</b> <b>*</b> <b>__p)</b>
       Read one double value (little endian) from EEPROM address <b>__</b><u>p</u>.

   <b>uint32_t</b> <b>eeprom_read_dword</b> <b>(const</b> <b>uint32_t</b> <b>*</b> <b>__p)</b>
       Read one 32-bit double word (little endian) from EEPROM address <b>__</b><u>p</u>.

   <b>float</b> <b>eeprom_read_float</b> <b>(const</b> <b>float</b> <b>*</b> <b>__p)</b>
       Read one float value (little endian) from EEPROM address <b>__</b><u>p</u>.

   <b>long</b> <b>double</b> <b>eeprom_read_long_double</b> <b>(const</b> <b>long</b> <b>double</b> <b>*</b> <b>__p)</b>
       Read one long double value (little endian) from EEPROM address <b>__</b><u>p</u>.

   <b>uint64_t</b> <b>eeprom_read_qword</b> <b>(const</b> <b>uint64_t</b> <b>*</b> <b>__p)</b>
       Read one 64-bit quad word (little endian) from EEPROM address <b>__</b><u>p</u>.

   <b>uint16_t</b> <b>eeprom_read_word</b> <b>(const</b> <b>uint16_t</b> <b>*</b> <b>__p)</b>
       Read one 16-bit word (little endian) from EEPROM address <b>__</b><u>p</u>.

   <b>void</b> <b>eeprom_update_block</b> <b>(const</b> <b>void</b> <b>*</b> <b>__src,</b> <b>void</b> <b>*</b> <b>__dst,</b> <b>size_t</b> <b>__n)</b>
       Update a block of <b>__</b><u>n</u> bytes at EEPROM address <b>__</b><u>dst</u> from <b>__</b><u>src</u>.

       <b>Note</b>
           The argument order is mismatch with common functions like strcpy().

   <b>void</b> <b>eeprom_update_byte</b> <b>(uint8_t</b> <b>*</b> <b>__p,</b> <b>uint8_t</b> <b>__value)</b>
       Update a byte <b>__</b><u>value</u> at EEPROM address <b>__</b><u>p</u>.

   <b>void</b> <b>eeprom_update_double</b> <b>(double</b> <b>*</b> <b>__p,</b> <b>double</b> <b>__value)</b>
       Update a double <b>__</b><u>value</u> at EEPROM address <b>__</b><u>p</u>.

   <b>void</b> <b>eeprom_update_dword</b> <b>(uint32_t</b> <b>*</b> <b>__p,</b> <b>uint32_t</b> <b>__value)</b>
       Update a 32-bit double word <b>__</b><u>value</u> at EEPROM address <b>__</b><u>p</u>.

   <b>void</b> <b>eeprom_update_float</b> <b>(float</b> <b>*</b> <b>__p,</b> <b>float</b> <b>__value)</b>
       Update a float <b>__</b><u>value</u> at EEPROM address <b>__</b><u>p</u>.

   <b>void</b> <b>eeprom_update_long_double</b> <b>(long</b> <b>double</b> <b>*</b> <b>__p,</b> <b>long</b> <b>double</b> <b>__value)</b>
       Update a long double <b>__</b><u>value</u> at EEPROM address <b>__</b><u>p</u>.

   <b>void</b> <b>eeprom_update_qword</b> <b>(uint64_t</b> <b>*</b> <b>__p,</b> <b>uint64_t</b> <b>__value)</b>
       Update a 64-bit quad word <b>__</b><u>value</u> at EEPROM address <b>__</b><u>p</u>.

   <b>void</b> <b>eeprom_update_word</b> <b>(uint16_t</b> <b>*</b> <b>__p,</b> <b>uint16_t</b> <b>__value)</b>
       Update a word <b>__</b><u>value</u> at EEPROM address <b>__</b><u>p</u>.

   <b>void</b> <b>eeprom_write_block</b> <b>(const</b> <b>void</b> <b>*</b> <b>__src,</b> <b>void</b> <b>*</b> <b>__dst,</b> <b>size_t</b> <b>__n)</b>
       Write a block of <b>__</b><u>n</u> bytes to EEPROM address <b>__</b><u>dst</u> from <b>__</b><u>src</u>.

       <b>Note</b>
           The argument order is mismatch with common functions like strcpy().

   <b>void</b> <b>eeprom_write_byte</b> <b>(uint8_t</b> <b>*</b> <b>__p,</b> <b>uint8_t</b> <b>__value)</b>
       Write a byte <b>__</b><u>value</u> to EEPROM address <b>__</b><u>p</u>.

   <b>void</b> <b>eeprom_write_double</b> <b>(double</b> <b>*</b> <b>__p,</b> <b>double</b> <b>__value)</b>
       Write a double <b>__</b><u>value</u> to EEPROM address <b>__</b><u>p</u>.

   <b>void</b> <b>eeprom_write_dword</b> <b>(uint32_t</b> <b>*</b> <b>__p,</b> <b>uint32_t</b> <b>__value)</b>
       Write a 32-bit double word <b>__</b><u>value</u> to EEPROM address <b>__</b><u>p</u>.

   <b>void</b> <b>eeprom_write_float</b> <b>(float</b> <b>*</b> <b>__p,</b> <b>float</b> <b>__value)</b>
       Write a float <b>__</b><u>value</u> to EEPROM address <b>__</b><u>p</u>.

   <b>void</b> <b>eeprom_write_long_double</b> <b>(long</b> <b>double</b> <b>*</b> <b>__p,</b> <b>long</b> <b>double</b> <b>__value)</b>
       Write a long double <b>__</b><u>value</u> to EEPROM address <b>__</b><u>p</u>.

   <b>void</b> <b>eeprom_write_qword</b> <b>(uint64_t</b> <b>*</b> <b>__p,</b> <b>uint64_t</b> <b>__value)</b>
       Write a 64-bit quad word <b>__</b><u>value</u> to EEPROM address <b>__</b><u>p</u>.

   <b>void</b> <b>eeprom_write_word</b> <b>(uint16_t</b> <b>*</b> <b>__p,</b> <b>uint16_t</b> <b>__value)</b>
       Write a word <b>__</b><u>value</u> to EEPROM address <b>__</b><u>p</u>.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for AVR-LibC from the source code.

AVR-LibC                                          Version 2.2.1                                 <u><a href="../man3avr/avr_eeprom.3avr.html">avr_eeprom</a></u>(3avr)
</pre>
 </div>
</div></section>
</div>
</body>
</html>