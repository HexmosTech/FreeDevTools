<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SGIextensions - SGI</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libstdc++-13-doc">libstdc++-13-doc_13.4.0-1ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       SGIextensions - SGI

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Classes</b>
       class <b>__gnu_cxx::binary_compose&lt;</b> <b>_Operation1,</b> <b>_Operation2,</b> <b>_Operation3</b> <b>&gt;</b>
           An <b>SGI</b> <b>extension</b> .
       struct <b>__gnu_cxx::constant_binary_fun&lt;</b> <b>_Result,</b> <b>_Arg1,</b> <b>_Arg2</b> <b>&gt;</b>
           An <b>SGI</b> <b>extension</b> .
       struct <b>__gnu_cxx::constant_unary_fun&lt;</b> <b>_Result,</b> <b>_Argument</b> <b>&gt;</b>
           An <b>SGI</b> <b>extension</b> .
       struct <b>__gnu_cxx::constant_void_fun&lt;</b> <b>_Result</b> <b>&gt;</b>
           An <b>SGI</b> <b>extension</b> .
       class <b>__gnu_cxx::hash_map&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_HashFn,</b> <b>_EqualKey,</b> <b>_Alloc</b> <b>&gt;</b>
       class <b>__gnu_cxx::hash_multimap&lt;</b> <b>_Key,</b> <b>_Tp,</b> <b>_HashFn,</b> <b>_EqualKey,</b> <b>_Alloc</b> <b>&gt;</b>
       class <b>__gnu_cxx::hash_multiset&lt;</b> <b>_Value,</b> <b>_HashFcn,</b> <b>_EqualKey,</b> <b>_Alloc</b> <b>&gt;</b>
       class <b>__gnu_cxx::hash_set&lt;</b> <b>_Value,</b> <b>_HashFcn,</b> <b>_EqualKey,</b> <b>_Alloc</b> <b>&gt;</b>
       struct <b>__gnu_cxx::project1st&lt;</b> <b>_Arg1,</b> <b>_Arg2</b> <b>&gt;</b>
           An <b>SGI</b> <b>extension</b> .
       struct <b>__gnu_cxx::project2nd&lt;</b> <b>_Arg1,</b> <b>_Arg2</b> <b>&gt;</b>
           An <b>SGI</b> <b>extension</b> .
       struct <b>__gnu_cxx::rb_tree&lt;</b> <b>_Key,</b> <b>_Value,</b> <b>_KeyOfValue,</b> <b>_Compare,</b> <b>_Alloc</b> <b>&gt;</b>
       class <b>__gnu_cxx::rope&lt;</b> <b>_CharT,</b> <b>_Alloc</b> <b>&gt;</b>
       struct <b>__gnu_cxx::select1st&lt;</b> <b>_Pair</b> <b>&gt;</b>
           An <b>SGI</b> <b>extension</b> .
       struct <b>__gnu_cxx::select2nd&lt;</b> <b>_Pair</b> <b>&gt;</b>
           An <b>SGI</b> <b>extension</b> .
       class <b>__gnu_cxx::slist&lt;</b> <b>_Tp,</b> <b>_Alloc</b> <b>&gt;</b>
       class <b>__gnu_cxx::subtractive_rng</b>
       struct <b>__gnu_cxx::temporary_buffer&lt;</b> <b>_ForwardIterator,</b> <b>_Tp</b> <b>&gt;</b>
       class <b>__gnu_cxx::unary_compose&lt;</b> <b>_Operation1,</b> <b>_Operation2</b> <b>&gt;</b>
           An <b>SGI</b> <b>extension</b> .

   <b>Functions</b>
       template&lt;typename _Tp &gt; const _Tp &amp; <b>__gnu_cxx::__median</b> (const _Tp &amp;__a, const _Tp &amp;__b, const _Tp &amp;__c)
           Find the median of three values.
       template&lt;typename _Tp , typename _Compare &gt; const _Tp &amp; <b>__gnu_cxx::__median</b> (const _Tp &amp;__a, const _Tp
           &amp;__b, const _Tp &amp;__c, _Compare __comp)
           Find the median of three values using a predicate for comparison.
       constexpr size_t <b>std::bitset&lt;</b> <b>_Nb</b> <b>&gt;::_Find_first</b> () const noexcept
           Finds the index of the first 'on' bit.
       constexpr size_t <b>std::bitset&lt;</b> <b>_Nb</b> <b>&gt;::_Find_next</b> (size_t <b>__prev</b>) const noexcept
           Finds the index of the next 'on' bit after prev.
       template&lt;class _Operation1 , class _Operation2 &gt; <b>unary_compose</b>&lt; _Operation1, _Operation2 &gt;
           <b>__gnu_cxx::compose1</b> (const _Operation1 &amp;__fn1, const _Operation2 &amp;__fn2)
           An <b>SGI</b> <b>extension</b> .
       template&lt;class _Operation1 , class _Operation2 , class _Operation3 &gt; <b>binary_compose</b>&lt; _Operation1,
           _Operation2, _Operation3 &gt; <b>__gnu_cxx::compose2</b> (const _Operation1 &amp;__fn1, const _Operation2 &amp;__fn2,
           const _Operation3 &amp;__fn3)
           An <b>SGI</b> <b>extension</b> .
       template&lt;class _Result &gt; <b>constant_void_fun</b>&lt; _Result &gt; <b>__gnu_cxx::constant0</b> (const _Result &amp;__val)
           An <b>SGI</b> <b>extension</b> .
       template&lt;class _Result &gt; <b>constant_unary_fun</b>&lt; _Result, _Result &gt; <b>__gnu_cxx::constant1</b> (const _Result
           &amp;__val)
           An <b>SGI</b> <b>extension</b> .
       template&lt;class _Result &gt; <b>constant_binary_fun</b>&lt; _Result, _Result, _Result &gt; <b>__gnu_cxx::constant2</b> (const
           _Result &amp;__val)
           An <b>SGI</b> <b>extension</b> .
       template&lt;typename _InputIterator , typename _Size , typename _OutputIterator &gt; <b>std::pair</b>&lt; _InputIterator,
           _OutputIterator &gt; <b>__gnu_cxx::copy_n</b> (_InputIterator __first, _Size __count, _OutputIterator __result)
           Copies the range [first,first+count) into [result,result+count).
       template&lt;typename _InputIterator , typename _Distance &gt; void <b>__gnu_cxx::distance</b> (_InputIterator __first,
           _InputIterator __last, _Distance &amp;__n)
       template&lt;class _Tp &gt; _Tp <b>__gnu_cxx::identity_element</b> (<b>std::multiplies</b>&lt; _Tp &gt;)
           An <b>SGI</b> <b>extension</b> .
       template&lt;class _Tp &gt; _Tp <b>__gnu_cxx::identity_element</b> (<b>std::plus</b>&lt; _Tp &gt;)
           An <b>SGI</b> <b>extension</b> .
       template&lt;typename _InputIterator1 , typename _InputIterator2 &gt; int
           <b>__gnu_cxx::lexicographical_compare_3way</b> (_InputIterator1 __first1, _InputIterator1 __last1,
           _InputIterator2 __first2, _InputIterator2 __last2)
           memcmp on steroids.
       template&lt;typename _Tp , typename _Integer &gt; _Tp <b>__gnu_cxx::power</b> (_Tp __x, _Integer __n)
       template&lt;typename _Tp , typename _Integer , typename _MonoidOperation &gt; _Tp <b>__gnu_cxx::power</b> (_Tp __x,
           _Integer __n, _MonoidOperation __monoid_op)
       template&lt;typename _InputIterator , typename _RandomAccessIterator &gt; _RandomAccessIterator
           <b>__gnu_cxx::random_sample</b> (_InputIterator __first, _InputIterator __last, _RandomAccessIterator
           __out_first, _RandomAccessIterator __out_last)
       template&lt;typename _InputIterator , typename _RandomAccessIterator , typename _RandomNumberGenerator &gt;
           _RandomAccessIterator <b>__gnu_cxx::random_sample</b> (_InputIterator __first, _InputIterator __last,
           _RandomAccessIterator __out_first, _RandomAccessIterator __out_last, _RandomNumberGenerator &amp;__rand)
       template&lt;typename _ForwardIterator , typename _OutputIterator , typename _Distance &gt; _OutputIterator
           <b>__gnu_cxx::random_sample_n</b> (_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __out,
           const _Distance __n)
       template&lt;typename _ForwardIterator , typename _OutputIterator , typename _Distance , typename
           _RandomNumberGenerator &gt; _OutputIterator <b>__gnu_cxx::random_sample_n</b> (_ForwardIterator __first,
           _ForwardIterator __last, _OutputIterator __out, const _Distance __n, _RandomNumberGenerator &amp;__rand)
       template&lt;typename _InputIter , typename _Size , typename _ForwardIter &gt; <b>std::pair</b>&lt; _InputIter,
           _ForwardIter &gt; <b>__gnu_cxx::uninitialized_copy_n</b> (_InputIter __first, _Size __count, _ForwardIter
           __result)
           Copies the range [first,last) into result.
       constexpr <b>bitset</b>&lt; <b>_Nb</b> &gt; &amp; <b>std::bitset&lt;</b> <b>_Nb</b> <b>&gt;::_Unchecked_set</b> (size_t <b>__pos</b>) noexcept
       constexpr <b>bitset</b>&lt; <b>_Nb</b> &gt; &amp; <b>std::bitset&lt;</b> <b>_Nb</b> <b>&gt;::_Unchecked_set</b> (size_t <b>__pos</b>, int __val) noexcept
       constexpr <b>bitset</b>&lt; <b>_Nb</b> &gt; &amp; <b>std::bitset&lt;</b> <b>_Nb</b> <b>&gt;::_Unchecked_reset</b> (size_t <b>__pos</b>) noexcept
       constexpr <b>bitset</b>&lt; <b>_Nb</b> &gt; &amp; <b>std::bitset&lt;</b> <b>_Nb</b> <b>&gt;::_Unchecked_flip</b> (size_t <b>__pos</b>) noexcept
       constexpr bool <b>std::bitset&lt;</b> <b>_Nb</b> <b>&gt;::_Unchecked_test</b> (size_t <b>__pos</b>) const noexcept

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       Because libstdc++ based its implementation of the STL subsections of the library on the SGI 3.3
       implementation, we inherited their extensions as well.

       They are additionally documented in the online documentation, a copy of which is also shipped with the
       library source code (in .../docs/html/documentation.html). You can also read the documentation on SGI's
       site, which is still running even though the code is not maintained.

       <b>NB</b> that the following notes are pulled from various comments all over the place, so they may seem
       stilted.

       The identity_element functions are not part of the C++ standard; SGI provided them as an extension. Its
       argument is an operation, and its return value is the identity element for that operation. It is
       overloaded for addition and multiplication, and you can overload it for your own nefarious operations.

       As an extension to the binders, SGI provided composition functors and wrapper functions to aid in their
       creation. The unary_compose functor is constructed from two functions/functors, f and g. Calling
       operator() with a single argument x returns f(g(x)). The function compose1 takes the two functions and
       constructs a unary_compose variable for you.

       binary_compose is constructed from three functors, f, g1, and g2. Its operator() returns f(g1(x),g2(x)).
       The function compose2 takes f, g1, and g2, and constructs the binary_compose instance for you. For
       example, if f returns an int, then

       int answer = (compose2(f,g1,g2))(x);

        is equivalent to

       int temp1 = g1(x);
       int temp2 = g2(x);
       int answer = f(temp1,temp2);

        But the first form is more compact, and can be passed around as a functor to other algorithms.

       As an extension, SGI provided a functor called identity. When a functor is required but no operations are
       desired, this can be used as a pass-through. Its operator() returns its argument unchanged.

       select1st and select2nd are extensions provided by SGI. Their operator()s take a std::pair as an
       argument, and return either the first member or the second member, respectively. They can be used
       (especially with the composition functors) to <u>strip</u> data from a sequence before performing the remainder
       of an algorithm.

       The operator() of the project1st functor takes two arbitrary arguments and returns the first one, while
       project2nd returns the second one. They are extensions provided by SGI.

       These three functors are each constructed from a single arbitrary variable/value. Later, their
       operator()s completely ignore any arguments passed, and return the stored value.

       • constant_void_fun's operator() takes no arguments

       • constant_unary_fun's operator() takes one argument (ignored)

       • constant_binary_fun's operator() takes two arguments (ignored)

       The  helper  creator  functions  constant0,  constant1,  and  constant2  each  take a <u>result</u> argument and
       construct variables of the appropriate functor type.

</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>template&lt;typename</b> <b>_Tp</b> <b>&gt;</b> <b>const</b> <b>_Tp</b> <b>&amp;</b> <b>__gnu_cxx::__median</b> <b>(const</b> <b>_Tp</b> <b>&amp;</b> <b>__a,</b> <b>const</b> <b>_Tp</b> <b>&amp;</b> <b>__b,</b> <b>const</b> <b>_Tp</b> <b>&amp;</b> <b>__c)</b>
       Find the median of three values.

       <b>Parameters</b>
           <b>__</b><u>a</u> A value.
           <b>__</b><u>b</u> A value.
           <b>__</b><u>c</u> A value.

       <b>Returns</b>
           One of a, b or c.

       If {l,m,n} is some convolution of {a,b,c} such that l&lt;=m&lt;=n then the value returned will be m. This is an
       SGI extension.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Compare</b> <b>&gt;</b> <b>const</b> <b>_Tp</b> <b>&amp;</b> <b>__gnu_cxx::__median</b> <b>(const</b> <b>_Tp</b> <b>&amp;</b>  <b>__a,</b>  <b>const</b>  <b>_Tp</b>  <b>&amp;</b>
       <b>__b,</b> <b>const</b> <b>_Tp</b> <b>&amp;</b> <b>__c,</b> <b>_Compare</b> <b>__comp)</b>
       Find the median of three values using a predicate for comparison.

       <b>Parameters</b>
           <b>__</b><u>a</u> A value.
           <b>__</b><u>b</u> A value.
           <b>__</b><u>c</u> A value.
           <b>__</b><u>comp</u> A binary predicate.

       <b>Returns</b>
           One of a, b or c.

       If  {l,m,n} is some convolution of {a,b,c} such that comp(l,m) and comp(m,n) are both true then the value
       returned will be m. This is an SGI extension.

   <b>template&lt;size_t</b> <b>_Nb&gt;</b> <b>constexpr</b> <b>size_t</b>  <b>std::bitset&lt;</b>  <b>_Nb</b>  <b>&gt;::_Find_first</b>  <b>()</b>  <b>const</b>  <b>[inline],</b>   <b>[constexpr],</b>
       <b>[noexcept]</b>
       Finds the index of the first 'on' bit.

       <b>Returns</b>
           The index of the first bit set, or size() if not found.

       <b>See</b> <b>also</b>
           _Find_next

   <b>template&lt;size_t</b>  <b>_Nb&gt;</b>  <b>constexpr</b>  <b>size_t</b>  <b>std::bitset&lt;</b>  <b>_Nb</b>  <b>&gt;::_Find_next</b>  <b>(size_t</b>  <b>__prev)</b>  <b>const</b> <b>[inline],</b>
       <b>[constexpr],</b>  <b>[noexcept]</b>
       Finds the index of the next 'on' bit after prev.

       <b>Returns</b>
           The index of the next bit set, or size() if not found.

       <b>Parameters</b>
           <b>__</b><u>prev</u> Where to start searching.

       <b>See</b> <b>also</b>
           _Find_first

   <b>template&lt;size_t</b> <b>_Nb&gt;</b> <b>constexpr</b> <b>bitset&lt;</b> <b>_Nb</b> <b>&gt;</b> <b>&amp;</b> <b>std::bitset&lt;</b> <b>_Nb</b> <b>&gt;::_Unchecked_flip</b> <b>(size_t</b>  <b>__pos)</b>  <b>[inline],</b>
       <b>[constexpr],</b>  <b>[noexcept]</b>
       These  versions  of single-bit set, reset, flip, and test are extensions from the SGI version. They do no
       range checking.

   <b>template&lt;size_t</b> <b>_Nb&gt;</b> <b>constexpr</b> <b>bitset&lt;</b> <b>_Nb</b> <b>&gt;</b> <b>&amp;</b> <b>std::bitset&lt;</b> <b>_Nb</b> <b>&gt;::_Unchecked_reset</b> <b>(size_t</b> <b>__pos)</b>  <b>[inline],</b>
       <b>[constexpr],</b>  <b>[noexcept]</b>
       These  versions  of single-bit set, reset, flip, and test are extensions from the SGI version. They do no
       range checking.

   <b>template&lt;size_t</b> <b>_Nb&gt;</b> <b>constexpr</b> <b>bitset&lt;</b> <b>_Nb</b> <b>&gt;</b> <b>&amp;</b> <b>std::bitset&lt;</b> <b>_Nb</b> <b>&gt;::_Unchecked_set</b>  <b>(size_t</b>  <b>__pos)</b>  <b>[inline],</b>
       <b>[constexpr],</b>  <b>[noexcept]</b>
       These  versions  of single-bit set, reset, flip, and test are extensions from the SGI version. They do no
       range checking.

   <b>template&lt;size_t</b> <b>_Nb&gt;</b> <b>constexpr</b> <b>bitset&lt;</b> <b>_Nb</b> <b>&gt;</b> <b>&amp;</b> <b>std::bitset&lt;</b> <b>_Nb</b> <b>&gt;::_Unchecked_set</b> <b>(size_t</b> <b>__pos,</b>  <b>int</b>  <b>__val)</b>
       <b>[inline],</b>  <b>[constexpr],</b>  <b>[noexcept]</b>
       These  versions  of single-bit set, reset, flip, and test are extensions from the SGI version. They do no
       range checking.

   <b>template&lt;size_t</b> <b>_Nb&gt;</b> <b>constexpr</b> <b>bool</b>  <b>std::bitset&lt;</b>  <b>_Nb</b>  <b>&gt;::_Unchecked_test</b>  <b>(size_t</b>  <b>__pos)</b>  <b>const</b>  <b>[inline],</b>
       <b>[constexpr],</b>  <b>[noexcept]</b>
       These  versions  of single-bit set, reset, flip, and test are extensions from the SGI version. They do no
       range checking.

   <b>template&lt;class</b>   <b>_Operation1</b>   <b>,</b>   <b>class</b>   <b>_Operation2</b>   <b>&gt;</b>   <b>unary_compose&lt;</b>   <b>_Operation1,</b>   <b>_Operation2</b>    <b>&gt;</b>
       <b>__gnu_cxx::compose1</b> <b>(const</b> <b>_Operation1</b> <b>&amp;</b> <b>__fn1,</b> <b>const</b> <b>_Operation2</b> <b>&amp;</b> <b>__fn2)</b> <b>[inline]</b>
       An <b>SGI</b> <b>extension</b> .

   <b>template&lt;class</b>   <b>_Operation1</b>   <b>,</b>  <b>class</b>  <b>_Operation2</b>  <b>,</b>  <b>class</b>  <b>_Operation3</b>  <b>&gt;</b>  <b>binary_compose&lt;</b>  <b>_Operation1,</b>
       <b>_Operation2,</b> <b>_Operation3</b> <b>&gt;</b> <b>__gnu_cxx::compose2</b> <b>(const</b> <b>_Operation1</b> <b>&amp;</b> <b>__fn1,</b>  <b>const</b>  <b>_Operation2</b>  <b>&amp;</b>  <b>__fn2,</b>
       <b>const</b> <b>_Operation3</b> <b>&amp;</b> <b>__fn3)</b> <b>[inline]</b>
       An <b>SGI</b> <b>extension</b> .

   <b>template&lt;class</b> <b>_Result</b> <b>&gt;</b> <b>constant_void_fun&lt;</b> <b>_Result</b> <b>&gt;</b> <b>__gnu_cxx::constant0</b> <b>(const</b> <b>_Result</b> <b>&amp;</b> <b>__val)</b> <b>[inline]</b>
       An <b>SGI</b> <b>extension</b> .

   <b>template&lt;class</b>  <b>_Result</b> <b>&gt;</b> <b>constant_unary_fun&lt;</b> <b>_Result,</b> <b>_Result</b> <b>&gt;</b> <b>__gnu_cxx::constant1</b> <b>(const</b> <b>_Result</b> <b>&amp;</b> <b>__val)</b>
       <b>[inline]</b>
       An <b>SGI</b> <b>extension</b> .

   <b>template&lt;class</b> <b>_Result</b> <b>&gt;</b> <b>constant_binary_fun&lt;</b> <b>_Result,</b> <b>_Result,</b> <b>_Result</b> <b>&gt;</b> <b>__gnu_cxx::constant2</b> <b>(const</b> <b>_Result</b>
       <b>&amp;</b> <b>__val)</b> <b>[inline]</b>
       An <b>SGI</b> <b>extension</b> .

   <b>template&lt;typename</b> <b>_InputIterator</b> <b>,</b> <b>typename</b> <b>_Size</b> <b>,</b> <b>typename</b>  <b>_OutputIterator</b>  <b>&gt;</b>  <b>std::pair&lt;</b>  <b>_InputIterator,</b>
       <b>_OutputIterator</b>  <b>&gt;</b>  <b>__gnu_cxx::copy_n</b>  <b>(_InputIterator</b>  <b>__first,</b> <b>_Size</b> <b>__count,</b> <b>_OutputIterator</b> <b>__result)</b>
       <b>[inline]</b>
       Copies the range [first,first+count) into [result,result+count).

       <b>Parameters</b>
           <b>__</b><u>first</u> An input iterator.
           <b>__</b><u>count</u> The number of elements to copy.
           <b>__</b><u>result</u> An output iterator.

       <b>Returns</b>
           A std::pair composed of first+count and result+count.

       This is an SGI extension. This inline function will boil down to a call  to  memmove  whenever  possible.
       Failing  that,  if random access iterators are passed, then the loop count will be known (and therefore a
       candidate for compiler optimizations such as unrolling).

   <b>template&lt;typename</b> <b>_InputIterator</b> <b>,</b> <b>typename</b> <b>_Distance</b> <b>&gt;</b>  <b>void</b>  <b>__gnu_cxx::distance</b>  <b>(_InputIterator</b>  <b>__first,</b>
       <b>_InputIterator</b> <b>__last,</b> <b>_Distance</b> <b>&amp;</b> <b>__n)</b> <b>[inline]</b>
       This is an SGI extension.

       <b>Todo</b>
           Needs documentation! See <a href="http://gcc.gnu.org/onlinedocs/libstdc">http://gcc.gnu.org/onlinedocs/libstdc</a>++/manual/documentation_style.html

   <b>template&lt;class</b> <b>_Tp</b> <b>&gt;</b> <b>_Tp</b> <b>__gnu_cxx::identity_element</b> <b>(std::multiplies&lt;</b> <b>_Tp</b> <b>&gt;)</b> <b>[inline]</b>
       An <b>SGI</b> <b>extension</b> .

   <b>template&lt;class</b> <b>_Tp</b> <b>&gt;</b> <b>_Tp</b> <b>__gnu_cxx::identity_element</b> <b>(std::plus&lt;</b> <b>_Tp</b> <b>&gt;)</b> <b>[inline]</b>
       An <b>SGI</b> <b>extension</b> .

   <b>template&lt;typename</b>  <b>_InputIterator1</b>  <b>,</b>  <b>typename</b> <b>_InputIterator2</b> <b>&gt;</b> <b>int</b> <b>__gnu_cxx::lexicographical_compare_3way</b>
       <b>(_InputIterator1</b> <b>__first1,</b> <b>_InputIterator1</b> <b>__last1,</b> <b>_InputIterator2</b> <b>__first2,</b> <b>_InputIterator2</b> <b>__last2)</b>
       memcmp on steroids.

       <b>Parameters</b>
           <b>__</b><u>first1</u> An input iterator.
           <b>__</b><u>last1</u> An input iterator.
           <b>__</b><u>first2</u> An input iterator.
           <b>__</b><u>last2</u> An input iterator.

       <b>Returns</b>
           An int, as with memcmp.

       The return value will be less than zero if the first range  is  <u>lexigraphically</u>  <u>less</u>  <u>than</u>  the  second,
       greater than zero if the second range is <u>lexigraphically</u> <u>less</u> <u>than</u> the first, and zero otherwise. This is
       an SGI extension.

   <b>template&lt;typename</b> <b>_Tp</b> <b>,</b> <b>typename</b> <b>_Integer</b> <b>&gt;</b> <b>_Tp</b> <b>__gnu_cxx::power</b> <b>(_Tp</b> <b>__x,</b> <b>_Integer</b> <b>__n)</b> <b>[inline]</b>
       This is an SGI extension.

       <b>Todo</b>
           Needs documentation! See <a href="http://gcc.gnu.org/onlinedocs/libstdc">http://gcc.gnu.org/onlinedocs/libstdc</a>++/manual/documentation_style.html

   <b>template&lt;typename</b>  <b>_Tp</b>  <b>,</b>  <b>typename</b>  <b>_Integer</b>  <b>,</b>  <b>typename</b>  <b>_MonoidOperation</b> <b>&gt;</b> <b>_Tp</b> <b>__gnu_cxx::power</b> <b>(_Tp</b> <b>__x,</b>
       <b>_Integer</b> <b>__n,</b> <b>_MonoidOperation</b> <b>__monoid_op)</b> <b>[inline]</b>
       This is an SGI extension.

       <b>Todo</b>
           Needs documentation! See <a href="http://gcc.gnu.org/onlinedocs/libstdc">http://gcc.gnu.org/onlinedocs/libstdc</a>++/manual/documentation_style.html

   <b>template&lt;typename</b>    <b>_InputIterator</b>    <b>,</b>    <b>typename</b>    <b>_RandomAccessIterator</b>     <b>&gt;</b>     <b>_RandomAccessIterator</b>
       <b>__gnu_cxx::random_sample</b>    <b>(_InputIterator</b>   <b>__first,</b>   <b>_InputIterator</b>   <b>__last,</b>   <b>_RandomAccessIterator</b>
       <b>__out_first,</b> <b>_RandomAccessIterator</b> <b>__out_last)</b> <b>[inline]</b>
       This is an SGI extension.

       <b>Todo</b>
           Needs documentation! See <a href="http://gcc.gnu.org/onlinedocs/libstdc">http://gcc.gnu.org/onlinedocs/libstdc</a>++/manual/documentation_style.html

   <b>template&lt;typename</b>  <b>_InputIterator</b>  <b>,</b>  <b>typename</b>  <b>_RandomAccessIterator</b>  <b>,</b>  <b>typename</b>  <b>_RandomNumberGenerator</b>  <b>&gt;</b>
       <b>_RandomAccessIterator</b>    <b>__gnu_cxx::random_sample</b>   <b>(_InputIterator</b>   <b>__first,</b>   <b>_InputIterator</b>   <b>__last,</b>
       <b>_RandomAccessIterator</b> <b>__out_first,</b> <b>_RandomAccessIterator</b>  <b>__out_last,</b>  <b>_RandomNumberGenerator</b>  <b>&amp;</b>  <b>__rand)</b>
       <b>[inline]</b>
       This is an SGI extension.

       <b>Todo</b>
           Needs documentation! See <a href="http://gcc.gnu.org/onlinedocs/libstdc">http://gcc.gnu.org/onlinedocs/libstdc</a>++/manual/documentation_style.html

   <b>template&lt;typename</b>  <b>_ForwardIterator</b>  <b>,</b>  <b>typename</b>  <b>_OutputIterator</b>  <b>,</b>  <b>typename</b>  <b>_Distance</b>  <b>&gt;</b>  <b>_OutputIterator</b>
       <b>__gnu_cxx::random_sample_n</b> <b>(_ForwardIterator</b> <b>__first,</b>  <b>_ForwardIterator</b>  <b>__last,</b>  <b>_OutputIterator</b>  <b>__out,</b>
       <b>const</b> <b>_Distance</b> <b>__n)</b>
       This is an SGI extension.

       <b>Todo</b>
           Needs documentation! See <a href="http://gcc.gnu.org/onlinedocs/libstdc">http://gcc.gnu.org/onlinedocs/libstdc</a>++/manual/documentation_style.html

   <b>template&lt;typename</b>   <b>_ForwardIterator</b>   <b>,</b>   <b>typename</b>   <b>_OutputIterator</b>   <b>,</b>   <b>typename</b>   <b>_Distance</b>  <b>,</b>  <b>typename</b>
       <b>_RandomNumberGenerator</b>   <b>&gt;</b>   <b>_OutputIterator</b>   <b>__gnu_cxx::random_sample_n</b>   <b>(_ForwardIterator</b>    <b>__first,</b>
       <b>_ForwardIterator</b> <b>__last,</b> <b>_OutputIterator</b> <b>__out,</b> <b>const</b> <b>_Distance</b> <b>__n,</b> <b>_RandomNumberGenerator</b> <b>&amp;</b> <b>__rand)</b>
       This is an SGI extension.

       <b>Todo</b>
           Needs documentation! See <a href="http://gcc.gnu.org/onlinedocs/libstdc">http://gcc.gnu.org/onlinedocs/libstdc</a>++/manual/documentation_style.html

   <b>template&lt;typename</b> <b>_InputIter</b> <b>,</b> <b>typename</b> <b>_Size</b> <b>,</b> <b>typename</b> <b>_ForwardIter</b> <b>&gt;</b> <b>std::pair&lt;</b> <b>_InputIter,</b> <b>_ForwardIter</b> <b>&gt;</b>
       <b>__gnu_cxx::uninitialized_copy_n</b> <b>(_InputIter</b> <b>__first,</b> <b>_Size</b> <b>__count,</b> <b>_ForwardIter</b> <b>__result)</b> <b>[inline]</b>
       Copies the range [first,last) into result.

       <b>Parameters</b>
           <b>__</b><u>first</u> An input iterator.
           <b>__</b><u>count</u> Length
           <b>__</b><u>result</u> An output iterator.

       <b>Returns</b>
           __result + (__first + __count)

       Like copy(), but does not require an initialized output range.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for libstdc++ from the source code.

                                                    libstdc++                                <u><a href="../man3cxx/SGIextensions.3cxx.html">SGIextensions</a></u>(3cxx)
</pre>
 </div>
</div></section>
</div>
</body>
</html>