<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>std::tr2::dynamic_bitset< _WordT, _Alloc > - The dynamic_bitset class represents a sequence of bits.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libstdc++-13-doc">libstdc++-13-doc_13.4.0-1ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       std::tr2::dynamic_bitset&lt; _WordT, _Alloc &gt; - The dynamic_bitset class represents a sequence of bits.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;dynamic_bitset&gt;

       Inherits <b>std::tr2::__dynamic_bitset_base&lt;</b> <b>_WordT,</b> <b>_Alloc</b> <b>&gt;</b>.

   <b>Classes</b>
       class <b>reference</b>

   <b>Public</b> <b>Types</b>
       <b>typedef</b> <b>__dynamic_bitset_base</b>&lt; _WordT, _Alloc &gt; <b>_Base</b>
       <b>typedef</b> _Alloc <b>allocator_type</b>
       <b>typedef</b> _WordT <b>block_type</b>
       <b>typedef</b> bool <b>const_reference</b>
       <b>typedef</b> size_t <b>size_type</b>

   <b>Public</b> <b>Member</b> <b>Functions</b>
       <b>dynamic_bitset</b> ()=<b>default</b>
           All bits set to zero.
       <b>dynamic_bitset</b> (const allocator_type &amp;<b>__alloc</b>)
           All bits set to zero.
       <b>dynamic_bitset</b> (const char *<b>__str</b>, const allocator_type &amp;<b>__alloc</b>=allocator_type())
           Construct from a string.
       <b>dynamic_bitset</b> (const <b>dynamic_bitset</b> &amp;)=<b>default</b>
           Copy constructor.
       template&lt;<b>typename</b> _CharT , <b>typename</b> _Traits , <b>typename</b> _Alloc1 &gt; <b>dynamic_bitset</b> (const <b>std::basic_string</b>&lt;
           _CharT, _Traits, _Alloc1 &gt; &amp;<b>__str</b>, <b>typename</b> <b>basic_string</b>&lt; _CharT, _Traits, _Alloc1 &gt;::size_type
           <b>__pos</b>=0, <b>typename</b> <b>basic_string</b>&lt; _CharT, _Traits, _Alloc1 &gt;::size_type __n=<b>std::basic_string</b>&lt; _CharT,
           _Traits, _Alloc1 &gt;::npos, _CharT <b>__zero</b>=_CharT('0'), _CharT <b>__one</b>=_CharT('1'), const allocator_type
           &amp;<b>__alloc</b>=allocator_type())
           Use a subset of a string.
       <b>dynamic_bitset</b> (<b>dynamic_bitset</b> &amp;&amp;__b) noexcept
           Move constructor.
       <b>dynamic_bitset</b> (<b>initializer_list</b>&lt; block_type &gt; <b>__il</b>, const allocator_type &amp;<b>__alloc</b>=allocator_type())
       <b>dynamic_bitset</b> (size_type <b>__nbits</b>, unsigned long long __val=0ULL, const allocator_type
           &amp;<b>__alloc</b>=allocator_type())
           Initial bits bitwise-copied from a single word (others set to zero).
       template&lt;<b>typename</b> _Traits  = std::char_traits&lt;char&gt;, <b>typename</b> _CharT  = typename _Traits::char_type&gt; <b>void</b>
           <b>_M_copy_from_ptr</b> (const _CharT *, size_t, size_t, size_t, _CharT <b>__zero</b>=_CharT('0'), _CharT
           <b>__one</b>=_CharT('1'))
       template&lt;<b>typename</b> _CharT , <b>typename</b> _Traits , <b>typename</b> _Alloc1 &gt; <b>void</b> <b>_M_copy_from_string</b> (const
           <b>basic_string</b>&lt; _CharT, _Traits, _Alloc1 &gt; &amp;<b>__str</b>, size_t <b>__pos</b>, size_t __n, _CharT <b>__zero</b>=_CharT('0'),
           _CharT <b>__one</b>=_CharT('1'))
       template&lt;<b>typename</b> _CharT , <b>typename</b> _Traits , <b>typename</b> _Alloc1 &gt; <b>void</b> <b>_M_copy_to_string</b>
           (<b>std::basic_string</b>&lt; _CharT, _Traits, _Alloc1 &gt; &amp;<b>__str</b>, _CharT <b>__zero</b>=_CharT('0'), _CharT
           <b>__one</b>=_CharT('1')) const
       bool <b>all</b> () const
           Tests whether all the bits are on.
       bool <b>any</b> () const
           Tests whether any of the bits are on.
       template&lt;<b>typename</b> <b>_BlockInputIterator</b> &gt; <b>void</b> <b>append</b> (<b>_BlockInputIterator</b> __first, <b>_BlockInputIterator</b>
           __last)
           Append an iterator range of blocks.
       <b>void</b> <b>append</b> (block_type <b>__block</b>)
           Append a block.
       <b>void</b> <b>append</b> (<b>initializer_list</b>&lt; block_type &gt; <b>__il</b>)
       <b>void</b> <b>clear</b> ()
           Clear the bitset.
       size_type <b>count</b> () const noexcept
           Returns the number of bits which are set.
       bool <b>empty</b> () const noexcept
           Returns true if the dynamic_bitset is empty.
       size_type <b>find_first</b> () const
           Finds the index of the first 'on' bit.
       size_type <b>find_next</b> (size_t <b>__prev</b>) const
           Finds the index of the next 'on' bit after prev.
       <b>dynamic_bitset</b> &amp; <b>flip</b> ()
           Toggles every bit to its opposite value.
       <b>dynamic_bitset</b> &amp; <b>flip</b> (size_type <b>__pos</b>)
           Toggles a given bit to its opposite value.
       allocator_type <b>get_allocator</b> () const noexcept
           Return the allocator for the bitset.
       bool <b>is_proper_subset_of</b> (const <b>dynamic_bitset</b> &amp;__b) const
       bool <b>is_subset_of</b> (const <b>dynamic_bitset</b> &amp;__b) const
       constexpr size_type <b>max_size</b> () noexcept
           Returns the maximum size of a dynamic_bitset object having the same type as *this. The real answer is
           max() * bits_per_block but is likely to overflow.
       bool <b>none</b> () const
           Tests whether any of the bits are on.
       size_type <b>num_blocks</b> () const noexcept
           Returns the total number of blocks.
       <b>dynamic_bitset</b> &amp; <b>operator=</b> (const <b>dynamic_bitset</b> &amp;)=<b>default</b>
           Copy assignment operator.
       <b>dynamic_bitset</b> &amp; <b>operator=</b> (<b>dynamic_bitset</b> &amp;&amp;__b) noexcept(<b>std::is_nothrow_move_assignable</b>&lt; <b>_Base</b>
           &gt;::value)
           Move assignment operator.
       <b>dynamic_bitset</b> <b>operator~</b> () const
           See the no-argument flip().
       <b>void</b> <b>push_back</b> (bool __bit)
           Push a bit onto the high end of the bitset.
       <b>dynamic_bitset</b> &amp; <b>reset</b> ()
           Sets every bit to false.
       <b>dynamic_bitset</b> &amp; <b>reset</b> (size_type <b>__pos</b>)
           Sets a given bit to false.
       <b>void</b> <b>resize</b> (size_type <b>__nbits</b>, bool __value=<b>false</b>)
           Resize the bitset.
       <b>dynamic_bitset</b> &amp; <b>set</b> ()
           Sets every bit to true.
       <b>dynamic_bitset</b> &amp; <b>set</b> (size_type <b>__pos</b>, bool __val=<b>true</b>)
           Sets a given bit to a particular value.
       size_type <b>size</b> () const noexcept
           Returns the total number of bits.
       <b>void</b> <b>swap</b> (<b>dynamic_bitset</b> &amp;__b) noexcept
           Swap with another bitset.
       bool <b>test</b> (size_type <b>__pos</b>) const
           Tests the value of a bit.
       template&lt;<b>typename</b> _CharT  = char, <b>typename</b> _Traits  = std::char_traits&lt;_CharT&gt;, <b>typename</b> _Alloc1  =
           std::allocator&lt;_CharT&gt;&gt; <b>std::basic_string</b>&lt; _CharT, _Traits, _Alloc1 &gt; <b>to_string</b> (_CharT
           <b>__zero</b>=_CharT('0'), _CharT <b>__one</b>=_CharT('1')) const
           Returns a character interpretation of the dynamic_bitset.
       unsigned long long <b>to_ullong</b> () const
           Returns a numerical interpretation of the dynamic_bitset.
       unsigned long <b>to_ulong</b> () const
           Returns a numerical interpretation of the dynamic_bitset.

           <b>dynamic_bitset</b> &amp; <b>operator&amp;=</b> (const <b>dynamic_bitset</b> &amp;<b>__rhs</b>)
               Operations on dynamic_bitsets.
           <b>dynamic_bitset</b> &amp; <b>operator&amp;=</b> (<b>dynamic_bitset</b> &amp;&amp;<b>__rhs</b>)
               Operations on dynamic_bitsets.
           <b>dynamic_bitset</b> &amp; <b>operator|=</b> (const <b>dynamic_bitset</b> &amp;<b>__rhs</b>)
               Operations on dynamic_bitsets.
           <b>dynamic_bitset</b> &amp; <b>operator^=</b> (const <b>dynamic_bitset</b> &amp;<b>__rhs</b>)
               Operations on dynamic_bitsets.
           <b>dynamic_bitset</b> &amp; <b>operator-=</b> (const <b>dynamic_bitset</b> &amp;<b>__rhs</b>)
               Operations on dynamic_bitsets.

           <b>dynamic_bitset</b> &amp; <b>operator&lt;&lt;=</b> (size_type <b>__pos</b>)
               Operations on dynamic_bitsets.
           <b>dynamic_bitset</b> &amp; <b>operator&gt;&gt;=</b> (size_type <b>__pos</b>)
               Operations on dynamic_bitsets.

           <b>reference</b> <b>operator[]</b> (size_type <b>__pos</b>)
               Array-indexing support.
           const_reference <b>operator[]</b> (size_type <b>__pos</b>) const
               Array-indexing support.

           <b>dynamic_bitset</b> <b>operator&lt;&lt;</b> (size_type <b>__pos</b>) const
               Self-explanatory.
           <b>dynamic_bitset</b> <b>operator&gt;&gt;</b> (size_type <b>__pos</b>) const
               Self-explanatory.

   <b>Static</b> <b>Public</b> <b>Attributes</b>
       <b>static</b> const size_type <b>bits_per_block</b>
       <b>static</b> const size_type <b>npos</b>

   <b>Friends</b>
       bool <b>operator&lt;</b> (const <b>dynamic_bitset</b> &amp;<b>__lhs</b>, const <b>dynamic_bitset</b> &amp;<b>__rhs</b>) noexcept
       bool <b>operator==</b> (const <b>dynamic_bitset</b> &amp;<b>__lhs</b>, const <b>dynamic_bitset</b> &amp;<b>__rhs</b>) noexcept
       <b>class</b> <b>reference</b>

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
   <b>template&lt;typename</b> <b>_WordT</b> <b>=</b> <b>unsigned</b> <b>long</b> <b>long,</b> <b>typename</b> <b>_Alloc</b> <b>=</b> <b>std::allocator&lt;_WordT&gt;&gt;</b>
       class std::tr2::dynamic_bitset&lt; _WordT, _Alloc &gt;"The dynamic_bitset class represents a sequence of bits.

       See N2050, Proposal to Add a Dynamically Sizeable Bitset to the Standard Library. <a href="http://www.open">http://www.open</a>-
       std.org/jtc1/sc22/wg21/docs/papers/2006/n2050.pdf

       In the general unoptimized case, storage is allocated in word-sized blocks. Let B be the number of bits
       in a word, then (Nb+(B-1))/B words will be used for storage. B - NbB bits are unused. (They are the high-
       order bits in the highest word.) It is a class invariant that those unused bits are always zero.

       If you think of dynamic_bitset as 'a simple array of bits,' be aware that your mental picture is
       reversed: a dynamic_bitset behaves the same way as bits in integers do, with the bit at index 0 in the
       'least significant / right-hand' position, and the bit at index Nb-1 in the 'most significant / left-
       hand' position. Thus, unlike other containers, a dynamic_bitset's index 'counts from right to left,' to
       put it very loosely.

       This behavior is preserved when translating to and from strings. For example, the first line of the
       following program probably prints 'b('a') is 0001100001' on a modern ASCII system.

       #include &lt;dynamic_bitset&gt;
       #include &lt;iostream&gt;
       #include &lt;sstream&gt;

       using namespace std;

       int main()
       {
           long         a = 'a';
           dynamic_bitset&lt;&gt; b(a);

           cout &lt;&lt; "b('a') is " &lt;&lt; b &lt;&lt; endl;

           ostringstream s;
           s &lt;&lt; b;
           string  str = s.str();
           cout &lt;&lt; "index 3 in the string is " &lt;&lt; str[3] &lt;&lt; " but\n"
                &lt;&lt; "index 3 in the bitset is " &lt;&lt; b[3] &lt;&lt; endl;
       }

       Most of the actual code isn't contained in dynamic_bitset&lt;&gt; itself, but in the base class
       __dynamic_bitset_base. The base class works with whole words, not with individual bits. This allows us to
       specialize __dynamic_bitset_base for the important special case where the dynamic_bitset is only a single
       word.

       Extra confusion can result due to the fact that the storage for __dynamic_bitset_base <u>is</u> a vector, and is
       indexed as such. This is carefully encapsulated.

</pre><h4><b>Constructor</b> <b>&amp;</b> <b>Destructor</b> <b>Documentation</b></h4><pre>
   <b>template&lt;typename</b> <b>_WordT</b>  <b>=</b> <b>unsigned</b> <b>long</b> <b>long,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_WordT&gt;&gt;</b>
       <b>std::tr2::dynamic_bitset&lt;</b> <b>_WordT,</b> <b>_Alloc</b> <b>&gt;::dynamic_bitset</b> <b>()</b> <b>[default]</b>
       All bits set to zero.

   <b>template&lt;typename</b> <b>_WordT</b>  <b>=</b> <b>unsigned</b> <b>long</b> <b>long,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_WordT&gt;&gt;</b>
       <b>std::tr2::dynamic_bitset&lt;</b> <b>_WordT,</b> <b>_Alloc</b> <b>&gt;::dynamic_bitset</b> <b>(const</b> <b>allocator_type</b> <b>&amp;</b> <b>__alloc)</b> <b>[inline],</b>
       <b>[explicit]</b>
       All bits set to zero.

   <b>template&lt;typename</b> <b>_WordT</b>  <b>=</b> <b>unsigned</b> <b>long</b> <b>long,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_WordT&gt;&gt;</b>
       <b>std::tr2::dynamic_bitset&lt;</b> <b>_WordT,</b> <b>_Alloc</b> <b>&gt;::dynamic_bitset</b> <b>(size_type</b> <b>__nbits,</b> <b>unsigned</b> <b>long</b> <b>long</b> <b>__val</b> <b>=</b>
       <b>0ULL,</b> <b>const</b> <b>allocator_type</b> <b>&amp;</b> <b>__alloc</b> <b>=</b> <b>allocator_type())</b> <b>[inline],</b>  <b>[explicit]</b>
       Initial bits bitwise-copied from a single word (others set to zero).

   <b>template&lt;typename</b> <b>_WordT</b>  <b>=</b> <b>unsigned</b> <b>long</b> <b>long,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_WordT&gt;&gt;</b> <b>template&lt;typename</b>
       <b>_CharT</b> <b>,</b> <b>typename</b> <b>_Traits</b> <b>,</b> <b>typename</b> <b>_Alloc1</b> <b>&gt;</b> <b>std::tr2::dynamic_bitset&lt;</b> <b>_WordT,</b> <b>_Alloc</b> <b>&gt;::dynamic_bitset</b>
       <b>(const</b> <b>std::basic_string&lt;</b> <b>_CharT,</b> <b>_Traits,</b> <b>_Alloc1</b> <b>&gt;</b> <b>&amp;</b> <b>__str,</b> <b>typename</b> <b>basic_string&lt;</b> <b>_CharT,</b> <b>_Traits,</b>
       <b>_Alloc1</b> <b>&gt;::size_type</b> <b>__pos</b> <b>=</b> <b>0,</b> <b>typename</b> <b>basic_string&lt;</b> <b>_CharT,</b> <b>_Traits,</b> <b>_Alloc1</b> <b>&gt;::size_type</b> <b>__n</b> <b>=</b>
       <b>std::basic_string&lt;_CharT,</b> <b>_Traits,</b> <b>_Alloc1&gt;::npos,</b> <b>_CharT</b> <b>__zero</b> <b>=</b> <b>_CharT('0'),</b> <b>_CharT</b> <b>__one</b> <b>=</b>
       <b>_CharT('1'),</b> <b>const</b> <b>allocator_type</b> <b>&amp;</b> <b>__alloc</b> <b>=</b> <b>allocator_type())</b> <b>[inline],</b>  <b>[explicit]</b>
       Use a subset of a string.

       <b>Parameters</b>
           <b>__</b><u>str</u> A string of '0' and '1' characters.
           <b>__</b><u>pos</u> Index of the first character in __str to use.
           <b>__</b><u>n</u> The number of characters to copy.
           <b>__</b><u>zero</u> The character to use for unset bits.
           <b>__</b><u>one</u> The character to use for set bits.
           <b>__</b><u>alloc</u> An allocator.

       <b>Exceptions</b>
           <u>std::out_of_range</u> If __pos is bigger the size of __str.
           <u>std::invalid_argument</u> If a character appears in the string which is neither '0' nor '1'.

   <b>template&lt;typename</b> <b>_WordT</b>  <b>=</b> <b>unsigned</b> <b>long</b> <b>long,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_WordT&gt;&gt;</b>
       <b>std::tr2::dynamic_bitset&lt;</b> <b>_WordT,</b> <b>_Alloc</b> <b>&gt;::dynamic_bitset</b> <b>(const</b> <b>char</b> <b>*</b> <b>__str,</b> <b>const</b> <b>allocator_type</b> <b>&amp;</b>
       <b>__alloc</b> <b>=</b> <b>allocator_type())</b> <b>[inline],</b>  <b>[explicit]</b>
       Construct from a string.

       <b>Parameters</b>
           <b>__</b><u>str</u> A string of '0' and '1' characters.
           <b>__</b><u>alloc</u> An allocator.

       <b>Exceptions</b>
           <u>std::invalid_argument</u> If a character appears in the string which is neither '0' nor '1'.

   <b>template&lt;typename</b> <b>_WordT</b>  <b>=</b> <b>unsigned</b> <b>long</b> <b>long,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_WordT&gt;&gt;</b>
       <b>std::tr2::dynamic_bitset&lt;</b> <b>_WordT,</b> <b>_Alloc</b> <b>&gt;::dynamic_bitset</b> <b>(const</b> <b>dynamic_bitset&lt;</b> <b>_WordT,</b> <b>_Alloc</b> <b>&gt;</b> <b>&amp;)</b>
       <b>[default]</b>
       Copy constructor.

   <b>template&lt;typename</b> <b>_WordT</b>  <b>=</b> <b>unsigned</b> <b>long</b> <b>long,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_WordT&gt;&gt;</b>
       <b>std::tr2::dynamic_bitset&lt;</b> <b>_WordT,</b> <b>_Alloc</b> <b>&gt;::dynamic_bitset</b> <b>(dynamic_bitset&lt;</b> <b>_WordT,</b> <b>_Alloc</b> <b>&gt;</b> <b>&amp;&amp;</b> <b>__b)</b>
       <b>[inline],</b>  <b>[noexcept]</b>
       Move constructor.

</pre><h4><b>Member</b> <b>Function</b> <b>Documentation</b></h4><pre>
   <b>template&lt;typename</b> <b>_WordT</b>  <b>=</b> <b>unsigned</b> <b>long</b> <b>long,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_WordT&gt;&gt;</b> <b>bool</b>
       <b>std::tr2::dynamic_bitset&lt;</b> <b>_WordT,</b> <b>_Alloc</b> <b>&gt;::all</b> <b>()</b> <b>const</b> <b>[inline]</b>
       Tests whether all the bits are on.

       <b>Returns</b>
           True if all the bits are set.

   <b>template&lt;typename</b> <b>_WordT</b>  <b>=</b> <b>unsigned</b> <b>long</b> <b>long,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_WordT&gt;&gt;</b> <b>bool</b>
       <b>std::tr2::dynamic_bitset&lt;</b> <b>_WordT,</b> <b>_Alloc</b> <b>&gt;::any</b> <b>()</b> <b>const</b> <b>[inline]</b>
       Tests whether any of the bits are on.

       <b>Returns</b>
           True if at least one bit is set.

   <b>template&lt;typename</b> <b>_WordT</b>  <b>=</b> <b>unsigned</b> <b>long</b> <b>long,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_WordT&gt;&gt;</b> <b>template&lt;typename</b>
       <b>_BlockInputIterator</b> <b>&gt;</b> <b>void</b> <b>std::tr2::dynamic_bitset&lt;</b> <b>_WordT,</b> <b>_Alloc</b> <b>&gt;::append</b> <b>(_BlockInputIterator</b>
       <b>__first,</b> <b>_BlockInputIterator</b> <b>__last)</b> <b>[inline]</b>
       Append an iterator range of blocks.

   <b>template&lt;typename</b> <b>_WordT</b>  <b>=</b> <b>unsigned</b> <b>long</b> <b>long,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_WordT&gt;&gt;</b> <b>void</b>
       <b>std::tr2::dynamic_bitset&lt;</b> <b>_WordT,</b> <b>_Alloc</b> <b>&gt;::append</b> <b>(block_type</b> <b>__block)</b> <b>[inline]</b>
       Append a block.

   <b>template&lt;typename</b> <b>_WordT</b>  <b>=</b> <b>unsigned</b> <b>long</b> <b>long,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_WordT&gt;&gt;</b> <b>void</b>
       <b>std::tr2::dynamic_bitset&lt;</b> <b>_WordT,</b> <b>_Alloc</b> <b>&gt;::clear</b> <b>()</b> <b>[inline]</b>
       Clear the bitset.

   <b>template&lt;typename</b> <b>_WordT</b>  <b>=</b> <b>unsigned</b> <b>long</b> <b>long,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_WordT&gt;&gt;</b> <b>size_type</b>
       <b>std::tr2::dynamic_bitset&lt;</b> <b>_WordT,</b> <b>_Alloc</b> <b>&gt;::count</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[noexcept]</b>
       Returns the number of bits which are set.

   <b>template&lt;typename</b> <b>_WordT</b>  <b>=</b> <b>unsigned</b> <b>long</b> <b>long,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_WordT&gt;&gt;</b> <b>bool</b>
       <b>std::tr2::dynamic_bitset&lt;</b> <b>_WordT,</b> <b>_Alloc</b> <b>&gt;::empty</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[noexcept]</b>
       Returns true if the dynamic_bitset is empty.

   <b>template&lt;typename</b> <b>_WordT</b>  <b>=</b> <b>unsigned</b> <b>long</b> <b>long,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_WordT&gt;&gt;</b> <b>size_type</b>
       <b>std::tr2::dynamic_bitset&lt;</b> <b>_WordT,</b> <b>_Alloc</b> <b>&gt;::find_first</b> <b>()</b> <b>const</b> <b>[inline]</b>
       Finds the index of the first 'on' bit.

       <b>Returns</b>
           The index of the first bit set, or size() if not found.

       <b>See</b> <b>also</b>
           find_next

   <b>template&lt;typename</b> <b>_WordT</b>  <b>=</b> <b>unsigned</b> <b>long</b> <b>long,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_WordT&gt;&gt;</b> <b>size_type</b>
       <b>std::tr2::dynamic_bitset&lt;</b> <b>_WordT,</b> <b>_Alloc</b> <b>&gt;::find_next</b> <b>(size_t</b> <b>__prev)</b> <b>const</b> <b>[inline]</b>
       Finds the index of the next 'on' bit after prev.

       <b>Returns</b>
           The index of the next bit set, or size() if not found.

       <b>Parameters</b>
           <b>__</b><u>prev</u> Where to start searching.

       <b>See</b> <b>also</b>
           find_first

   <b>template&lt;typename</b> <b>_WordT</b>  <b>=</b> <b>unsigned</b> <b>long</b> <b>long,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_WordT&gt;&gt;</b> <b>dynamic_bitset</b> <b>&amp;</b>
       <b>std::tr2::dynamic_bitset&lt;</b> <b>_WordT,</b> <b>_Alloc</b> <b>&gt;::flip</b> <b>()</b> <b>[inline]</b>
       Toggles every bit to its opposite value.

   <b>template&lt;typename</b> <b>_WordT</b>  <b>=</b> <b>unsigned</b> <b>long</b> <b>long,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_WordT&gt;&gt;</b> <b>dynamic_bitset</b> <b>&amp;</b>
       <b>std::tr2::dynamic_bitset&lt;</b> <b>_WordT,</b> <b>_Alloc</b> <b>&gt;::flip</b> <b>(size_type</b> <b>__pos)</b> <b>[inline]</b>
       Toggles a given bit to its opposite value.

       <b>Parameters</b>
           <b>__</b><u>pos</u> The index of the bit.

       <b>Exceptions</b>
           <u>std::out_of_range</u> If <b>__</b><u>pos</u> is bigger the size of the set.

   <b>template&lt;typename</b> <b>_WordT</b>  <b>=</b> <b>unsigned</b> <b>long</b> <b>long,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_WordT&gt;&gt;</b> <b>allocator_type</b>
       <b>std::tr2::dynamic_bitset&lt;</b> <b>_WordT,</b> <b>_Alloc</b> <b>&gt;::get_allocator</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[noexcept]</b>
       Return the allocator for the bitset.

   <b>template&lt;typename</b> <b>_WordT</b>  <b>=</b> <b>unsigned</b> <b>long</b> <b>long,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_WordT&gt;&gt;</b> <b>constexpr</b>
       <b>size_type</b> <b>std::tr2::dynamic_bitset&lt;</b> <b>_WordT,</b> <b>_Alloc</b> <b>&gt;::max_size</b> <b>()</b> <b>[inline],</b>  <b>[constexpr],</b>  <b>[noexcept]</b>
       Returns the maximum size of a dynamic_bitset object having the same type as *this. The real answer is
       max() * bits_per_block but is likely to overflow.

   <b>template&lt;typename</b> <b>_WordT</b>  <b>=</b> <b>unsigned</b> <b>long</b> <b>long,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_WordT&gt;&gt;</b> <b>bool</b>
       <b>std::tr2::dynamic_bitset&lt;</b> <b>_WordT,</b> <b>_Alloc</b> <b>&gt;::none</b> <b>()</b> <b>const</b> <b>[inline]</b>
       Tests whether any of the bits are on.

       <b>Returns</b>
           True if none of the bits are set.

   <b>template&lt;typename</b> <b>_WordT</b>  <b>=</b> <b>unsigned</b> <b>long</b> <b>long,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_WordT&gt;&gt;</b> <b>size_type</b>
       <b>std::tr2::dynamic_bitset&lt;</b> <b>_WordT,</b> <b>_Alloc</b> <b>&gt;::num_blocks</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[noexcept]</b>
       Returns the total number of blocks.

   <b>template&lt;typename</b> <b>_WordT</b>  <b>=</b> <b>unsigned</b> <b>long</b> <b>long,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_WordT&gt;&gt;</b> <b>dynamic_bitset</b> <b>&amp;</b>
       <b>std::tr2::dynamic_bitset&lt;</b> <b>_WordT,</b> <b>_Alloc</b> <b>&gt;::operator&amp;=</b> <b>(const</b> <b>dynamic_bitset&lt;</b> <b>_WordT,</b> <b>_Alloc</b> <b>&gt;</b> <b>&amp;</b> <b>__rhs)</b>
       <b>[inline]</b>
       Operations on dynamic_bitsets.

       <b>Parameters</b>
           <b>__</b><u>rhs</u> A same-sized dynamic_bitset.

       These should be self-explanatory.

   <b>template&lt;typename</b> <b>_WordT</b>  <b>=</b> <b>unsigned</b> <b>long</b> <b>long,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_WordT&gt;&gt;</b> <b>dynamic_bitset</b> <b>&amp;</b>
       <b>std::tr2::dynamic_bitset&lt;</b> <b>_WordT,</b> <b>_Alloc</b> <b>&gt;::operator&amp;=</b> <b>(dynamic_bitset&lt;</b> <b>_WordT,</b> <b>_Alloc</b> <b>&gt;</b> <b>&amp;&amp;</b> <b>__rhs)</b>
       <b>[inline]</b>
       Operations on dynamic_bitsets.

       <b>Parameters</b>
           <b>__</b><u>rhs</u> A same-sized dynamic_bitset.

       These should be self-explanatory.

   <b>template&lt;typename</b> <b>_WordT</b>  <b>=</b> <b>unsigned</b> <b>long</b> <b>long,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_WordT&gt;&gt;</b> <b>dynamic_bitset</b> <b>&amp;</b>
       <b>std::tr2::dynamic_bitset&lt;</b> <b>_WordT,</b> <b>_Alloc</b> <b>&gt;::operator-=</b> <b>(const</b> <b>dynamic_bitset&lt;</b> <b>_WordT,</b> <b>_Alloc</b> <b>&gt;</b> <b>&amp;</b> <b>__rhs)</b>
       <b>[inline]</b>
       Operations on dynamic_bitsets.

       <b>Parameters</b>
           <b>__</b><u>rhs</u> A same-sized dynamic_bitset.

       These should be self-explanatory.

   <b>template&lt;typename</b> <b>_WordT</b>  <b>=</b> <b>unsigned</b> <b>long</b> <b>long,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_WordT&gt;&gt;</b> <b>dynamic_bitset</b>
       <b>std::tr2::dynamic_bitset&lt;</b> <b>_WordT,</b> <b>_Alloc</b> <b>&gt;::operator&lt;&lt;</b> <b>(size_type</b> <b>__pos)</b> <b>const</b> <b>[inline]</b>
       Self-explanatory.

   <b>template&lt;typename</b> <b>_WordT</b>  <b>=</b> <b>unsigned</b> <b>long</b> <b>long,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_WordT&gt;&gt;</b> <b>dynamic_bitset</b> <b>&amp;</b>
       <b>std::tr2::dynamic_bitset&lt;</b> <b>_WordT,</b> <b>_Alloc</b> <b>&gt;::operator&lt;&lt;=</b> <b>(size_type</b> <b>__pos)</b> <b>[inline]</b>
       Operations on dynamic_bitsets.

       <b>Parameters</b>
           <b>__</b><u>pos</u> The number of places to shift.

       These should be self-explanatory.

   <b>template&lt;typename</b> <b>_WordT</b>  <b>=</b> <b>unsigned</b> <b>long</b> <b>long,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_WordT&gt;&gt;</b> <b>dynamic_bitset</b> <b>&amp;</b>
       <b>std::tr2::dynamic_bitset&lt;</b> <b>_WordT,</b> <b>_Alloc</b> <b>&gt;::operator=</b> <b>(const</b> <b>dynamic_bitset&lt;</b> <b>_WordT,</b> <b>_Alloc</b> <b>&gt;</b> <b>&amp;)</b>
       <b>[default]</b>
       Copy assignment operator.

   <b>template&lt;typename</b> <b>_WordT</b>  <b>=</b> <b>unsigned</b> <b>long</b> <b>long,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_WordT&gt;&gt;</b> <b>dynamic_bitset</b> <b>&amp;</b>
       <b>std::tr2::dynamic_bitset&lt;</b> <b>_WordT,</b> <b>_Alloc</b> <b>&gt;::operator=</b> <b>(dynamic_bitset&lt;</b> <b>_WordT,</b> <b>_Alloc</b> <b>&gt;</b> <b>&amp;&amp;</b> <b>__b)</b> <b>[inline],</b>
       <b>[noexcept]</b>
       Move assignment operator.

   <b>template&lt;typename</b> <b>_WordT</b>  <b>=</b> <b>unsigned</b> <b>long</b> <b>long,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_WordT&gt;&gt;</b> <b>dynamic_bitset</b>
       <b>std::tr2::dynamic_bitset&lt;</b> <b>_WordT,</b> <b>_Alloc</b> <b>&gt;::operator&gt;&gt;</b> <b>(size_type</b> <b>__pos)</b> <b>const</b> <b>[inline]</b>
       Self-explanatory.

   <b>template&lt;typename</b> <b>_WordT</b>  <b>=</b> <b>unsigned</b> <b>long</b> <b>long,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_WordT&gt;&gt;</b> <b>dynamic_bitset</b> <b>&amp;</b>
       <b>std::tr2::dynamic_bitset&lt;</b> <b>_WordT,</b> <b>_Alloc</b> <b>&gt;::operator&gt;&gt;=</b> <b>(size_type</b> <b>__pos)</b> <b>[inline]</b>
       Operations on dynamic_bitsets.

       <b>Parameters</b>
           <b>__</b><u>pos</u> The number of places to shift.

       These should be self-explanatory.

   <b>template&lt;typename</b> <b>_WordT</b>  <b>=</b> <b>unsigned</b> <b>long</b> <b>long,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_WordT&gt;&gt;</b> <b>reference</b>
       <b>std::tr2::dynamic_bitset&lt;</b> <b>_WordT,</b> <b>_Alloc</b> <b>&gt;::operator[]</b> <b>(size_type</b> <b>__pos)</b> <b>[inline]</b>
       Array-indexing support.

       <b>Parameters</b>
           <b>__</b><u>pos</u> Index into the dynamic_bitset.

       <b>Returns</b>
           A bool for a 'const dynamic_bitset'. For non-const bitsets, an instance of the reference proxy class.

       <b>Note</b>
           These operators do no range checking and throw no exceptions, as required by DR 11 to the standard.

   <b>template&lt;typename</b> <b>_WordT</b>  <b>=</b> <b>unsigned</b> <b>long</b> <b>long,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_WordT&gt;&gt;</b> <b>const_reference</b>
       <b>std::tr2::dynamic_bitset&lt;</b> <b>_WordT,</b> <b>_Alloc</b> <b>&gt;::operator[]</b> <b>(size_type</b> <b>__pos)</b> <b>const</b> <b>[inline]</b>
       Array-indexing support.

       <b>Parameters</b>
           <b>__</b><u>pos</u> Index into the dynamic_bitset.

       <b>Returns</b>
           A bool for a 'const dynamic_bitset'. For non-const bitsets, an instance of the reference proxy class.

       <b>Note</b>
           These operators do no range checking and throw no exceptions, as required by DR 11 to the standard.

   <b>template&lt;typename</b> <b>_WordT</b>  <b>=</b> <b>unsigned</b> <b>long</b> <b>long,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_WordT&gt;&gt;</b> <b>dynamic_bitset</b> <b>&amp;</b>
       <b>std::tr2::dynamic_bitset&lt;</b> <b>_WordT,</b> <b>_Alloc</b> <b>&gt;::operator^=</b> <b>(const</b> <b>dynamic_bitset&lt;</b> <b>_WordT,</b> <b>_Alloc</b> <b>&gt;</b> <b>&amp;</b> <b>__rhs)</b>
       <b>[inline]</b>
       Operations on dynamic_bitsets.

       <b>Parameters</b>
           <b>__</b><u>rhs</u> A same-sized dynamic_bitset.

       These should be self-explanatory.

   <b>template&lt;typename</b> <b>_WordT</b>  <b>=</b> <b>unsigned</b> <b>long</b> <b>long,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_WordT&gt;&gt;</b> <b>dynamic_bitset</b> <b>&amp;</b>
       <b>std::tr2::dynamic_bitset&lt;</b> <b>_WordT,</b> <b>_Alloc</b> <b>&gt;::operator|=</b> <b>(const</b> <b>dynamic_bitset&lt;</b> <b>_WordT,</b> <b>_Alloc</b> <b>&gt;</b> <b>&amp;</b> <b>__rhs)</b>
       <b>[inline]</b>
       Operations on dynamic_bitsets.

       <b>Parameters</b>
           <b>__</b><u>rhs</u> A same-sized dynamic_bitset.

       These should be self-explanatory.

   <b>template&lt;typename</b> <b>_WordT</b>  <b>=</b> <b>unsigned</b> <b>long</b> <b>long,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_WordT&gt;&gt;</b> <b>dynamic_bitset</b>
       <b>std::tr2::dynamic_bitset&lt;</b> <b>_WordT,</b> <b>_Alloc</b> <b>&gt;::operator~</b> <b>()</b> <b>const</b> <b>[inline]</b>
       See the no-argument flip().

   <b>template&lt;typename</b> <b>_WordT</b>  <b>=</b> <b>unsigned</b> <b>long</b> <b>long,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_WordT&gt;&gt;</b> <b>void</b>
       <b>std::tr2::dynamic_bitset&lt;</b> <b>_WordT,</b> <b>_Alloc</b> <b>&gt;::push_back</b> <b>(bool</b> <b>__bit)</b> <b>[inline]</b>
       Push a bit onto the high end of the bitset.

   <b>template&lt;typename</b> <b>_WordT</b>  <b>=</b> <b>unsigned</b> <b>long</b> <b>long,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_WordT&gt;&gt;</b> <b>dynamic_bitset</b> <b>&amp;</b>
       <b>std::tr2::dynamic_bitset&lt;</b> <b>_WordT,</b> <b>_Alloc</b> <b>&gt;::reset</b> <b>()</b> <b>[inline]</b>
       Sets every bit to false.

   <b>template&lt;typename</b> <b>_WordT</b>  <b>=</b> <b>unsigned</b> <b>long</b> <b>long,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_WordT&gt;&gt;</b> <b>dynamic_bitset</b> <b>&amp;</b>
       <b>std::tr2::dynamic_bitset&lt;</b> <b>_WordT,</b> <b>_Alloc</b> <b>&gt;::reset</b> <b>(size_type</b> <b>__pos)</b> <b>[inline]</b>
       Sets a given bit to false.

       <b>Parameters</b>
           <b>__</b><u>pos</u> The index of the bit.

       <b>Exceptions</b>
           <u>std::out_of_range</u> If <b>__</b><u>pos</u> is bigger the size of the set.

       Same as writing set(__pos, false).

   <b>template&lt;typename</b> <b>_WordT</b>  <b>=</b> <b>unsigned</b> <b>long</b> <b>long,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_WordT&gt;&gt;</b> <b>void</b>
       <b>std::tr2::dynamic_bitset&lt;</b> <b>_WordT,</b> <b>_Alloc</b> <b>&gt;::resize</b> <b>(size_type</b> <b>__nbits,</b> <b>bool</b> <b>__value</b> <b>=</b> <b>false)</b> <b>[inline]</b>
       Resize the bitset.

   <b>template&lt;typename</b> <b>_WordT</b>  <b>=</b> <b>unsigned</b> <b>long</b> <b>long,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_WordT&gt;&gt;</b> <b>dynamic_bitset</b> <b>&amp;</b>
       <b>std::tr2::dynamic_bitset&lt;</b> <b>_WordT,</b> <b>_Alloc</b> <b>&gt;::set</b> <b>()</b> <b>[inline]</b>
       Sets every bit to true.

   <b>template&lt;typename</b> <b>_WordT</b>  <b>=</b> <b>unsigned</b> <b>long</b> <b>long,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_WordT&gt;&gt;</b> <b>dynamic_bitset</b> <b>&amp;</b>
       <b>std::tr2::dynamic_bitset&lt;</b> <b>_WordT,</b> <b>_Alloc</b> <b>&gt;::set</b> <b>(size_type</b> <b>__pos,</b> <b>bool</b> <b>__val</b> <b>=</b> <b>true)</b> <b>[inline]</b>
       Sets a given bit to a particular value.

       <b>Parameters</b>
           <b>__</b><u>pos</u> The index of the bit.
           <b>__</b><u>val</u> Either true or false, defaults to true.

       <b>Exceptions</b>
           <u>std::out_of_range</u> If <b>__</b><u>pos</u> is bigger the size of the set.

   <b>template&lt;typename</b> <b>_WordT</b>  <b>=</b> <b>unsigned</b> <b>long</b> <b>long,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_WordT&gt;&gt;</b> <b>size_type</b>
       <b>std::tr2::dynamic_bitset&lt;</b> <b>_WordT,</b> <b>_Alloc</b> <b>&gt;::size</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[noexcept]</b>
       Returns the total number of bits.

   <b>template&lt;typename</b> <b>_WordT</b>  <b>=</b> <b>unsigned</b> <b>long</b> <b>long,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_WordT&gt;&gt;</b> <b>void</b>
       <b>std::tr2::dynamic_bitset&lt;</b> <b>_WordT,</b> <b>_Alloc</b> <b>&gt;::swap</b> <b>(dynamic_bitset&lt;</b> <b>_WordT,</b> <b>_Alloc</b> <b>&gt;</b> <b>&amp;</b> <b>__b)</b> <b>[inline],</b>
       <b>[noexcept]</b>
       Swap with another bitset.

   <b>template&lt;typename</b> <b>_WordT</b>  <b>=</b> <b>unsigned</b> <b>long</b> <b>long,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_WordT&gt;&gt;</b> <b>bool</b>
       <b>std::tr2::dynamic_bitset&lt;</b> <b>_WordT,</b> <b>_Alloc</b> <b>&gt;::test</b> <b>(size_type</b> <b>__pos)</b> <b>const</b> <b>[inline]</b>
       Tests the value of a bit.

       <b>Parameters</b>
           <b>__</b><u>pos</u> The index of a bit.

       <b>Returns</b>
           The value at <b>__</b><u>pos</u>.

       <b>Exceptions</b>
           <u>std::out_of_range</u> If <b>__</b><u>pos</u> is bigger the size of the set.

   <b>template&lt;typename</b> <b>_WordT</b>  <b>=</b> <b>unsigned</b> <b>long</b> <b>long,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_WordT&gt;&gt;</b> <b>template&lt;typename</b>
       <b>_CharT</b>  <b>=</b> <b>char,</b> <b>typename</b> <b>_Traits</b>  <b>=</b> <b>std::char_traits&lt;_CharT&gt;,</b> <b>typename</b> <b>_Alloc1</b>  <b>=</b> <b>std::allocator&lt;_CharT&gt;&gt;</b>
       <b>std::basic_string&lt;</b> <b>_CharT,</b> <b>_Traits,</b> <b>_Alloc1</b> <b>&gt;</b> <b>std::tr2::dynamic_bitset&lt;</b> <b>_WordT,</b> <b>_Alloc</b> <b>&gt;::to_string</b>
       <b>(_CharT</b> <b>__zero</b> <b>=</b> <b>_CharT('0'),</b> <b>_CharT</b> <b>__one</b> <b>=</b> <b>_CharT('1'))</b> <b>const</b> <b>[inline]</b>
       Returns a character interpretation of the dynamic_bitset.

       <b>Returns</b>
           The string equivalent of the bits.

       Note the ordering of the bits: decreasing character positions correspond to increasing bit positions (see
       the main class notes for an example).

   <b>template&lt;typename</b> <b>_WordT</b>  <b>=</b> <b>unsigned</b> <b>long</b> <b>long,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_WordT&gt;&gt;</b> <b>unsigned</b> <b>long</b> <b>long</b>
       <b>std::tr2::dynamic_bitset&lt;</b> <b>_WordT,</b> <b>_Alloc</b> <b>&gt;::to_ullong</b> <b>()</b> <b>const</b> <b>[inline]</b>
       Returns a numerical interpretation of the dynamic_bitset.

       <b>Returns</b>
           The integral equivalent of the bits.

       <b>Exceptions</b>
           <u>std::overflow_error</u> If there are too many bits to be represented in an unsigned long.

   <b>template&lt;typename</b> <b>_WordT</b>  <b>=</b> <b>unsigned</b> <b>long</b> <b>long,</b> <b>typename</b> <b>_Alloc</b>  <b>=</b> <b>std::allocator&lt;_WordT&gt;&gt;</b> <b>unsigned</b> <b>long</b>
       <b>std::tr2::dynamic_bitset&lt;</b> <b>_WordT,</b> <b>_Alloc</b> <b>&gt;::to_ulong</b> <b>()</b> <b>const</b> <b>[inline]</b>
       Returns a numerical interpretation of the dynamic_bitset.

       <b>Returns</b>
           The integral equivalent of the bits.

       <b>Exceptions</b>
           <u>std::overflow_error</u> If there are too many bits to be represented in an unsigned long.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for libstdc++ from the source code.

                                                    libstdc++   <u>std::tr2::dynamic_bitset&lt;</u> <b>_</b><u>WordT,</u> <b>_</b><u>Alloc</u> <u>&gt;</u>(3cxx)
</pre>
 </div>
</div></section>
</div>
</body>
</html>