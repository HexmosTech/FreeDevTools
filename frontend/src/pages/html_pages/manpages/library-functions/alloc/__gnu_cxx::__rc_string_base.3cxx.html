<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title></title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libstdc++-13-doc">libstdc++-13-doc_13.4.0-1ubuntu1_all</a> <br><br><pre>
<b>__</b><u>gnu_cxx::</u><b>__</b><u>rc_string_...harT,</u> <b>_</b><u>Traits,</u> <b>_</b><u>Alloc</u> <u>&gt;</u>(3cxx)  <b>__</b><u>gnu_cxx::</u><b>__</b><u>rc_string_...harT,</u> <b>_</b><u>Traits,</u> <b>_</b><u>Alloc</u> <u>&gt;</u>(3cxx)

</pre><h4><b>NAME</b></h4><pre>
       __gnu_cxx::__rc_string_base&lt; _CharT, _Traits, _Alloc &gt;

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;rc_string_base.h&gt;

       Inherits __gnu_cxx::__vstring_utility&lt; _CharT, _Traits, _Alloc &gt;.

   <b>Public</b> <b>Types</b>
       typedef _Util_Base::_CharT_alloc_type <b>_CharT_alloc_type</b>
       typedef __vstring_utility&lt; _CharT, _Traits, _Alloc &gt; <b>_Util_Base</b>
       typedef _Alloc <b>allocator_type</b>
       typedef _CharT_alloc_type::size_type <b>size_type</b>
       typedef _Traits <b>traits_type</b>
       typedef _Traits::char_type <b>value_type</b>

   <b>Public</b> <b>Member</b> <b>Functions</b>
       <b>__rc_string_base</b> (<b>__rc_string_base</b> &amp;&amp;__rcs)
       template&lt;typename _InputIterator &gt; <b>__rc_string_base</b> (_InputIterator __beg, _InputIterator __end, const
           _Alloc &amp;__a)
       <b>__rc_string_base</b> (const <b>__rc_string_base</b> &amp;__rcs)
       <b>__rc_string_base</b> (const _Alloc &amp;__a)
       <b>__rc_string_base</b> (size_type __n, _CharT __c, const _Alloc &amp;__a)
       void <b>_M_assign</b> (const <b>__rc_string_base</b> &amp;__rcs)
       size_type <b>_M_capacity</b> () const
       void <b>_M_clear</b> ()
       bool <b>_M_compare</b> (const <b>__rc_string_base</b> &amp;) const
       bool <b>_M_compare</b> (const <b>__rc_string_base</b> &amp;__rcs) const
       bool <b>_M_compare</b> (const <b>__rc_string_base</b> &amp;__rcs) const
       _CharT * <b>_M_data</b> () const
       void <b>_M_erase</b> (size_type __pos, size_type __n)
       allocator_type &amp; <b>_M_get_allocator</b> ()
       const allocator_type &amp; <b>_M_get_allocator</b> () const
       bool <b>_M_is_shared</b> () const
       void <b>_M_leak</b> ()
       size_type <b>_M_length</b> () const
       size_type <b>_M_max_size</b> () const
       void <b>_M_mutate</b> (size_type __pos, size_type __len1, const _CharT *__s, size_type __len2)
       void <b>_M_reserve</b> (size_type __res)
       void <b>_M_set_leaked</b> ()
       void <b>_M_set_length</b> (size_type __n)
       void <b>_M_swap</b> (<b>__rc_string_base</b> &amp;__rcs)
       template&lt;typename _InIterator &gt; _CharT * <b>_S_construct</b> (_InIterator __beg, _InIterator __end, const _Alloc
           &amp;__a, <b>std::forward_iterator_tag</b>)

   <b>Protected</b> <b>Types</b>
       typedef __gnu_cxx::__normal_iterator&lt; const_pointer, <b>__gnu_cxx::__versa_string</b>&lt; _CharT, _Traits, _Alloc,
           <b>__rc_string_base</b> &gt; &gt; <b>__const_rc_iterator</b>
       typedef __gnu_cxx::__normal_iterator&lt; const_pointer, <b>__gnu_cxx::__versa_string</b>&lt; _CharT, _Traits, _Alloc,
           __sso_string_base &gt; &gt; <b>__const_sso_iterator</b>
       typedef __gnu_cxx::__normal_iterator&lt; <b>pointer</b>, <b>__gnu_cxx::__versa_string</b>&lt; _CharT, _Traits, _Alloc,
           <b>__rc_string_base</b> &gt; &gt; <b>__rc_iterator</b>
       typedef __gnu_cxx::__normal_iterator&lt; <b>pointer</b>, <b>__gnu_cxx::__versa_string</b>&lt; _CharT, _Traits, _Alloc,
           __sso_string_base &gt; &gt; <b>__sso_iterator</b>
       typedef <b>__alloc_traits</b>&lt; _CharT_alloc_type &gt; <b>_CharT_alloc_traits</b>
       typedef _CharT_alloc_traits::const_pointer <b>const_pointer</b>
       typedef _CharT_alloc_type::difference_type <b>difference_type</b>
       typedef <b>_CharT_alloc_traits::pointer</b> <b>pointer</b>

   <b>Static</b> <b>Protected</b> <b>Member</b> <b>Functions</b>
       static void <b>_S_assign</b> (_CharT *__d, size_type __n, _CharT __c)
       static int <b>_S_compare</b> (size_type __n1, size_type __n2)
       static void <b>_S_copy</b> (_CharT *__d, const _CharT *__s, size_type __n)
       static void <b>_S_copy_chars</b> (_CharT *__p, __const_rc_iterator __k1, __const_rc_iterator __k2)
       static void <b>_S_copy_chars</b> (_CharT *__p, __const_sso_iterator __k1, __const_sso_iterator __k2)
       static void <b>_S_copy_chars</b> (_CharT *__p, __rc_iterator __k1, __rc_iterator __k2)
       static void <b>_S_copy_chars</b> (_CharT *__p, __sso_iterator __k1, __sso_iterator __k2)
       static void <b>_S_copy_chars</b> (_CharT *__p, _CharT *__k1, _CharT *__k2)
       template&lt;typename _Iterator &gt; static void <b>_S_copy_chars</b> (_CharT *__p, _Iterator __k1, _Iterator __k2)
       static void <b>_S_copy_chars</b> (_CharT *__p, const _CharT *__k1, const _CharT *__k2)
       static void <b>_S_move</b> (_CharT *__d, const _CharT *__s, size_type __n)

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
   <b>template&lt;typename</b> <b>_CharT,</b> <b>typename</b> <b>_Traits,</b> <b>typename</b> <b>_Alloc&gt;</b>
       class __gnu_cxx::__rc_string_base&lt; _CharT, _Traits, _Alloc &gt;"Documentation? What's that? Nathan Myers
       <a href="mailto:ncm@cantrip.org">ncm@cantrip.org</a>.

       A string looks like this:

                                            [_Rep]
                                            _M_length
       [__rc_string_base&lt;char_type&gt;]        _M_capacity
       _M_dataplus                          _M_refcount
       _M_p ----------------&gt;               unnamed array of char_type

       Where the _M_p points to the first character in the string, and you cast it to a pointer-to-_Rep and
       subtract 1 to get a pointer to the header.

       This approach has the enormous advantage that a string object requires only one allocation. All the
       ugliness is confined within a single pair of inline functions, which each compile to a single <u>add</u>
       instruction: _Rep::_M_refdata(), and __rc_string_base::_M_rep(); and the allocation function which gets a
       block of raw bytes and with room enough and constructs a _Rep object at the front.

       The reason you want _M_data pointing to the character array and not the _Rep is so that the debugger can
       see the string contents. (Probably we should add a non-inline member to get the _Rep for the debugger to
       use, so users can check the actual string length.)

       Note that the _Rep object is a POD so that you can have a static <u>empty</u> <u>string</u> _Rep object already
       <u>constructed</u> before static constructors have run. The reference-count encoding is chosen so that a 0
       indicates one reference, so you never try to destroy the empty-string _Rep object.

       All but the last paragraph is considered pretty conventional for a C++ string implementation.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for libstdc++ from the source code.

                                                    libst<b>__</b><u>gnu_cxx::</u><b>__</b><u>rc_string_...harT,</u> <b>_</b><u>Traits,</u> <b>_</b><u>Alloc</u> <u>&gt;</u>(3cxx)
</pre>
 </div>
</div></section>
</div>
</body>
</html>