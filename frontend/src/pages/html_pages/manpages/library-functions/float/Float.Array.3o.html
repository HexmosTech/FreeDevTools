<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Float.Array - Float arrays with packed representation.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/ocaml-man">ocaml-man_5.3.0-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Float.Array - Float arrays with packed representation.

</pre><h4><b>Module</b></h4><pre>
       Module   Float.Array

</pre><h4><b>Documentation</b></h4><pre>
       Module <b>Array</b>
        : <b>sig</b> <b>end</b>

       Float arrays with packed representation.

       <u>type</u> <u>t</u> = <b>floatarray</b>

       The type of float arrays with packed representation.

       <b>Since</b> 4.08

       <u>val</u> <u>length</u> : <b>t</b> <b>-&gt;</b> <b>int</b>

       Return the length (number of elements) of the given floatarray.

       <u>val</u> <u>get</u> : <b>t</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>float</b>

       <b>get</b> <b>a</b> <b>n</b> returns the element number <b>n</b> of floatarray <b>a</b> .

       <b>Raises</b> <b>Invalid_argument</b> if <b>n</b> is outside the range 0 to <b>(length</b> <b>a</b> <b>-</b> <b>1)</b> .

       <u>val</u> <u>set</u> : <b>t</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>float</b> <b>-&gt;</b> <b>unit</b>

       <b>set</b> <b>a</b> <b>n</b> <b>x</b> modifies floatarray <b>a</b> in place, replacing element number <b>n</b> with <b>x</b> .

       <b>Raises</b> <b>Invalid_argument</b> if <b>n</b> is outside the range 0 to <b>(length</b> <b>a</b> <b>-</b> <b>1)</b> .

       <u>val</u> <u>make</u> : <b>int</b> <b>-&gt;</b> <b>float</b> <b>-&gt;</b> <b>t</b>

       <b>make</b> <b>n</b> <b>x</b> returns a fresh floatarray of length <b>n</b> , initialized with <b>x</b> .

       <b>Raises</b> <b>Invalid_argument</b> if <b>n</b> <b>&lt;</b> <b>0</b> or <b>n</b> <b>&gt;</b> <b>Sys.max_floatarray_length</b> .

       <u>val</u> <u>create</u> : <b>int</b> <b>-&gt;</b> <b>t</b>

       <b>create</b> <b>n</b> returns a fresh floatarray of length <b>n</b> , with uninitialized data.

       <b>Raises</b> <b>Invalid_argument</b> if <b>n</b> <b>&lt;</b> <b>0</b> or <b>n</b> <b>&gt;</b> <b>Sys.max_floatarray_length</b> .

       <u>val</u> <u>init</u> : <b>int</b> <b>-&gt;</b> <b>(int</b> <b>-&gt;</b> <b>float)</b> <b>-&gt;</b> <b>t</b>

       <b>init</b>  <b>n</b> <b>f</b> returns a fresh floatarray of length <b>n</b> , with element number <b>i</b> initialized to the result of <b>f</b> <b>i</b>
       .  In other terms, <b>init</b> <b>n</b> <b>f</b> tabulates the results of <b>f</b> applied to the integers <b>0</b> to <b>n-1</b> .

       <b>Raises</b> <b>Invalid_argument</b> if <b>n</b> <b>&lt;</b> <b>0</b> or <b>n</b> <b>&gt;</b> <b>Sys.max_floatarray_length</b> .

       <u>val</u> <u>make_matrix</u> : <b>int</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>float</b> <b>-&gt;</b> <b>t</b> <b>array</b>

       <b>make_matrix</b> <b>dimx</b> <b>dimy</b> <b>e</b> returns a two-dimensional array (an array of arrays) with  first  dimension  <b>dimx</b>
       and second dimension <b>dimy</b> , where all elements are initialized with <b>e</b> .

       <b>Since</b> 5.2

       <b>Raises</b> <b>Invalid_argument</b> if <b>dimx</b> or <b>dimy</b> is negative or greater than <b>Sys.max_floatarray_length</b> .

       <u>val</u> <u>init_matrix</u> : <b>int</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>(int</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>float)</b> <b>-&gt;</b> <b>t</b> <b>array</b>

       <b>init_matrix</b>  <b>dimx</b>  <b>dimy</b>  <b>f</b> returns a two-dimensional array (an array of arrays) with first dimension <b>dimx</b>
       and second dimension <b>dimy</b> , where the element at index ( <b>x,y</b> ) is initialized with <b>f</b> <b>x</b> <b>y</b> .

       <b>Since</b> 5.2

       <b>Raises</b> <b>Invalid_argument</b> if <b>dimx</b> or <b>dimy</b> is negative or greater than <b>Sys.max_floatarray_length</b> .

       <u>val</u> <u>append</u> : <b>t</b> <b>-&gt;</b> <b>t</b> <b>-&gt;</b> <b>t</b>

       <b>append</b> <b>v1</b> <b>v2</b> returns a fresh floatarray containing the concatenation of the floatarrays <b>v1</b> and <b>v2</b> .

       <b>Raises</b> <b>Invalid_argument</b> if <b>length</b> <b>v1</b> <b>+</b> <b>length</b> <b>v2</b> <b>&gt;</b> <b>Sys.max_floatarray_length</b> .

       <u>val</u> <u>concat</u> : <b>t</b> <b>list</b> <b>-&gt;</b> <b>t</b>

       Same as <b>Float.Array.append</b> , but concatenates a list of floatarrays.

       <u>val</u> <u>sub</u> : <b>t</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>t</b>

       <b>sub</b> <b>a</b> <b>pos</b> <b>len</b> returns a fresh floatarray of length <b>len</b> , containing the elements number <b>pos</b> to <b>pos</b> <b>+</b>  <b>len</b>
       <b>-</b> <b>1</b> of floatarray <b>a</b> .

       <b>Raises</b>  <b>Invalid_argument</b> if <b>pos</b> and <b>len</b> do not designate a valid subarray of <b>a</b> ; that is, if <b>pos</b> <b>&lt;</b> <b>0</b> , or
       <b>len</b> <b>&lt;</b> <b>0</b> , or <b>pos</b> <b>+</b> <b>len</b> <b>&gt;</b> <b>length</b> <b>a</b> .

       <u>val</u> <u>copy</u> : <b>t</b> <b>-&gt;</b> <b>t</b>

       <b>copy</b> <b>a</b> returns a copy of <b>a</b> , that is, a fresh floatarray containing the same elements as <b>a</b> .

       <u>val</u> <u>fill</u> : <b>t</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>float</b> <b>-&gt;</b> <b>unit</b>

       <b>fill</b> <b>a</b> <b>pos</b> <b>len</b> <b>x</b> modifies the floatarray <b>a</b> in place, storing <b>x</b> in elements number <b>pos</b> to <b>pos</b> <b>+</b> <b>len</b> <b>-</b> <b>1</b> .

       <b>Raises</b> <b>Invalid_argument</b> if <b>pos</b> and <b>len</b> do not designate a valid subarray of <b>a</b> .

       <u>val</u> <u>blit</u> : <b>t</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>t</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>int</b> <b>-&gt;</b> <b>unit</b>

       <b>blit</b> <b>src</b> <b>src_pos</b> <b>dst</b> <b>dst_pos</b> <b>len</b> copies <b>len</b> elements from floatarray <b>src</b> ,  starting  at  element  number
       <b>src_pos</b>  ,  to  floatarray <b>dst</b> , starting at element number <b>dst_pos</b> .  It works correctly even if <b>src</b> and
       <b>dst</b> are the same floatarray, and the source and destination chunks overlap.

       <b>Raises</b> <b>Invalid_argument</b> if <b>src_pos</b> and <b>len</b> do not designate a valid subarray of <b>src</b> , or if  <b>dst_pos</b>  and
       <b>len</b> do not designate a valid subarray of <b>dst</b> .

       <u>val</u> <u>to_list</u> : <b>t</b> <b>-&gt;</b> <b>float</b> <b>list</b>

       <b>to_list</b> <b>a</b> returns the list of all the elements of <b>a</b> .

       <u>val</u> <u>of_list</u> : <b>float</b> <b>list</b> <b>-&gt;</b> <b>t</b>

       <b>of_list</b> <b>l</b> returns a fresh floatarray containing the elements of <b>l</b> .

       <b>Raises</b> <b>Invalid_argument</b> if the length of <b>l</b> is greater than <b>Sys.max_floatarray_length</b> .

   <b>Iterators</b>
       <u>val</u> <u>iter</u> : <b>(float</b> <b>-&gt;</b> <b>unit)</b> <b>-&gt;</b> <b>t</b> <b>-&gt;</b> <b>unit</b>

       <b>iter</b>  <b>f</b>  <b>a</b>  applies  function <b>f</b> in turn to all the elements of <b>a</b> .  It is equivalent to <b>f</b> <b><a href="../man0/a..0.html">a.</a>(0);</b> <b>f</b> <b><a href="../man1/a..1.html">a.</a>(1);</b>
       <b>...;</b> <b>f</b> <b>a.(length</b> <b>a</b> <b>-</b> <b>1);</b> <b>()</b> .

       <u>val</u> <u>iteri</u> : <b>(int</b> <b>-&gt;</b> <b>float</b> <b>-&gt;</b> <b>unit)</b> <b>-&gt;</b> <b>t</b> <b>-&gt;</b> <b>unit</b>

       Same as <b>Float.Array.iter</b> , but the function is applied with the index of the element as  first  argument,
       and the element itself as second argument.

       <u>val</u> <u>map</u> : <b>(float</b> <b>-&gt;</b> <b>float)</b> <b>-&gt;</b> <b>t</b> <b>-&gt;</b> <b>t</b>

       <b>map</b>  <b>f</b>  <b>a</b> applies function <b>f</b> to all the elements of <b>a</b> , and builds a floatarray with the results returned
       by <b>f</b> .

       <u>val</u> <u>map_inplace</u> : <b>(float</b> <b>-&gt;</b> <b>float)</b> <b>-&gt;</b> <b>t</b> <b>-&gt;</b> <b>unit</b>

       <b>map_inplace</b> <b>f</b> <b>a</b> applies function <b>f</b> to all elements of <b>a</b> , and updates their values in place.

       <b>Since</b> 5.1

       <u>val</u> <u>mapi</u> : <b>(int</b> <b>-&gt;</b> <b>float</b> <b>-&gt;</b> <b>float)</b> <b>-&gt;</b> <b>t</b> <b>-&gt;</b> <b>t</b>

       Same as <b>Float.Array.map</b> , but the function is applied to the index of the element as first argument,  and
       the element itself as second argument.

       <u>val</u> <u>mapi_inplace</u> : <b>(int</b> <b>-&gt;</b> <b>float</b> <b>-&gt;</b> <b>float)</b> <b>-&gt;</b> <b>t</b> <b>-&gt;</b> <b>unit</b>

       Same  as  <b>Float.Array.map_inplace</b>  ,  but  the  function  is applied to the index of the element as first
       argument, and the element itself as second argument.

       <b>Since</b> 5.1

       <u>val</u> <u>fold_left</u> : <b>('acc</b> <b>-&gt;</b> <b>float</b> <b>-&gt;</b> <b>'acc)</b> <b>-&gt;</b> <b>'acc</b> <b>-&gt;</b> <b>t</b> <b>-&gt;</b> <b>'acc</b>

       <b>fold_left</b> <b>f</b> <b>x</b> <b>init</b> computes <b>f</b> <b>(...</b> <b>(f</b> <b>(f</b> <b>x</b> <b><a href="../man0/init..0.html">init.</a>(0))</b> <b><a href="../man1/init..1.html">init.</a>(1))</b> <b>...)</b> <b>init.(n-1)</b> , where <b>n</b> is the length of
       the floatarray <b>init</b> .

       <u>val</u> <u>fold_right</u> : <b>(float</b> <b>-&gt;</b> <b>'acc</b> <b>-&gt;</b> <b>'acc)</b> <b>-&gt;</b> <b>t</b> <b>-&gt;</b> <b>'acc</b> <b>-&gt;</b> <b>'acc</b>

       <b>fold_right</b> <b>f</b> <b>a</b> <b>init</b> computes <b>f</b> <b><a href="../man0/a..0.html">a.</a>(0)</b> <b>(f</b> <b><a href="../man1/a..1.html">a.</a>(1)</b> <b>(</b> <b>...</b> <b>(f</b> <b>a.(n-1)</b> <b>init)</b> <b>...))</b>  , where <b>n</b> is  the  length  of
       the floatarray <b>a</b> .

   <b>Iterators</b> <b>on</b> <b>two</b> <b>arrays</b>
       <u>val</u> <u>iter2</u> : <b>(float</b> <b>-&gt;</b> <b>float</b> <b>-&gt;</b> <b>unit)</b> <b>-&gt;</b> <b>t</b> <b>-&gt;</b> <b>t</b> <b>-&gt;</b> <b>unit</b>

       <b>Array.iter2</b> <b>f</b> <b>a</b> <b>b</b> applies function <b>f</b> to all the elements of <b>a</b> and <b>b</b> .

       <b>Raises</b> <b>Invalid_argument</b> if the floatarrays are not the same size.

       <u>val</u> <u>map2</u> : <b>(float</b> <b>-&gt;</b> <b>float</b> <b>-&gt;</b> <b>float)</b> <b>-&gt;</b> <b>t</b> <b>-&gt;</b> <b>t</b> <b>-&gt;</b> <b>t</b>

       <b>map2</b>  <b>f</b>  <b>a</b> <b>b</b> applies function <b>f</b> to all the elements of <b>a</b> and <b>b</b> , and builds a floatarray with the results
       returned by <b>f</b> : <b>[|</b> <b>f</b> <b><a href="../man0/a..0.html">a.</a>(0)</b> <b><a href="../man0/b..0.html">b.</a>(0);</b> <b>...;</b> <b>f</b> <b>a.(length</b> <b>a</b> <b>-</b> <b>1)</b> <b>b.(length</b> <b>b</b> <b>-</b> <b>1)|]</b> .

       <b>Raises</b> <b>Invalid_argument</b> if the floatarrays are not the same size.

   <b>Array</b> <b>scanning</b>
       <u>val</u> <u>for_all</u> : <b>(float</b> <b>-&gt;</b> <b>bool)</b> <b>-&gt;</b> <b>t</b> <b>-&gt;</b> <b>bool</b>

       <b>for_all</b> <b>f</b> <b>[|a1;</b> <b>...;</b> <b>an|]</b> checks if all elements of the floatarray satisfy the predicate <b>f</b> . That is,  it
       returns <b>(f</b> <b>a1)</b> <b>&amp;&amp;</b> <b>(f</b> <b>a2)</b> <b>&amp;&amp;</b> <b>...</b> <b>&amp;&amp;</b> <b>(f</b> <b>an)</b> .

       <u>val</u> <u>exists</u> : <b>(float</b> <b>-&gt;</b> <b>bool)</b> <b>-&gt;</b> <b>t</b> <b>-&gt;</b> <b>bool</b>

       <b>exists</b>  <b>f</b>  <b>[|a1;</b>  <b>...;</b>  <b>an|]</b> checks if at least one element of the floatarray satisfies the predicate <b>f</b> .
       That is, it returns <b>(f</b> <b>a1)</b> <b>||</b> <b>(f</b> <b>a2)</b> <b>||</b> <b>...</b> <b>||</b> <b>(f</b> <b>an)</b> .

       <u>val</u> <u>mem</u> : <b>float</b> <b>-&gt;</b> <b>t</b> <b>-&gt;</b> <b>bool</b>

       <b>mem</b> <b>a</b> <b>set</b> is true if and only if there is an element of <b>set</b> that is structurally equal to <b>a</b> , i.e.  there
       is an <b>x</b> in <b>set</b> such that <b>compare</b> <b>a</b> <b>x</b> <b>=</b> <b>0</b> .

       <u>val</u> <u>mem_ieee</u> : <b>float</b> <b>-&gt;</b> <b>t</b> <b>-&gt;</b> <b>bool</b>

       Same as <b>Float.Array.mem</b> , but uses IEEE equality instead of structural equality.

   <b>Array</b> <b>searching</b>
       <u>val</u> <u>find_opt</u> : <b>(float</b> <b>-&gt;</b> <b>bool)</b> <b>-&gt;</b> <b>t</b> <b>-&gt;</b> <b>float</b> <b>option</b>

       <u>val</u> <u>find_index</u> : <b>(float</b> <b>-&gt;</b> <b>bool)</b> <b>-&gt;</b> <b>t</b> <b>-&gt;</b> <b>int</b> <b>option</b>

       <b>find_index</b> <b>f</b> <b>a</b> returns <b>Some</b> <b>i</b> , where <b>i</b> is the index of the first element of the array <b>a</b> that satisfies <b>f</b>
       <b>x</b> , if there is such an element.

       It returns <b>None</b> if there is no such element.

       <b>Since</b> 5.1

       <u>val</u> <u>find_map</u> : <b>(float</b> <b>-&gt;</b> <b>'a</b> <b>option)</b> <b>-&gt;</b> <b>t</b> <b>-&gt;</b> <b>'a</b> <b>option</b>

       <u>val</u> <u>find_mapi</u> : <b>(int</b> <b>-&gt;</b> <b>float</b> <b>-&gt;</b> <b>'a</b> <b>option)</b> <b>-&gt;</b> <b>t</b> <b>-&gt;</b> <b>'a</b> <b>option</b>

       Same  as  <b>find_map</b> , but the predicate is applied to the index of the element as first argument (counting
       from 0), and the element itself as second argument.

       <b>Since</b> 5.1

   <b>Sorting</b> <b>and</b> <b>shuffling</b>
       <u>val</u> <u>sort</u> : <b>(float</b> <b>-&gt;</b> <b>float</b> <b>-&gt;</b> <b>int)</b> <b>-&gt;</b> <b>t</b> <b>-&gt;</b> <b>unit</b>

       Sort a floatarray in increasing order according to a comparison function.  The comparison  function  must
       return  0  if  its arguments compare as equal, a positive integer if the first is greater, and a negative
       integer if the first is smaller (see below for a complete specification).   For  example,  <b>compare</b>  is  a
       suitable  comparison  function.   After  calling <b>sort</b> , the array is sorted in place in increasing order.
       <b>sort</b> is guaranteed to run in constant heap space and (at most) logarithmic stack space.

       The current implementation uses Heap Sort.  It runs in constant stack space.

       Specification of the comparison function: Let <b>a</b> be the floatarray and <b>cmp</b> the  comparison  function.  The
       following must be true for all <b>x</b> , <b>y</b> , <b>z</b> in <b>a</b> :

       - <b>cmp</b> <b>x</b> <b>y</b> &gt; 0 if and only if <b>cmp</b> <b>y</b> <b>x</b> &lt; 0

       -     if <b>cmp</b> <b>x</b> <b>y</b> &gt;= 0 and <b>cmp</b> <b>y</b> <b>z</b> &gt;= 0 then <b>cmp</b> <b>x</b> <b>z</b> &gt;= 0

       When  <b>sort</b>  returns, <b>a</b> contains the same elements as before, reordered in such a way that for all i and j
       valid indices of <b>a</b> :

       - <b>cmp</b> <b>a.(i)</b> <b>a.(j)</b> &gt;= 0 if i &gt;= j

       <u>val</u> <u>stable_sort</u> : <b>(float</b> <b>-&gt;</b> <b>float</b> <b>-&gt;</b> <b>int)</b> <b>-&gt;</b> <b>t</b> <b>-&gt;</b> <b>unit</b>

       Same as <b>Float.Array.sort</b> , but the sorting algorithm is stable (i.e.  elements  that  compare  equal  are
       kept in their original order) and not guaranteed to run in constant heap space.

       The current implementation uses Merge Sort. It uses a temporary floatarray of length <b>n/2</b> , where <b>n</b> is the
       length of the floatarray.  It is usually faster than the current implementation of <b>Float.Array.sort</b> .

       <u>val</u> <u>fast_sort</u> : <b>(float</b> <b>-&gt;</b> <b>float</b> <b>-&gt;</b> <b>int)</b> <b>-&gt;</b> <b>t</b> <b>-&gt;</b> <b>unit</b>

       Same as <b>Float.Array.sort</b> or <b>Float.Array.stable_sort</b> , whichever is faster on typical input.

       <u>val</u> <u>shuffle</u> : <b>rand:(int</b> <b>-&gt;</b> <b>int)</b> <b>-&gt;</b> <b>t</b> <b>-&gt;</b> <b>unit</b>

       <b>shuffle</b>  <b>rand</b>  <b>a</b>  randomly  permutes  <b>a</b>  's  elements  using  <b>rand</b>  for  randomness.  The distribution of
       permutations is uniform.

       <b>rand</b> must be such that a call to <b>rand</b> <b>n</b> returns a uniformly distributed random number in the range [ <b>0</b>  ;
       <b>n-1</b> ].  <b>Random.int</b> can be used for this (do not forget to <b>Random.self_init</b> the generator).

       <b>Since</b> 5.2

   <b>Float</b> <b>arrays</b> <b>and</b> <b>Sequences</b>
       <u>val</u> <u>to_seq</u> : <b>t</b> <b>-&gt;</b> <b>float</b> <b>Seq.t</b>

       Iterate  on the floatarray, in increasing order. Modifications of the floatarray during iteration will be
       reflected in the sequence.

       <u>val</u> <u>to_seqi</u> : <b>t</b> <b>-&gt;</b> <b>(int</b> <b>*</b> <b>float)</b> <b>Seq.t</b>

       Iterate on the floatarray, in increasing order, yielding indices along  elements.  Modifications  of  the
       floatarray during iteration will be reflected in the sequence.

       <u>val</u> <u>of_seq</u> : <b>float</b> <b>Seq.t</b> <b>-&gt;</b> <b>t</b>

       Create an array from the generator.

       <u>val</u> <u>map_to_array</u> : <b>(float</b> <b>-&gt;</b> <b>'a)</b> <b>-&gt;</b> <b>t</b> <b>-&gt;</b> <b>'a</b> <b>array</b>

       <b>map_to_array</b>  <b>f</b>  <b>a</b>  applies  function  <b>f</b>  to all the elements of <b>a</b> , and builds an array with the results
       returned by <b>f</b> : <b>[|</b> <b>f</b> <b><a href="../man0/a..0.html">a.</a>(0);</b> <b>f</b> <b><a href="../man1/a..1.html">a.</a>(1);</b> <b>...;</b> <b>f</b> <b>a.(length</b> <b>a</b> <b>-</b> <b>1)</b> <b>|]</b> .

       <u>val</u> <u>map_from_array</u> : <b>('a</b> <b>-&gt;</b> <b>float)</b> <b>-&gt;</b> <b>'a</b> <b>array</b> <b>-&gt;</b> <b>t</b>

       <b>map_from_array</b> <b>f</b> <b>a</b> applies function <b>f</b> to all the elements of <b>a</b> , and builds a floatarray with the results
       returned by <b>f</b> .

   <b>Arrays</b> <b>and</b> <b>concurrency</b> <b>safety</b>
       Care must be taken when concurrently accessing float arrays from multiple  domains:  accessing  an  array
       will    never    crash    a    program,    but    unsynchronized    accesses   might   yield   surprising
       (non-sequentially-consistent) results.

   <b>Atomicity</b>
       Every float array operation that accesses more than one  array  element  is  not  atomic.  This  includes
       iteration, scanning, sorting, splitting and combining arrays.

       For example, consider the following program:
       <b>let</b> <b>size</b> <b>=</b> <b>100_000_000</b>
         <b>let</b> <b>a</b> <b>=</b> <b>Float.Array.make</b> <b>size</b> <b>1.</b>
         <b>let</b> <b>update</b> <b>a</b> <b>f</b> <b>()</b> <b>=</b>
            <b>Float.Array.iteri</b> <b>(fun</b> <b>i</b> <b>x</b> <b>-&gt;</b> <b>Float.Array.set</b> <b>a</b> <b>i</b> <b>(f</b> <b>x))</b> <b>a</b>
         <b>let</b> <b>d1</b> <b>=</b> <b>Domain.spawn</b> <b>(update</b> <b>a</b> <b>(fun</b> <b>x</b> <b>-&gt;</b> <b>x</b> <b>+.</b> <b>1.))</b>
         <b>let</b> <b>d2</b> <b>=</b> <b>Domain.spawn</b> <b>(update</b> <b>a</b> <b>(fun</b> <b>x</b> <b>-&gt;</b>  <b>2.</b> <b>*.</b> <b>x</b> <b>+.</b> <b>1.))</b>
         <b>let</b> <b>()</b> <b>=</b> <b>Domain.join</b> <b>d1;</b> <b>Domain.join</b> <b>d2</b>

       After  executing  this  code,  each  field  of  the  float  array <b>a</b> is either <b>2.</b>  , <b>3.</b>  , <b>4.</b>  or <b>5.</b>  . If
       atomicity is required, then the user must implement their own synchronization (for example, using <b>Mutex.t</b>
       ).

   <b>Data</b> <b>races</b>
       If two domains only access disjoint parts of the array, then the observed behaviour is the equivalent  to
       some sequential interleaving of the operations from the two domains.

       A  data  race is said to occur when two domains access the same array element without synchronization and
       at least one of the accesses is a write. In  the  absence  of  data  races,  the  observed  behaviour  is
       equivalent to some sequential interleaving of the operations from different domains.

       Whenever  possible,  data races should be avoided by using synchronization to mediate the accesses to the
       array elements.

       Indeed, in the presence of data races, programs will not crash but the  observed  behaviour  may  not  be
       equivalent to any sequential interleaving of operations from different domains. Nevertheless, even in the
       presence  of data races, a read operation will return the value of some prior write to that location with
       a few exceptions.

   <b>Tearing</b>
       Float arrays have two supplementary caveats in the presence of data races.

       First, the blit operation might copy an array byte-by-byte. Data races between such a blit operation  and
       another  operation  might produce surprising values due to tearing: partial writes interleaved with other
       operations can create float values that would not exist with a sequential execution.

       For instance, at the end of
       <b>let</b> <b>zeros</b> <b>=</b> <b>Float.Array.make</b> <b>size</b> <b>0.</b>
         <b>let</b> <b>max_floats</b> <b>=</b> <b>Float.Array.make</b> <b>size</b> <b>Float.max_float</b>
         <b>let</b> <b>res</b> <b>=</b> <b>Float.Array.copy</b> <b>zeros</b>
         <b>let</b> <b>d1</b> <b>=</b> <b>Domain.spawn</b> <b>(fun</b> <b>()</b> <b>-&gt;</b> <b>Float.Array.blit</b> <b>zeros</b> <b>0</b> <b>res</b> <b>0</b> <b>size)</b>
         <b>let</b> <b>d2</b> <b>=</b> <b>Domain.spawn</b> <b>(fun</b> <b>()</b> <b>-&gt;</b> <b>Float.Array.blit</b> <b>max_floats</b> <b>0</b> <b>res</b> <b>0</b> <b>size)</b>
         <b>let</b> <b>()</b> <b>=</b> <b>Domain.join</b> <b>d1;</b> <b>Domain.join</b> <b>d2</b>

       the <b>res</b> float array might contain values that are neither <b>0.</b>  nor <b>max_float</b> .

       Second, on 32-bit architectures, getting or setting a field involves two separate memory accesses. In the
       presence of data races, the user may observe tearing on any operation.

OCamldoc                                           2025-06-12                                    <u><a href="../man3o/Float.Array.3o.html">Float.Array</a></u>(3o)
</pre>
 </div>
</div></section>
</div>
</body>
</html>