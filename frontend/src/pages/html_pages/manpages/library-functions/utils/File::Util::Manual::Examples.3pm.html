<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>File::Util::Manual::Examples - File::Util Examples</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libfile-util-perl">libfile-util-perl_4.201720-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       File::Util::Manual::Examples - File::Util Examples

</pre><h4><b>VERSION</b></h4><pre>
       version 4.201720

</pre><h4><b>INTRODUCTION</b></h4><pre>
       This manual subsection is fully comprised of simple examples of File::Util in greater depth than what you
       see in the main documentation, however to keep things simple, these examples are short, quick, and to the
       point.

       For examples of full Programs using File::Util, take a look at the Cookbook at the File::Util::Cookbook.

</pre><h4><b>EXAMPLES</b></h4><pre>
       Many of these are demonstrated in the standalone scripts that come in the "examples" directory as part of
       this distribution.

       Unless indicated otherwise, all of these short examples assume that you have started out with:

          use File::Util;
          my $f = File::Util-&gt;new();

       The variable $f is used for simplicity here in the examples.  In your actual programming you should
       refrain from using single-letter variables and use something more obvious instead, such as $ftl or $futil

   <b>Get</b> <b>the</b> <b>contents</b> <b>of</b> <b>a</b> <b>file</b> <b>in</b> <b>a</b> <b>string</b>
          my $contents = $f-&gt;load_file( 'filename' );


             -OR-
          my $contents = $f-&gt;load_file( '/path/to/filename' );


             -OR-
          my $contents = $f-&gt;load_file( 'C:\path\to\filename' );

   <b>Get</b> <b>the</b> <b>contents</b> <b>of</b> <b>a</b> <b>UTF-8</b> <b>encoded</b> <b>file</b> <b>in</b> <b>a</b> <b>UTF-8</b> <b>encoded</b> <b>string</b>
          my $encoded_data = $f-&gt;load_file( 'encoded.txt' =&gt; { binmode =&gt; 'utf8' } );

   <b>Get</b> <b>the</b> <b>contents</b> <b>of</b> <b>a</b> <b>file</b> <b>in</b> <b>an</b> <b>array</b> <b>of</b> <b>lines</b> <b>in</b> <b>the</b> <b>file</b>
          my @contents = $f-&gt;load_file( 'filename' =&gt; { as_lines =&gt; 1 } );

   <b>Get</b> <b>an</b> <b>open</b> <b>file</b> <b>handle</b> <b>for</b> <b>reading</b>
          my $fh = $f-&gt;open_handle(
             file =&gt; '/some/existing/file',
             mode =&gt; 'read'
          );


             -OR-
          # ... you can also use the shorter syntax:
          my $fh = $f-&gt;open_handle( '/some/existing/file' =&gt; 'read' );

          # ... you can open a file handle to a UTF-8 encoded file too
          my $fh = $f-&gt;open_handle( 'encoded.txt' =&gt; 'read' =&gt; { binmode =&gt; 'utf8' } );

          # then use the filehandle like you would use any other file handle:
          while ( my $line = &lt;$fh&gt; ) {

             # ... do stuff with $line
          }

          close $fh or die $!;

   <b>Get</b> <b>an</b> <b>open</b> <b>file</b> <b>handle</b> <b>for</b> <b>writing</b>
       Opening a file for writing (write mode) will create the file if it doesn't already exist.  The file
       handle is automatically locked for you with <b>flock()</b> if your system supports it.

          my $fh = $f-&gt;open_handle(
             file =&gt; '/some/file',
             mode =&gt; 'write'
          );


             -OR-
          # ... you can also use the shorter syntax:
          my $fh = $f-&gt;open_handle( '/some/file' =&gt; 'write' );

          # ... you can open a file handle with UTF-8 encoding support
          my $fh = $f-&gt;open_handle( '/some/file' =&gt; 'write' =&gt; { binmode =&gt; 'utf8' } );

          print $fh 'Hello world!';

          close $fh or die $!;

   <b>Write</b> <b>to</b> <b>a</b> <b>new</b> <b>or</b> <b>existing</b> <b>file</b>
          my $content = 'Pathelogically Eclectic Rubbish Lister';

          $f-&gt;write_file( file =&gt; 'a new file.txt', content =&gt; $content );


             -OR-
          # you can use the shorter syntax:
          $f-&gt;write_file( 'a new file.txt' =&gt; $content );


             -OR-
          # write UTF-8 encoded data also.  the file will have UTF-8 encoding:
          $f-&gt;write_file( 'encoded.txt' =&gt; $encoded_data =&gt; { binmode =&gt; 'utf8' } );

       You can optionally specify a bitmask for a file if it doesn't exist yet.  The bitmask is combined with
       the user's current umask for the creation mode of the file.  (You should usually omit this.)

          $f-&gt;write_file(
             file    =&gt; 'C:\some\new\file.txt',
             content =&gt; $content
             bitmask =&gt; oct 777,
          );


             -OR-
          $f-&gt;write_file( 'file.txt' =&gt; $content =&gt; { bitmask =&gt; oct 777 } );

   <b>Warn</b> <b>if</b> <b>the</b> <b>file</b> <b>couldn't</b> <b>be</b> <b>written,</b> <b>instead</b> <b>of</b> <b>dying</b> <b>by</b> <b>default</b>
          $f-&gt;write_file(
             'file.txt' =&gt; $content,
             {
                onfail  =&gt; 'warn',
                bitmask =&gt; oct 777
             }
          );

   <b>Conceal</b> <b>the</b> <b>error</b> <b>if</b> <b>the</b> <b>file</b> <b>couldn't</b> <b>be</b> <b>written</b> <b>(secure),</b> <b>but</b> <b>log</b> <b>it</b> <b>too</b>
          # define a custom (secure) error handler

          $f-&gt;write_file(
             'file.txt' =&gt; $content =&gt;
             {
                bitmask =&gt; oct 777
                onfail  =&gt; sub {
                   my ( $err, $stack ) = @_;

                   # send the error message and stack trace to a logger of some kind...
                   $logger-&gt;log( $err . $stack );

                   # or send an email alert?
                   send_email_alert_to_admin( $err ); #&lt;&lt; you'll have to write that sub

                   # return undef to indicate a problem (or you could die/exit too)
                   return;
                }
             }
          );

   <b>Why</b> <b>not</b> <b>first</b> <b>check</b> <b>if</b> <b>the</b> <b>file</b> <b>is</b> <b>writeable/can</b> <b>be</b> <b>created</b>
          if ( $f-&gt;is_writable( '/root/some/file.txt' ) ) {

             # ... now create/write to the file
          }

   <b>Append</b> <b>to</b> <b>a</b> <b>new</b> <b>or</b> <b>existing</b> <b>file</b>
          my $content = 'The fastest hunk of junk in the galaxy';

          $f-&gt;write_file(
             file    =&gt; 'mfalcon.spec',
             mode    =&gt; 'append',
             content =&gt; $content
          );


             -OR-
          $f-&gt;write_file( 'mfalcon.spec' =&gt; $content =&gt; { mode =&gt; 'append' } );

   <b>Get</b> <b>the</b> <b>names</b> <b>of</b> <b>all</b> <b>files</b> <b>and</b> <b>subdirectories</b> <b>in</b> <b>a</b> <b>directory</b>
          # option no_fsdots excludes "." and ".." from the list
          my @dirs_and_files = $f-&gt;list_dir( '/foo' =&gt; { no_fsdots =&gt; 1 } );

   <b>Get</b> <b>the</b> <b>names</b> <b>of</b> <b>all</b> <b>files</b> <b>and</b> <b>subdirectories</b> <b>in</b> <b>a</b> <b>directory,</b> <b>recursively</b>
          my @dirs_and_files = $f-&gt;list_dir( '/foo' =&gt; { recurse =&gt; 1 } );

   <b>Do</b> <b>the</b> <b>same</b> <b>as</b> <b>above,</b> <b>but</b> <b>only</b> <b>to</b> <b>a</b> <b>certain</b> <b>maximum</b> <b>depth</b>
          my @dirs_and_files =
             $f-&gt;list_dir( '/foo' =&gt; { recurse =&gt; 1, max_depth =&gt; 3 } );

   <b>Do</b> <b>the</b> <b>same,</b> <b>but</b> <b>ignore</b> <b>potential</b> <b>filesystem</b> <b>loops</b> <b>for</b> <b>a</b> <b>speed</b> <b>boost</b>
          my @dirs_and_files =
             $f-&gt;list_dir( '/foo' =&gt; { recurse_fast =&gt; 1, max_depth =&gt; 3 } );

   <b>Get</b> <b>the</b> <b>names</b> <b>of</b> <b>all</b> <b>files</b> <b>(no</b> <b>subdirectories)</b> <b>in</b> <b>a</b> <b>directory</b>
          my @dirs_and_files = $f-&gt;list_dir( '/foo' =&gt; { files_only =&gt; } );

   <b>Get</b> <b>the</b> <b>names</b> <b>of</b> <b>all</b> <b>subdirectories</b> <b>(no</b> <b>files)</b> <b>in</b> <b>a</b> <b>directory</b>
          my @dirs_and_files = $f-&gt;list_dir( '/foo' =&gt; { dirs_only =&gt; 1 } );

   <b>Get</b> <b>the</b> <b>number</b> <b>of</b> <b>files</b> <b>and</b> <b>subdirectories</b> <b>in</b> <b>a</b> <b>directory</b>
          my @dirs_and_files = $f-&gt;list_dir(
             '/foo' =&gt; { no_fsdots =&gt; 1, count_only =&gt; 1 }
          );

   <b>Get</b> <b>the</b> <b>names</b> <b>of</b> <b>files</b> <b>and</b> <b>subdirs</b> <b>in</b> <b>a</b> <b>directory</b> <b>as</b> <b>separate</b> <b>array</b> <b>refs</b>
          my( $dirs, $files ) = $f-&gt;list_dir( '/foo' =&gt; { as_ref =&gt; 1 } );


             -OR-
          my( $dirs, $files ) = $f-&gt;list_dir(
             '/foo' =&gt; { dirs_as_ref =&gt; 1, files_as_ref =&gt; 1 }
          );

   <b>Load</b> <b>all</b> <b>the</b> <b>files</b> <b>in</b> <b>a</b> <b>directory</b> <b>into</b> <b>a</b> <b>hashref</b>
          my $templates = $f-&gt;load_dir( '/var/www/mysite/templates' );

          # $templates now contains something like:
          # {
          #    'header.html' =&gt; '...file contents...',
          #    'body.html'   =&gt; '...file contents...',
          #    'footer.html' =&gt; '...file contents...',
          # }

          print $templates-&gt;{'header.html'};

   <b>Recursively</b> <b>Get</b> <b>the</b> <b>names</b> <b>of</b> <b>all</b> <b>files</b> <b>that</b> <b>end</b> <b>in</b> <b>'.pl'</b>
          my @perl_files = $f-&gt;list_dir(
             '/home/scripts' =&gt; { files_match =&gt; qr/\.pl$/, recurse =&gt; 1 }
          }

   <b>Recursively</b> <b>get</b> <b>the</b> <b>names</b> <b>of</b> <b>all</b> <b>files</b> <b>that</b> <b>do</b> <b>NOT</b> <b>end</b> <b>in</b> <b>'.pl'</b>
       File::Util's "list_dir()" method doesn't have a "not_matches" counterpart to the "files_match" parameter.
       This is because it doesn't need one.  Perl already provides native support for negation in regular
       expressions.  The example below shows you how to make sure a file does NOT match the pattern you provide
       as a subexpression in a "negative zero width assertion".

       It might sound complicated for a beginner, but it's really not that hard.

       See the perlre documentation for more about negation in regular expressions.

          # find all files that don't end in ".pl"
          my @other_files = $f-&gt;list_dir(
             '/home/scripts' =&gt; { files_match =&gt; qr/^(?!.*\.pl$)/, recurse =&gt; 1 }
          }

   <b>Combine</b> <b>several</b> <b>options</b> <b>for</b> <b>list_dir()</b> <b>and</b> <b>be</b> <b>awesome</b>
       Find all files (not directories) that matches *any* number of given patterns (OR), whose parent directory
       matches *every* pattern in a list of given patterns (AND).  Also make sure that the path to the files
       matches a list of patterns (AND).

          # find the droids I'm looking for...
          my @files = $f-&gt;list_dir(
             '/home/anakin' =&gt; {
                files_match    =&gt; { or  =&gt; [ qr/droid/, qr/3p(o|O)$/i, qr/^R2/ },
                parent_matches =&gt; { and =&gt; [ qr/vader/i, qr/darth/i ] },
                path_matches   =&gt; { and =&gt; [ qr/obi-wan/i, qr/^(?!.*Qui-Gon)/ ] },
                recursive      =&gt; 1,
                files_only     =&gt; 1,
                max_depth      =&gt; 8,
             }
          );

       The above example would find and return files like:

          /home/anakin/mentors/obi-wan/villains/darth-vader/R2.png
          /home/anakin/mentors/obi-wan/villains/darth-vader/C3P0.dict
          /home/anakin/mentors/obi-wan/villains/darth-vader/my_droids.list

       But would not return files like:

          /home/anakin/mentors/Qui-Gon Jinn/villains/darth-vader/my_droids.list

   <b>Use</b> <b>a</b> <b>callback</b> <b>to</b> <b>descend</b> <b>through</b> <b>(walk)</b> <b>a</b> <b>directory</b> <b>tree</b>
       This is a really powerful feature. Because <b>File::Util::list_dir()</b> is a higher order function, it can take
       other functions as arguments.  We often refer to these as "callbacks".

       Any time you specify a callback, File::Util will make sure it's first argument is the name if the
       directory it's in (recursion), and then the second and third arguments are listrefs.  The first is a list
       reference containing the names of all subdirectories, and the second list ref contains the names of all
       the files.

       Below is a very simple example that doesn't really do much other than demonstrate the syntax.  You can
       see more full-blown examples of callbacks in the File::Util::Cookbook

          # print all subdirectories under /home/larry/
          $f-&gt;list_dir(
             '/home/larry' =&gt; {
                callback =&gt; sub { print shift @_, "\n" },
                recurse  =&gt; 1,
             }
          }

   <b>Get</b> <b>a</b> <b>directory</b> <b>tree</b> <b>in</b> <b>a</b> <b>hierarchical</b> <b>hashref</b>
          my $tree = $f-&gt;list_dir( '<a href="file:/tmp">/tmp</a>' =&gt; { as_tree =&gt; 1, recurse =&gt; 1 } );

          Gives you a datastructure like:
          {
            '/' =&gt; {
                     '_DIR_PARENT_' =&gt; undef,
                     '_DIR_SELF_' =&gt; '/',
                     'tmp' =&gt; {
                                '_DIR_PARENT_' =&gt; '/',
                                '_DIR_SELF_' =&gt; '<a href="file:/tmp">/tmp</a>',
                                'hJMOsoGuEb' =&gt; {
                                                  '_DIR_PARENT_' =&gt; '<a href="file:/tmp">/tmp</a>',
                                                  '_DIR_SELF_' =&gt; '/tmp/hJMOsoGuEb',
                                                  'a.txt' =&gt; '/tmp/hJMOsoGuEb/a.txt',
                                                  'b.log' =&gt; '/tmp/hJMOsoGuEb/b.log',
                                                  'c.ini' =&gt; '/tmp/hJMOsoGuEb/c.ini',
                                                  'd.bat' =&gt; '/tmp/hJMOsoGuEb/d.bat',
                                                  'e.sh' =&gt; '/tmp/hJMOsoGuEb/e.sh',
                                                  'f.conf' =&gt; '/tmp/hJMOsoGuEb/f.conf',
                                                  'g.bin' =&gt; '/tmp/hJMOsoGuEb/g.bin',
                                                  'h.rc' =&gt; '/tmp/hJMOsoGuEb/h.rc',
                                                }
                              }
                   }
          }

       *You can add the "dirmeta" option, set to 0 (false), to remove the special entries "_DIR_PARENT_" and
       "_DIR_SELF_" from each subdirectory branch.

       Example:

          my $tree = $f-&gt;list_dir(
             '<a href="file:/tmp">/tmp</a>' =&gt; { as_tree =&gt; 1, dirmeta =&gt; 0, recurse =&gt; 1 }
          );

       *You can still combine the "as_tree" option with other options, such as the regex pattern matching
       options covered above, or options like "recurse", or "files_only".

       *You should be careful using this feature with very large directory trees, due to the memory it might
       consume.  Memory usage is generally low, but will grow when you use this feature for larger and larger
       directory trees.  Bear in mind that the $ABORT_DEPTH limit applies here too (see File::Util
       documentation), which you can override manually by setting the "abort_depth" option:

          # set max recursion limit to an integer value as shown below
          $f-&gt;list_dir( '<a href="file:/tmp">/tmp</a>' =&gt; { as_tree =&gt; 1, recurse =&gt; 1, abort_depth =&gt; 123 } );

   <b>Determine</b> <b>if</b> <b>something</b> <b>is</b> <b>a</b> <b>valid</b> <b>file</b> <b>name</b>
       NOTE: This method is for determining if a <b>file</b> <b>name</b>  is valid.  It does not determine if a full path is
       valid.

          print $f-&gt;valid_filename( 'foo?+/bar~@/#baz.txt' ) ? 'ok' : 'bad';


             -OR-
          print File::Util-&gt;valid_filename( 'foo?+/bar~@/#baz.txt' ) ? 'ok' : 'bad';

       Like many other methods in File::Util, you can import this into your own namespace so you can call it
       like any other function, avoid the object-oriented syntax when you don't want or need it:  (This manual
       doesn't duplicate the main documentation by telling you every method you can import -- see the @EXPORT_OK
       section of the File::Util documentation)

          use File::Util qw( valid_filename );

          if ( valid_filename( 'foo?+/bar~@/#baz.txt' ) )
          {
             print 'file name is valid';
          }
          else
          {
             print 'That file name contains illegal characters';
          }

   <b>Get</b> <b>the</b> <b>number</b> <b>of</b> <b>lines</b> <b>in</b> <b>a</b> <b>file</b>
          my $linecount = $f-&gt;line_count( 'foo.txt' );

   <b>Split</b> <b>a</b> <b>file</b> <b>path</b> <b>into</b> <b>its</b> <b>parts</b>
       This method works differently than <b>atomize_path()</b>.  With this method, you get not just the components of
       the path, but each element in the form of a list.  The path will be split into the following pieces:
       (path root, if it exists, each subdirectory in the path, and the final file/directory )

          use File::Util qw( split_path );

          print "$_\n" for split_path( q{C:\foo\bar\baz\flarp.pl} )


             -OR-
          print "$_\n" for $f-&gt;split_path( q{C:\foo\bar\baz\flarp.pl} )


             -OR-
          print "$_\n" for File::Util-&gt;split_path( q{C:\foo\bar\baz\flarp.pl} )

          The output of all of the above commands is:
             C:\
             foo
             bar
             baz
             flarp.pl

       Above you see examples working on Windows-type paths.  Below are some examples using *nix-style paths:

          print "$_\n" for split_path( '/I/am/your/father/NOOOO' )

          The output of all of the above commands is:
             /
             I
             am
             your
             father
             NOOOO

   <b>Strip</b> <b>the</b> <b>path</b> <b>from</b> <b>a</b> <b>file</b> <b>name</b>
          # On Windows
          #  (prints "hosts")
          my $path = $f-&gt;strip_path( 'C:\WINDOWS\system32\drivers\etc\hosts' );

          # On Linux/Unix
          #  (prints "perl")
          print $f-&gt;strip_path( '<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?perl">/usr/bin/perl</a>' );

          # On a Mac
          #  (prints "baz")
          print $f-&gt;strip_path( 'foo:bar:baz' );


             -OR-
          use File::Util qw( strip_path );

          print strip_path( '/some/file/name' ); # prints "name"

   <b>Get</b> <b>the</b> <b>path</b> <b>preceding</b> <b>a</b> <b>file</b> <b>name</b>
          # On Windows
          #  (prints "C:\WINDOWS\system32\drivers\etc")
          my $path = $f-&gt;return_path( 'C:\WINDOWS\system32\drivers\etc\hosts' );

          # On Linux/Unix
          #  (prints "<a href="file:/usr/bin">/usr/bin</a>")
          print $f-&gt;return_path( '<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?perl">/usr/bin/perl</a>' );

          # On a (very, very old) Mac
          #  (prints "foo:bar")
          print $f-&gt;return_path( 'foo:bar:baz' );

   <b>Find</b> <b>out</b> <b>if</b> <b>the</b> <b>host</b> <b>system</b> <b>can</b> <b>use</b> <b>flock</b>
          use File::Util qw( can_flock );
          print can_flock;


             -OR-
          print File::Util-&gt;can_flock;


             -OR-
          print $f-&gt;can_flock;

   <b>Find</b> <b>out</b> <b>if</b> <b>the</b> <b>host</b> <b>system</b> <b>needs</b> <b>to</b> <b>call</b> <b>binmode</b> <b>on</b> <b>binary</b> <b>files</b>
          use File::Util qw( needs_binmode );
          print needs_binmode;


             -OR-
          print File::Util-&gt;needs_binmode;


             -OR-
          print $f-&gt;needs_binmode;

   <b>Find</b> <b>out</b> <b>if</b> <b>a</b> <b>file</b> <b>can</b> <b>be</b> <b>opened</b> <b>for</b> <b>read</b> <b>(based</b> <b>on</b> <b>file</b> <b>permissions)</b>
          my $is_readable = $f-&gt;is_readable( 'foo.txt' );

   <b>Find</b> <b>out</b> <b>if</b> <b>a</b> <b>file</b> <b>can</b> <b>be</b> <b>opened</b> <b>for</b> <b>write</b> <b>(based</b> <b>on</b> <b>file</b> <b>permissions)</b>
          my $is_writable = $f-&gt;is_writable( 'foo.txt' );

   <b>Escape</b> <b>illegal</b> <b>characters</b> <b>in</b> <b>a</b> <b>potential</b> <b>file</b> <b>name</b> <b>(and</b> <b>its</b> <b>path)</b>
          # prints "C__WINDOWS_system32_drivers_etc_hosts"
          print $f-&gt;escape_filename( 'C:\WINDOWS\system32\drivers\etc\hosts' );

          # prints "baz)__@^"
          # (strips the file path from the file name, then escapes it
          print $f-&gt;escape_filename( '/foo/bar/baz)?*@^' =&gt; { strip_path =&gt; 1 } );

          # prints "_foo_!_@so~me#illegal$_file&amp;(name"
          # (yes, technically that is a legal filename)
          print $f-&gt;escape_filename( q{\foo*!_@so~me#illegal$*file&amp;(name} );

   <b>Find</b> <b>out</b> <b>if</b> <b>the</b> <b>host</b> <b>system</b> <b>uses</b> <b>EBCDIC</b>
          use File::Util qw( ebcdic );
          print ebcdic;


             -OR-
          print File::Util-&gt;ebcdic;


             -OR-
          print $f-&gt;ebcdic;

   <b>Get</b> <b>the</b> <b>type(s)</b> <b>of</b> <b>an</b> <b>existent</b> <b>file</b>
          use File::Util qw( file_type );
          print file_type( 'foo.exe' );


             -OR-
          print File::Util-&gt;file_type( 'bar.txt' );


             -OR-
          print $f-&gt;file_type( '/dev/null' );

   <b>Get</b> <b>the</b> <b>bitmask</b> <b>of</b> <b>an</b> <b>existent</b> <b>file</b>
          use File::Util qw( bitmask );
          print bitmask( '/usr/sbin/sendmail' );


             -OR-
          print File::Util-&gt;bitmask( 'C:\COMMAND.COM' );


             -OR-
          print $f-&gt;bitmask( '/dev/null' );

   <b>Get</b> <b>time</b> <b>of</b> <b>creation</b> <b>for</b> <b>a</b> <b>file</b>
          use File::Util qw( created );
          print scalar localtime created( '/usr/bin/exim' );


             -OR-
          print scalar localtime File::Util-&gt;created( 'C:\COMMAND.COM' );


             -OR-
          print scalar localtime $f-&gt;created( '<a href="file:/bin/less">/bin/less</a>' );

   <b>Get</b> <b>the</b> <b>last</b> <b>access</b> <b>time</b> <b>for</b> <b>a</b> <b>file</b>
          use File::Util qw( last_access );
          print scalar localtime last_access( '/usr/bin/exim' );


             -OR-
          print scalar localtime File::Util-&gt;last_access( 'C:\COMMAND.COM' );


             -OR-
          print scalar localtime $f-&gt;last_access( '<a href="file:/bin/less">/bin/less</a>' );

   <b>Get</b> <b>the</b> <b>inode</b> <b>change</b> <b>time</b> <b>for</b> <b>a</b> <b>file</b>
          use File::Util qw( last_changed );
          print scalar localtime last_changed( '<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?vim">/usr/bin/vim</a>' );


             -OR-
          print scalar localtime File::Util-&gt;last_changed( 'C:\COMMAND.COM' );


             -OR-
          print scalar localtime $f-&gt;last_changed( '<a href="file:/bin/cpio">/bin/cpio</a>' );

   <b>Get</b> <b>the</b> <b>last</b> <b>modified</b> <b>time</b> <b>for</b> <b>a</b> <b>file</b>
          use File::Util qw( last_modified );
          print scalar localtime last_modified( '/usr/bin/exim' );


             -OR-
          print scalar localtime File::Util-&gt;last_modified( 'C:\COMMAND.COM' );


             -OR-
          print scalar localtime $f-&gt;last_modified( '<a href="file:/bin/less">/bin/less</a>' );

   <b>Make</b> <b>a</b> <b>new</b> <b>directory,</b> <b>recursively</b> <b>if</b> <b>necessary</b>
          $f-&gt;make_dir( '/var/tmp/tempfiles/foo/bar/' );

          # you can optionally specify a bitmask for the new directory.
          # the bitmask is combined with the user's current umask for the creation
          # mode of the directory.  (You should usually omit this.)

          $f-&gt;make_dir( '/var/tmp/tempfiles/foo/bar/', 0755 );

   <b>Touch</b> <b>a</b> <b>file</b>
          use File::Util qw( touch );
          touch( 'somefile.txt' );


             -OR-
          $f-&gt;touch( '/foo/bar/baz.tmp' );

   <b>Truncate</b> <b>a</b> <b>file</b>
          $f-&gt;trunc( '/wibble/wombat/noot.tmp' );

   <b>Get</b> <b>the</b> <b>correct</b> <b>path</b> <b>separator</b> <b>for</b> <b>the</b> <b>host</b> <b>system</b>
          use File::Util qw( SL );
          print SL;


             -OR-
          print File::Util-&gt;SL;


             -OR-
          print $f-&gt;SL;

   <b>Get</b> <b>the</b> <b>correct</b> <b>newline</b> <b>character</b> <b>for</b> <b>the</b> <b>host</b> <b>system</b>
          use File::Util qw( NL );

          print NL;


             -OR-
          print File::Util-&gt;NL;


             -OR-
          print $f-&gt;NL;

   <b>Choose</b> <b>what</b> <b>to</b> <b>do</b> <b>if</b> <b>there's</b> <b>a</b> <b>problem</b> <b>(die,</b> <b>warn,</b> <b>zero,</b> <b>undefined,</b> <b>subref)</b>
          # When doing things with IO that might fail, set up good error handlers

          # "Fail, these examples will..."

          # If this call fails, die with an error message (*default*)
          $f-&gt;write_file( 'bobafett.txt' =&gt; $content =&gt; { onfail =&gt; 'die' } );

          # If this call fails, issue a warning to STDERR, but don't die/exit
          $f-&gt;list_dir( '/home/greivous' =&gt; { onfail =&gt; 'warn' } );

          # If this call fails, return a zero value (0), and don't die/exit
          $f-&gt;open_handle( '/home/ventress/.emacs' =&gt; { onfail =&gt; 'zero' } );

          # If this call fails, return undef, and don't die/exit
          $f-&gt;load_file( '/home/vader/darkside.manual' =&gt; { onfail =&gt; 'undefined' } );

          # If this call fails, execute the subroutine code and do whatever it says
          # This code tries to load one directory, and failing that, loads another
          $f-&gt;load_dir( '/home/palpatine/lofty_plans/' =&gt; {
                onfail =&gt; sub { return $f-&gt;load_dir( '/home/sidious/evil_plots/' ) }
             }
          );

</pre><h4><b>AUTHORS</b></h4><pre>
       Tommy Butler &lt;<a href="http://www.atrixnet.com/contact">http://www.atrixnet.com/contact</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright(C) 2001-2013, Tommy Butler.  All rights reserved.

</pre><h4><b>LICENSE</b></h4><pre>
       This library is free software, you may redistribute it and/or modify it under the same terms as Perl
       itself. For more details, see the full text of the LICENSE file that is included in this distribution.

</pre><h4><b>LIMITATION</b> <b>OF</b> <b>WARRANTY</b></h4><pre>
       This software is distributed in the hope that it will be useful, but without any warranty; without even
       the implied warranty of merchantability or fitness for a particular purpose.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       File::Util::Manual, File::Util::Cookbook

perl v5.36.0                                       2022-11-29                  <u>File::Util::Manual::<a href="../man3pm/Examples.3pm.html">Examples</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>