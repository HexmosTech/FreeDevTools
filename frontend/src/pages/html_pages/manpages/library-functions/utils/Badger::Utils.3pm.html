<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Badger::Utils - various utility functions</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libbadger-perl">libbadger-perl_0.16-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Badger::Utils - various utility functions

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Badger::Utils 'blessed params';

           sub example {
               my $self   = shift;
               my $params = params(@_);

               if (blessed $self) {
                   print "self is blessed\n";
               }
           }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module implements a number of utility functions.  It also provides access to all of the utility
       functions in Scalar::Util, List::Util, List::MoreUtils, Hash::Util and Digest::MD5 as a convenience.

           use Badger::Utils 'blessed reftype first max any all lock_hash md5_hex';

       The single line of code shown here will import "blessed" and "reftype" from Scalar::Util, "first" and
       "max" from List::Util, "any" and "all" from List::Util, "lock_hash" from Hash::Util, and "md5_hex" from
       Digest::MD5.

       These modules are loaded on demand so there's no overhead incurred if you don't use them (other than a
       lookup table so we know where to find them).

</pre><h4><b>EXPORTABLE</b> <b>CONSTANTS</b></h4><pre>
   <b>UTILS</b>
       Exports a "UTILS" constant which contains the name of the "Badger::Utils" class.

</pre><h4><b>EXPORTABLE</b> <b>FUNCTIONS</b></h4><pre>
       "Badger::Utils" can automatically load and export functions defined in the Scalar::Util, List::Util,
       List::MoreUtils, Hash::Util and Digest::MD5 Perl modules.

           use Badger::Utils 'blessed max md5_hex'

           # a rather contrived example
           if (blessed $some_ref) {
               print md5_hex(max @some_list);
           }

       "Badger::Utils" can also automatically load and export functions and constants defined in various other
       Badger modules.  For example, you can use "Badger::Utils" to load the <b>Now()</b> function from
       Badger::Timestamp.

           use Badger::Utils 'Now';
           print Now-&gt;year;            # prints the current year

   <b>Badger::Duration</b>
       <u>DURATION</u>

       An alias for Badger::Duration.

       <u><b>Duration()</b></u>

       A function to create a Badger::Duration object.

           use Badger::Utils 'Duration';

           my $duration = Duration('2 hours 20 minutes');
           print $duration-&gt;seconds;

   <b>Badger::Filesystem</b>
       <u>FS,</u>

       An alias for "Badger::Filesystem".

       <u>VFS,</u>

       An alias for "Badger::Filesystem::Virtual".

       <u><b>File()</b></u>

       A function for creating a Badger::Filesystem::File object.

           my $f = File('filename');
           print $filename-&gt;modified;

       <u><b>Dir()</b></u>

       A function for creating a Badger::Filesystem::Directory object.

       <u><b>Bin()</b></u>

       Returns a Badger::Filesystem::Directory object for the directory in which the current script is located.
       See <b>Bin()</b> in Badger::Filesystem.

       <u><b>Cwd()</b></u>

       Returns a Badger::Filesystem::Directory object for the current working directory.  See <b>Cwd()</b> in
       Badger::Filesystem.

   <b>Badger::Filter</b>
       <u>FILTER</u>

       An alias for "Badger::Filter".

       <u><b>Filter()</b></u>

       Function for returning a Badger::Filter object for filtering data.

           my $filter = Filter(
               include =&gt; [ qr/beer/ ],
               exclude =&gt; [ 'root beer' ],
           );
           my @matches = $filter-&gt;accept(
               'beer', 'lite beer', 'root beer', 'soda'
           );

   <b>Badger::Logic</b>
       <u>LOGIC</u>

       An alias for "Badger::Logic".

       <u><b>Logic()</b>.</u>

       Function for returning a Badger::Logic object for representing simple logical assertions.

           my $logic  = Logic('trusted and not banned');
           my $person = {
               trusted =&gt; 1,
               banned  =&gt; 0,
           };

           if ($logic-&gt;evaluate($person)) {
               ...
           }

   <b>Badger::Timestamp</b>
       <u>TIMESTAMP</u>

       An alias for "Badger::Timestamp".

       <u>TS</u>

       A shorter alias for "Badger::Timestamp".

       <u><b>Now()</b>.</u>

       Function for returning a Badger::Timestamp object representing the current date and time.

           print Now-&gt;date;

       <u><b>Timestamp()</b></u>

       Function for creating a Badger::Timestamp object.

           my $stamp = Timestamp('2013-03-19 16:20:00');
           print $stamp-&gt;time;
           print $stamp-&gt;year;

   <b>Badger::URL</b>
       <u><b>URL()</b></u>

       Function for creating a Badger::URL object for representing and manipulating a URL.

           my $url = URL('<a href="http://badgerpower.org/example">http://badgerpower.org/example</a>?animal=badger');
           print $url-&gt;path;
           print $url-&gt;query;
           print $url-&gt;server;

   <b>Text</b> <b>Utility</b> <b>Functions</b>
       <u>alternates($text)</u>

       This function is used internally by the <b>permute_fragments()</b> function. It returns a reference to a list
       containing the alternates split from $text.

           alternates('foo|bar');          # returns ['foo','bar']
           alternates('foo');              # returns ['','bar']

       If the $text doesn't contain the "|" character then it is assumed to be an optional item.  A list
       reference is returned containing the empty string as the first element and the original $text string as
       the second.

       <u>camel_case($string)</u> <u>/</u> <u>CamelCase($string)</u>

       Converts a lower case string where words are separated by underscores (e.g.  "like_this_example") into
       CamelCase where each word is capitalised and words are joined together (e.g. "LikeThisExample").

       According to Perl convention (and personal preference), we use the lower case form wherever possible.
       However, Perl's convention also dictates that module names should be in CamelCase.  This function
       performs that conversion.

       <u>dotid($text)</u>

       The function returns a lower case representation of the text passed as an argument with all non-word
       character sequences replaced with dots.

           print dotid('Foo::Bar');            # foo.bar

       <u>inflect($n,</u> <u>$noun,</u> <u>$format,</u> <u>$none_word)</u>

       This uses the "plurality()" function to construct an appropriate string listing the number $n of $noun
       items.

           inflect(0, 'package');      # no packages
           inflect(1, 'package');      # 1 package
           inflect(2, 'package');      # 2 packages

       Or:

           inflect($n, 'wo(men|man|men');

       The third optional argument can be used to specify a format string for xprintf to generate the string.
       The default value is "%s %s", expecting the number (or word 'no') as the first parameter, followed by the
       relevant noun as the second.

           inflect($n, 'item', 'There are &lt;b&gt;%s&lt;/b&gt; %s in your basket');

       The fourth optional argument can be used to provide a word other than 'no' to be used when $n is zero.

           inflect(
               $n, 'item',
               'You have %s %s in your basket',
               'none, none more'
           );

       Please note that this function is intentionally limited.  It's sufficient to generate simple headings,
       summary lines, etc., but isn't intended to be comprehensive or work in languages other than English.

       <u>numlike($item)</u>

       This is an alias to the "looks_like_number()" function defined in Scalar::Util.

       <u>permute_fragments($text)</u>

       This function permutes any optional or alternate fragments embedded in parentheses. For example,
       Badger(X) is permuted as ("Badger", "BadgerX") and "Badger(X|Y)" is permuted as ("BadgerX", "BadgerY").

           permute_fragments('Badger(X)');     # Badger, BadgerX
           permute_fragments('Badger(X|Y)');   # BadgerX, BadgerY

       Multiple fragments may be embedded. They are expanded in order from left to right, with the rightmost
       fragments changing most often.

           permute_fragments('A(1|2):B(3|4)')  # A1:B3, A1:B4, A2:B3, A2:B4

       <u>plural($noun)</u>

       The function makes a very naive attempt at pluralising the singular noun word passed as an argument.

       If the $noun word ends in "ss", "sh", "ch" or "x" then "es" will be added to the end of it.

           print plural('class');      # classes
           print plural('hash');       # hashes
           print plural('patch');      # patches
           print plural('box');        # boxes

       If it ends in "y" then it will be replaced with "ies".

           print plural('party');      # parties

       In all other cases, "s" will be added to the end of the word.

           print plural('device');     # devices

       It will fail miserably on many common words.

           print plural('woman');      # womans     FAIL!
           print plural('child');      # childs     FAIL!
           print plural('foot');       # foots      FAIL!

       This function should <u>only</u> be used in cases where the singular noun is known in advance and has a regular
       form that can be pluralised correctly by the algorithm described above. For example, the Badger::Factory
       module allows you to specify $ITEM and $ITEMS package variable to provide the singular and plural names
       of the items that the factory manages.

           our $ITEM  = 'person';
           our $ITEMS = 'people';

       If the singular noun is sufficiently regular then the $ITEMS can be omitted and the "plural" function
       will be used.

           our $ITEM  = 'codec';       # $ITEMS defaults to 'codecs'

       In this case we know that "codec" will pluralise correctly to "codecs" and can safely leave $ITEMS
       undefined.

       For more robust pluralisation of English words, you should use the Lingua::EN::Inflect module by Damian
       Conway. For further information on the difficulties of correctly pluralising English, and details of the
       implementation of Lingua::EN::Inflect, see Damian's paper "An Algorithmic Approach to English
       Pluralization" at &lt;<a href="http://www.csse.monash.edu.au/~damian/papers/HTML/Plurals.html">http://www.csse.monash.edu.au/~damian/papers/HTML/Plurals.html</a>&gt;

       <u>plurality($n,</u> <u>$noun)</u>

       This function can be used to construct the correct singular or plural form for a given number, $n, of a
       noun, $noun in the English language.  For nouns that pluralise regularly (i.e. via the quick-and-dirty
       <b>plural()</b> function), the following is sufficient:

           plurality(0, 'package');      # packages
           plurality(1, 'package');      # package
           plurality(2, 'package');      # packages

       For nouns that don't pluralise regularly, or where more complicated phrases should be constructed, the
       alternates for 0, 1 and 2 or more items can be specified in the format expected by <b>permute_fragments()</b>.

           plurality($n, 'women|woman|women');     # 0 women, 1 woman, 2 women
           plurality($n, 'wo(men|man|men');        # optimised form

       <u>random_name($length,@data)</u>

       Generates a random name of maximum length $length using any additional seeding data passed as @args.  If
       $length is undefined then the default value in $RANDOM_NAME_LENGTH (32) is used.

           my $name = random_name();
           my $name = <a href="../man64/random_name.64.html">random_name</a>(64);

       <u>textlike($item)</u>

       Returns true if $item is a non-reference scalar or an object that has an overloaded stringification
       operator.

           use Badger::Filesystem 'File';
           use Badger::Utils 'textlike';

           # Badger::Filesystem::File objects have overloaded string operator
           my $file = File('example.txt');
           print $file;                                # example.txt
           print textlike $file ? 'ok' : 'not ok';     # ok

       <u>wrap($text,</u> <u>$width,</u> <u>$indent)</u>

       Simple subroutine to wrap $text to a fixed $width, applying an optional indent of $indent spaces.  It
       uses a trivial algorithm which splits the text into words, then rejoins them as lines.  It has an
       additional hack to recognise the literal sequence '\n' as a magical word indicating a forced newline
       break.  It must be specified as a separate whitespace delimited word.

           print wrap('Foo \n Bar');

       If anyone knows how to make Text::Wrap handle this, or knows of a better solution then please let me
       know.

       <u>xprintf($format,@args)</u>

       A wrapper around "sprintf()" which provides some syntactic sugar for embedding positional parameters.

           xprintf('The &lt;2&gt; sat on the &lt;1&gt;', 'mat', 'cat');
           xprintf('The &lt;1&gt; costs &lt;2:%.2f&gt;', 'widget', 11.99);

   <b>Hash</b> <b>Utility</b> <b>Functions</b>
       <u>extend($hash,</u> <u>$another_hash,</u> <u>$yet_another_hash,</u> <u>...)</u>

       This function merges the contents of several hash arrays into one.  The first hash array will end up
       containing the keys and values of all the others.

           my $one = { a =&gt; 10 };
           my $two = { b =&gt; 20 };
           extend($one, $two);     # $one now contains a and b

       If you want to create a new hash, simply pass an empty hash in as the first argument.

           my $mixed = extend(
               { },
               $one.
               $two
           );

       You can also extend a hash array with named parameters.

           extend(
               $mixed,
               c =&gt; 30,
               d =&gt; 40,
           );

       You can mix and match the two calling conventions as long as any hash references come first.

           extend(
               { },
               $mixed,
               $a,
               $b,
               c =&gt; 30,
               d =&gt; 40,
           );

       <u>merge($hash,</u> <u>$another_hash,</u> <u>$yet_another_hash,</u> <u>...)</u>

       This function is a version of <b>extend()</b> that merges nested hash arrays to any depth.

           my $one = {
               a =&gt; 10,
               b =&gt; {
                   c =&gt; 20,
                   d =&gt; {
                       e =&gt; 30,
                   }
               },
           };
           my $two = {
               b =&gt; {
                   d =&gt; {
                       f =&gt; 40
                   },
                   g =&gt; 50,
               },
               h =&gt; 60
           };

           merge($one, $two);

       After merging $one will contain:

           {
               a =&gt; 10,
               b =&gt; {
                   c =&gt; 20,
                   d =&gt; {
                       e =&gt; 30,
                       f =&gt; 40
                   }
                   g =&gt; 50,
               },
               h =&gt; 60
           }

       <u>hash_each($hash,$function)</u>

       Iterates over each key/value pair in the hash array referenced by the first argument, $hash, calling the
       function passed as the second argument, $function.

       The function is called with 3 arguments: a reference to the hash array, the key of the current item and
       the value.

           hash_each(
               { a =&gt; 10, b =&gt; 20 },
               sub {
                   my ($hash, $key, $value) = @_;
                   print "hash item $key is $value\n";
               }
           );

   <b>List</b> <b>Utility</b> <b>Functions</b>
       <u>list_each($list,$function)</u>

       Iterates over each item in the array referenced by the first argument, $list, calling the function passed
       as the second argument, $function.

       The function is called with 3 arguments: a reference to the list, the index of the current index (from 0
       to size-1) and the item in the list at that index.

           list_each(
               [10,20,30],
               sub {
                   my ($list, $index, $item) = @_;
                   print "list item #$index is $item\n";
               }
           );

       <u>split_to_list($list)</u>

       This splits a string of words separated by whitespace (and/or commas) into a list reference.  The
       following are all valid and equivalent:

           my $list = split_to_list("foo bar baz");    # =&gt; ['foo', 'bar', 'baz']
           my $list = split_to_list("foo,bar,baz");
           my $list = split_to_list("foo, bar, baz");

       If the argument is already a list then it is returned unmodified.

   <b>Object</b> <b>Utility</b> <b>Functions</b>
       <u>is_object($class,$object)</u>

       Returns true if the $object is a blessed reference which isa $class.

           use Badger::Filesystem 'FS';
           use Badger::Utils 'is_object';

           if (is_object( FS =&gt; $object )) {       # FS == Badger::Filesystem
               print $object, ' isa ', FS, "\n";
           }

   <b>Parameter</b> <b>Handling</b> <b>Functions</b>
       <u>params(@args)</u>

       Method to coerce a list of named parameters to a hash array reference.  If the first argument is a
       reference to a hash array then it is returned.  Otherwise the arguments are folded into a hash reference.

           use Badger::Utils 'params';

           params({ a =&gt; 10 });            # { a =&gt; 10 }
           params( a =&gt; 10 );              # { a =&gt; 10 }

       Pro Tip: If you're getting warnings about an "Odd number of elements in anonymous hash" then try enabling
       debugging in "Badger::Utils". To do this, add the following to the start of your program before you've
       loaded "Badger::Utils":

           use Badger::Debug
               modules =&gt; 'Badger::Utils'

       When debugging is enabled in "Badger::Utils" you'll get a full stack backtrace showing you where the
       subroutine was called from.  e.g.

           Badger::Utils::self_params() called with an odd number of arguments: &lt;undef&gt;
           #1: Called from Foo::bar in /path/to/Foo/Bar.pm at line 210
           #2: Called from Wam::bam in /path/to/Wam/Bam.pm at line 420
           #3: Called from main in /path/to/your/script.pl at line 217

       <u>self_params(@args)</u>

       Similar to <b>params()</b> but also expects a $self reference at the start of the argument list.

           use Badger::Utils 'self_params';

           sub example {
               my ($self, $params) = self_params(@_);
               # do something...
           }

       If you enable debugging in "Badger::Utils" then you'll get a stack backtrace in the event of an odd
       number of parameters being passed to this function.  See <b>params()</b> for further details.

       <u>odd_params(@_)</u>

       This is an internal function used by <b>params()</b> and <b>self_params()</b> to report any attempt to pass an odd
       number of arguments to either of them.  It can be enabled by setting $Badger::Utils::DEBUG to a true
       value.

           use Badger::Utils 'params';
           $Badger::Utils::DEBUG = 1;

           my $hash = params( foo =&gt; 10, 20 );    # oops!

       The above code will raise a warning showing the arguments passed and a stack backtrace, allowing you to
       easily track down and fix the offending code.  Apart from obvious typos like the above, this is most
       likely to happen if you call a function or methods that returns an empty list.  e.g.

           params(
               foo =&gt; 10,
               bar =&gt; get_the_bar_value(),
           );

       If "get_the_bar_value()" returns an empty list then you'll end up with an odd number of elements being
       passed to "params()".  You can correct this by providing "undef" as an alternative value.  e.g.

           params(
               foo =&gt; 10,
               bar =&gt; get_the_bar_value() || undef,
           );

   <b>URI</b> <b>Utility</b> <b>Functions</b>
       The following functions are provided for very simple manipulation of URI paths.  You should consider
       using the URI module for anything non-trivial.

       <u>join_uri(frag1,</u> <u>frag2,</u> <u>etc)</u>

       Joins the elements of a URI passed as arguments into a single URI.

           use Contentity::Utils 'join_uri';
           print join_uri('/foo', 'bar');     # /foo/bar

       <u>resolve_uri(base,</u> <u>frag1,</u> <u>frag2,</u> <u>etc)</u>

       The first argument is a base URI.  The remaining argument(s) are joined (via <b>join_uri()</b>) to construct a
       relative URI.  If the relative URI begins with "/" then it is considered absolute and is returned
       unchanged.  Otherwise it is appended to the base URI.

           use Contentity::Utils 'resolve_uri';
           print resolve_uri('/foo', 'bar/baz');     # /foo/bar/baz
           print resolve_uri('/foo', '/bar/baz');    # /bar/baz

   <b>Miscellanesou</b> <b>Utility</b> <b>Functions</b>
       <u>module_file($name)</u>

       Returns the module name passed as an argument as a relative filesystem path suitable for feeding into
       "require()"

           print module_file('My::Module');     # My/Module.pm

</pre><h4><b>AUTHOR</b></h4><pre>
       Andy Wardley &lt;<a href="http://wardley.org/">http://wardley.org/</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (C) 1996-2013 Andy Wardley.  All Rights Reserved.

       This module is free software; you can redistribute it and/or modify it under the same terms as Perl
       itself.

perl v5.36.0                                       2023-08-28                                 <u>Badger::<a href="../man3pm/Utils.3pm.html">Utils</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>