<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>util_crc - <util/crc16.h>: CRC Computations</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/avr-libc">avr-libc_2.2.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       util_crc - &lt;util/crc16.h&gt;: CRC Computations

</pre><h4><b>SYNOPSIS</b></h4><pre>
   <b>Functions</b>
       static <b>uint16_t</b> <b>_crc16_update</b> (<b>uint16_t</b> __crc, <b>uint8_t</b> __data)
       static <b>uint16_t</b> <b>_crc_xmodem_update</b> (<b>uint16_t</b> __crc, <b>uint8_t</b> __data)
       static <b>uint16_t</b> <b>_crc_ccitt_update</b> (<b>uint16_t</b> __crc, <b>uint8_t</b> __data)
       static <b>uint8_t</b> <b>_crc_ibutton_update</b> (<b>uint8_t</b> __crc, <b>uint8_t</b> __data)
       static <b>uint8_t</b> <b>_crc8_ccitt_update</b> (<b>uint8_t</b> __crc, <b>uint8_t</b> __data)

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
       #include &lt;util/crc16.h&gt;

       This header file provides a optimized inline functions for calculating cyclic redundancy checks (CRC)
       using common polynomials.

       <b>References:</b>

       See the Dallas Semiconductor app note 27 for 8051 assembler example and general CRC optimization
       suggestions. The table on the last page of the app note is the key to understanding these
       implementations.

       Jack Crenshaw's 'Implementing CRCs' article in the January 1992 isue of <u>Embedded</u> <u>Systems</u> <u>Programming</u>.
       This may be difficult to find, but it explains CRC's in very clear and concise terms. Well worth the
       effort to obtain a copy.

       A typical application would look like:

       // Dallas iButton test vector.
       uint8_t serno[] = { 0x02, 0x1c, 0xb8, 0x01, 0, 0, 0, 0xa2 };

       int
       checkcrc (void)
       {
           uint8_t crc = 0, i;

           for (i = 0; i &lt; sizeof serno / sizeof serno[0]; i++)
               crc = _crc_ibutton_update (crc, serno[i]);

           return crc; // must be 0
       }

</pre><h4><b>Function</b> <b>Documentation</b></h4><pre>
   <b>static</b> <b>uint16_t</b> <b>_crc16_update</b> <b>(uint16_t</b> <b>__crc,</b> <b>uint8_t</b> <b>__data)</b> <b>[inline],</b>  <b>[static]</b>
       Optimized CRC-16 calculation.

       Polynomial: x16  + x15  + x2  + 1 (0xa001)
        Initial value: 0xffff

       This CRC is normally used in disk-drive controllers.

       The following is the equivalent functionality written in C.

       uint16_t
       crc16_update (uint16_t crc, uint8_t a)
       {
           crc ^= a;
           for (int i = 0; i &lt; 8; ++i)
           {
               if (crc &amp; 1)
                   crc = (crc &gt;&gt; 1) ^ 0xA001;
               else
                   crc = crc &gt;&gt; 1;
           }

           return crc;
       }

   <b>static</b> <b>uint8_t</b> <b>_crc8_ccitt_update</b> <b>(uint8_t</b> <b>__crc,</b> <b>uint8_t</b> <b>__data)</b> <b>[inline],</b>  <b>[static]</b>
       Optimized CRC-8-CCITT calculation.

       Polynomial: x8  + x2  + x + 1 (0xE0)

       For use with simple CRC-8
        Initial value: 0x0

       For use with CRC-8-ROHC
        Initial value: 0xff
        Reference: <a href="http://tools.ietf.org/html/rfc3095">http://tools.ietf.org/html/rfc3095</a>#section-5.9.1

       For use with CRC-8-ATM/ITU
        Initial value: 0xff
        Final XOR value: 0x55
        Reference: <a href="http://www.itu.int/rec/T-REC-I.432.1-199902-I/en">http://www.itu.int/rec/T-REC-I.432.1-199902-I/en</a>

       The C equivalent has been originally written by Dave Hylands. Assembly code is based on
       _crc_ibutton_update optimization.

       The following is the equivalent functionality written in C.

       uint8_t
       _crc8_ccitt_update (uint8_t inCrc, uint8_t inData)
       {
           uint8_t data = inCrc ^ inData;

           for (int i = 0; i &lt; 8; i++)
           {
               if ((data &amp; 0x80) != 0)
               {
                   data &lt;&lt;= 1;
                   data ^= 0x07;
               }
               else
               {
                   data &lt;&lt;= 1;
               }
           }
           return data;
       }

   <b>static</b> <b>uint16_t</b> <b>_crc_ccitt_update</b> <b>(uint16_t</b> <b>__crc,</b> <b>uint8_t</b> <b>__data)</b> <b>[inline],</b>  <b>[static]</b>
       Optimized CRC-CCITT calculation.

       Polynomial: x16  + x12  + x5  + 1 (0x8408)
        Initial value: 0xffff

       This is the CRC used by PPP and IrDA.

       See RFC1171 (PPP protocol) and IrDA IrLAP 1.1

       <b>Note</b>
           Although the CCITT polynomial is the same as that used by the Xmodem protocol, they are quite
           different. The difference is in how the bits are shifted through the alorgithm. Xmodem shifts the MSB
           of the CRC and the input first, while CCITT shifts the LSB of the CRC and the input first.

       The following is the equivalent functionality written in C.

       uint16_t
       crc_ccitt_update (uint16_t crc, uint8_t data)
       {
           data ^= lo8 (crc);
           data ^= data &lt;&lt; 4;

           return ((((uint16_t)data &lt;&lt; 8) | hi8 (crc)) ^ (uint8_t)(data &gt;&gt; 4)
                   ^ ((uint16_t)data &lt;&lt; 3));
       }

   <b>static</b> <b>uint8_t</b> <b>_crc_ibutton_update</b> <b>(uint8_t</b> <b>__crc,</b> <b>uint8_t</b> <b>__data)</b> <b>[inline],</b>  <b>[static]</b>
       Optimized Dallas (now Maxim) iButton 8-bit CRC calculation.

       Polynomial: x8  + x5  + x4  + 1 (0x8C)
        Initial value: 0x0

       See <a href="http://www.maxim-ic.com/appnotes.cfm/appnote_number/27">http://www.maxim-ic.com/appnotes.cfm/appnote_number/27</a>

       The following is the equivalent functionality written in C.

       uint8_t
       _crc_ibutton_update (uint8_t crc, uint8_t data)
       {
           crc = crc ^ data;
           for (uint8_t i = 0; i &lt; 8; i++)
           {
               if (crc &amp; 0x01)
                   crc = (crc &gt;&gt; 1) ^ 0x8C;
               else
                   crc &gt;&gt;= 1;
           }

           return crc;
       }

   <b>static</b> <b>uint16_t</b> <b>_crc_xmodem_update</b> <b>(uint16_t</b> <b>__crc,</b> <b>uint8_t</b> <b>__data)</b> <b>[inline],</b>  <b>[static]</b>
       Optimized CRC-XMODEM calculation.

       Polynomial: x16  + x12  + x5  + 1 (0x1021)
        Initial value: 0x0

       This is the CRC used by the Xmodem-CRC protocol.

       The following is the equivalent functionality written in C.

       uint16_t
       crc_xmodem_update (uint16_t crc, uint8_t data)
       {
           crc = crc ^ ((uint16_t)data &lt;&lt; 8);
           for (int i = 0; i &lt; 8; i++)
           {
               if (crc &amp; 0x8000)
                   crc = (crc &lt;&lt; 1) ^ 0x1021;
               else
                   crc &lt;&lt;= 1;
           }

           return crc;
       }

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for AVR-LibC from the source code.

AVR-LibC                                          Version 2.2.1                                   <u><a href="../man3avr/util_crc.3avr.html">util_crc</a></u>(3avr)
</pre>
 </div>
</div></section>
</div>
</body>
</html>