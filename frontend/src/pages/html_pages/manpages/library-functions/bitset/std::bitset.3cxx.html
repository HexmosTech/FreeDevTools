<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>std::bitset< _Nb > - The bitset class represents a fixed-size sequence of bits.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libstdc++-13-doc">libstdc++-13-doc_13.4.0-1ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       std::bitset&lt; _Nb &gt; - The bitset class represents a <u>fixed-size</u> sequence of bits.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;bitset&gt;

       Inherits <b>std::_Base_bitset&lt;((_Nb)/(__CHAR_BIT__</b> <b>*__SIZEOF_LONG__)+((_Nb)</b> <b>%(__CHAR_BIT__</b>
       <b>*__SIZEOF_LONG__)==0</b> <b>?</b> <b>0</b> <b>:1))&gt;</b>.

   <b>Classes</b>
       class <b>reference</b>

   <b>Public</b> <b>Member</b> <b>Functions</b>
       constexpr <b>bitset</b> () noexcept
           All bits set to zero.
       template&lt;<b>typename</b> _CharT &gt; constexpr <b>bitset</b> (const _CharT *<b>__str</b>, <b>typename</b> <b>__bitset::__string</b>&lt; _CharT
           &gt;::size_type __n=<b>__bitset::__string</b>&lt; _CharT &gt;::npos, _CharT <b>__zero</b>=_CharT('0'), _CharT
           <b>__one</b>=_CharT('1'))
       template&lt;<b>class</b> _CharT , <b>class</b> _Traits , <b>class</b> _Alloc &gt; constexpr <b>bitset</b> (const <b>std::basic_string</b>&lt; _CharT,
           _Traits, _Alloc &gt; &amp;<b>__s</b>, size_t <b>__position</b>, size_t __n)
       template&lt;<b>class</b> _CharT , <b>class</b> _Traits , <b>class</b> _Alloc &gt; constexpr <b>bitset</b> (const <b>std::basic_string</b>&lt; _CharT,
           _Traits, _Alloc &gt; &amp;<b>__s</b>, size_t <b>__position</b>, size_t __n, _CharT <b>__zero</b>, _CharT <b>__one</b>=_CharT('1'))
       template&lt;<b>class</b> _CharT , <b>class</b> _Traits , <b>class</b> _Alloc &gt; constexpr <b>bitset</b> (const <b>std::basic_string</b>&lt; _CharT,
           _Traits, _Alloc &gt; &amp;<b>__s</b>, size_t <b>__position</b>=0)
       constexpr <b>bitset</b> (unsigned long long __val) noexcept
           Initial bits bitwise-copied from a single word (others set to zero).
       constexpr size_t <b>_Find_first</b> () const noexcept
           Finds the index of the first 'on' bit.
       constexpr size_t <b>_Find_next</b> (size_t <b>__prev</b>) const noexcept
           Finds the index of the next 'on' bit after prev.
       constexpr bool <b>all</b> () const noexcept
           Tests whether all the bits are on.
       constexpr bool <b>any</b> () const noexcept
           Tests whether any of the bits are on.
       constexpr size_t <b>count</b> () const noexcept
           Returns the number of bits which are set.
       constexpr <b>bitset</b>&lt; <b>_Nb</b> &gt; &amp; <b>flip</b> () noexcept
           Toggles every bit to its opposite value.
       constexpr <b>bitset</b>&lt; <b>_Nb</b> &gt; &amp; <b>flip</b> (size_t <b>__position</b>)
           Toggles a given bit to its opposite value.
       constexpr bool <b>none</b> () const noexcept
           Tests whether any of the bits are on.
       constexpr <b>bitset</b>&lt; <b>_Nb</b> &gt; <b>operator~</b> () const noexcept
           See the no-argument flip().
       constexpr <b>bitset</b>&lt; <b>_Nb</b> &gt; &amp; <b>reset</b> () noexcept
           Sets every bit to false.
       constexpr <b>bitset</b>&lt; <b>_Nb</b> &gt; &amp; <b>reset</b> (size_t <b>__position</b>)
           Sets a given bit to false.
       constexpr <b>bitset</b>&lt; <b>_Nb</b> &gt; &amp; <b>set</b> () noexcept
           Sets every bit to true.
       constexpr <b>bitset</b>&lt; <b>_Nb</b> &gt; &amp; <b>set</b> (size_t <b>__position</b>, bool __val=<b>true</b>)
           Sets a given bit to a particular value.
       constexpr size_t <b>size</b> () const noexcept
           Returns the total number of bits.
       constexpr bool <b>test</b> (size_t <b>__position</b>) const
           Tests the value of a bit.
       template&lt;<b>class</b> _CharT , <b>class</b> _Traits , <b>class</b> _Alloc &gt; constexpr <b>std::basic_string</b>&lt; _CharT, _Traits,
           _Alloc &gt; <b>to_string</b> () const
           Returns a character interpretation of the bitset.
       template&lt;<b>class</b> _CharT , <b>class</b> _Traits &gt; constexpr <b>std::basic_string</b>&lt; _CharT, _Traits, <b>std::allocator</b>&lt;
           _CharT &gt; &gt; <b>to_string</b> () const
       template&lt;<b>class</b> _CharT &gt; constexpr <b>std::basic_string</b>&lt; _CharT, <b>std::char_traits</b>&lt; _CharT &gt;, <b>std::allocator</b>&lt;
           _CharT &gt; &gt; <b>to_string</b> () const
       constexpr <b>std::basic_string</b>&lt; char, <b>std::char_traits</b>&lt; char &gt;, <b>std::allocator</b>&lt; char &gt; &gt; <b>to_string</b> () const
       template&lt;<b>class</b> _CharT , <b>class</b> _Traits , <b>class</b> _Alloc &gt; constexpr <b>std::basic_string</b>&lt; _CharT, _Traits,
           _Alloc &gt; <b>to_string</b> (_CharT <b>__zero</b>, _CharT <b>__one</b>=_CharT('1')) const
       template&lt;<b>class</b> _CharT , <b>class</b> _Traits &gt; constexpr <b>std::basic_string</b>&lt; _CharT, _Traits, <b>std::allocator</b>&lt;
           _CharT &gt; &gt; <b>to_string</b> (_CharT <b>__zero</b>, _CharT <b>__one</b>=_CharT('1')) const
       template&lt;<b>class</b> _CharT &gt; constexpr <b>std::basic_string</b>&lt; _CharT, <b>std::char_traits</b>&lt; _CharT &gt;, <b>std::allocator</b>&lt;
           _CharT &gt; &gt; <b>to_string</b> (_CharT <b>__zero</b>, _CharT <b>__one</b>=_CharT('1')) const
       constexpr <b>std::basic_string</b>&lt; char, <b>std::char_traits</b>&lt; char &gt;, <b>std::allocator</b>&lt; char &gt; &gt; <b>to_string</b> (char
           <b>__zero</b>, char <b>__one</b>='1') const
       constexpr unsigned long long <b>to_ullong</b> () const
       constexpr unsigned long <b>to_ulong</b> () const
           Returns a numerical interpretation of the bitset.

           constexpr <b>bitset</b>&lt; <b>_Nb</b> &gt; &amp; <b>operator&amp;=</b> (const <b>bitset</b>&lt; <b>_Nb</b> &gt; &amp;<b>__rhs</b>) noexcept
           constexpr <b>bitset</b>&lt; <b>_Nb</b> &gt; &amp; <b>operator|=</b> (const <b>bitset</b>&lt; <b>_Nb</b> &gt; &amp;<b>__rhs</b>) noexcept
           constexpr <b>bitset</b>&lt; <b>_Nb</b> &gt; &amp; <b>operator^=</b> (const <b>bitset</b>&lt; <b>_Nb</b> &gt; &amp;<b>__rhs</b>) noexcept

           constexpr <b>bitset</b>&lt; <b>_Nb</b> &gt; &amp; <b>operator&lt;&lt;=</b> (size_t <b>__position</b>) noexcept
           constexpr <b>bitset</b>&lt; <b>_Nb</b> &gt; &amp; <b>operator&gt;&gt;=</b> (size_t <b>__position</b>) noexcept

           constexpr <b>bitset</b>&lt; <b>_Nb</b> &gt; &amp; <b>_Unchecked_set</b> (size_t <b>__pos</b>) noexcept
           constexpr <b>bitset</b>&lt; <b>_Nb</b> &gt; &amp; <b>_Unchecked_set</b> (size_t <b>__pos</b>, int __val) noexcept
           constexpr <b>bitset</b>&lt; <b>_Nb</b> &gt; &amp; <b>_Unchecked_reset</b> (size_t <b>__pos</b>) noexcept
           constexpr <b>bitset</b>&lt; <b>_Nb</b> &gt; &amp; <b>_Unchecked_flip</b> (size_t <b>__pos</b>) noexcept
           constexpr bool <b>_Unchecked_test</b> (size_t <b>__pos</b>) const noexcept

           constexpr <b>reference</b> <b>operator[]</b> (size_t <b>__position</b>)
               Array-indexing support.
           constexpr bool <b>operator[]</b> (size_t <b>__position</b>) const
               Array-indexing support.

           constexpr bool <b>operator==</b> (const <b>bitset</b>&lt; <b>_Nb</b> &gt; &amp;<b>__rhs</b>) const noexcept
               These comparisons for equality/inequality are, well, <u>bitwise</u>.

           constexpr <b>bitset</b>&lt; <b>_Nb</b> &gt; <b>operator&lt;&lt;</b> (size_t <b>__position</b>) const noexcept
               Self-explanatory.
           constexpr <b>bitset</b>&lt; <b>_Nb</b> &gt; <b>operator&gt;&gt;</b> (size_t <b>__position</b>) const noexcept
               Self-explanatory.

   <b>Friends</b>
       template&lt;<b>class</b> _CharT , <b>class</b> _Traits , size_t _Nb2&gt; <b>std::basic_ostream</b>&lt; _CharT, _Traits &gt; &amp; <b>operator&lt;&lt;</b>
           (<b>std::basic_ostream</b>&lt; _CharT, _Traits &gt; &amp;, const <b>bitset</b>&lt; <b>_Nb2</b> &gt; &amp;)
       template&lt;<b>class</b> _CharT , <b>class</b> _Traits , size_t _Nb2&gt; <b>std::basic_istream</b>&lt; _CharT, _Traits &gt; &amp; <b>operator&gt;&gt;</b>
           (<b>std::basic_istream</b>&lt; _CharT, _Traits &gt; &amp;, <b>bitset</b>&lt; <b>_Nb2</b> &gt; &amp;)
       <b>class</b> <b>reference</b>
       <b>struct</b> <b>std::hash&lt;</b> <b>bitset</b> <b>&gt;</b>

</pre><h4><b>Detailed</b> <b>Description</b></h4><pre>
   <b>template&lt;size_t</b> <b>_Nb&gt;</b>
       class std::bitset&lt; _Nb &gt;"The bitset class represents a <u>fixed-size</u> sequence of bits.

       (Note that bitset does <u>not</u> meet the formal requirements of a container. Mainly, it lacks iterators.)

       The template argument, <u>Nb</u>, may be any non-negative number, specifying the number of bits (e.g., '0',
       '12', '1024*1024').

       In the general unoptimized case, storage is allocated in word-sized blocks. Let B be the number of bits
       in a word, then (Nb+(B-1))/B words will be used for storage. B - NbB bits are unused. (They are the high-
       order bits in the highest word.) It is a class invariant that those unused bits are always zero.

       If you think of bitset as <u>a</u> <u>simple</u> <u>array</u> <u>of</u> <u>bits</u>, be aware that your mental picture is reversed: a bitset
       behaves the same way as bits in integers do, with the bit at index 0 in the <u>least</u> <u>significant</u> <u>/</u> <u>right-</u>
       <u>hand</u> position, and the bit at index Nb-1 in the <u>most</u> <u>significant</u> <u>/</u> <u>left-hand</u> position. Thus, unlike other
       containers, a bitset's index <u>counts</u> <u>from</u> <u>right</u> <u>to</u> <u>left</u>, to put it very loosely.

       This behavior is preserved when translating to and from strings. For example, the first line of the
       following program probably prints <u>b('a')</u> <u>is</u> <u>0001100001</u> on a modern ASCII system.

       #include &lt;bitset&gt;
       #include &lt;iostream&gt;
       #include &lt;sstream&gt;

       using namespace std;

       int main()
       {
           long         a = 'a';
           bitset&lt;10&gt;   b(a);

           cout &lt;&lt; "b('a') is " &lt;&lt; b &lt;&lt; endl;

           ostringstream s;
           s &lt;&lt; b;
           string  str = s.str();
           cout &lt;&lt; "index 3 in the string is " &lt;&lt; str[3] &lt;&lt; " but\n"
                &lt;&lt; "index 3 in the bitset is " &lt;&lt; b[3] &lt;&lt; endl;
       }

       Also see: https://gcc.gnu.org/onlinedocs/libstdc++/manual/ext_containers.html for a description of
       extensions.

       Most of the actual code isn't contained in bitset&lt;&gt; itself, but in the base class _Base_bitset. The base
       class works with whole words, not with individual bits. This allows us to specialize _Base_bitset for the
       important special case where the bitset is only a single word.

       Extra confusion can result due to the fact that the storage for _Base_bitset <u>is</u> a regular array, and is
       indexed as such. This is carefully encapsulated.

</pre><h4><b>Constructor</b> <b>&amp;</b> <b>Destructor</b> <b>Documentation</b></h4><pre>
   <b>template&lt;size_t</b> <b>_Nb&gt;</b> <b>constexpr</b> <b>std::bitset&lt;</b> <b>_Nb</b> <b>&gt;::bitset</b> <b>()</b> <b>[inline],</b>  <b>[constexpr],</b>  <b>[noexcept]</b>
       All bits set to zero.

   <b>template&lt;size_t</b> <b>_Nb&gt;</b> <b>constexpr</b> <b>std::bitset&lt;</b> <b>_Nb</b> <b>&gt;::bitset</b> <b>(unsigned</b> <b>long</b> <b>long</b> <b>__val)</b> <b>[inline],</b>  <b>[constexpr],</b>
       <b>[noexcept]</b>
       Initial bits bitwise-copied from a single word (others set to zero).

   <b>template&lt;size_t</b> <b>_Nb&gt;</b> <b>template&lt;class</b> <b>_CharT</b> <b>,</b> <b>class</b> <b>_Traits</b> <b>,</b> <b>class</b> <b>_Alloc</b> <b>&gt;</b> <b>constexpr</b> <b>std::bitset&lt;</b> <b>_Nb</b>
       <b>&gt;::bitset</b> <b>(const</b> <b>std::basic_string&lt;</b> <b>_CharT,</b> <b>_Traits,</b> <b>_Alloc</b> <b>&gt;</b> <b>&amp;</b> <b>__s,</b> <b>size_t</b> <b>__position</b> <b>=</b> <b>0)</b> <b>[inline],</b>
       <b>[explicit],</b>  <b>[constexpr]</b>
       Use a subset of a string.

       <b>Parameters</b>
           <b>__</b><u>s</u> A string of <u>0</u> and <u>1</u> characters.
           <b>__</b><u>position</u> Index of the first character in <b>__</b><u>s</u> to use; defaults to zero.

       <b>Exceptions</b>
           <u>std::out_of_range</u> If <u>pos</u> is bigger the size of <b>__</b><u>s</u>.
           <u>std::invalid_argument</u> If a character appears in the string which is neither <u>0</u> nor <u>1</u>.

   <b>template&lt;size_t</b> <b>_Nb&gt;</b> <b>template&lt;class</b> <b>_CharT</b> <b>,</b> <b>class</b> <b>_Traits</b> <b>,</b> <b>class</b> <b>_Alloc</b> <b>&gt;</b> <b>constexpr</b> <b>std::bitset&lt;</b> <b>_Nb</b>
       <b>&gt;::bitset</b> <b>(const</b> <b>std::basic_string&lt;</b> <b>_CharT,</b> <b>_Traits,</b> <b>_Alloc</b> <b>&gt;</b> <b>&amp;</b> <b>__s,</b> <b>size_t</b> <b>__position,</b> <b>size_t</b> <b>__n)</b>
       <b>[inline],</b>  <b>[constexpr]</b>
       Use a subset of a string.

       <b>Parameters</b>
           <b>__</b><u>s</u> A string of <u>0</u> and <u>1</u> characters.
           <b>__</b><u>position</u> Index of the first character in <b>__</b><u>s</u> to use.
           <b>__</b><u>n</u> The number of characters to copy.

       <b>Exceptions</b>
           <u>std::out_of_range</u> If <b>__</b><u>position</u> is bigger the size of <b>__</b><u>s</u>.
           <u>std::invalid_argument</u> If a character appears in the string which is neither <u>0</u> nor <u>1</u>.

   <b>template&lt;size_t</b> <b>_Nb&gt;</b> <b>template&lt;typename</b> <b>_CharT</b> <b>&gt;</b> <b>constexpr</b> <b>std::bitset&lt;</b> <b>_Nb</b> <b>&gt;::bitset</b> <b>(const</b> <b>_CharT</b> <b>*</b> <b>__str,</b>
       <b>typename</b> <b>__bitset&lt;</b> <b>_Nb</b> <b>&gt;::__string&lt;</b> <b>_CharT</b> <b>&gt;::size_type</b> <b>__n</b> <b>=</b> <b>__bitset&lt;</b> <b>_Nb</b> <b>&gt;::__string&lt;_CharT&gt;::npos,</b>
       <b>_CharT</b> <b>__zero</b> <b>=</b> <b>_CharT('0'),</b> <b>_CharT</b> <b>__one</b> <b>=</b> <b>_CharT('1'))</b> <b>[inline],</b>  <b>[explicit],</b>  <b>[constexpr]</b>
       Construct from a character array.

       <b>Parameters</b>
           <b>__</b><u>str</u> An array of characters <u>zero</u> and <u>one</u>.
           <b>__</b><u>n</u> The number of characters to use.
           <b>__</b><u>zero</u> The character corresponding to the value 0.
           <b>__</b><u>one</u> The character corresponding to the value 1.

       <b>Exceptions</b>
           <u>std::invalid_argument</u> If a character appears in the string which is neither <b>__</b><u>zero</u> nor <b>__</b><u>one</u>.

</pre><h4><b>Member</b> <b>Function</b> <b>Documentation</b></h4><pre>
   <b>template&lt;size_t</b> <b>_Nb&gt;</b> <b>constexpr</b> <b>bool</b> <b>std::bitset&lt;</b> <b>_Nb</b> <b>&gt;::all</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[constexpr],</b>  <b>[noexcept]</b>
       Tests whether all the bits are on.

       <b>Returns</b>
           True if all the bits are set.

   <b>template&lt;size_t</b> <b>_Nb&gt;</b> <b>constexpr</b> <b>bool</b> <b>std::bitset&lt;</b> <b>_Nb</b> <b>&gt;::any</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[constexpr],</b>  <b>[noexcept]</b>
       Tests whether any of the bits are on.

       <b>Returns</b>
           True if at least one bit is set.

   <b>template&lt;size_t</b> <b>_Nb&gt;</b> <b>constexpr</b> <b>size_t</b> <b>std::bitset&lt;</b> <b>_Nb</b> <b>&gt;::count</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[constexpr],</b>  <b>[noexcept]</b>
       Returns the number of bits which are set.

   <b>template&lt;size_t</b> <b>_Nb&gt;</b> <b>constexpr</b> <b>bitset&lt;</b> <b>_Nb</b> <b>&gt;</b> <b>&amp;</b> <b>std::bitset&lt;</b> <b>_Nb</b> <b>&gt;::flip</b> <b>()</b> <b>[inline],</b>  <b>[constexpr],</b>
       <b>[noexcept]</b>
       Toggles every bit to its opposite value.

   <b>template&lt;size_t</b> <b>_Nb&gt;</b> <b>constexpr</b> <b>bitset&lt;</b> <b>_Nb</b> <b>&gt;</b> <b>&amp;</b> <b>std::bitset&lt;</b> <b>_Nb</b> <b>&gt;::flip</b> <b>(size_t</b> <b>__position)</b> <b>[inline],</b>
       <b>[constexpr]</b>
       Toggles a given bit to its opposite value.

       <b>Parameters</b>
           <b>__</b><u>position</u> The index of the bit.

       <b>Exceptions</b>
           <u>std::out_of_range</u> If <u>pos</u> is bigger the size of the set.

   <b>template&lt;size_t</b> <b>_Nb&gt;</b> <b>constexpr</b> <b>bool</b> <b>std::bitset&lt;</b> <b>_Nb</b> <b>&gt;::none</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[constexpr],</b>  <b>[noexcept]</b>
       Tests whether any of the bits are on.

       <b>Returns</b>
           True if none of the bits are set.

   <b>template&lt;size_t</b> <b>_Nb&gt;</b> <b>constexpr</b> <b>bitset&lt;</b> <b>_Nb</b> <b>&gt;</b> <b>&amp;</b> <b>std::bitset&lt;</b> <b>_Nb</b> <b>&gt;::operator&amp;=</b> <b>(const</b> <b>bitset&lt;</b> <b>_Nb</b> <b>&gt;</b> <b>&amp;</b> <b>__rhs)</b>
       <b>[inline],</b>  <b>[constexpr],</b>  <b>[noexcept]</b>
       Operations on bitsets.

       <b>Parameters</b>
           <b>__</b><u>rhs</u> A same-sized bitset.

       These should be self-explanatory.

   <b>template&lt;size_t</b> <b>_Nb&gt;</b> <b>constexpr</b> <b>bitset&lt;</b> <b>_Nb</b> <b>&gt;</b> <b>std::bitset&lt;</b> <b>_Nb</b> <b>&gt;::operator&lt;&lt;</b> <b>(size_t</b> <b>__position)</b> <b>const</b>
       <b>[inline],</b>  <b>[constexpr],</b>  <b>[noexcept]</b>
       Self-explanatory.

   <b>template&lt;size_t</b> <b>_Nb&gt;</b> <b>constexpr</b> <b>bitset&lt;</b> <b>_Nb</b> <b>&gt;</b> <b>&amp;</b> <b>std::bitset&lt;</b> <b>_Nb</b> <b>&gt;::operator&lt;&lt;=</b> <b>(size_t</b> <b>__position)</b> <b>[inline],</b>
       <b>[constexpr],</b>  <b>[noexcept]</b>
       Operations on bitsets.

       <b>Parameters</b>
           <b>__</b><u>position</u> The number of places to shift.

       These should be self-explanatory.

   <b>template&lt;size_t</b> <b>_Nb&gt;</b> <b>constexpr</b> <b>bool</b> <b>std::bitset&lt;</b> <b>_Nb</b> <b>&gt;::operator==</b> <b>(const</b> <b>bitset&lt;</b> <b>_Nb</b> <b>&gt;</b> <b>&amp;</b> <b>__rhs)</b> <b>const</b>
       <b>[inline],</b>  <b>[constexpr],</b>  <b>[noexcept]</b>
       These comparisons for equality/inequality are, well, <u>bitwise</u>.

   <b>template&lt;size_t</b> <b>_Nb&gt;</b> <b>constexpr</b> <b>bitset&lt;</b> <b>_Nb</b> <b>&gt;</b> <b>std::bitset&lt;</b> <b>_Nb</b> <b>&gt;::operator&gt;&gt;</b> <b>(size_t</b> <b>__position)</b> <b>const</b>
       <b>[inline],</b>  <b>[constexpr],</b>  <b>[noexcept]</b>
       Self-explanatory.

   <b>template&lt;size_t</b> <b>_Nb&gt;</b> <b>constexpr</b> <b>bitset&lt;</b> <b>_Nb</b> <b>&gt;</b> <b>&amp;</b> <b>std::bitset&lt;</b> <b>_Nb</b> <b>&gt;::operator&gt;&gt;=</b> <b>(size_t</b> <b>__position)</b> <b>[inline],</b>
       <b>[constexpr],</b>  <b>[noexcept]</b>
       Operations on bitsets.

       <b>Parameters</b>
           <b>__</b><u>position</u> The number of places to shift.

       These should be self-explanatory.

   <b>template&lt;size_t</b> <b>_Nb&gt;</b> <b>constexpr</b> <b>reference</b> <b>std::bitset&lt;</b> <b>_Nb</b> <b>&gt;::operator[]</b> <b>(size_t</b> <b>__position)</b> <b>[inline],</b>
       <b>[constexpr]</b>
       Array-indexing support.

       <b>Parameters</b>
           <b>__</b><u>position</u> Index into the bitset.

       <b>Returns</b>
           A bool for a <u>const</u> <u>bitset</u>. For non-const bitsets, an instance of the reference proxy class.

       <b>Note</b>
           These operators do no range checking and throw no exceptions, as required by DR 11 to the standard.

       _GLIBCXX_RESOLVE_LIB_DEFECTS Note that this implementation already resolves DR 11 (items 1 and 2), but
       does not do the range-checking required by that DR's resolution. -pme The DR has since been changed:
       range-checking is a precondition (users' responsibility), and these functions must not throw. -pme

   <b>template&lt;size_t</b> <b>_Nb&gt;</b> <b>constexpr</b> <b>bool</b> <b>std::bitset&lt;</b> <b>_Nb</b> <b>&gt;::operator[]</b> <b>(size_t</b> <b>__position)</b> <b>const</b> <b>[inline],</b>
       <b>[constexpr]</b>
       Array-indexing support.

       <b>Parameters</b>
           <b>__</b><u>position</u> Index into the bitset.

       <b>Returns</b>
           A bool for a <u>const</u> <u>bitset</u>. For non-const bitsets, an instance of the reference proxy class.

       <b>Note</b>
           These operators do no range checking and throw no exceptions, as required by DR 11 to the standard.

       _GLIBCXX_RESOLVE_LIB_DEFECTS Note that this implementation already resolves DR 11 (items 1 and 2), but
       does not do the range-checking required by that DR's resolution. -pme The DR has since been changed:
       range-checking is a precondition (users' responsibility), and these functions must not throw. -pme

   <b>template&lt;size_t</b> <b>_Nb&gt;</b> <b>constexpr</b> <b>bitset&lt;</b> <b>_Nb</b> <b>&gt;</b> <b>&amp;</b> <b>std::bitset&lt;</b> <b>_Nb</b> <b>&gt;::operator^=</b> <b>(const</b> <b>bitset&lt;</b> <b>_Nb</b> <b>&gt;</b> <b>&amp;</b> <b>__rhs)</b>
       <b>[inline],</b>  <b>[constexpr],</b>  <b>[noexcept]</b>
       Operations on bitsets.

       <b>Parameters</b>
           <b>__</b><u>rhs</u> A same-sized bitset.

       These should be self-explanatory.

   <b>template&lt;size_t</b> <b>_Nb&gt;</b> <b>constexpr</b> <b>bitset&lt;</b> <b>_Nb</b> <b>&gt;</b> <b>&amp;</b> <b>std::bitset&lt;</b> <b>_Nb</b> <b>&gt;::operator|=</b> <b>(const</b> <b>bitset&lt;</b> <b>_Nb</b> <b>&gt;</b> <b>&amp;</b> <b>__rhs)</b>
       <b>[inline],</b>  <b>[constexpr],</b>  <b>[noexcept]</b>
       Operations on bitsets.

       <b>Parameters</b>
           <b>__</b><u>rhs</u> A same-sized bitset.

       These should be self-explanatory.

   <b>template&lt;size_t</b> <b>_Nb&gt;</b> <b>constexpr</b> <b>bitset&lt;</b> <b>_Nb</b> <b>&gt;</b> <b>std::bitset&lt;</b> <b>_Nb</b> <b>&gt;::operator~</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[constexpr],</b>
       <b>[noexcept]</b>
       See the no-argument flip().

   <b>template&lt;size_t</b> <b>_Nb&gt;</b> <b>constexpr</b> <b>bitset&lt;</b> <b>_Nb</b> <b>&gt;</b> <b>&amp;</b> <b>std::bitset&lt;</b> <b>_Nb</b> <b>&gt;::reset</b> <b>()</b> <b>[inline],</b>  <b>[constexpr],</b>
       <b>[noexcept]</b>
       Sets every bit to false.

   <b>template&lt;size_t</b> <b>_Nb&gt;</b> <b>constexpr</b> <b>bitset&lt;</b> <b>_Nb</b> <b>&gt;</b> <b>&amp;</b> <b>std::bitset&lt;</b> <b>_Nb</b> <b>&gt;::reset</b> <b>(size_t</b> <b>__position)</b> <b>[inline],</b>
       <b>[constexpr]</b>
       Sets a given bit to false.

       <b>Parameters</b>
           <b>__</b><u>position</u> The index of the bit.

       <b>Exceptions</b>
           <u>std::out_of_range</u> If <u>pos</u> is bigger the size of the set.

       Same as writing set(pos,false).

   <b>template&lt;size_t</b> <b>_Nb&gt;</b> <b>constexpr</b> <b>bitset&lt;</b> <b>_Nb</b> <b>&gt;</b> <b>&amp;</b> <b>std::bitset&lt;</b> <b>_Nb</b> <b>&gt;::set</b> <b>()</b> <b>[inline],</b>  <b>[constexpr],</b>  <b>[noexcept]</b>

       Sets every bit to true.

   <b>template&lt;size_t</b> <b>_Nb&gt;</b> <b>constexpr</b> <b>bitset&lt;</b> <b>_Nb</b> <b>&gt;</b> <b>&amp;</b> <b>std::bitset&lt;</b> <b>_Nb</b> <b>&gt;::set</b> <b>(size_t</b> <b>__position,</b> <b>bool</b> <b>__val</b> <b>=</b> <b>true)</b>
       <b>[inline],</b>  <b>[constexpr]</b>
       Sets a given bit to a particular value.

       <b>Parameters</b>
           <b>__</b><u>position</u> The index of the bit.
           <b>__</b><u>val</u> Either true or false, defaults to true.

       <b>Exceptions</b>
           <u>std::out_of_range</u> If <u>pos</u> is bigger the size of the set.

   <b>template&lt;size_t</b> <b>_Nb&gt;</b> <b>constexpr</b> <b>size_t</b> <b>std::bitset&lt;</b> <b>_Nb</b> <b>&gt;::size</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[constexpr],</b>  <b>[noexcept]</b>
       Returns the total number of bits.

   <b>template&lt;size_t</b> <b>_Nb&gt;</b> <b>constexpr</b> <b>bool</b> <b>std::bitset&lt;</b> <b>_Nb</b> <b>&gt;::test</b> <b>(size_t</b> <b>__position)</b> <b>const</b> <b>[inline],</b>  <b>[constexpr]</b>

       Tests the value of a bit.

       <b>Parameters</b>
           <b>__</b><u>position</u> The index of a bit.

       <b>Returns</b>
           The value at <u>pos</u>.

       <b>Exceptions</b>
           <u>std::out_of_range</u> If <u>pos</u> is bigger the size of the set.

   <b>template&lt;size_t</b> <b>_Nb&gt;</b> <b>template&lt;class</b> <b>_CharT</b> <b>,</b> <b>class</b> <b>_Traits</b> <b>,</b> <b>class</b> <b>_Alloc</b> <b>&gt;</b> <b>constexpr</b> <b>std::basic_string&lt;</b>
       <b>_CharT,</b> <b>_Traits,</b> <b>_Alloc</b> <b>&gt;</b> <b>std::bitset&lt;</b> <b>_Nb</b> <b>&gt;::to_string</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[constexpr]</b>
       Returns a character interpretation of the bitset.

       <b>Returns</b>
           The string equivalent of the bits.

       Note the ordering of the bits: decreasing character positions correspond to increasing bit positions (see
       the main class notes for an example).

   <b>template&lt;size_t</b> <b>_Nb&gt;</b> <b>constexpr</b> <b>unsigned</b> <b>long</b> <b>std::bitset&lt;</b> <b>_Nb</b> <b>&gt;::to_ulong</b> <b>()</b> <b>const</b> <b>[inline],</b>  <b>[constexpr]</b>
       Returns a numerical interpretation of the bitset.

       <b>Returns</b>
           The integral equivalent of the bits.

       <b>Exceptions</b>
           <u>std::overflow_error</u> If there are too many bits to be represented in an unsigned long.

</pre><h4><b>Author</b></h4><pre>
       Generated automatically by Doxygen for libstdc++ from the source code.

                                                    libstdc++                           <u>std::bitset&lt;</u> <b>_</b><u>Nb</u> <u>&gt;</u>(3cxx)
</pre>
 </div>
</div></section>
</div>
</body>
</html>