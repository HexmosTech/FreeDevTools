<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WWW::Mechanize::Shell - An interactive shell for WWW::Mechanize</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libwww-mechanize-shell-perl">libwww-mechanize-shell-perl_0.62-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       WWW::Mechanize::Shell - An interactive shell for WWW::Mechanize

</pre><h4><b>SYNOPSIS</b></h4><pre>
       From the command line as

         perl -MWWW::Mechanize::Shell -eshell

       or alternatively as a custom shell program via :

         #!<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?perl">/usr/bin/perl</a> -w
         use strict;
         use WWW::Mechanize::Shell;

         my $shell = WWW::Mechanize::Shell-&gt;new("shell");

         if (@ARGV) {
           $shell-&gt;source_file( @ARGV );
         } else {
           $shell-&gt;cmdloop;
         };

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module implements a www-like shell above WWW::Mechanize and also has the capability to output crude
       Perl code that recreates the recorded session. Its main use is as an interactive starting point for
       automating a session through WWW::Mechanize.

       The cookie support is there, but no cookies are read from your existing browser sessions. See
       HTTP::Cookies on how to implement reading/writing your current browsers cookies.

   <b>"WWW::Mechanize::Shell-&gt;new</b> <b>%ARGS"</b>
       This is the constructor for a new shell instance. Some of the options can be passed to the constructor as
       parameters.

       By default, a file ".mechanizerc" (respectively "mechanizerc" under Windows) in the users home directory
       is executed before the interactive shell loop is entered. This can be used to set some defaults. If you
       want to supply a different filename for the rcfile, the "rcfile" parameter can be passed to the
       constructor :

         rcfile =&gt; '.myapprc',

       <b>agent</b>
             my $shell = WWW::Mechanize::Shell-&gt;new(
                 agent =&gt; WWW::Mechanize::Chrome-&gt;new(),
             );

           Pass  in  a  premade  custom  user  agent. This object must be compatible to WWW::Mechanize. Use this
           feature from the command line as

             perl -Ilib -MWWW::Mechanize::Chrome \
                        -MWWW::Mechanize::Shell \
                        -e"shell(agent =&gt; WWW::Mechanize::Chrome-&gt;new())"

   <b>"$shell-&gt;release_agent"</b>
       Since the shell stores a reference back to itself within the WWW::Mechanize instance, it is necessary  to
       break this circular reference. This method does this.

   <b>"$shell-&gt;source_file</b> <b>FILENAME"</b>
       The "source_file" method executes the lines of FILENAME as if they were typed in.

         $shell-&gt;source_file( $filename );

   <b>"$shell-&gt;display_user_warning"</b>
       All user warnings are routed through this routine so they can be rerouted / disabled easily.

   <b>"$shell-&gt;print_paged</b> <b>LIST"</b>
       Prints  the text in LIST using $ENV{PAGER}. If $ENV{PAGER} is empty, prints directly to "STDOUT". Most of
       this routine comes from the "perldoc" utility.

   <b>"$shell-&gt;link_text</b> <b>LINK"</b>
       Returns a meaningful text from a WWW::Mechanize::Link object. This is (in order of precedence) :

           $link-&gt;text
           $link-&gt;name
           $link-&gt;url

   <b>"$shell-&gt;history"</b>
       Returns the (relevant) shell history, that is, all commands that were not solely for the  information  of
       the user. The lines are returned as a list.

         print join "\n", $shell-&gt;history;

   <b>"$shell-&gt;script"</b>
       Returns  the  shell  history as a Perl program. The lines are returned as a list. The lines do not have a
       one-by-one correspondence to the lines in the history.

         print join "\n", $shell-&gt;script;

   <b>"$shell-&gt;status"</b>
       "status" is called for status updates.

   <b>"$shell-&gt;display</b> <b>FILENAME</b> <b>LINES"</b>
       "display" is called to output listings, currently from the "history" and "script" commands. If the second
       parameter is defined, it is the name of the file to be written, otherwise the lines are displayed to  the
       user.

</pre><h4><b>COMMANDS</b></h4><pre>
       The shell implements various commands :

   <b>exit</b>
       Leaves the shell.

   <b>restart</b>
       Restart the shell.

       This  is  mostly  useful when you are modifying the shell itself. It doesn't work if you use the shell in
       oneliner mode with "-e".

   <b>get</b>
       Download a specific URL.

       This is used as the entry point in all sessions

       Syntax:

         get URL

   <b>save</b>
       Download a link into a file.

       If more than one link matches the RE, all matching links are saved. The filename is taken from  the  last
       part of the URL. Alternatively, the number of a link may also be given.

       Syntax:

         save RE

   <b>content</b>
       Display the content for the current page.

       Syntax: content [FILENAME]

       If the FILENAME argument is provided, save the content to the file.

       A  trailing  "\n"  is  added to the end of the content when using the shell, so this might not be ideally
       suited to save binary files without manual editing of the produced script.

   <b>title</b>
       Display the current page title as found in the "&lt;TITLE&gt;" tag.

   <b>headers</b>
       Prints all "&lt;H1&gt;" through "&lt;H5&gt;" strings found in the content, indented accordingly.  With  an  argument,
       prints only those levels; e.g., "headers 145" prints H1,H4,H5 strings only.

   <b>ua</b>
       Get/set the current user agent

       Syntax:

         # fake Internet Explorer
         ua "Mozilla/4.0 (compatible; MSIE 4.01; Windows 98)"

         # fake QuickTime v5
         ua "QuickTime (qtver=5.0.2;os=Windows NT 5.0Service Pack 2)"

         # fake Mozilla/Gecko based
         ua "Mozilla/5.001 (windows; U; NT4.0; en-us) Gecko/25250101"

         # set empty user agent :
         ua ""

   <b>links</b>
       Display all links on a page

       The links numbers displayed can used by "open" to directly select a link to follow.

   <b>images</b>
       Display images on a page

   <b>parse</b>
       Dump the output of HTML::TokeParser of the current content

   <b>forms</b>
       Display all forms on the current page.

   <b>form</b>
       Select the form named NAME

       If NAME matches "/^\d+$/", it is assumed to be the (1-based) index of the form to select. There is no way
       of selecting a numerically named form by its name.

   <b>dump</b>
       Dump the values of the current form

   <b>value</b>
       Set a form value

       Syntax:

         value NAME [VALUE]

   <b>tick</b>
       Set checkbox marks

       Syntax:

         tick NAME VALUE(s)

       If no value is given, all boxes are checked.

   <b>untick</b>
       Remove checkbox marks

       Syntax:

         untick NAME VALUE(s)

       If no value is given, all marks are removed.

   <b>submit</b>
       submits the form without clicking on any button

   <b>click</b>
       Clicks on the button named NAME.

       No regular expression expansion is done on NAME.

       Syntax:

         click NAME

       If you have a button that has no name (displayed as NONAME), use

         click ""

       to click on it.

   <b>open</b>
       &lt;open&gt;  accepts  one  argument,  which  can  be a regular expression or the number of a link on the page,
       starting at zero. These numbers are displayed by the "links" function. It goes directly to the page if  a
       number  is used or if the RE has one match. Otherwise, a list of links matching the regular expression is
       displayed.

       The regular expression should start and end with "/".

       Syntax:

         open  [ RE | # ]

   <b>back</b>
       Go back one page in the browser page history.

   <b>reload</b>
       Repeat the last request, thus reloading the current page.

       Note that also POST requests are blindly repeated, as this command is mostly intended  to  be  used  when
       testing server side code.

   <b>browse</b>
       Open the web browser with the current page

       Displays the current page in the browser.

   <b>set</b>
       Set a shell option

       Syntax:

          set OPTION [value]

       The command lists all valid options. Here is a short overview over the different options available :

           autosync      - automatically synchronize the browser window
           autorestart   - restart the shell when any required module changes
                           This does not work with C&lt;-e&gt; oneliners.
           watchfiles    - watch all required modules for changes
           cookiefile    - the file where to store all cookies
           dumprequests  - dump all requests to STDOUT
           dumpresponses - dump the headers of the responses to STDOUT
           verbose       - print commands to STDERR as they are run,
                           when sourcing from a file

   <b>history</b>
       Display your current session history as the relevant commands.

       Syntax:

         history [FILENAME]

       Commands  that  have  no  influence  on the browser state are not added to the history. If a parameter is
       given to the "history" command, the history is saved to that file instead of displayed onscreen.

   <b>script</b>
       Display your current session history as a Perl script using WWW::Mechanize.

       Syntax:

         script [FILENAME]

       If a parameter is given to the "script" command, the script is saved to that file instead of displayed on
       the console.

       This command was formerly known as "history".

   <b>comment</b>
       Adds a comment to the script and the history. The comment is prepended with a \n to increase readability.

   <b>fillout</b>
       Fill out the current form

       Interactively asks the values hat have no preset value via the autofill command.

   <b>auth</b>
       Set basic authentication credentials.

       Syntax:

         auth user password

       If you know the authority and the realm in advance, you can presupply the credentials, for example at the
       start of the script :

               &gt;auth corion secret
               &gt;get <a href="http://www.example.com">http://www.example.com</a>
               Retrieving <a href="http://www.example.com">http://www.example.com</a>(200)
               <a href="http://www.example.com">http://www.example.com</a>&gt;

   <b>table</b>
       Display a table described by the columns COLUMNS.

       Syntax:

         table COLUMNS

       Example:

         table Product Price Description

       If there is a table on the current page that has in its first row the three  columns  "Product",  "Price"
       and  "Description"  (not  necessarily  in that order), the script will display these columns of the whole
       table.

       The "HTML::TableExtract" module is needed for this feature.

   <b>tables</b>
       Display a list of tables.

       Syntax:

         tables

       This command will display the top row for every table on the current page. This is convenient if you want
       to find out what the exact spellings for each column are.

       The command does not always work nice, for example if a site uses tables for layout, it will be harder to
       guess what tables are irrelevant and what tables are relevant.

       HTML::TableExtract is needed for this feature.

   <b>cookies</b>
       Set the cookie file name

       Syntax:

         cookies FILENAME

   <b>autofill</b>
       Define an automatic value

       Sets a form value to be filled automatically. The NAME parameter is the WWW::Mechanize::FormFiller::Value
       subclass you want to use. For session fields, "Keep" is a good candidate, for interactive stuff, "Ask" is
       a value implemented by the shell.

       A field name starting and ending with a slash ("/") is taken to be  a  regular  expression  and  will  be
       applied  to  all fields with their name matching the expression. A field with a matching name still takes
       precedence over the regular expression.

       Syntax:

         autofill NAME [PARAMETERS]

       Examples:

         autofill login Fixed corion
         autofill password Ask
         autofill selection Random red green orange
         autofill session Keep
         autofill "/date$/" Random::Date string "%m/%d/%Y"

   <b>eval</b>
       Evaluate Perl code and print the result

       Syntax:

         eval CODE

       For the generated scripts, anything matching the regular expression "/\$self-&gt;agent\b/" is  automatically
       replaced by $agent in your eval code, to do the Right Thing.

       Examples:

         # Say hello
         eval "Hello World"

         # And take a look at the current content type
         eval $self-&gt;agent-&gt;ct

   <b>source</b>
       Execute a batch of commands from a file

       Syntax:

         source FILENAME

   <b>versions</b>
       Print the version numbers of important modules

       Syntax:

         versions

   <b>timeout</b>
       Set new timeout value for the agent. Effects all subsequent requests. VALUE is in seconds.

       Syntax:

         timeout VALUE

   <b>ct</b>
       prints the content type of the most current response.

       Syntax:

         ct

   <b>referrer</b>
       set the value of the Referer: header

       Syntax:

         referer URL
         referrer URL

   <b>referer</b>
       Alias for referrer

   <b>response</b>
       display the last server response

   <b>"$shell-&gt;munge_code(</b> <b>CODE</b> <b>)"</b>
       Munges a coderef to become code fit for output independent of WWW::Mechanize::Shell.

   <b>"shell"</b>
       This  subroutine is exported by default as a convenience method so that the following oneliner invocation
       works:

           perl -MWWW::Mechanize::Shell -eshell

       You can pass constructor arguments to this routine as well. Any scripts given in @ARGV will  be  run.  If
       @ARGV is empty, an interactive loop will be started.

</pre><h4><b>SAMPLE</b> <b>SESSIONS</b></h4><pre>
   <b>Entering</b> <b>values</b>
         # Search for a term on Google
         get <a href="http://www.google.com">http://www.google.com</a>
         value q "Corions Homepage"
         click btnG
         script
         # (yes, this is a bad example of automating, as Google
         #  already has a Perl API. But other sites don't)

   <b>Retrieving</b> <b>a</b> <b>table</b>
         get <a href="http://www.perlmonks.org">http://www.perlmonks.org</a>
         open "/Saints in/"
         table User Experience Level
         script
         # now you have a program that gives you a csv file of
         # that table.

   <b>Uploading</b> <b>a</b> <b>file</b>
         get <a href="http://aliens">http://aliens</a>:xxxxx/
         value f path/to/file
         click "upload"

   <b>Batch</b> <b>download</b>
         # download prerelease versions of my modules
         get <a href="http://www.corion.net/perl-dev">http://www.corion.net/perl-dev</a>
         save /.tar.gz$/

</pre><h4><b>REGULAR</b> <b>EXPRESSION</b> <b>SYNTAX</b></h4><pre>
       Some  commands  take  regular  expressions as parameters. A regular expression <b>must</b> be a single parameter
       matching "^<a href="file:/.">/.</a>*/([isxm]+)?$", so you have to use quotes around it if the expression contains spaces :

         /link_foo/       # will match as (?-xims:link_foo)
         "/link foo/"     # will match as (?-xims:link foo)

       Slashes do not need to be escaped, as the shell knows that a RE starts and ends with a slash :

         /link/foo/       # will match as (?-xims:link/foo)
         "/link/ /foo/"   # will match as (?-xims:link/\s/foo)

       The "/i" modifier works as expected.  If you desire more power over  the  regular  expressions,  consider
       dropping to Perl or recommend me a good parser module for regular expressions.

</pre><h4><b>DISPLAYING</b> <b>HTML</b></h4><pre>
       WWW::Mechanize::Shell  now  uses the module HTML::Display to display the HTML of the current page in your
       browser.  Have a look at the documentation of HTML::Display how to make it use your browser of choice  in
       the case it does not already guess it correctly.

</pre><h4><b>FILLING</b> <b>FORMS</b> <b>VIA</b> <b>CUSTOM</b> <b>CODE</b></h4><pre>
       If  you want to stay within the confines of the shell, but still want to fill out forms using custom Perl
       code, here is a recipe how to achieve this :

       Code passed to the "eval" command gets evaluated in the WWW::Mechanize::Shell namespace. You  can  inject
       new subroutines there and these get picked up by the Callback class of WWW::Mechanize::FormFiller :

         # Fill in the "date" field with the current date/time as string
         eval sub &amp;::custom_today { scalar localtime };
         autofill date Callback WWW::Mechanize::Shell::custom_today
         fillout

       This method can also be used to retrieve data from shell scripts :

         # Fill in the "date" field with the current date/time as string
         # works only if there is a program "date"
         eval sub &amp;::custom_today { chomp `date` };
         autofill date Callback WWW::Mechanize::Shell::custom_today
         fillout

       As  the  namespace  is  different  between the shell and the generated script, make sure you always fully
       qualify your subroutine names, either in your own namespace or in the main namespace.

</pre><h4><b>GENERATED</b> <b>SCRIPTS</b></h4><pre>
       The "script" command outputs a skeleton script that reproduces  your  actions  as  done  in  the  current
       session.  It  pulls  in  "WWW::Mechanize::FormFiller",  which is possibly not needed. You should add some
       error and connection checking afterwards.

</pre><h4><b>ADDING</b> <b>FIELDS</b> <b>TO</b> <b>HTML</b></h4><pre>
       If you are automating a JavaScript dependent site, you will encounter JavaScript like this :

           &lt;script&gt;
             document.write( "&lt;input type=submit name=submit&gt;" );
           &lt;/script&gt;

       HTML::Form will not know about this and will not have provided a submit button for you  (understandably).
       If you want to create such a submit button from within your automation script, use the following code :

         $agent-&gt;current_form-&gt;push_input( submit =&gt; { name =&gt; "submit", value =&gt;"submit" } );

       This also works for other dynamically generated input fields.

       To fake an input field from within a shell session, use the "eval" command :

         eval $self-&gt;agent-&gt;current_form-&gt;push_input(submit=&gt;{name=&gt;"submit",value=&gt;"submit"});

       And yes, the generated script should do the Right Thing for this eval as well.

</pre><h4><b>LOCAL</b> <b>FILES</b></h4><pre>
       If  you  want  to use the shell on a local file without setting up a "http" server to serve the file, you
       can use the "file:" URI scheme to load it into the "browser":

         get file:local.html
         forms

</pre><h4><b>PROXY</b> <b>SUPPORT</b></h4><pre>
       Currently, the proxy support is realized via a call to  the  "env_proxy"  method  of  the  WWW::Mechanize
       object, which loads the proxies from the environment. There is no provision made to prevent using proxies
       (yet). The generated scripts also load their proxies from the environment.

</pre><h4><b>ONLINE</b> <b>HELP</b></h4><pre>
       The  online  help  feature  is  currently a bit broken in "Term::Shell", but a fix is in the works. Until
       then, you can re-enable the dynamic online help by patching "Term::Shell" :

       Remove the three lines

             my $smry = exists $o-&gt;{handlers}{$h}{smry}
           ? $o-&gt;summary($h)
           : "undocumented";

       in "sub run_help" and replace them by

             my $smry = $o-&gt;summary($h);

       The  shell  works  without  this  patch  and  the  online  help  is  still  available  through   "perldoc
       WWW::Mechanize::Shell"

</pre><h4><b>BUGS</b></h4><pre>
       Bug     reports     are     very     welcome     -     please     use     the     RT     interface     at
       https://rt.cpan.org/NoAuth/Bugs.html?Dist=WWW-Mechanize-Shell   or   send   a   descriptive    mail    to
       <a href="mailto:bug-WWW-Mechanize-Shell@rt.cpan.org">bug-WWW-Mechanize-Shell@rt.cpan.org</a>  . Please try to include as much (relevant) information as possible -
       a test script that replicates the undesired behaviour is welcome every time!

       •   The two parameter version of the "auth" command guesses the realm from the  last  received  response.
           Currently  a  RE  is used to extract the realm, but this fails with some servers resp. in some cases.
           Use the four parameter version of "auth", or if not possible, code the extraction in Perl, either  in
           the final script or through "eval" commands.

       •   The  shell currently detects when you want to follow a JavaScript link and tells you that this is not
           supported. It would be nicer if there was some callback mechanism to  (automatically?)  extract  URLs
           from JavaScript-infected links.

</pre><h4><b>TODO</b></h4><pre>
       •   Add  XPath  expressions (by moving "WWW::Mechanize" from HTML::Parser to XML::XMLlib or maybe easier,
           by tacking Class::XPath onto an HTML tree)

       •   Add "head" as a command ?

       •   Optionally silence the HTML::Parser / HTML::Forms warnings about invalid HTML.

</pre><h4><b>EXPORT</b></h4><pre>
       The routine "shell" is exported into the importing namespace. This is mainly for convenience so  you  can
       use the following commandline invocation of the shell like with CPAN :

         perl -MWWW::Mechanize::Shell -e"shell"

</pre><h4><b>REPOSITORY</b></h4><pre>
       The public repository of this module is &lt;https://github.com/Corion/WWW-Mechanize-Shell&gt;.

</pre><h4><b>SUPPORT</b></h4><pre>
       The public support forum of this module is &lt;<a href="http://perlmonks.org/">http://perlmonks.org/</a>&gt;.

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This  library  is  free  software;  you can redistribute it and/or modify it under the same terms as Perl
       itself.

       Copyright (C) 2002-2023 Max Maischein

</pre><h4><b>AUTHOR</b></h4><pre>
       Max Maischein, &lt;<a href="mailto:corion@cpan.org">corion@cpan.org</a>&gt;

       Please contact me if you find bugs or otherwise improve the module. More tests are also very welcome !

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       WWW::Mechanize,WWW::Mechanize::FormFiller,WWW::Mechanize::Firefox

perl v5.36.0                                       2023-08-21                         <u>WWW::Mechanize::<a href="../man3pm/Shell.3pm.html">Shell</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>