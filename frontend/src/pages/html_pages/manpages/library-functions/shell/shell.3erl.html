<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>shell - The Erlang shell.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/jammy/+package/erlang-manpages">erlang-manpages_24.2.1+dfsg-1ubuntu0.5_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       shell - The Erlang shell.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module provides an Erlang shell.

       The  shell  is  a user interface program for entering expression sequences. The expressions are evaluated
       and a value is returned. A history mechanism saves previous commands and their values, which can then  be
       incorporated  in  later  commands.  How  many commands and results to save can be determined by the user,
       either interactively, by calling <u>history/1</u> and <u>results/1</u>, or by  setting  the  application  configuration
       parameters <u>shell_history_length</u> and <u>shell_saved_results</u> for the STDLIB application.

       The shell uses a helper process for evaluating commands to protect the history mechanism from exceptions.
       By  default the evaluator process is killed when an exception occurs, but by calling <u>catch_exception/1</u> or
       by setting the application configuration parameter <u>shell_catch_exception</u> for the STDLIB application  this
       behavior can be changed. See also the example below.

       Variable  bindings,  and  local  process  dictionary  changes  that are generated in user expressions are
       preserved, and the variables can be used in later commands to access their values. The bindings can  also
       be forgotten so the variables can be reused.

       The  special  shell  commands all have the syntax of (local) function calls. They are evaluated as normal
       function calls and many commands can be used in one expression sequence.

       If a command (local function call) is not recognized by the shell, an attempt is first made to  find  the
       function in module <u>user_default</u>, where customized local commands can be placed. If found, the function is
       evaluated,  otherwise  an  attempt  is  made  to  evaluate  the  function in module <u>shell_default</u>. Module
       <u>user_default</u> must be explicitly loaded.

       The shell also permits the user to start multiple concurrent jobs. A job can be  regarded  as  a  set  of
       processes that can communicate with the shell.

       There  is  some  support  for  reading  and  printing  records  in  the  shell. During compilation record
       expressions are translated to tuple expressions. In runtime it is not known whether a tuple represents  a
       record,  and  the  record  definitions  used  by the compiler are unavailable at runtime. So, to read the
       record syntax and print tuples as records when possible, record definitions must  be  maintained  by  the
       shell itself.

       The  shell commands for reading, defining, forgetting, listing, and printing records are described below.
       Notice that each job has its own set of record definitions. To facilitate matters, record definitions  in
       modules  <u>shell_default</u> and <u>user_default</u> (if loaded) are read each time a new job is started. For example,
       adding the following line to <u>user_default</u> makes the definition of  <u>file_info</u>  readily  available  in  the
       shell:

       -include_lib("kernel/include/file.hrl").

       The shell runs in two modes:

         * <u>Normal</u> <u>(possibly</u> <u>restricted)</u> mode, in which commands can be edited and expressions evaluated

         * Job Control Mode, <u>JCL</u>, in which jobs can be started, killed, detached, and connected

       Only the currently connected job can 'talk' to the shell.

</pre><h4><b>SHELL</b> <b>COMMANDS</b></h4><pre>
       The commands below are the built-in shell commands that are always available. In most system the commands
       listed in the <a href="../man3erl/c.3erl.html">c</a>(3erl) module are also available in the shell.

         <u>b()</u>:
           Prints the current variable bindings.

         <u>f()</u>:
           Removes all variable bindings.

         <u>f(X)</u>:
           Removes the binding of variable <u>X</u>.

         <u>h()</u>:
           Prints the history list.

         <u>history(N)</u>:
           Sets  the  number  of  previous  commands  to  keep  in the history list to <u>N</u>. The previous number is
           returned. Defaults to 20.

         <u>results(N)</u>:
           Sets the number of results from previous commands to keep in the history  list  to  <u>N</u>.  The  previous
           number is returned. Defaults to 20.

         <u>e(N)</u>:
           Repeats  command  <u>N</u>,  if <u>N</u> is positive. If it is negative, the <u>N</u>th previous command is repeated (that
           is, <u>e(-1)</u> repeats the previous command).

         <u>v(N)</u>:
           Uses the return value of command <u>N</u> in the current command, if <u>N</u> is positive. If it is  negative,  the
           return  value  of  the  <u>N</u>th  previous  command is used (that is, <u>v(-1)</u> uses the value of the previous
           command).

         <u>help()</u>:
           Evaluates <u>shell_default:help()</u>.

         <u>c(Mod)</u>:
           Evaluates <u>shell_default:c(Mod)</u>. This compiles and loads the module <u>Mod</u> and purges old versions of the
           code, if necessary. <u>Mod</u> can be either a module name or a a source file path,  with  or  without  <u>.erl</u>
           extension.

         <u>catch_exception(Bool)</u>:
           Sets  the  exception  handling of the evaluator process. The previous exception handling is returned.
           The default (<u>false</u>) is to kill the evaluator process when an exception occurs, which causes the shell
           to create a new evaluator process. When the exception handling is set to <u>true</u>, the evaluator  process
           lives  on.  This  means,  for  example,  that ports and ETS tables as well as processes linked to the
           evaluator process survive the exception.

         <u>rd(RecordName,</u> <u>RecordDefinition)</u>:
           Defines a record in the shell. <u>RecordName</u> is an atom and <u>RecordDefinition</u> lists the field  names  and
           the  default  values.  Usually  record definitions are made known to the shell by use of the <u>rr/1,2,3</u>
           commands described below, but sometimes it is handy to define records on the fly.

         <u>rf()</u>:
           Removes all record definitions, then reads record definitions  from  the  modules  <u>shell_default</u>  and
           <u>user_default</u> (if loaded). Returns the names of the records defined.

         <u>rf(RecordNames)</u>:
           Removes  selected  record  definitions.  <u>RecordNames</u>  is  a record name or a list of record names. To
           remove all record definitions, use <u>'_'</u>.

         <u>rl()</u>:
           Prints all record definitions.

         <u>rl(RecordNames)</u>:
           Prints selected record definitions. <u>RecordNames</u> is a record name or a list of record names.

         <u>rp(Term)</u>:
           Prints a term using the record definitions known to the shell. All of <u>Term</u> is printed; the  depth  is
           not limited as is the case when a return value is printed.

         <u>rr(Module)</u>:
           Reads  record  definitions  from a module's BEAM file. If there are no record definitions in the BEAM
           file, the source file is located and read instead. Returns the names of the record definitions  read.
           <u>Module</u> is an atom.

         <u>rr(Wildcard)</u>:
           Reads  record  definitions  from  files.  Existing  definitions  of  any of the record names read are
           replaced. <u>Wildcard</u> is a wildcard string as defined in <u><a href="../man3erl/filelib.3erl.html">filelib</a>(3erl)</u>, but not an atom.

         <u>rr(WildcardOrModule,</u> <u>RecordNames)</u>:
           Reads record definitions from files but discards record names not mentioned in <u>RecordNames</u> (a  record
           name or a list of record names).

         <u>rr(WildcardOrModule,</u> <u>RecordNames,</u> <u>Options)</u>:
           Reads record definitions from files. The compiler options <u>{i,</u> <u>Dir}</u>, <u>{d,</u> <u>Macro}</u>, and <u>{d,</u> <u>Macro,</u> <u>Value}</u>
           are  recognized  and  used  for setting up the include path and macro definitions. To read all record
           definitions, use <u>'_'</u> as value of <u>RecordNames</u>.

</pre><h4><b>EXAMPLE</b></h4><pre>
       The following example is a long dialog with the shell. Commands starting with <u>&gt;</u> are inputs to the  shell.
       All other lines are output from the shell.

       strider 1&gt; erl
       Erlang (BEAM) emulator version 5.3 [hipe] [threads:0]

       Eshell V5.3  (abort with ^G)
       1&gt; Str = "abcd".
       "abcd"

       Command 1 sets variable <u>Str</u> to string <u>"abcd"</u>.

       2&gt; L = length(Str).
       4

       Command 2 sets <u>L</u> to the length of string <u>Str</u>.

       3&gt; Descriptor = {L, list_to_atom(Str)}.
       {4,abcd}

       Command 3 builds the tuple <u>Descriptor</u>, evaluating the BIF <u>list_to_atom/1</u>.

       4&gt; L.
       4

       Command 4 prints the value of variable <u>L</u>.

       5&gt; b().
       Descriptor = {4,abcd}
       L = 4
       Str = "abcd"
       ok

       Command  5  evaluates the internal shell command <u>b()</u>, which is an abbreviation of "bindings". This prints
       the current shell variables and their bindings. <u>ok</u> at the end is the return value of function <u>b()</u>.

       6&gt; f(L).
       ok

       Command 6 evaluates the internal shell command <u>f(L)</u> (abbreviation of "forget"). The value of  variable  <u>L</u>
       is removed.

       7&gt; b().
       Descriptor = {4,abcd}
       Str = "abcd"
       ok

       Command 7 prints the new bindings.

       8&gt; f(L).
       ok

       Command 8 has no effect, as <u>L</u> has no value.

       9&gt; {L, _} = Descriptor.
       {4,abcd}

       Command 9 performs a pattern matching operation on <u>Descriptor</u>, binding a new value to <u>L</u>.

       10&gt; L.
       4

       Command 10 prints the current value of <u>L</u>.

       11&gt; {P, Q, R} = Descriptor.
       ** exception error: no match of right hand side value {4,abcd}

       Command  11  tries  to match <u>{P,</u> <u>Q,</u> <u>R}</u> against <u>Descriptor</u>, which is <u>{4,</u> <u>abc}</u>. The match fails and none of
       the new variables become bound. The printout starting with "<u>**</u> <u>exception</u> <u>error:</u>" is not the value of  the
       expression  (the  expression  had  no  value because its evaluation failed), but a warning printed by the
       system to inform the user that an error has occurred. The values of the other variables (<u>L</u>, <u>Str</u>,  and  so
       on) are unchanged.

       12&gt; P.
       * 1:1: variable 'P' is unbound
       13&gt; Descriptor.
       {4,abcd}

       Commands  12  and  13 show that <u>P</u> is unbound because the previous command failed, and that <u>Descriptor</u> has
       not changed.

       14&gt;{P, Q} = Descriptor.
       {4,abcd}
       15&gt; P.
       4

       Commands 14 and 15 show a correct match where <u>P</u> and <u>Q</u> are bound.

       16&gt; f().
       ok

       Command 16 clears all bindings.

       The next few commands assume that <u>test1:demo(X)</u> is defined as follows:

       <u>demo(X)</u> <u>-&gt;</u>
       <u>put(aa,</u> <u>worked),</u>
       <u>X</u> <u>=</u> <u>1,</u>
       <u>X</u> <u>+</u> <u>10.</u>

       17&gt; put(aa, hello).
       undefined
       18&gt; get(aa).
       hello

       Commands 17 and 18 set and inspect the value of item <u>aa</u> in the process dictionary.

       19&gt; Y = test1:<a href="../man1/demo.1.html">demo</a>(1).
       11

       Command 19 evaluates <u>test1:<a href="../man1/demo.1.html">demo</a>(1)</u>.  The  evaluation  succeeds  and  the  changes  made  in  the  process
       dictionary become visible to the shell. The new value of dictionary item <u>aa</u> can be seen in command 20.

       20&gt; get().
       [{aa,worked}]
       21&gt; put(aa, hello).
       worked
       22&gt; Z = test1:<a href="../man2/demo.2.html">demo</a>(2).
       ** exception error: no match of right hand side value 1
            in function  test1:demo/1

       Commands  21  and  22  change the value of dictionary item <u>aa</u> to <u>hello</u> and call <u>test1:<a href="../man2/demo.2.html">demo</a>(2)</u>. Evaluation
       fails and the changes made to the dictionary in <u>test1:<a href="../man2/demo.2.html">demo</a>(2)</u>, before the error occurred, are discarded.

       23&gt; Z.
       * 1:1: variable 'Z' is unbound
       24&gt; get(aa).
       hello

       Commands 23 and 24 show that <u>Z</u> was not bound and that dictionary item <u>aa</u> has retained its original value.

       25&gt; erase(), put(aa, hello).
       undefined
       26&gt; spawn(test1, demo, [1]).
       &lt;0.57.0&gt;
       27&gt; get(aa).
       hello

       Commands 25, 26, and 27 show the effect of evaluating <u>test1:<a href="../man1/demo.1.html">demo</a>(1)</u> in the background. In this case,  the
       expression  is evaluated in a newly spawned process. Any changes made in the process dictionary are local
       to the newly spawned process and therefore not visible to the shell.

       28&gt; io:format("hello hello\n").
       hello hello
       ok
       29&gt; <a href="../man28/e.28.html">e</a>(28).
       hello hello
       ok
       30&gt; <a href="../man28/v.28.html">v</a>(28).
       ok

       Commands 28, 29 and 30 use the history facilities of the  shell.  Command  29  re-evaluates  command  28.
       Command  30  uses  the  value (result) of command 28. In the cases of a pure function (a function with no
       side effects), the result is the same. For a function with side effects, the result can be different.

       The next few commands show some record manipulation. It is  assumed  that  <u>ex.erl</u>  defines  a  record  as
       follows:

       <u>-record(rec,</u> <u>{a,</u> <u>b</u> <u>=</u> <u>val()}).</u>

       <u>val()</u> <u>-&gt;</u>
       <u>3.</u>

       31&gt; c(ex).
       {ok,ex}
       32&gt; rr(ex).
       [rec]

       Commands  31  and  32 compile file <u>ex.erl</u> and read the record definitions in <u>ex.beam</u>. If the compiler did
       not output any record definitions on the BEAM file, <u>rr(ex)</u> tries to  read  record  definitions  from  the
       source file instead.

       33&gt; rl(rec).
       -record(rec,{a,b = val()}).
       ok

       Command 33 prints the definition of the record named <u>rec</u>.

       34&gt; #rec{}.
       ** exception error: undefined shell command val/0

       Command 34 tries to create a <u>rec</u> record, but fails as function <u>val/0</u> is undefined.

       35&gt; #rec{b = 3}.
       #rec{a = undefined,b = 3}

       Command  35  shows  the  workaround:  explicitly  assign values to record fields that cannot otherwise be
       initialized.

       36&gt; rp(v(-1)).
       #rec{a = undefined,b = 3}
       ok

       Command 36 prints the newly created record using record definitions maintained by the shell.

       37&gt; rd(rec, {f = orddict:new()}).
       rec

       Command 37 defines a record directly in the shell.  The  definition  replaces  the  one  read  from  file
       <u>ex.beam</u>.

       38&gt; #rec{}.
       #rec{f = []}
       ok

       Command 38 creates a record using the new definition, and prints the result.

       39&gt; rd(rec, {c}), A.
       * 1:15: variable 'A' is unbound
       40&gt; #rec{}.
       #rec{c = undefined}
       ok

       Command 39 and 40 show that record definitions are updated as side effects. The evaluation of the command
       fails, but the definition of <u>rec</u> has been carried out.

       For the next command, it is assumed that <u>test1:loop(N)</u> is defined as follows:

       <u>loop(N)</u> <u>-&gt;</u>
       <u>io:format("Hello</u> <u>Number:</u> <u>~w~n",</u> <u>[N]),</u>
       <u>loop(N+1).</u>

       41&gt; test1:<a href="../man0/loop.0.html">loop</a>(0).
       Hello Number: 0
       Hello Number: 1
       Hello Number: 2
       Hello Number: 3

       User switch command
        --&gt; i
        --&gt; c
       Hello Number: 3374
       Hello Number: 3375
       Hello Number: 3376
       Hello Number: 3377
       Hello Number: 3378
       ** exception exit: killed

       Command  41  evaluates <u>test1:<a href="../man0/loop.0.html">loop</a>(0)</u>, which puts the system into an infinite loop. At this point the user
       types <u>^G</u> (Control G), which suspends output from the current process, which  is  stuck  in  a  loop,  and
       activates <u>JCL</u> mode. In <u>JCL</u> mode the user can start and stop jobs.

       In  this  particular case, command <u>i</u> ("interrupt") terminates the looping program, and command <u>c</u> connects
       to the shell again. As the process was running in the background before  we  killed  it,  more  printouts
       occur before message "<u>**</u> <u>exception</u> <u>exit:</u> <u>killed</u>" is shown.

       42&gt; E = ets:new(t, []).
       #Ref&lt;0.1662103692.2407923716.214192&gt;

       Command 42 creates an ETS table.

       43&gt; ets:insert({d,1,2}).
       ** exception error: undefined function ets:insert/1

       Command 43 tries to insert a tuple into the ETS table, but the first argument (the table) is missing. The
       exception kills the evaluator process.

       44&gt; ets:insert(E, {d,1,2}).
       ** exception error: argument is of wrong type
            in function  ets:insert/2
               called as ets:insert(16,{d,1,2})

       Command  44  corrects  the  mistake,  but  the ETS table has been destroyed as it was owned by the killed
       evaluator process.

       45&gt; f(E).
       ok
       46&gt; catch_exception(true).
       false

       Command 46 sets the exception handling of the evaluator process to <u>true</u>. The exception handling can  also
       be set when starting Erlang by <u>erl</u> <u>-stdlib</u> <u>shell_catch_exception</u> <u>true</u>.

       47&gt; E = ets:new(t, []).
       #Ref&lt;0.1662103692.2407923716.214197&gt;
       48&gt; ets:insert({d,1,2}).
       * exception error: undefined function ets:insert/1

       Command  48  makes  the  same mistake as in command 43, but this time the evaluator process lives on. The
       single star at the beginning of the printout signals that the exception has been caught.

       49&gt; ets:insert(E, {d,1,2}).
       true

       Command 49 successfully inserts the tuple into the ETS table.

       50&gt; ets:insert(#Ref&lt;0.1662103692.2407923716.214197&gt;, {e,3,4}).
       true

       Command 50 inserts another tuple into the ETS table. This time the first argument is the table identifier
       itself.  The  shell  can  parse  commands  with  pids  (<u>&lt;0.60.0&gt;</u>),   ports   (<u>#Port&lt;0.536&gt;</u>),   references
       (<u>#Ref&lt;0.1662103692.2407792644.214210&gt;</u>),  and  external  functions  (<u>#Fun&lt;a.b.1&gt;</u>),  but  the command fails
       unless the corresponding pid, port, reference, or function can be created in the running system.

       51&gt; halt().
       strider 2&gt;

       Command 51 exits the Erlang runtime system.

</pre><h4><b>JCL</b> <b>MODE</b></h4><pre>
       When the shell starts, it starts a single evaluator  process.  This  process,  together  with  any  local
       processes  that  it spawns, is referred to as a <u>job</u>. Only the current job, which is said to be <u>connected</u>,
       can perform operations with standard I/O. All other jobs, which are said to be <u>detached</u>, are  <u>blocked</u>  if
       they attempt to use standard I/O.

       All jobs that do not use standard I/O run in the normal way.

       The  shell escape key <u>^G</u> (Control G) detaches the current job and activates <u>JCL</u> mode. The <u>JCL</u> mode prompt
       is <u>"--&gt;"</u>. If <u>"?"</u> is entered at the prompt, the following help message is displayed:

       --&gt; ?
       c [nn]            - connect to job
       i [nn]            - interrupt job
       k [nn]            - kill job
       j                 - list all jobs
       s [shell]         - start local shell
       r [node [shell]]  - start remote shell
       q                 - quit erlang
       ? | h             - this message

       The <u>JCL</u> commands have the following meaning:

         <u>c</u> <u>[nn]</u>:
           Connects to job number <u>&lt;nn&gt;</u> or the current job. The standard shell is resumed.  Operations  that  use
           standard I/O by the current job are interleaved with user inputs to the shell.

         <u>i</u> <u>[nn]</u>:
           Stops the current evaluator process for job number <u>nn</u> or the current job, but does not kill the shell
           process.  So,  any  variable  bindings  and  the  process dictionary are preserved and the job can be
           connected again. This command can be used to interrupt an endless loop.

         <u>k</u> <u>[nn]</u>:
           Kills job number <u>nn</u> or the current job. All spawned processes in the job are  killed,  provided  they
           have  not evaluated the <u>group_leader/1</u> BIF and are located on the local machine. Processes spawned on
           remote nodes are not killed.

         <u>j</u>:
           Lists all jobs. A list of all known jobs is printed. The current job name is prefixed with '*'.

         <u>s</u>:
           Starts a new job. This is assigned the new index <u>[nn]</u>, which can be used in references.

         <u>s</u> <u>[shell]</u>:
           Starts a new job. This is assigned the new index <u>[nn]</u>, which can be used in references.  If  optional
           argument <u>shell</u> is specified, it is assumed to be a module that implements an alternative shell.

         <u>r</u> <u>[node]</u>:
           Starts  a remote job on <u>node</u>. This is used in distributed Erlang to allow a shell running on one node
           to control a number of applications running on a network of nodes.  If  optional  argument  <u>shell</u>  is
           specified, it is assumed to be a module that implements an alternative shell.

         <u>q</u>:
           Quits  Erlang.  Notice  that this option is disabled if Erlang is started with the ignore break, <u>+Bi</u>,
           system flag (which can be useful, for example when running a restricted shell, see the next section).

         <u>?</u>:
           Displays the help message above.

       The behavior of shell escape can be changed by the STDLIB application variable <u>shell_esc</u>.  The  value  of
       the  variable  can  be either <u>jcl</u> (<u>erl</u> <u>-stdlib</u> <u>shell_esc</u> <u>jcl</u>) or <u>abort</u> (<u>erl</u> <u>-stdlib</u> <u>shell_esc</u> <u>abort</u>). The
       first option sets <u>^G</u> to activate <u>JCL</u> mode (which is  also  default  behavior).  The  latter  sets  <u>^G</u>  to
       terminate  the  current  shell  and  start a new one. <u>JCL</u> mode cannot be invoked when <u>shell_esc</u> is set to
       <u>abort</u>.

       If you want an Erlang node to have a remote job active from the start  (rather  than  the  default  local
       job), start Erlang with flag <u>-remsh</u>, for example, <u>erl</u> <u>-remsh</u> <u>other_node@other_host</u>

</pre><h4><b>RESTRICTED</b> <b>SHELL</b></h4><pre>
       The  shell can be started in a restricted mode. In this mode, the shell evaluates a function call only if
       allowed. This feature makes it possible to, for example, prevent  a  user  from  accidentally  calling  a
       function from the prompt that could harm a running system (useful in combination with system flag <u>+Bi</u>).

       When  the  restricted  shell  evaluates  an  expression  and  encounters  a  function call or an operator
       application, it calls a callback function (with information about the function call  in  question).  This
       callback function returns <u>true</u> to let the shell go ahead with the evaluation, or <u>false</u> to abort it. There
       are two possible callback functions for the user to implement:

         * <u>local_allowed(Func,</u> <u>ArgList,</u> <u>State)</u> <u>-&gt;</u> <u>{boolean(),NewState}</u>

           This  is  used  to  determine  if the call to the local function <u>Func</u> with arguments <u>ArgList</u> is to be
           allowed.

         * <u>non_local_allowed(FuncSpec,</u>       <u>ArgList,</u>       <u>State)</u>       <u>-&gt;</u>        <u>{boolean(),NewState}</u>        <u>|</u>
           <u>{{redirect,NewFuncSpec,NewArgList},NewState}</u>

           This  is  used  to determine if the call to non-local function <u>FuncSpec</u> (<u>{Module,Func}</u> or a fun) with
           arguments <u>ArgList</u> is to be allowed. The return value <u>{redirect,NewFuncSpec,NewArgList}</u> can be used to
           let the shell evaluate some other function than the one specified by <u>FuncSpec</u> and <u>ArgList</u>.

       These callback functions are called from local and non-local evaluation function handlers,  described  in
       the <u>erl_eval</u> manual page. (Arguments in <u>ArgList</u> are evaluated before the callback functions are called.)

       Argument  <u>State</u>  is a tuple <u>{ShellState,ExprState}</u>. The return value <u>NewState</u> has the same form. This can
       be used to carry a state between calls to the callback functions. Data saved in <u>ShellState</u> lives  through
       an  entire  shell  session.  Data  saved  in  <u>ExprState</u>  lives only through the evaluation of the current
       expression.

       There are two ways to start a restricted shell session:

         * Use STDLIB application variable <u>restricted_shell</u> and specify, as its value, the name of the  callback
           module.   Example   (with   callback  functions  implemented  in  <u>callback_mod.erl</u>):  <u>$</u>  <u>erl</u>  <u>-stdlib</u>
           <u>restricted_shell</u> <u>callback_mod</u>.

         * From a normal shell session, call function <u>start_restricted/1</u>. This exits the current  evaluator  and
           starts a new one in restricted mode.

       <u>Notes:</u>

         * When  restricted  shell  mode  is  activated  or  deactivated,  new  jobs  started on the node run in
           restricted or normal mode, respectively.

         * If restricted mode has been enabled on a particular node, remote shells connecting to this node  also
           run in restricted mode.

         * The  callback  functions  cannot  be  used  to  allow  or disallow execution of functions called from
           compiled code (only functions called from expressions entered at the shell prompt).

       Errors when loading the callback module is handled in different ways  depending  on  how  the  restricted
       shell is activated:

         * If  the restricted shell is activated by setting the STDLIB variable during emulator startup, and the
           callback module cannot be loaded, a default restricted shell  allowing  only  the  commands  <u>q()</u>  and
           <u>init:stop()</u> is used as fallback.

         * If  the  restricted  shell  is  activated  using <u>start_restricted/1</u> and the callback module cannot be
           loaded, an error report is sent to the error logger and the call returns <u>{error,Reason}</u>.

</pre><h4><b>PROMPTING</b></h4><pre>
       The default shell prompt function displays the name of the node (if the node can be part of a distributed
       system) and the  current  command  number.  The  user  can  customize  the  prompt  function  by  calling
       <u>prompt_func/1</u>  or  by  setting  application  configuration  parameter  <u>shell_prompt_func</u>  for  the STDLIB
       application.

       A customized prompt function is stated as a tuple <u>{Mod,</u> <u>Func}</u>. The function  is  called  as  <u>Mod:Func(L)</u>,
       where  <u>L</u>  is  a list of key-value pairs created by the shell. Currently there is only one pair: <u>{history,</u>
       <u>N}</u>, where <u>N</u> is the current command number. The function is to return a list of  characters  or  an  atom.
       This  constraint  is  because  of  the  Erlang I/O protocol. Unicode characters beyond code point 255 are
       allowed in the list and the atom. Notice that in restricted mode the call <u>Mod:Func(L)</u> must be allowed  or
       the default shell prompt function is called.

</pre><h4><b>EXPORTS</b></h4><pre>
       <b>catch_exception(Bool)</b> <b>-&gt;</b> <b>boolean()</b>

              Types:

                 Bool = boolean()

              Sets the exception handling of the evaluator process. The previous exception handling is returned.
              The  default  (<u>false</u>)  is to kill the evaluator process when an exception occurs, which causes the
              shell to create a new evaluator process. When the exception handling is set to <u>true</u>, the evaluator
              process lives on, which means that, for example, ports and ETS tables as well as processes  linked
              to the evaluator process survive the exception.

       <b>history(N)</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>0</b>

              Types:

                 N = integer() &gt;= 0

              Sets  the  number  of  previous  commands to keep in the history list to <u>N</u>. The previous number is
              returned. Defaults to 20.

       <b>prompt_func(PromptFunc)</b> <b>-&gt;</b> <b>PromptFunc2</b>

              Types:

                 PromptFunc = PromptFunc2 = default | {module(), atom()}

              Sets the shell prompt function to <u>PromptFunc</u>. The previous prompt function is returned.

       <b>results(N)</b> <b>-&gt;</b> <b>integer()</b> <b>&gt;=</b> <b>0</b>

              Types:

                 N = integer() &gt;= 0

              Sets the number of results from previous commands to keep in the history list to <u>N</u>.  The  previous
              number is returned. Defaults to 20.

       <b>start_restricted(Module)</b> <b>-&gt;</b> <b>{error,</b> <b>Reason}</b>

              Types:

                 Module = module()
                 Reason = code:load_error_rsn()

              Exits  a  normal shell and starts a restricted shell. <u>Module</u> specifies the callback module for the
              functions <u>local_allowed/3</u> and <u>non_local_allowed/3</u>. The function is meant to  be  called  from  the
              shell.

              If the callback module cannot be loaded, an error tuple is returned. The <u>Reason</u> in the error tuple
              is the one returned by the code loader when trying to load the code of the callback module.

       <b>stop_restricted()</b> <b>-&gt;</b> <b>no_return()</b>

              Exits  a  restricted  shell and starts a normal shell. The function is meant to be called from the
              shell.

       <b>strings(Strings)</b> <b>-&gt;</b> <b>Strings2</b>

              Types:

                 Strings = Strings2 = boolean()

              Sets pretty printing of lists to <u>Strings</u>. The previous value of the flag is returned.

              The flag can also be set by the STDLIB application variable <u>shell_strings</u>. Defaults to <u>true</u>, which
              means that lists of integers are printed using the string syntax, when possible. Value <u>false</u> means
              that no lists are printed using the string syntax.

Ericsson AB                                        stdlib 3.17                                       <u><a href="../man3erl/shell.3erl.html">shell</a></u>(3erl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>