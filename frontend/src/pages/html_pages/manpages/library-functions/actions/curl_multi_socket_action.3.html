<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>curl_multi_socket_action - read/write available data given an action</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcurl4-doc">libcurl4-doc_8.14.1-1ubuntu2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       curl_multi_socket_action - read/write available data given an action

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;curl/curl.h&gt;

       CURLMcode curl_multi_socket_action(CURLM *multi_handle,
                                          curl_socket_t sockfd,
                                          int ev_bitmask,
                                          int *running_handles);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       When   the   application   has   detected  action  on  a  socket  handled  by  libcurl,  it  should  call
       <u><a href="../man3/curl_multi_socket_action.3.html">curl_multi_socket_action</a>(3)</u> with the <b>sockfd</b> argument set to the socket with the action. When  the  events
       on  a socket are known, they can be passed as an events bitmask <b>ev_bitmask</b> by first setting <b>ev_bitmask</b> to
       0, and then adding using bitwise OR (|) any combination of events  to  be  chosen  from  CURL_CSELECT_IN,
       CURL_CSELECT_OUT  or  CURL_CSELECT_ERR.  When  the  events  on  a socket are unknown, pass 0 instead, and
       libcurl tests the descriptor internally. It is also permissible to pass CURL_SOCKET_TIMEOUT to the <b>sockfd</b>
       parameter in order to initiate the whole process or when a timeout occurs.

       At return, <b>running_handles</b> points to the number of running easy handles within  the  multi  handle.  When
       this number reaches zero, all transfers are complete/done. When you call <u><a href="../man3/curl_multi_socket_action.3.html">curl_multi_socket_action</a>(3)</u> on a
       specific  socket  and  the  counter  decreases  by  one,  it  DOES  NOT  necessarily mean that this exact
       socket/transfer is the one that completed. Use <u><a href="../man3/curl_multi_info_read.3.html">curl_multi_info_read</a>(3)</u> to figure out  which  easy  handle
       that completed.

       The  <u><a href="../man3/curl_multi_socket_action.3.html">curl_multi_socket_action</a>(3)</u>  function  informs  the  application  about  updates in the socket (file
       descriptor) status by doing none, one, or multiple calls to the socket callback  function  set  with  the
       <u><a href="../man3/CURLMOPT_SOCKETFUNCTION.3.html">CURLMOPT_SOCKETFUNCTION</a>(3)</u>  option to <u><a href="../man3/curl_multi_setopt.3.html">curl_multi_setopt</a>(3)</u>. They update the status with changes since the
       previous time the callback was called.

       Get the timeout time by setting the  <u><a href="../man3/CURLMOPT_TIMERFUNCTION.3.html">CURLMOPT_TIMERFUNCTION</a>(3)</u>  option  with  <u><a href="../man3/curl_multi_setopt.3.html">curl_multi_setopt</a>(3)</u>.  Your
       application then gets called with information on how long to wait for socket actions at most before doing
       the  timeout  action:  call  the  <u><a href="../man3/curl_multi_socket_action.3.html">curl_multi_socket_action</a>(3)</u>  function  with  the <b>sockfd</b> argument set to
       CURL_SOCKET_TIMEOUT. You can also use the <u><a href="../man3/curl_multi_timeout.3.html">curl_multi_timeout</a>(3)</u> function to poll the value at  any  given
       time,  but for an event-based system using the callback is far better than relying on polling the timeout
       value.

       When this function returns error, the state of all transfers are uncertain and they cannot be  continued.
       <u><a href="../man3/curl_multi_socket_action.3.html">curl_multi_socket_action</a>(3)</u>  should  not be called again on the same multi handle after an error has been
       returned, unless first removing all the handles and adding new ones.

</pre><h4><b>TYPICAL</b> <b>USAGE</b></h4><pre>
       1. Create a multi handle

       2. Set the socket callback with <u><a href="../man3/CURLMOPT_SOCKETFUNCTION.3.html">CURLMOPT_SOCKETFUNCTION</a>(3)</u>

       3. Set the timeout callback with <u><a href="../man3/CURLMOPT_TIMERFUNCTION.3.html">CURLMOPT_TIMERFUNCTION</a>(3)</u>, to get to know what timeout value to use when
       waiting for socket activities.

       4. Add easy handles with curl_multi_add_handle()

       5. Provide some means to manage the sockets libcurl is using, so you can check them  for  activity.  This
       can be done through your application code, or by way of an external library such as libevent or glib.

       6.  Call  curl_multi_socket_action(..., CURL_SOCKET_TIMEOUT, 0, ...)  to kickstart everything. To get one
       or more callbacks called.

       7. Wait for activity on any of libcurl's sockets, use the timeout value your callback has been told.

       8, When activity is detected, call curl_multi_socket_action() for the socket(s) that got  action.  If  no
       activity is detected and the timeout expires, call <u><a href="../man3/curl_multi_socket_action.3.html">curl_multi_socket_action</a>(3)</u> with <u>CURL_SOCKET_TIMEOUT</u>.

</pre><h4><b>PROTOCOLS</b></h4><pre>
       This functionality affects all supported protocols

</pre><h4><b>EXAMPLE</b></h4><pre>
       int main(void)
       {
         /* the event-library gets told when there activity on the socket 'fd',
            which we translate to a call to curl_multi_socket_action() */
         int running = 0;
         int fd = 3; /* the descriptor that had action */
         int bitmask = 2; /* what activity that happened */

         CURLM *multi = curl_multi_init();

         CURLMcode mc = curl_multi_socket_action(multi, fd, bitmask, &amp;running);
         <a href="../manmc/if.mc.html">if</a>(mc)
           printf("error: %s\n", <a href="../manmc/curl_multi_strerror.mc.html">curl_multi_strerror</a>(mc));
       }

</pre><h4><b>AVAILABILITY</b></h4><pre>
       Added in curl 7.15.4

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       This function returns a CURLMcode indicating success or error.

       CURLM_OK (0) means everything was OK, non-zero means an error occurred, see <u><a href="../man3/libcurl-errors.3.html">libcurl-errors</a>(3)</u>.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/curl_multi_cleanup.3.html">curl_multi_cleanup</a></b>(3),       <b><a href="../man3/curl_multi_fdset.3.html">curl_multi_fdset</a></b>(3),       <b><a href="../man3/curl_multi_info_read.3.html">curl_multi_info_read</a></b>(3),      <b><a href="../man3/curl_multi_init.3.html">curl_multi_init</a></b>(3),
       <b>the</b>hiperfifo.c<b>example</b>

libcurl                                            2025-06-16                        <u><a href="../man3/curl_multi_socket_action.3.html">curl_multi_socket_action</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>