<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cairo - Perl interface to the cairo 2d vector graphics library</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcairo-perl">libcairo-perl_1.109-5build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Cairo - Perl interface to the cairo 2d vector graphics library

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Cairo;

         my $surface = Cairo::ImageSurface-&gt;create ('argb32', 100, 100);
         my $cr = Cairo::Context-&gt;create ($surface);

         $cr-&gt;rectangle (10, 10, 40, 40);
         $cr-&gt;set_source_rgb (0, 0, 0);
         $cr-&gt;fill;

         $cr-&gt;rectangle (50, 50, 40, 40);
         $cr-&gt;set_source_rgb (1, 1, 1);
         $cr-&gt;fill;

         $cr-&gt;show_page;

         $surface-&gt;write_to_png ('output.png');

</pre><h4><b>ABSTRACT</b></h4><pre>
       Cairo provides Perl bindings for the vector graphics library cairo.  It supports multiple output targets,
       including PNG, PDF and SVG.  Cairo produces identical output on all those targets.

</pre><h4><b>API</b> <b>DOCUMENTATION</b></h4><pre>
       This is a listing of the API Cairo provides.  For more verbose information, refer to the cairo manual at
       &lt;<a href="http://cairographics.org/manual/">http://cairographics.org/manual/</a>&gt;.

   <b>Drawing</b>
       <u>Cairo::Context</u> <u>--</u> <u>The</u> <u>cairo</u> <u>drawing</u> <u>context</u>

       <u>Cairo::Context</u> is the main object used when drawing with Cairo. To draw with Cairo, you create a
       <u>Cairo::Context</u>, set the target surface, and drawing options for the <u>Cairo::Context</u>, create shapes with
       methods like "$cr-&gt;move_to" and "$cr-&gt;line_to", and then draw shapes with "$cr-&gt;stroke" or "$cr-&gt;fill".

       <u>Cairo::Context</u>'s can be pushed to a stack via "$cr-&gt;save". They may then safely be changed, without
       loosing the current state. Use "$cr-&gt;restore" to restore to the saved state.

       $cr = Cairo::Context-&gt;create ($surface)
           $surface: <u>Cairo::Surface</u>
       $cr-&gt;save
       $cr-&gt;restore
       $status = $cr-&gt;status
       $surface = $cr-&gt;get_target
       $cr-&gt;push_group [1.2]
       $cr-&gt;push_group_with_content ($content) [1.2]
           $content: <u>Cairo::Content</u>
       $pattern = $cr-&gt;pop_group [1.2]
       $cr-&gt;pop_group_to_source [1.2]
       $surface = $cr-&gt;get_group_target [1.2]
       $cr-&gt;set_source_rgb ($red, $green, $blue)
           $red: double
           $green: double
           $blue: double
       $cr-&gt;set_source_rgba ($red, $green, $blue, $alpha)
           $red: double
           $green: double
           $blue: double
           $alpha: double
       $cr-&gt;set_source ($source)
           $source: <u>Cairo::Pattern</u>
       $cr-&gt;set_source_surface ($surface, $x, $y)
           $surface: <u>Cairo::Surface</u>
           $x: double
           $y: double
       $source = $cr-&gt;get_source
       $cr-&gt;set_antialias ($antialias)
           $antialias: <u>Cairo::Antialias</u>
       $antialias = $cr-&gt;get_antialias
       $cr-&gt;set_dash ($offset, ...)
           $offset: double
           ...: list of doubles
       $cr-&gt;set_fill_rule ($fill_rule)
           $fill_rule: <u>Cairo::FillRule</u>
       $fill_rule = $cr-&gt;get_fill_rule
       $cr-&gt;set_line_cap ($line_cap)
           $line_cap: <u>Cairo::LineCap</u>
       $line_cap = $cr-&gt;get_line_cap
       $cr-&gt;set_line_join ($line_join)
           $line_join: <u>Cairo::LineJoin</u>
       $line_join = $cr-&gt;get_line_join
       $cr-&gt;set_line_width ($width)
           $width: double
       $width = $cr-&gt;get_line_width
       $cr-&gt;set_miter_limit ($limit)
           $limit: double
       ($offset, @dashes) = $cr-&gt;get_dash [1.4]
       $limit = $cr-&gt;get_miter_limit
       $cr-&gt;set_operator ($op)
           $op: <u>Cairo::Operator</u>
       $op = $cr-&gt;get_operator
       $cr-&gt;set_tolerance ($tolerance)
           $tolerance: double
       $tolerance = $cr-&gt;get_tolerance
       $cr-&gt;clip
       $cr-&gt;clip_preserve
       ($x1, $y1, $x2, $y2) = $cr-&gt;clip_extents [1.4]
       $bool = $cr-&gt;in_clip ($x, $y) [1.10]
           $x: double
           $y: double
       @rectangles = $cr-&gt;copy_clip_rectangle_list [1.4]
       $cr-&gt;reset_clip
       $cr-&gt;fill
       $cr-&gt;fill_preserve
       ($x1, $y1, $x2, $y2) = $cr-&gt;fill_extents
       $bool = $cr-&gt;in_fill ($x, $y)
           $x: double
           $y: double
       $cr-&gt;mask ($pattern)
           $pattern: <u>Cairo::Pattern</u>
       $cr-&gt;mask_surface ($surface, $surface_x, $surface_y)
           $surface: <u>Cairo::Surface</u>
           $surface_x: double
           $surface_y: double
       $cr-&gt;paint
       $cr-&gt;paint_with_alpha ($alpha)
           $alpha: double
       $cr-&gt;stroke
       $cr-&gt;stroke_preserve
       ($x1, $y1, $x2, $y2) = $cr-&gt;stroke_extents
       $bool = $cr-&gt;in_stroke ($x, $y)
           $x: double
           $y: double
       $cr-&gt;tag_begin($name, $atts) [1.16]
           $name: string
           $atts: string
       $cr-&gt;tag_end($name) [1.16]
           $name: string
       Predefined names:
           Cairo::TAG_DEST [1.16]
           Cairo::TAG_LINK [1.16]
       $cr-&gt;copy_page
       $cr-&gt;show_page

       <u>Paths</u> <u>--</u> <u>Creating</u> <u>paths</u> <u>and</u> <u>manipulating</u> <u>path</u> <u>data</u>

         $path = [
           { type =&gt; "move-to", points =&gt; [[1, 2]] },
           { type =&gt; "line-to", points =&gt; [[3, 4]] },
           { type =&gt; "curve-to", points =&gt; [[5, 6], [7, 8], [9, 10]] },
           ...
           { type =&gt; "close-path", points =&gt; [] },
         ];

       <u>Cairo::Path</u>  is  a  data structure for holding a path. This data structure serves as the return value for
       "$cr-&gt;copy_path" and "$cr-&gt;copy_path_flat" as well the input value for "$cr-&gt;append_path".

       <u>Cairo::Path</u> is represented as an array  reference  that  contains  path  elements,  represented  by  hash
       references with two keys: <u>type</u> and <u>points</u>.  The value for <u>type</u> can be either of the following:

       "move-to"
       "line-to"
       "curve-to"
       "close-path"

       The value for <u>points</u> is an array reference which contains zero or more points.  Points are represented as
       array  references  that contain two doubles: <u>x</u> and <u>y</u>.  The necessary number of points depends on the <u>type</u>
       of the path element:

       "move-to": 1 point
       "line_to": 1 point
       "curve-to": 3 points
       "close-path": 0 points

       The semantics and ordering of the coordinate values are consistent with  "$cr-&gt;move_to",  "$cr-&gt;line_to",
       "$cr-&gt;curve_to", and "$cr-&gt;close_path".

       Note  that  the  paths  returned  by  Cairo are implemented as tied array references which do <b>not</b> support
       adding, removing or shuffling of path segments.  For these operations, you need to make  a  shallow  copy
       first:

         my @path_clone = @{$path};
         # now you can alter @path_clone which ever way you want

       The  points  of  a  single  path element can be changed directly, however, without the need for a shallow
       copy:

         $path-&gt;[$i]{points} = [[3, 4], [5, 6], [7, 8]];

       $path = $cr-&gt;copy_path
       $path = $cr-&gt;copy_path_flat
       $cr-&gt;append_path ($path)
           $path: <u>Cairo::Path</u>
       $bool = $cr-&gt;has_current_point [1.6]
       ($x, $y) = $cr-&gt;get_current_point
       $cr-&gt;new_path
       $cr-&gt;new_sub_path [1.2]
       $cr-&gt;close_path
       ($x1, $y1, $x2, $y2) = $cr-&gt;path_extents [1.6]
       $cr-&gt;arc ($xc, $yc, $radius, $angle1, $angle2)
           $xc: double
           $yc: double
           $radius: double
           $angle1: double
           $angle2: double
       $cr-&gt;arc_negative ($xc, $yc, $radius, $angle1, $angle2)
           $xc: double
           $yc: double
           $radius: double
           $angle1: double
           $angle2: double
       $cr-&gt;curve_to ($x1, $y1, $x2, $y2, $x3, $y3)
           $x1: double
           $y1: double
           $x2: double
           $y2: double
           $x3: double
           $y3: double
       $cr-&gt;line_to ($x, $y)
           $x: double
           $y: double
       $cr-&gt;move_to ($x, $y)
           $x: double
           $y: double
       $cr-&gt;rectangle ($x, $y, $width, $height)
           $x: double
           $y: double
           $width: double
           $height: double
       $cr-&gt;glyph_path (...)
           ...: list of <u>Cairo::Glyph</u>'s
       $cr-&gt;text_path ($utf8)
           $utf8: string in utf8 encoding
       $cr-&gt;rel_curve_to ($dx1, $dy1, $dx2, $dy2, $dx3, $dy3)
           $dx1: double
           $dy1: double
           $dx2: double
           $dy2: double
           $dx3: double
           $dy3: double
       $cr-&gt;rel_line_to ($dx, $dy)
           $dx: double
           $dy: double
       $cr-&gt;rel_move_to ($dx, $dy)
           $dx: double
           $dy: double

       <u>Patterns</u> <u>--</u> <u>Gradients</u> <u>and</u> <u>filtered</u> <u>sources</u>

       $status = $pattern-&gt;status
       $type = $pattern-&gt;get_type [1.2]
       $pattern-&gt;set_extend ($extend)
           $extend: <u>Cairo::Extend</u>
       $extend = $pattern-&gt;get_extend
       $pattern-&gt;set_filter ($filter)
           $filter: <u>Cairo::Filter</u>
       $filter = $pattern-&gt;get_filter
       $pattern-&gt;set_matrix ($matrix)
           $matrix: <u>Cairo::Matrix</u>
       $matrix = $pattern-&gt;get_matrix
       $pattern = Cairo::SolidPattern-&gt;create_rgb ($red, $green, $blue)
           $red: double
           $green: double
           $blue: double
       $pattern = Cairo::SolidPattern-&gt;create_rgba ($red, $green, $blue, $alpha)
           $red: double
           $green: double
           $blue: double
           $alpha: double
       ($r, $g, $b, $a) = $pattern-&gt;get_rgba [1.4]
       $pattern = Cairo::SurfacePattern-&gt;create ($surface)
           $surface: <u>Cairo::Surface</u>
       $surface = $pattern-&gt;get_surface [1.4]
       $pattern = Cairo::LinearGradient-&gt;create ($x0, $y0, $x1, $y1)
           $x0: double
           $y0: double
           $x1: double
           $y1: double
       ($x0, $y0, $x1, $y1) = $pattern-&gt;get_points [1.4]
       $pattern = Cairo::RadialGradient-&gt;create ($cx0, $cy0, $radius0, $cx1, $cy1, $radius1)
           $cx0: double
           $cy0: double
           $radius0: double
           $cx1: double
           $cy1: double
           $radius1: double
       ($x0, $y0, $r0, $x1, $y1, $r1) = $pattern-&gt;get_circles [1.4]
       $pattern-&gt;add_color_stop_rgb ($offset, $red, $green, $blue)
           $offset: double
           $red: double
           $green: double
           $blue: double
       $pattern-&gt;add_color_stop_rgba ($offset, $red, $green, $blue, $alpha)
           $offset: double
           $red: double
           $green: double
           $blue: double
           $alpha: double
       @stops = $pattern-&gt;get_color_stops [1.4]
           A color stop is represented as an array reference with five elements: offset, red, green,  blue,  and
           alpha.

       <u>Regions</u> <u>--</u> <u>Representing</u> <u>a</u> <u>pixel-aligned</u> <u>area</u>

       $region = Cairo::Region-&gt;create (...) [1.10]
           ...: zero or more <u>Cairo::RectangleInt</u>
       $status = $region-&gt;status [1.10]
       $num = $region-&gt;num_rectangles [1.10]
       $rect = $region-&gt;get_rectangle ($i) [1.10]
           $i: integer
       $bool = $region-&gt;is_empty [1.10]
       $bool = $region-&gt;contains_point ($x, $y) [1.10]
           $x: integer
           $y: integer
       $bool = $region_one-&gt;equal ($region_two) [1.10]
           $region_two: <u>Cairo::Region</u>
       $region-&gt;translate ($dx, $dy) [1.10]
           $dx: integer
           $dy: integer
       $status = $dst-&gt;intersect ($other) [1.10]
       $status = $dst-&gt;intersect_rectangle ($rect) [1.10]
       $status = $dst-&gt;subtract ($other) [1.10]
       $status = $dst-&gt;subtract_rectangle ($rect) [1.10]
       $status = $dst-&gt;union ($other) [1.10]
       $status = $dst-&gt;union_rectangle ($rect) [1.10]
       $status = $dst-&gt;xor ($other) [1.10]
       $status = $dst-&gt;xor_rectangle ($rect) [1.10]
           $other: <u>Cairo::Region</u>
           $rect: <u>Cairo::RectangleInt</u>

       <u>Transformations</u> <u>--</u> <u>Manipulating</u> <u>the</u> <u>current</u> <u>transformation</u> <u>matrix</u>

       $cr-&gt;translate ($tx, $ty)
           $tx: double
           $ty: double
       $cr-&gt;scale ($sx, $sy)
           $sx: double
           $sy: double
       $cr-&gt;rotate ($angle)
           $angle: double
       $cr-&gt;transform ($matrix)
           $matrix: <u>Cairo::Matrix</u>
       $cr-&gt;set_matrix ($matrix)
           $matrix: <u>Cairo::Matrix</u>
       $matrix = $cr-&gt;get_matrix
       $cr-&gt;identity_matrix
       ($x, $y) = $cr-&gt;user_to_device ($x, $y)
           $x: double
           $y: double
       ($dx, $dy) = $cr-&gt;user_to_device_distance ($dx, $dy)
           $dx: double
           $dy: double
       ($x, $y) = $cr-&gt;device_to_user ($x, $y)
           $x: double
           $y: double
       ($dx, $dy) = $cr-&gt;device_to_user_distance ($dx, $dy)
           $dx: double
           $dy: double

       <u>Text</u> <u>--</u> <u>Rendering</u> <u>text</u> <u>and</u> <u>sets</u> <u>of</u> <u>glyphs</u>

       Glyphs are represented as anonymous hash references with three keys: <u>index</u>, <u>x</u> and <u>y</u>.  Example:

         my @glyphs = ({ index =&gt; 1, x =&gt; 2, y =&gt; 3 },
                       { index =&gt; 2, x =&gt; 3, y =&gt; 4 },
                       { index =&gt; 3, x =&gt; 4, y =&gt; 5 });

       $cr-&gt;select_font_face ($family, $slant, $weight)
           $family: string
           $slant: <u>Cairo::FontSlant</u>
           $weight: <u>Cairo::FontWeight</u>
       $cr-&gt;set_font_size ($size)
           $size: double
       $cr-&gt;set_font_matrix ($matrix)
           $matrix: <u>Cairo::Matrix</u>
       $matrix = $cr-&gt;get_font_matrix
       $cr-&gt;set_font_options ($options)
           $options: <u>Cairo::FontOptions</u>
       $options = $cr-&gt;get_font_options
       $cr-&gt;set_scaled_font ($scaled_font) [1.2]
           $scaled_font: <u>Cairo::ScaledFont</u>
       $scaled_font = $cr-&gt;get_scaled_font [1.4]
       $cr-&gt;show_text ($utf8)
           $utf8: string
       $cr-&gt;show_glyphs (...)
           ...: list of glyphs
       $cr-&gt;show_text_glyphs ($utf8, $glyphs, $clusters, $cluster_flags) [1.8]
           $utf8: string
           $glyphs: array ref of glyphs
           $clusters: array ref of clusters
           $cluster_flags: <u>Cairo::TextClusterFlags</u>
       $face = $cr-&gt;get_font_face
       $extents = $cr-&gt;font_extents
       $cr-&gt;set_font_face ($font_face)
           $font_face: <u>Cairo::FontFace</u>
       $cr-&gt;set_scaled_font ($scaled_font)
           $scaled_font: <u>Cairo::ScaledFont</u>
       $extents = $cr-&gt;text_extents ($utf8)
           $utf8: string
       $extents = $cr-&gt;glyph_extents (...)
           ...: list of glyphs
       $face = Cairo::ToyFontFace-&gt;create ($family, $slant, $weight) [1.8]
           $family: string
           $slant: <u>Cairo::FontSlant</u>
           $weight: <u>Cairo::FontWeight</u>
       $family = $face-&gt;get_family [1.8]
       $slang = $face-&gt;get_slant [1.8]
       $weight = $face-&gt;get_weight [1.8]

   <b>Fonts</b>
       <u>Cairo::FontFace</u> <u>--</u> <u>Base</u> <u>class</u> <u>for</u> <u>fonts</u>

       $status = $font_face-&gt;status
       $type = $font_face-&gt;get_type [1.2]

       <u>Scaled</u> <u>Fonts</u> <u>--</u> <u>Caching</u> <u>metrics</u> <u>for</u> <u>a</u> <u>particular</u> <u>font</u> <u>size</u>

       $scaled_font = Cairo::ScaledFont-&gt;create ($font_face, $font_matrix, $ctm, $options)
           $font_face: <u>Cairo::FontFace</u>
           $font_matrix: <u>Cairo::Matrix</u>
           $ctm: <u>Cairo::Matrix</u>
           $options: <u>Cairo::FontOptions</u>
       $status = $scaled_font-&gt;status
       $extents = $scaled_font-&gt;extents
       $extents = $scaled_font-&gt;text_extents ($utf8) [1.2]
           $utf8: string
       $extents = $scaled_font-&gt;glyph_extents (...)
           ...: list of glyphs
       ($status, $glyphs, $clusters, $cluster_flags) = $scaled_font-&gt;text_to_glyphs ($x, $y, $utf8) [1.8]
           $x: double
           $y: double
           $utf8: string
       $font_face = $scaled_font-&gt;get_font_face [1.2]
       $options = $scaled_font-&gt;get_font_options [1.2]
       $font_matrix = $scaled_font-&gt;get_font_matrix [1.2]
       $ctm = $scaled_font-&gt;get_ctm [1.2]
       $scale_matrix = $scaled_font-&gt;get_scale_matrix [1.8]
       $type = $scaled_font-&gt;get_type [1.2]

       <u>Font</u> <u>Options</u> <u>--</u> <u>How</u> <u>a</u> <u>font</u> <u>should</u> <u>be</u> <u>rendered</u>

       $font_options = Cairo::FontOptions-&gt;create
       $status = $font_options-&gt;status
       $font_options-&gt;merge ($other)
           $other: <u>Cairo::FontOptions</u>
       $hash = $font_options-&gt;hash
       $bools = $font_options-&gt;equal ($other)
           $other: <u>Cairo::FontOptions</u>
       $font_options-&gt;set_antialias ($antialias)
           $antialias: <u>Cairo::AntiAlias</u>
       $antialias = $font_options-&gt;get_antialias
       $font_options-&gt;set_subpixel_order ($subpixel_order)
           $subpixel_order: <u>Cairo::SubpixelOrder</u>
       $subpixel_order = $font_options-&gt;get_subpixel_order
       $font_options-&gt;set_hint_style ($hint_style)
           $hint_style: <u>Cairo::HintStyle</u>
       $hint_style = $font_options-&gt;get_hint_style
       $font_options-&gt;set_hint_metrics ($hint_metrics)
           $hint_metrics: <u>Cairo::HintMetrics</u>
       $hint_metrics = $font_options-&gt;get_hint_metrics

       <u>FreeType</u> <u>Fonts</u> <u>--</u> <u>Font</u> <u>support</u> <u>for</u> <u>FreeType</u>

       If  your  cairo  library  supports  it,  the FreeType integration allows you to load font faces from font
       files.  You can query for this capability with "Cairo::HAS_FT_FONT".  To actually use this,  you'll  need
       the Font::FreeType module.

       my $face = Cairo::FtFontFace-&gt;create ($ft_face, $load_flags=0)
           $ft_face: <u>Font::FreeType::Face</u>
           $load_flags: integer

           This  method  allows  you  to  create  a  <u>Cairo::FontFace</u> from a <u>Font::FreeType::Face</u>.  To obtain the
           latter, you can for example load it from a file:

             my $file = '/usr/share/fonts/truetype/ttf-bitstream-vera/Vera.ttf';
             my $ft_face = Font::FreeType-&gt;new-&gt;face ($file);
             my $face = Cairo::FtFontFace-&gt;create ($ft_face);

   <b>Surfaces</b>
       <u>Cairo::Surface</u> <u>--</u> <u>Base</u> <u>class</u> <u>for</u> <u>surfaces</u>

       $similar = Cairo::Surface-&gt;create_similar ($other, $content, $width, $height)
           $other: <u>Cairo::Surface</u>
           $content: <u>Cairo::Content</u>
           $width: integer
           $height: integer

           For hysterical reasons, you can also use the following syntax:

             $similar = $other-&gt;create_similar ($content, $width, $height)

       $new = Cairo::Surface-&gt;create_for_rectangle ($target, $x, $y, $width, $height) [1.10]
           $target: <u>Cairo::Surface</u>
           $x: double
           $y: double
           $width: double
           $height: double
       $status = $surface-&gt;status
       $surface-&gt;finish
       $surface-&gt;flush
       $font_options = $surface-&gt;get_font_options
       $content = $surface-&gt;get_content [1.2]
       $surface-&gt;mark_dirty
       $surface-&gt;mark_dirty_rectangle ($x, $y, $width, $height)
           $x: integer
           $y: integer
           $width: integer
           $height: integer
       $surface-&gt;set_device_offset ($x_offset, $y_offset)
           $x_offset: integer
           $y_offset: integer
       ($x_offset, $y_offset) = $surface-&gt;get_device_offset [1.2]
       $surface-&gt;set_fallback_resolution ($x_pixels_per_inch, $y_pixels_per_inch) [1.2]
           $x_pixels_per_inch: double
           $y_pixels_per_inch: double
       ($x_pixels_per_inch, $y_pixels_per_inch) = $surface-&gt;get_fallback_resolution [1.8]
       $type = $surface-&gt;get_type [1.2]
       $surface-&gt;set_mime_data ($mime_type, $mime_data) [1.10]
       $mime_data = $surface-&gt;get_mime_data ($mime_type) [1.10]
       $bool = $surface-&gt;supports_mime_type ($mime_type) [1.12]
           $mime_type: string
               Predefined MIME types:
                   Cairo::Surface::MIME_TYPE_JP2 [1.10]
                   Cairo::Surface::MIME_TYPE_JPEG [1.10]
                   Cairo::Surface::MIME_TYPE_PNG [1.10]
                   Cairo::Surface::MIME_TYPE_URI [1.10]
                   Cairo::Surface::MIME_TYPE_UNIQUE_ID [1.12]
                   Cairo::Surface::MIME_TYPE_JBIG2 [1.14]
                   Cairo::Surface::MIME_TYPE_JBIG2_GLOBAL [1.14]
                   Cairo::Surface::MIME_TYPE_JBIG2_GLOBAL_PARAMS [1.14]
                   Cairo::Surface::MIME_TYPE_CCITT_FAX [1.16]
                   Cairo::Surface::MIME_TYPE_CCITT_FAX_PARAMS [1.16]
                   Cairo::Surface::MIME_TYPE_EPS [1.16]
                   Cairo::Surface::MIME_TYPE_EPS_PARAMS [1.16]
           $mime_data: binary data string
       $status = $surface-&gt;copy_page [1.6]
           $status: <u>Cairo::Status</u>
       $status = $surface-&gt;show_page [1.6]
           $status: <u>Cairo::Status</u>
       $boolean = $surface-&gt;has_show_text_glyphs [1.8]

       <u>Image</u> <u>Surfaces</u> <u>--</u> <u>Rendering</u> <u>to</u> <u>memory</u> <u>buffers</u>

       $surface = Cairo::ImageSurface-&gt;create ($format, $width, $height)
           $format: <u>Cairo::Format</u>
           $width: integer
           $height: integer
       $surface = Cairo::ImageSurface-&gt;create_for_data ($data, $format, $width, $height, $stride)
           $data: image data
           $format: <u>Cairo::Format</u>
           $width: integer
           $height: integer
           $stride: integer
       $data = $surface-&gt;get_data [1.2]
       $format = $surface-&gt;get_format [1.2]
       $width = $surface-&gt;get_width
       $height = $surface-&gt;get_height
       $stride = $surface-&gt;get_stride [1.2]
       $stride = Cairo::Format::stride_for_width ($format, $width) [1.6]
           $format: <u>Cairo::Format</u>
           $width: integer

       <u>PDF</u> <u>Surfaces</u> <u>--</u> <u>Rendering</u> <u>PDF</u> <u>documents</u>

       $surface = Cairo::PdfSurface-&gt;create ($filename, $width_in_points, $height_in_points) [1.2]
           $filename: string
           $width_in_points: double
           $height_in_points: double
       $surface = Cairo::PdfSurface-&gt;create_for_stream ($callback, $callback_data, $width_in_points,
       $height_in_points) [1.2]
           $callback: <u>Cairo::WriteFunc</u>
           $callback_data: scalar
           $width_in_points: double
           $height_in_points: double
       $surface-&gt;set_size ($width_in_points, $height_in_points) [1.2]
           $width_in_points: double
           $height_in_points: double
       $surface-&gt;restrict_to_version ($version) [1.10]
           $version: <u>Cairo::PdfVersion</u>
       @versions = Cairo::PdfSurface::get_versions [1.10]
       $string = Cairo::PdfSurface::version_to_string ($version) [1.10]
           $version: <u>Cairo::PdfVersion</u>
       $item_id = $surface-&gt;add_outline($parent_id, $name, $attributes, $flags) [1.16]
           $item_id: int, item ID
           $parent_id: parent item id or Cairo::PdfSurface::OUTLINE_ROOT
           $name: string, item display
           $attributes: string, item attributes
           $flags: list reference, item flags
       $surface-&gt;set_metadata($name, $value) [1.16]
           $name: string
           $value: string
       $surface-&gt;set_page_label($label) [1.16]
           $label: string, page label
       $surface-&gt;set_thumbnail_size($width, $height) [1.16]
           $width: int, thumbnail width
           $height: int, thumbnail height

       <u>PNG</u> <u>Support</u> <u>--</u> <u>Reading</u> <u>and</u> <u>writing</u> <u>PNG</u> <u>images</u>

       $surface = Cairo::ImageSurface-&gt;create_from_png ($filename)
           $filename: string
       Cairo::ReadFunc: $data = sub { my ($callback_data, $length) = @_; }
           $data: binary image data, of length $length
           $callback_data: scalar, user data
           $length: integer, bytes to read
       $surface = Cairo::ImageSurface-&gt;create_from_png_stream ($callback, $callback_data)
           $callback: <u>Cairo::ReadFunc</u>
           $callback_data: scalar
       $status = $surface-&gt;write_to_png ($filename)
           $filename: string
       Cairo::WriteFunc: sub { my ($callback_data, $data) = @_; }
           $callback_data: scalar, user data
           $data: binary image data, to be written
       $status = $surface-&gt;write_to_png_stream ($callback, $callback_data)
           $callback: <u>Cairo::WriteFunc</u>
           $callback_data: scalar

       <u>PostScript</u> <u>Surfaces</u> <u>--</u> <u>Rendering</u> <u>PostScript</u> <u>documents</u>

       $surface = Cairo::PsSurface-&gt;create ($filename, $width_in_points, $height_in_points) [1.2]
           $filename: string
           $width_in_points: double
           $height_in_points: double
       $surface = Cairo::PsSurface-&gt;create_for_stream ($callback, $callback_data, $width_in_points,
       $height_in_points) [1.2]
           $callback: <u>Cairo::WriteFunc</u>
           $callback_data: scalar
           $width_in_points: double
           $height_in_points: double
       $surface-&gt;set_size ($width_in_points, $height_in_points) [1.2]
           $width_in_points: double
           $height_in_points: double
       $surface-&gt;dsc_begin_setup [1.2]
       $surface-&gt;dsc_begin_page_setup [1.2]
       $surface-&gt;dsc_comment ($comment) [1.2]
           $comment: string
       $surface-&gt;restrict_to_level ($level) [1.6]
           $level: <u>Cairo::PsLevel</u>
       @levels = Cairo::PsSurface::get_levels [1.6]
       $string = Cairo::PsSurface::level_to_string ($level) [1.6]
           $level: <u>Cairo::PsLevel</u>
       $surface-&gt;set_eps ($eps) [1.6]
           $eps: boolean
       $eps = $surface-&gt;get_eps [1.6]

       <u>Recording</u> <u>Surfaces</u> <u>--</u> <u>Records</u> <u>all</u> <u>drawing</u> <u>operations</u>

       $surface = Cairo::RecordingSurface-&gt;create ($content, $extents) [1.10]
           $content: <u>Cairo::Content</u>
           $extents: <u>Cairo::Rectangle</u>
       ($x0, $y0, $width, $height) = $surface-&gt;ink_extents [1.10]
       $extents_ref = $surface-&gt;get_extents [1.12]
           $extents_ref: <u>Cairo::Rectangle</u> reference

       <u>SVG</u> <u>Surfaces</u> <u>--</u> <u>Rendering</u> <u>SVG</u> <u>documents</u>

       $surface = Cairo::SvgSurface-&gt;create ($filename, $width_in_points, $height_in_points) [1.2]
           $filename: string
           $width_in_points: double
           $height_in_points: double
       $surface = Cairo::SvgSurface-&gt;create_for_stream ($callback, $callback_data, $width_in_points,
       $height_in_points) [1.2]
           $callback: <u>Cairo::WriteFunc</u>
           $callback_data: scalar
           $width_in_points: double
           $height_in_points: double
       $surface-&gt;restrict_to_version ($version) [1.2]
           $version: <u>Cairo::SvgVersion</u>
       @versions = Cairo::SvgSurface::get_versions [1.2]
       $string = Cairo::SvgSurface::version_to_string ($version) [1.2]
           $version: <u>Cairo::SvgVersion</u>

   <b>Utilities</b>
       <u>Version</u> <u>Information</u> <u>--</u> <u>Run-time</u> <u>and</u> <u>compile-time</u> <u>version</u> <u>checks.</u>

       $version_code = Cairo-&gt;lib_version
       $version_string = Cairo-&gt;lib_version_string
           These two functions return the version of libcairo that the program is currently running against.

       $version_code = Cairo-&gt;LIB_VERSION
           Returns the version of libcairo that Cairo was compiled against.

       $version_code = Cairo-&gt;LIB_VERSION_ENCODE ($major, $minor, $micro)
           $major: integer
           $minor: integer
           $micro: integer

           Encodes  the  version  "$major.$minor.$micro"  as  an  integer  suitable   for   comparison   against
           "Cairo-&gt;lib_version" and "Cairo-&gt;LIB_VERSION".

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       &lt;<a href="http://cairographics.org/documentation">http://cairographics.org/documentation</a>&gt;
           Lists many available resources including tutorials and examples

       &lt;<a href="http://cairographics.org/manual/">http://cairographics.org/manual/</a>&gt;
           Contains the reference manual

</pre><h4><b>AUTHORS</b></h4><pre>
       Ross McFarland &lt;rwmcfa1 at neces dot com&gt;
       Torsten Schoenfeld &lt;kaffeetisch at gmx dot de&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (C) 2004-2013 by the cairo perl team

perl v5.40.0                                       2024-10-20                                         <u><a href="../man3pm/Cairo.3pm.html">Cairo</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>