<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data::Types - Validate and convert data types.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdata-types-perl">libdata-types-perl_0.17-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Data::Types - Validate and convert data types.

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Data::Types qw(:all);

         my $whole = 4.5;
         $whole = to_whole($whole) unless is_whole($whole);

         my $int = 1.2;
         $int = to_int($int) unless is_int($int);

         my $decimal = '1.2foo';
         $decimal = to_decimal($decimal) unless is_decimal($decimal);

         my $real = '1.2foo';
         $real = to_real($real) unless is_real($real);

         my $float = '1.2foo';
         $float = to_float($float) unless is_float($float);

         my $string = [];
         $string = to_string($string) unless is_string($string);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module exports a number of functions that are useful for validating and converting data types. It is
       intended for use in applications where data types are more important than they typically are in Perl --
       e.g., database applications.

</pre><h4><b>EXPORT</b></h4><pre>
       No functions are exported by default, though each function may be exported explicitly (see "FUNCTIONS"
       below, for a list of functions available for export). The following export tags are supported:

       :whole
           Exports <b>is_whole()</b> and <b>to_whole()</b>.

       :count
           Exports <b>is_count()</b> and <b>to_count()</b>.

       :int
           Exports <b>is_int()</b> and <b>to_int()</b>.

       :decimal
           Exports <b>is_decimal()</b> and <b>to_decimal()</b>.

       :real
           Exports <b>is_real()</b> and <b>to_real()</b>.

       :float
           Exports <b>is_float()</b> and <b>to_float()</b>.

       :string
           Exports <b>is_string()</b> and <b>to_string()</b>.

       :is Exports  all  validation  functions:  <b>is_whole()</b>,  <b>is_int()</b>, <b>is_real()</b>, <b>is_decimal()</b>, <b>is_float()</b>, and
           <b>is_string()</b>.

       :to Exports all conversion functions: <b>to_whole()</b>,  <b>to_int()</b>,  <b>to_real()</b>,  <b>to_decimal()</b>,  <b>to_float()</b>,  and
           <b>to_string()</b>.

       :all
           Exports all functions.

</pre><h4><b>FUNCTIONS</b></h4><pre>
   <b>is_whole</b>
         my $bool = is_whole($val);

       Returns  true  if  $val  is a whole number (including 0), and false if it is not.  The regular expression
       used to test the wholeness of $val is "/^\d+$/".

         my $bool = <a href="../man1/is_whole.1.html">is_whole</a>(1); # Returns true.
         $bool = is_whole(-1);   # Returns false.
         $bool = <a href="../man0/is_whole.0.html">is_whole</a>(0);    # Returns true.

   <b>to_whole</b>
         my $whole = to_whole($val);

       Converts $val to a whole number and returns it. Numbers will be rounded to the nearest whole. If $val  is
       a  mixture  of numbers and letters, <b>to_whole()</b> will extract the first decimal number it finds and convert
       that number to a whole number.

         my $whole = <a href="../man10/to_whole.10.html">to_whole</a>(10);     # Returns 10.
         $whole = <a href="../man0/to_whole.0.html">to_whole</a>(0);         # Returns 0.
         $whole = to_whole(.22);       # Returns 0.
         $whole = to_whole(-2);        # Returns undef.
         $whole = to_whole('foo3.56'); # Returns 4.
         $whole = to_whole('foo');     # Returns undef.

   <b>is_count</b>
         my $bool = is_count($val);

       Returns true if $val is a counting number (1, 2, 3, ...), and false if it is not. The regular  expression
       used to test whether $val is a counting number is "/^\d+$/".

         my $bool = <a href="../man1/is_count.1.html">is_count</a>(1); # Returns true.
         $bool = is_count(-1);   # Returns false.
         $bool = <a href="../man0/is_count.0.html">is_count</a>(0);    # Returns false.

   <b>to_count</b>
         my $count = to_count($val);

       Converts  $val  to  a  counting  number  and  returns it. Numbers will be rounded to the nearest counting
       number. Note that since 0 (zero) is not considered a counting number by  this  module,  it  will  not  be
       returned.  If  $val is a mixture of numbers and letters, <b>to_count()</b> will extract the first decimal number
       it finds and convert that number to a counting number.

         my $count = <a href="../man10/to_count.10.html">to_count</a>(10);     # Returns 10.
         $count = <a href="../man0/to_count.0.html">to_count</a>(0);         # Returns undef.
         $count = to_count(.22);       # Returns undef (rounded down to 0).
         $count = to_count(-2);        # Returns undef.
         $count = to_count('foo3.56'); # Returns 4.
         $count = to_count('foo');     # Returns undef.

   <b>is_int</b>
         my $bool = is_int($val);

       Returns true if $val is an integer, and false if it is not. Numbers may be preceded by a  plus  or  minus
       sign. The regular expression used to test for an integer in $val is "/^[+-]?\d+$/".

         my $bool = <a href="../man0/is_int.0.html">is_int</a>(0); # Returns true.
         $bool = <a href="../man22/is_int.22.html">is_int</a>(22);   # Returns true.
         $bool = is_int(-22);  # Returns true.
         $bool = is_int(3.2);  # Returns false.

   <b>to_int</b>
         my $int = to_int($val);

       Converts  $val  to an integer. If $val is a decimal number, it will be rounded to the nearest integer. If
       $val is a mixture of numbers and letters, <b>to_int()</b> will extract the first decimal  number  it  finds  and
       convert that number to an integer.

         my $int = to_int(10.5);  # Returns 10.
         $int = to_int(10.51);    # Returns 11.
         $int = to_int(-0.22);    # Returns 0.
         $int = to_int(-6.51);    # Returns 7.
         $int = to_int('foo');    # Returns undef.

   <b>is_decimal</b>
         my $bool = is_decimal($val);

       Returns  true  if  $val is a decimal number, and false if it is not. Numbers may be preceded by a plus or
       minus sign. The regular expression used to test $val is "/^[+-]?(?:\d+(?:\.\d*)?|\.\d+)$/".

         my $bool = <a href="../man10/is_decimal.10.html">is_decimal</a>(10)    # Returns true.
         $bool = is_decimal(10.8)     # Returns true.
         $bool = is_decimal(-33.48)   # Returns true.
         $bool = is_decimal(1.23e99)  # Returns false.

   <b>to_decimal</b>
         my $dec = to_decimal($val);
         $dec = to_decimal($val, $precision);

       Converts $val to a decimal number. The optional second argument sets the precision  of  the  number.  The
       default  precision is 5. If $val is a mixture of numbers and letters, <b>to_decimal()</b> will extract the first
       decimal number it finds.

         my $dec = <a href="../man0/to_decimal.0.html">to_decimal</a>(0);         # Returns 0.00000.
         $dec = to_decimal(10.5);         # Returns 10.5.
         $dec = to_decimal(10.500009);    # Returns 10.50001.
         $dec = to_decimal(10.500009, 7); # Returns 10.5000090.
         $dec = to_decimal('foo10.3')     # Returns 10.30000.
         $dec = to_decimal('foo-4.9')     # Returns -4.90000.
         $dec = to_decimal('foo')         # Returns undef.

   <b>is_real</b>
         my $bool = is_real($val);

       Returns true if $val is a real number, and false if it is not.

       <b>Note:</b> This function is currently equivalent to <b>is_decimal()</b>,  since  this  module  cannot  identify  non-
       decimal real numbers (e.g., irrational numbers). This implementation may change in the future.

   <b>to_real</b>
         my $real = to_real($val);
         $real = to_real($val, $precision);

       Converts $val to a real number.

       <b>Note:</b>  Currently, this function is the equivalent of <b>to_decimal()</b>, since this module cannot identify non-
       decimal real numbers (e.g., irrational numbers). This implementation may change in the future.

   <b>is_float</b>
         my $bool = is_float($val);

       Returns true if $val is a float, and false if it is not. The regular expression  used  to  test  $val  is
       "/^([+-]?)(?=[0-9]|\.[0-9])[0-9]*(\.[0-9]*)?([Ee]([+-]?[0-9]+))?$/".

         my $bool = <a href="../man30/is_float.30.html">is_float</a>(30);   # Returns true.
         $bool = is_float(1.23e99); # Returns true.
         $bool = is_float('foo');   # Returns false.

   <b>to_float</b>
         my $dec = to_float($val);
         $dec = to_float($val, $precision);

       Converts  $val  to  a  float.  The optional second argument sets the precision of the number. The default
       precision is 5. If $val is a mixture of numbers and letters, <b>to_float()</b> will extract the first  float  it
       finds.

         my $float = to_float(1.23);          # Returns 1.23000.
         $float = to_float(1.23e99);          # Returns 1.23000e+99.
         $float = to_float(1.23e99, 1);       # Returns 1.2e+99.
         $float = to_float('foo-1.23');       # Returns -1.23000.
         $float = to_float('ick_1.23e99foo'); # Returns 1.23000e+99.

   <b>is_string</b>
         my $bool = is_string($val);

       Returns  true  if  $val  is  a  string, and false if it is not. All defined non-references are considered
       strings.

         my $bool = is_string('foo'); # Returns true.
         $bool = <a href="../man20001/is_string.20001.html">is_string</a>(20001);    # Returns true.
         $bool = is_string([]);       # Returns false.
         $bool = is_string(undef);    # Returns false.

   <b>to_string</b>
         my $string = to_string($val);
         $string = to_string($val, $length);

       Converts $val into a string. If $val is a reference, the string value of the reference will be  returned.
       Such  a  value  may  be  a  memory address, or some other value, if the stringification operator has been
       overridden for the object stored in $val. If the optional second argument $length is passed,  <b>to_string()</b>
       will  truncate  the  string  to  that length. If $length is 0 (zero), it will not limit the length of the
       return string. If $val is undefined, <b>to_string()</b> will return undef.

         my $string = to_string('foo');   # Returns 'foo'.
         $string = to_string([]);         # Returns '<a href="../man0x101bec14/ARRAY.0x101bec14.html">ARRAY</a>(0x101bec14)'.
         $string = to_string(undef);      # Returns undef.
         $string = to_string('hello', 4); # Returns 'hell'.

</pre><h4><b>SUPPORT</b></h4><pre>
       This module is stored in an open GitHub repository &lt;<a href="http://github.com/manwar/data-types/">http://github.com/manwar/data-types/</a>&gt;. Feel  free  to
       fork and contribute!

       Please  file  bug  reports  via GitHub Issues &lt;<a href="http://github.com/manwar/data-types/issues/">http://github.com/manwar/data-types/issues/</a>&gt; or by sending
       mail to <a href="mailto:bug-Data-Types@rt.cpan.org">bug-Data-Types@rt.cpan.org</a> &lt;<a href="mailto:bug-Data-Types@rt.cpan.org">mailto:bug-Data-Types@rt.cpan.org</a>&gt;.

       Patches against Class::Meta are welcome. Please send bug reports to &lt;<a href="mailto:bug-data-types@rt.cpan.org">bug-data-types@rt.cpan.org</a>&gt;.

</pre><h4><b>AUTHOR</b></h4><pre>
       David E. Wheeler &lt;<a href="mailto:david@justatheory.com">david@justatheory.com</a>&gt;

       Currently maintained by Mohammad S Anwar "&lt;mohammad.anwar @ yahoo.com&gt;"

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       perlfaq4 lists the most of the regular expressions used to identify the different numeric types  used  in
       this module.

       String::Checker also does some data type validation.

       String::Scanf  reimplements  the  C  "sscanf()"  function in perl, and also does data type validation and
       conversion.

       Regexp::Common contains many useful common regular expressions (surprise!), including some  that  can  be
       used to identify data types.

       Arthur Bergman's types pragma, offers compile-time data types for Perl 5.8.0. The data types include int,
       float, and string. I highly recommend using this pragma for fast, static data types.

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright (c) 2002-2011, David E. Wheeler. Some Rights Reserved.

       This  module  is  free  software;  you  can redistribute it and/or modify it under the same terms as Perl
       itself.

perl v5.28.1                                       2019-02-25                                   <u>Data::<a href="../man3pm/Types.3pm.html">Types</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>