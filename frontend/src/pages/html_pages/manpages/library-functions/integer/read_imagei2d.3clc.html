<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>read_image{i|ui}_(2D) - Do an element lookup in the 2D image object, returning unnormalized signed</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/opencl-1.2-man-doc">opencl-1.2-man-doc_1.0~svn33624-5.1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       read_image{i|ui}<a href="../man2D/_.2D.html">_</a>(2D) - Do an element lookup in the 2D image object, returning unnormalized signed
       integer and unsigned integer values.

       <b>int4</b> <b>read_imagei(image2d_t</b> <u>image</u><b>,</b> <b>sampler_t</b> <u>sampler</u><b>,</b> <b>int2</b> <u>coord</u><b>);</b>

       <b>int4</b> <b>read_imagei(image2d_t</b> <u>image</u><b>,</b> <b>sampler_t</b> <u>sampler</u><b>,</b> <b>float2</b> <u>coord</u><b>);</b>

       <b>uint4</b> <b>read_imageui(image2d_t</b> <u>image</u><b>,</b> <b>sampler_t</b> <u>sampler</u><b>,</b> <b>int2</b> <u>coord</u><b>);</b>

       <b>int4</b> <b>read_imagei(image2d_t</b> <u>image</u><b>,</b> <b>int2</b> <u>coord</u><b>);</b>

       <b>uint4</b> <b>read_imageui(image2d_t</b> <u>image</u><b>,</b> <b>int2</b> <u>coord</u><b>);</b>

       <b>int4</b> <b>read_imagei(image2d_array_t</b> <u>image</u><b>,</b> <b>int4</b> <u>coord</u><b>);</b>

       <b>uint4</b> <b>read_imageui(image2d_array_t</b> <u>image</u><b>,</b> <b>int4</b> <u>coord</u><b>);</b>

       <b>int4</b> <b>read_imagei(image2d_array_t</b> <u>image</u><b>,</b> <b>sampler_t</b> <u>sampler</u><b>,</b> <b>int4</b> <u>coord</u><b>);</b>

       <b>int4</b> <b>read_imagei(image2d_array_t</b> <u>image</u><b>,</b> <b>sampler_t</b> <u>sampler</u><b>,</b> <b>float4</b> <u>coord</u><b>);</b>

       <b>int4</b> <b>read_imageui(image2d_array_t</b> <u>image</u><b>,</b> <b>sampler_t</b> <u>sampler</u><b>,</b> <b>int4</b> <u>coord</u><b>);</b>

       <b>int4</b> <b>read_imageui(image2d_array_t</b> <u>image</u><b>,</b> <b>sampler_t</b> <u>sampler</u><b>,</b> <b>float4</b> <u>coord</u><b>);</b>

       <b>uint4</b> <b>read_imageui(image2d_array_t</b> <u>image</u><b>,</b> <b>sampler_t</b> <u>sampler</u><b>,</b> <b>int4</b> <u>coord</u><b>);</b>

       <b>uint4</b> <b>read_imageui(image2d_array_t</b> <u>image</u><b>,</b> <b>sampler_t</b> <u>sampler</u><b>,</b> <b>float4</b> <u>coord</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       For the forms that take an <b>image2d_t</b> object, use the coordinate <u>(coord.x,</u> <u>coord.y)</u> to do an element
       lookup in the 2D image object specified by <u>image</u>.

       For the forms that take an <b>image2d_array_t</b> object, use <u>coord.xy</u> to do an element lookup in the 2D image
       identified by <u>coord.z</u> in the 2D image array specified by <u>image</u>.

       The samplerless read image functions behave exactly as the corresponding read image functions that take
       integer coordinates and a sampler with filter mode set to <b>CLK_FILTER_NEAREST</b>, normalized coordinates set
       to <b>CLK_NORMALIZED_COORDS_FALSE</b> and addressing mode to <b>CLK_ADDRESS_NONE</b>.

       <b>read_imagei</b> and <b>read_imageui</b> return unnormalized signed integer and unsigned integer values respectively.
       Each channel will be stored in a 32-bit integer.

       <b>read_imagei</b> can only be used with image objects created with <u>image_channel_data_type</u> set to one of the
       following values: <b>CL_SIGNED_INT8</b>, <b>CL_SIGNED_INT16</b>, or <b>CL_SIGNED_INT32</b>. If the <u>image_channel_data_type</u> is
       not one of the above values, the values returned by <b>read_imagei</b> are undefined.

       <b>read_imageui</b> can only be used with image objects created with <u>image_channel_data_type</u> set to one of the
       following values: <b>CL_UNSIGNED_INT8</b>, <b>CL_UNSIGNED_INT16</b>, and <b>CL_UNSIGNED_INT32</b>. If the
       <u>image_channel_data_type</u> is not one of the above values, the values returned by <b>read_imageui</b> are
       undefined.

       The <b>read_imagei</b> and <b>read_imageui</b> calls support a nearest filter only. The <u>filter_mode</u> specified in
       <u>sampler</u> must be set to <b>CLK_FILTER_NEAREST</b>; otherwise the values returned are undefined.

       Furthermore, the <b>read_imagei</b> and <b>read_imageui</b> calls that take integer coordinates must use a sampler with
       normalized coordinates set to <b>CLK_NORMALIZED_COORDS_FALSE</b> and addressing mode set to
       <b>CLK_ADDRESS_CLAMP_TO_EDGE</b>, <b>CLK_ADDRESS_CLAMP</b> or <b>CLK_ADDRESS_NONE</b>; otherwise the values returned are
       undefined.

</pre><h4><b>NOTES</b></h4><pre>
       The built-in functions defined in this section can only be used with image memory objects. An image
       memory object can be accessed by specific function calls that read from and/or write to specific
       locations in the image.

       Image memory objects that are being read by a kernel should be declared with the <b><a href="../man3clc/accessQualifiers.3clc.html">accessQualifiers</a></b>(3clc)
       qualifier.  <b>write_image</b> calls to image memory objects declared with the <b><a href="../man3clc/accessQualifiers.3clc.html">accessQualifiers</a></b>(3clc) qualifier
       will generate a compilation error. Image memory objects that are being written to by a kernel should be
       declared with the <b><a href="../man3clc/accessQualifiers.3clc.html">accessQualifiers</a></b>(3clc) qualifier.  <b>read_image</b> calls to image memory objects declared
       with the <b><a href="../man3clc/accessQualifiers.3clc.html">accessQualifiers</a></b>(3clc) qualifier will generate a compilation error.  <b>read_image</b> and <b>write_image</b>
       calls to the same image memory object in a kernel are not supported.

       The <b>read_image</b> calls returns a four component floating-point, integer or unsigned integer color value.
       The color values returned by <b>read_image</b> are identified as x, y, z, w where x refers to the red component,
       y refers to the green component, z refers to the blue component and w refers to the alpha component.

       The following table describes the mapping of the number of channels of an image element to the
       appropriate components in the <b>float4</b>, <b>int4</b> or <b>uint4</b> vector data type for the color values returned by
       <b>read_image{f|i|ui}</b> or supplied to <b>write_image{f|i|ui}</b>. The unmapped components will be set to <b>0.0</b> for
       red, green and blue channels and will be set to <b>1.0</b> for the alpha channel.

                         ┌───────────────────────────┬─────────────────────────────────────┐
                         │       <b>Channel</b> <b>Order</b>       │ <b>float4</b>, <b>int4</b> or <b>uint4</b> components of │
                         │                           │ channel data                        │
                         ├───────────────────────────┼─────────────────────────────────────┤
                         │        <b>CL_R</b>, <b>CL_Rx</b>        │         <b>(r,</b> <b>0.0,</b> <b>0.0,</b> <b>1.0)</b>          │
                         ├───────────────────────────┼─────────────────────────────────────┤
                         │           <b>CL_A</b>            │         <b>(0.0,</b> <b>0.0,</b> <b>0.0,</b> <b>a)</b>          │
                         ├───────────────────────────┼─────────────────────────────────────┤
                         │       <b>CL_RG</b>, <b>CL_RGx</b>       │          <b>(r,</b> <b>g,</b> <b>0.0,</b> <b>1.0)</b>           │
                         ├───────────────────────────┼─────────────────────────────────────┤
                         │           <b>CL_RA</b>           │          <b>(r,</b> <b>0.0,</b> <b>0.0,</b> <b>a)</b>           │
                         ├───────────────────────────┼─────────────────────────────────────┤
                         │      <b>CL_RGB</b>, <b>CL_RGBx</b>      │           <b>(r,</b> <b>g,</b> <b>b,</b> <b>1.0)</b>            │
                         ├───────────────────────────┼─────────────────────────────────────┤
                         │ <b>CL_RGBA,</b> <b>CL_BGRA,</b> <b>CL_ARGB</b> │            <b>(r,</b> <b>g,</b> <b>b,</b> <b>a)</b>             │
                         ├───────────────────────────┼─────────────────────────────────────┤
                         │       <b>CL_INTENSITY</b>        │            <b>(I,</b> <b>I,</b> <b>I,</b> <b>I)</b>             │
                         ├───────────────────────────┼─────────────────────────────────────┤
                         │       <b>CL_LUMINANCE</b>        │           <b>(L,</b> <b>L,</b> <b>L,</b> <b>1.0)</b>            │
                         └───────────────────────────┴─────────────────────────────────────┘

       A kernel that uses a sampler with the <b>CL_ADDRESS_CLAMP</b> addressing mode with multiple images may result in
       additional samplers being used internally by an implementation. If the same sampler is used with multiple
       images called via <b>read_image{f|i|ui}</b>, then it is possible that an implementation may need to allocate an
       additional sampler to handle the different border color values that may be needed depending on the image
       formats being used. These implementation allocated samplers will count against the maximum sampler values
       supported by the device and given by <b>CL_DEVICE_MAX_SAMPLERS</b>. Enqueuing a kernel that requires more
       samplers than the implementation can support will result in a <b>CL_OUT_OF_RESOURCES</b> error being returned.

</pre><h4><b>SPECIFICATION</b></h4><pre>
       <b>OpenCL</b> <b>Specification</b>[1]

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3clc/imageFunctions.3clc.html">imageFunctions</a></b>(3clc)

</pre><h4><b>AUTHORS</b></h4><pre>
       <b>The</b> <b>Khronos</b> <b>Group</b>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright © 2007-2011 The Khronos Group Inc.
       Permission is hereby granted, free of charge, to any person obtaining a copy of this software and/or
       associated documentation files (the "Materials"), to deal in the Materials without restriction, including
       without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       copies of the Materials, and to permit persons to whom the Materials are furnished to do so, subject to
       the condition that this copyright notice and permission notice shall be included in all copies or
       substantial portions of the Materials.

</pre><h4><b>NOTES</b></h4><pre>
        1. OpenCL Specification
           page 292, section 6.12.14 - Image Read and Write Functions

The Khronos Group                                  11/18/2024                             <u>READ_IMAGEI</u> <u>(2D)</u>(3clc)
</pre>
 </div>
</div></section>
</div>
</body>
</html>