<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Data::Integer - details of the native integer data type</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libdata-integer-perl">libdata-integer-perl_0.007-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Data::Integer - details of the native integer data type

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use Data::Integer qw(natint_bits);

           $n = natint_bits;

           # and other constants; see text

           use Data::Integer qw(nint sint uint nint_is_sint nint_is_uint);

           $ni = nint($ni);
           $si = sint($si);
           $ui = uint($ui);
           if(nint_is_sint($ni)) { ...
           if(nint_is_uint($ni)) { ...

           use Data::Integer qw(
               nint_sgn sint_sgn uint_sgn
               nint_abs sint_abs uint_abs
               nint_cmp sint_cmp uint_cmp
               nint_min sint_min uint_min
               nint_max sint_max uint_max
               nint_neg sint_neg uint_neg
               nint_add sint_add uint_add
               nint_sub sint_sub uint_sub);

           $sn = nint_sgn($ni);
           $sn = sint_sgn($si);
           $sn = uint_sgn($ui);
           $ni = nint_abs($ni);
           $si = sint_abs($si);
           $ui = uint_abs($ui);
           @sorted_nints = sort { nint_cmp($a, $b) } @nints;
           @sorted_sints = sort { sint_cmp($a, $b) } @sints;
           @sorted_uints = sort { uint_cmp($a, $b) } @uints;
           $ni = nint_min($na, $nb);
           $si = sint_min($sa, $sb);
           $ui = uint_min($ua, $ub);
           $ni = nint_max($na, $nb);
           $si = sint_max($sa, $sb);
           $ui = uint_max($ua, $ub);
           $ni = nint_neg($ni);
           $si = sint_neg($si);
           $ui = uint_neg($ui);
           $ni = nint_add($na, $nb);
           $si = sint_add($sa, $sb);
           $ui = uint_add($ua, $ub);
           $ni = nint_sub($na, $nb);
           $si = sint_sub($sa, $sb);
           $ui = uint_sub($ua, $ub);

           use Data::Integer qw(
               sint_shl uint_shl
               sint_shr uint_shr
               sint_rol uint_rol
               sint_ror uint_ror);

           $si = sint_shl($si, $dist);
           $ui = uint_shl($ui, $dist);
           $si = sint_shr($si, $dist);
           $ui = uint_shr($ui, $dist);
           $si = sint_rol($si, $dist);
           $ui = uint_rol($ui, $dist);
           $si = sint_ror($si, $dist);
           $ui = uint_ror($ui, $dist);

           use Data::Integer qw(
               nint_bits_as_sint nint_bits_as_uint
               sint_bits_as_uint uint_bits_as_sint);

           $si = nint_bits_as_sint($ni);
           $ui = nint_bits_as_uint($ni);
           $ui = sint_bits_as_uint($si);
           $si = uint_bits_as_sint($ui);

           use Data::Integer qw(
               sint_not uint_not
               sint_and uint_and
               sint_nand uint_nand
               sint_andn uint_andn
               sint_or uint_or
               sint_nor uint_nor
               sint_orn uint_orn
               sint_xor uint_xor
               sint_nxor uint_nxor
               sint_mux uint_mux);

           $si = sint_not($si);
           $ui = uint_not($ui);
           $si = sint_and($sa, $sb);
           $ui = uint_and($ua, $ub);
           $si = sint_nand($sa, $sb);
           $ui = uint_nand($ua, $ub);
           $si = sint_andn($sa, $sb);
           $ui = uint_andn($ua, $ub);
           $si = sint_or($sa, $sb);
           $ui = uint_or($ua, $ub);
           $si = sint_nor($sa, $sb);
           $ui = uint_nor($ua, $ub);
           $si = sint_orn($sa, $sb);
           $ui = uint_orn($ua, $ub);
           $si = sint_xor($sa, $sb);
           $ui = uint_xor($ua, $ub);
           $si = sint_nxor($sa, $sb);
           $ui = uint_nxor($ua, $ub);
           $si = sint_mux($sa, $sb, $sc);
           $ui = uint_mux($ua, $ub, $uc);

           use Data::Integer qw(
               sint_madd uint_madd
               sint_msub uint_msub
               sint_cadd uint_cadd
               sint_csub uint_csub
               sint_sadd uint_sadd
               sint_ssub uint_ssub);

           $si = sint_madd($sa, $sb);
           $ui = uint_madd($ua, $ub);
           $si = sint_msub($sa, $sb);
           $ui = uint_msub($ua, $ub);
           ($carry, $si) = sint_cadd($sa, $sb, $carry);
           ($carry, $ui) = uint_cadd($ua, $ub, $carry);
           ($carry, $si) = sint_csub($sa, $sb, $carry);
           ($carry, $ui) = uint_csub($ua, $ub, $carry);
           $si = sint_sadd($sa, $sb);
           $ui = uint_sadd($ua, $ub);
           $si = sint_ssub($sa, $sb);
           $ui = uint_ssub($ua, $ub);

           use Data::Integer qw(natint_hex hex_natint);

           print natint_hex($value);
           $value = hex_natint($string);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module is about the native integer numerical data type.  A native integer is one of the types of
       datum that can appear in the numeric part of a Perl scalar.  This module supplies constants describing
       the native integer type.

       There are actually two native integer representations: signed and unsigned.  Both are handled by this
       module.

</pre><h4><b>NATIVE</b> <b>INTEGERS</b></h4><pre>
       Each native integer format represents a value using binary place value, with some fixed number of bits.
       The number of bits is the same for both signed and unsigned representations.  In each case the least-
       significant bit has the value 1, the next 2, the next 4, and so on.  In the unsigned representation, this
       pattern continues up to and including the most-significant bit, which for a 32-bit machine therefore has
       the value 2^31 (2147483648).  The unsigned format cannot represent any negative numbers.

       In the signed format, the most-significant bit is exceptional, having the negation of the value that it
       does in the unsigned format.  Thus on a 32-bit machine this has the value -2^31 (-2147483648).  Values
       with this bit set are negative, and those with it clear are non-negative; this bit is also known as the
       "sign bit".

       It is usual in machine arithmetic to use one of these formats at a time, for example to add two signed
       numbers yielding a signed result.  However, Perl has a trick: a scalar with a native integer value
       contains an additional flag bit which indicates whether the signed or unsigned format is being used.  It
       is therefore possible to mix signed and unsigned numbers in arithmetic, at some extra expense.

</pre><h4><b>CONSTANTS</b></h4><pre>
       Each of the extreme-value constants has two names, a short one and a long one.  The short names are more
       convenient to use, but the long names are clearer in a context where other similar constants exist.

       Due to the risks of Perl changing the behaviour of a native integer value that has been involved in
       floating point arithmetic (see "BUGS"), the extreme-value constants are actually non-constant functions
       that always return a fresh copy of the appropriate value.  The returned value is always a pure native
       integer value, unsullied by floating point or string operations.

       natint_bits
           The width, in bits, of the native integer data types.

       min_nint
       min_natint
           The minimum representable value in either representation.  This is -2^(natint_bits - 1).

       max_nint
       max_natint
           The maximum representable value in either representation.  This is 2^natint_bits - 1.

       min_sint
       min_signed_natint
           The minimum representable value in the signed representation.  This is -2^(natint_bits - 1).

       max_sint
       max_signed_natint
           The maximum representable value in the signed representation.  This is 2^(natint_bits - 1) - 1.

       min_uint
       min_unsigned_natint
           The minimum representable value in the unsigned representation.  This is zero.

       max_uint
       max_unsigned_natint
           The maximum representable value in the unsigned representation.  This is 2^natint_bits - 1.

</pre><h4><b>FUNCTIONS</b></h4><pre>
       Each  "nint_",  "sint_",  or  "uint_"  function  operates  on  one of the three integer formats.  "nint_"
       functions operate on Perl's union of signed and unsigned; "sint_" functions operate on  signed  integers;
       and  "uint_"  functions  operate  on  unsigned  integers.  Except where indicated otherwise, the function
       returns a value of its primary type.

       Parameters <u>A</u>, <u>B</u>, and <u>C</u>, where present, must be numbers of the  appropriate  type:  specifically,  with  a
       numerical  value  that  can  be represented in that type.  If there are multiple flavours of zero, due to
       floating point funkiness, all zeroes are treated the  same.   Parameters  with  other  names  have  other
       requirements, explained with each function.

       The  functions  attempt to detect unsuitable arguments, and "die" if an invalid argument is detected, but
       they can't notice some kinds of incorrect argument.  Generally, it  is  the  caller's  responsibility  to
       provide a sane numerical argument, and supplying an invalid argument will cause mayhem.  Only the numeric
       value  of  plain  scalar arguments is used; the string value is completely ignored, so dualvars are not a
       problem.

   <b>Canonicalisation</b> <b>and</b> <b>classification</b>
       These are basic glue functions.

       nint(A)
       sint(A)
       uint(A)
           These functions each take an argument in a specific integer format and return  its  numerical  value.
           This  is  the  argument  canonicalisation  that  is performed by all of the functions in this module,
           presented in isolation.

       nint_is_sint(A)
           Takes a native integer of either type.  Returns a truth value indicating whether this  value  can  be
           exactly represented as a signed native integer.

       nint_is_uint(A)
           Takes  a  native  integer of either type.  Returns a truth value indicating whether this value can be
           exactly represented as an unsigned native integer.

   <b>Arithmetic</b>
       These functions operate on numerical values rather than just bit patterns.  They will all  "die"  if  the
       true numerical result doesn't fit into the result format, rather than give a wrong answer.

       nint_sgn(A)
       sint_sgn(A)
       uint_sgn(A)
           Returns +1 if the argument is positive, 0 if the argument is zero, or -1 if the argument is negative.

       nint_abs(A)
       sint_abs(A)
       uint_abs(A)
           Absolute value (magnitude, discarding sign).

       nint_cmp(A, B)
       sint_cmp(A, B)
       uint_cmp(A, B)
           Arithmetic comparison.  Returns -1, 0, or +1, indicating whether A is less than, equal to, or greater
           than B.

       nint_min(A, B)
       sint_min(A, B)
       uint_min(A, B)
           Arithmetic minimum.  Returns the arithmetically lesser of the two arguments.

       nint_max(A, B)
       sint_max(A, B)
       uint_max(A, B)
           Arithmetic maximum.  Returns the arithmetically greater of the two arguments.

       nint_neg(A)
       sint_neg(A)
       uint_neg(A)
           Negation: returns -A.

       nint_add(A, B)
       sint_add(A, B)
       uint_add(A, B)
           Addition: returns A + B.

       nint_sub(A, B)
       sint_sub(A, B)
       uint_sub(A, B)
           Subtraction: returns A - B.

   <b>Bit</b> <b>shifting</b>
       These  functions  all  operate  on  the bit patterns representing integers, mostly ignoring the numerical
       values represented.  In most cases the results for particular numerical arguments are influenced  by  the
       word  size,  because that determines where a bit being left-shifted will drop off the end of the word and
       where a bit will be shifted in during a rightward shift.

       With the exception of rightward shifts (see below), each pair of  functions  performs  exactly  the  same
       operations  on  the  bit  sequences.  There inevitably can't be any functions here that operate on Perl's
       union of signed and unsigned; you must choose, by which function you call, which type the result is to be
       tagged as.

       sint_shl(A, DIST)
       uint_shl(A, DIST)
           Bitwise left shift (towards more-significant bits).  <u>DIST</u> is the distance to shift, in bits, and must
           be an integer in the range [0, natint_bits).  Zeroes are shifted in from the right.

       sint_shr(A, DIST)
       uint_shr(A, DIST)
           Bitwise right shift (towards less-significant bits).  <u>DIST</u> is the distance to  shift,  in  bits,  and
           must be an integer in the range [0, natint_bits).

           When  performing  an unsigned right shift, zeroes are shifted in from the left.  A signed right shift
           is different: the sign bit gets duplicated, so  right-shifting  a  negative  number  always  gives  a
           negative result.

       sint_rol(A, DIST)
       uint_rol(A, DIST)
           Bitwise left rotation (towards more-significant bits, with the most-significant bit wrapping round to
           the  least-significant  bit).  <u>DIST</u> is the distance to rotate, in bits, and must be an integer in the
           range [0, natint_bits).

       sint_ror(A, DIST)
       uint_ror(A, DIST)
           Bitwise right rotation (towards less-significant bits, with the least-significant bit wrapping  round
           to the most-significant bit).  <u>DIST</u> is the distance to rotate, in bits, and must be an integer in the
           range [0, natint_bits).

   <b>Format</b> <b>conversion</b>
       These  functions  convert  between  the various native integer formats by reinterpreting the bit patterns
       used to represent the integers.  The bit pattern remains unchanged;  its  meaning  changes,  and  so  the
       numerical value changes.  Perl scalars preserve the numerical value, rather than just the bit pattern, so
       from the Perl point of view these are functions that change numbers into other numbers.

       nint_bits_as_sint(A)
           Converts  a native integer of either type to a signed integer, by reinterpreting the bits.  The most-
           significant bit (whether a sign bit or not) becomes a sign bit.

       nint_bits_as_uint(A)
           Converts a native integer of either type to an unsigned integer, by  reinterpreting  the  bits.   The
           most-significant bit (whether a sign bit or not) becomes an ordinary most-significant bit.

       sint_bits_as_uint(A)
           Converts  a  signed integer to an unsigned integer, by reinterpreting the bits.  The sign bit becomes
           an ordinary most-significant bit.

       uint_bits_as_sint(A)
           Converts an unsigned integer to a signed integer, by reinterpreting the bits.   The  most-significant
           bit becomes a sign bit.

   <b>Bitwise</b> <b>operations</b>
       These  functions all operate on the bit patterns representing integers, completely ignoring the numerical
       values represented.  They are mostly not influenced by the word size, in the sense that they will produce
       the same numerical result for the same numerical arguments regardless of word size.  However, a  few  are
       affected  by  the  word  size:  those  on  unsigned  operands that return a non-zero result if given zero
       arguments.

       Each pair of functions performs exactly the same operations on the bit sequences.  There inevitably can't
       be any functions here that operate on Perl's union of signed and unsigned;  you  must  choose,  by  which
       function you call, which type the result is to be tagged as.

       sint_not(A)
       uint_not(A)
           Bitwise complement (NOT).

       sint_and(A, B)
       uint_and(A, B)
           Bitwise conjunction (AND).

       sint_nand(A, B)
       uint_nand(A, B)
           Bitwise inverted conjunction (NAND).

       sint_andn(A, B)
       uint_andn(A, B)
           Bitwise conjunction with inverted argument (A AND (NOT B)).

       sint_or(A, B)
       uint_or(A, B)
           Bitwise disjunction (OR).

       sint_nor(A, B)
       uint_nor(A, B)
           Bitwise inverted disjunction (NOR).

       sint_orn(A, B)
       uint_orn(A, B)
           Bitwise disjunction with inverted argument (A OR (NOT B)).

       sint_xor(A, B)
       uint_xor(A, B)
           Bitwise symmetric difference (XOR).

       sint_nxor(A, B)
       uint_nxor(A, B)
           Bitwise symmetric similarity (NXOR).

       sint_mux(A, B, C)
       uint_mux(A, B, C)
           Bitwise  multiplex.   The output has a bit from B wherever A has a 1 bit, and a bit from C wherever A
           has a 0 bit.  That is, the result is (A AND B) OR ((NOT A) AND C).

   <b>Machine</b> <b>arithmetic</b>
       These functions perform arithmetic operations that are inherently influenced  by  the  word  size.   They
       always produce a well-defined output if given valid inputs.  There inevitably can't be any functions here
       that  operate  on Perl's union of signed and unsigned; you must choose, by which function you call, which
       type the result is to be tagged as.

       sint_madd(A, B)
       uint_madd(A, B)
           Modular addition.  The result for unsigned addition is (A + B) mod 2^natint_bits.  The signed version
           behaves similarly, but with a different result range.

       sint_msub(A, B)
       uint_msub(A, B)
           Modular subtraction.  The result for unsigned subtraction is (A - B) mod 2^natint_bits.   The  signed
           version behaves similarly, but with a different result range.

       sint_cadd(A, B, CARRY_IN)
       uint_cadd(A, B, CARRY_IN)
           Addition  with carry.  Two word arguments (A and B) and an input carry bit (CARRY_IN, which must have
           the value 0 or 1) are all added together.  Returns a list of two items: an output carry and an output
           word (of the same signedness as the inputs).  Precisely, the output list (CARRY_OUT, R) is such  that
           CARRY_OUT*2^natint_bits + R = A + B + CARRY_IN.

       sint_csub(A, B, CARRY_IN)
       uint_csub(A, B, CARRY_IN)
           Subtraction  with  carry  (borrow).   The  second word argument (B) and an input carry bit (CARRY_IN,
           which must have the value 0 or 1) are subtracted from the first word argument (A).  Returns a list of
           two items: an output carry and an output word (of the same signedness as the inputs).  Precisely, the
           output list (CARRY_OUT, R) is such that R - CARRY_OUT*2^natint_bits = A - B - CARRY_IN.

       sint_sadd(A, B)
       uint_sadd(A, B)
           Saturating addition.  The result is A + B if that will fit into  the  result  format,  otherwise  the
           minimum  or  maximum  value  of the result format is returned depending on the direction in which the
           addition overflowed.

       sint_ssub(A, B)
       uint_ssub(A, B)
           Saturating subtraction.  The result is A - B if that will fit into the result format,  otherwise  the
           minimum  or  maximum  value  of the result format is returned depending on the direction in which the
           subtraction overflowed.

   <b>String</b> <b>conversion</b>
       natint_hex(VALUE)
           VALUE must be a native integer value.  The function encodes  VALUE  in  hexadecimal,  returning  that
           representation as a string.  Specifically, the output is of the form "<u>s</u><b>0x</b><u>dddd</u>", where "<u>s</u>" is the sign
           and "<u>dddd</u>" is a sequence of hexadecimal digits.

       hex_natint(STRING)
           Generates and returns a native integer value from a string encoding it in hexadecimal.  Specifically,
           the  input  format  is  "[<u>s</u>][<b>0x</b>]<u>dddd</u>",  where "<u>s</u>" is the sign and "<u>dddd</u>" is a sequence of one or more
           hexadecimal digits.  The input is interpreted case insensitively.  If the value given in  the  string
           cannot be exactly represented in the native integer type, the function "die"s.

           The core Perl function "hex" (see "hex" in perlfunc) does a similar job to this function, but differs
           in  several  ways.   Principally, "hex" doesn't handle negative values, and it gives the wrong answer
           for values that don't fit into the native integer type.  In Perl 5.6 it also gives the  wrong  answer
           for values that don't fit into the native floating point type.  It also doesn't enforce strict syntax
           on the input string.

</pre><h4><b>BUGS</b></h4><pre>
       In  Perl  5.6,  when  a  native  integer scalar is used in any arithmetic other than specifically integer
       arithmetic, it gets partially transformed into a floating point scalar.  Even if its numerical value  can
       be  represented  exactly  in floating point, so that floating point arithmetic uses the correct numerical
       value, some operations are affected by the floatness.  In particular, the stringification of  the  scalar
       doesn't necessarily represent its exact value if it is tagged as floating point.

       Because  of  this  transforming behaviour, if you need to stringify a native integer it is best to ensure
       that it doesn't get used in any non-integer arithmetic first.  If an  integer  scalar  must  be  used  in
       standard Perl arithmetic, it may be copied first and the copy operated upon to avoid causing side effects
       on  the original.  If an integer scalar might have already been transformed, it can be cleaned by passing
       it through the canonicalisation function "nint".  The functions in this module all avoid modifying  their
       arguments, and always return pristine integers.

       Perl  5.8+  still  internally  modifies  integer  scalars  in  the  same circumstances, but seems to have
       corrected all the misbehaviour that resulted from it.

       Also in Perl 5.6, default Perl arithmetic doesn't necessarily work correctly on native  integers.   (This
       is  part  of the motivation for the myriad arithmetic functions in this module.)  Default arithmetic here
       is strictly floating point, so if there are  native  integers  that  cannot  be  exactly  represented  in
       floating  point  then  the  arithmetic  will  approximate the values before operating on them.  Perl 5.8+
       attempts to use native integer operations where possible in its default arithmetic, but as of Perl  5.8.8
       it  doesn't  always succeed.  For reliable integer arithmetic, integer operations must still be requested
       explicitly.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       Data::Float, Scalar::Number, <b><a href="../man1/perlnumber.1.html">perlnumber</a></b>(1)

</pre><h4><b>AUTHOR</b></h4><pre>
       Andrew Main (Zefram) &lt;<a href="mailto:zefram@fysh.org">zefram@fysh.org</a>&gt;

       Currently maintained by Robert Rothenberg &lt;<a href="mailto:rrwo@cpan.org">rrwo@cpan.org</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (C) 2007, 2010, 2015, 2017, 2025 Andrew Main (Zefram) &lt;<a href="mailto:zefram@fysh.org">zefram@fysh.org</a>&gt;

</pre><h4><b>LICENSE</b></h4><pre>
       This module is free software; you can redistribute it and/or modify it  under  the  same  terms  as  Perl
       itself.

perl v5.40.1                                       2025-04-19                                 <u>Data::<a href="../man3pm/Integer.3pm.html">Integer</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>