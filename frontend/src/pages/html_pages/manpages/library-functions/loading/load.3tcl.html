<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>load - Load machine code and initialize new commands</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcl9.0-doc">tcl9.0-doc_9.0.1+dfsg-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       load - Load machine code and initialize new commands

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>load</b> ?<b>-global</b>? ?<b>-lazy</b>? ?<b>--</b>? <u>fileName</u>
       <b>load</b> ?<b>-global</b>? ?<b>-lazy</b>? ?<b>--</b>? <u>fileName</u> <u>prefix</u>
       <b>load</b> ?<b>-global</b>? ?<b>-lazy</b>? ?<b>--</b>? <u>fileName</u> <u>prefix</u> <u>interp</u>
________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This  command  loads  binary  code  from  a  file  into  the  application's  address  space  and calls an
       initialization procedure in the library to incorporate it into an interpreter.  <u>fileName</u> is the  name  of
       the  file  containing  the code;  its exact form varies from system to system but on most systems it is a
       shared library, such as a <b>.so</b> file under Solaris or a DLL under Windows.  <u>prefix</u> is used to  compute  the
       name  of  an initialization procedure.  <u>interp</u> is the path name of the interpreter into which to load the
       library (see the <b>interp</b> manual entry for details); if <u>interp</u> is omitted, it defaults to  the  interpreter
       in which the <b>load</b> command was invoked.

       Once  the file has been loaded into the application's address space, one of two initialization procedures
       will be invoked in the new code.  Typically the initialization procedure will add new commands to  a  Tcl
       interpreter.   The  name  of  the initialization procedure is determined by <u>prefix</u> and whether or not the
       target interpreter is a safe one.  For normal interpreters the name of the initialization procedure  will
       have  the  form  <u>prefix</u><b>_Init</b>.  For example, if <u>prefix</u> is <b>Foo</b>, the initialization procedure's name will be
       <b>Foo_Init</b>.

       If the target interpreter is a safe interpreter, then the name of the initialization  procedure  will  be
       <u>prefix</u><b>_SafeInit</b>  instead  of  <u>prefix</u><b>_Init</b>.   The <u>prefix</u><b>_SafeInit</b> function should be written carefully, so
       that it initializes the safe interpreter only with partial functionality provided by the library that  is
       safe for use by untrusted code. For more information on Safe-Tcl, see the <b>safe</b> manual entry.

       The initialization procedure must match the following prototype:

              typedef int <b>Tcl_LibraryInitProc</b>(
                      Tcl_Interp *<u>interp</u>);

       The  <u>interp</u> argument identifies the interpreter in which the library is to be loaded.  The initialization
       procedure must return <b>TCL_OK</b> or <b>TCL_ERROR</b> to indicate whether or not it completed successfully;   in  the
       event of an error it should set the interpreter's result to point to an error message.  The result of the
       <b>load</b> command will be the result returned by the initialization procedure.

       The  actual  loading  of  a  file will only be done once for each <u>fileName</u> in an application.  If a given
       <u>fileName</u> is loaded into multiple interpreters, then the first <b>load</b>  will  load  the  code  and  call  the
       initialization  procedure;   subsequent  <b>load</b>s will call the initialization procedure without loading the
       code again.  For Tcl versions lower than 8.5, it is not possible to unload  or  reload  a  library.  From
       version 8.5 however, the <b>unload</b> command allows the unloading of libraries loaded with <b>load</b>, for libraries
       that are aware of the Tcl's unloading mechanism.

       The  <b>load</b>  command  also  supports  libraries  that  are statically linked with the application, if those
       libraries have been registered by calling the <b>Tcl_StaticLibrary</b>  procedure.   If  <u>fileName</u>  is  an  empty
       string, then <u>prefix</u> must be specified.

       If  <u>prefix</u>  is  omitted or specified as an empty string, Tcl tries to guess the prefix by taking the last
       element of <u>fileName</u>, strip off the first three characters if they are <b>lib</b>, then strip off the  next  four
       characters  if  they  are <b>tcl9</b>, and use any following wordchars but not digits, converted to titlecase as
       the prefix.  For example, the command <b>load</b>  <b>libxyz4.2.so</b>  uses  the  prefix  <b>Xyz</b>  and  the  command  <b>load</b>
       <b>bin/last.so</b> <b>{}</b> uses the prefix <b>Last</b>.

       If  <u>fileName</u>  is  an  empty string, then <u>prefix</u> must be specified.  The <b>load</b> command first searches for a
       statically loaded library (one that has been registered by calling the  <b>Tcl_StaticLibrary</b>  procedure)  by
       that  name;  if  one is found, it is used.  Otherwise, the <b>load</b> command searches for a dynamically loaded
       library by that name, and uses it if it is found.  If several  different  files  have  been  <b>load</b>ed  with
       different versions of the library, Tcl picks the file that was loaded first.

       If  <b>-global</b> is specified preceding the filename, all symbols found in the shared library are exported for
       global use by other libraries. The option <b>-lazy</b> delays the actual loading of symbols  until  their  first
       actual  use.  The options may be abbreviated.  The option <b>--</b> indicates the end of the options, and should
       be used if you wish to use a filename which starts with <b>-</b> and you provide a prefix to the <b>load</b> command.

       On platforms which do not support the <b>-global</b> or <b>-lazy</b> options, the  options  still  exist  but  have  no
       effect.  Note  that  use of the <b>-global</b> or <b>-lazy</b> option may lead to crashes in your application later (in
       case of symbol conflicts resp. missing symbols), which cannot be detected during the <b>load</b>. So,  only  use
       this when you know what you are doing, you will not get a nice error message when something is wrong with
       the loaded library.

</pre><h4><b>PORTABILITY</b> <b>ISSUES</b></h4><pre>
       <b>Windows</b>
              When a load fails with “library not found” error, it is also possible that a dependent library was
              not  found.  To see the dependent libraries, type “dumpbin -imports &lt;dllname&gt;” in a DOS console to
              see what the library must import.  When loading a DLL  in  the  current  directory,  Windows  will
              ignore  “./”  as  a  path  specifier and use a search heuristic to find the DLL instead.  To avoid
              this, load the DLL with:

                     <b>load</b> [file join [pwd] mylib.DLL]

</pre><h4><b>BUGS</b></h4><pre>
       If the same file is <b>load</b>ed by different <u>fileName</u>s, it will be loaded into  the  process's  address  space
       multiple times.  The behavior of this varies from system to system (some systems may detect the redundant
       loads, others may not).

</pre><h4><b>EXAMPLE</b></h4><pre>
       The following is a minimal extension:

              #include &lt;tcl.h&gt;
              #include &lt;<a href="file:/usr/include/stdio.h">stdio.h</a>&gt;
              static int fooCmd(void *clientData,
                      Tcl_Interp *interp, int objc, Tcl_Obj *const objv[]) {
                  printf("called with %d arguments\n", objc);
                  return TCL_OK;
              }
              int Foo_Init(Tcl_Interp *interp) {
                  if (Tcl_InitStubs(interp, "8.1", 0) == NULL) {
                return TCL_ERROR;
                  }
                  printf("creating foo command");
                  Tcl_CreateObjCommand(interp, "foo", fooCmd, NULL, NULL);
                  return TCL_OK;
              }

       When  built  into  a  shared/dynamic  library with a suitable name (e.g. <b>foo.dll</b> on Windows, <b>libfoo.so</b> on
       Solaris and Linux) it can then be loaded into Tcl with the following:

              # Load the extension
              switch $tcl_platform(platform) {
                  windows {
                      <b>load</b> [file join [pwd] foo.dll]
                  }
                  unix {
                      <b>load</b> [file join [pwd] libfoo[info sharedlibextension]]
                  }
              }

              # Now execute the command defined by the extension
              foo

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       info sharedlibextension, <a href="../man3tcl/package.3tcl.html">package</a>(3tcl), <a href="../man3tcl/Tcl_StaticLibrary.3tcl.html">Tcl_StaticLibrary</a>(3tcl), <a href="../man3tcl/safe.3tcl.html">safe</a>(3tcl)

</pre><h4><b>KEYWORDS</b></h4><pre>
       binary code, dynamic library, load, safe interpreter, shared library

Tcl                                                    7.5                                            <u><a href="../man3tcl/load.3tcl.html">load</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>