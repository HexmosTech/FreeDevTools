<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pt::peg::export - PEG Export</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcllib">tcllib_2.0+dfsg-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       pt::peg::export - PEG Export

</pre><h4><b>SYNOPSIS</b></h4><pre>
       package require <b>Tcl</b> <b>8.5</b> <b>9</b>

       package require <b>snit</b>

       package require <b>struct::map</b>

       package require <b>pt::peg</b>

       package require <b>pluginmgr</b>

       package require <b>pt::peg::export</b> <b>?1.0.2?</b>

       <b>::pt::peg::export</b> <u>objectName</u>

       <b>objectName</b> <b>method</b> ?<u>arg</u> <u>arg</u> <u>...</u>?

       <u>objectName</u> <b>destroy</b>

       <u>objectName</u> <b>export</b> <b>serial</b> <u>serial</u> ?<u>format</u>?

       <u>objectName</u> <b>export</b> <b>object</b> <u>object</u> ?<u>format</u>?

       <u>objectName</u> <b>configuration</b> <b>names</b>

       <u>objectName</u> <b>configuration</b> <b>get</b>

       <u>objectName</u> <b>configuration</b> <b>set</b> <u>name</u> ?<u>value</u>?

       <u>objectName</u> <b>configuration</b> <b>unset</b> <u>pattern</u>...

________________________________________________________________________________________________________________

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Are  you lost ?  Do you have trouble understanding this document ?  In that case please read the overview
       provided by the <u>Introduction</u> <u>to</u> <u>Parser</u> <u>Tools</u>. This document is the entrypoint to  the  whole  system  the
       current package is a part of.

       This  package  provides  a  manager for parsing expression grammars, with each instance handling a set of
       plugins for the export of them to other formats, i.e. their conversion to, for example <u>nroff</u>, <u>HTML</u>, etc.

       It resides in the Export section of the Core Layer of Parser Tools, and is one of the three  pillars  the
       management of parsing expression grammars resides on.

       IMAGE: arch_core_export

       The other two pillars are, as shown above

       [1]    <u>PEG</u> <u>Import</u>, and

       [2]    <u>PEG</u> <u>Storage</u>

       For information about the data structure which is the major input to the manager objects provided by this
       package see the section <b>PEG</b> <b>serialization</b> <b>format</b>.

       The  plugin  system  of  this class is based on the package <b>pluginmgr</b>, and configured to look for plugins
       using

       [1]    the environment variable <b>GRAMMAR_PEG_EXPORT_PLUGINS</b>,

       [2]    the environment variable <b>GRAMMAR_PEG_PLUGINS</b>,

       [3]    the environment variable <b>GRAMMAR_PLUGINS</b>,

       [4]    the path "<u><a href="file:~/.grammar/peg/export/plugin">~/.grammar/peg/export/plugin</a></u>"

       [5]    the path "<u><a href="file:~/.grammar/peg/plugin">~/.grammar/peg/plugin</a></u>"

       [6]    the path "<u><a href="file:~/.grammar/plugin">~/.grammar/plugin</a></u>"

       [7]    the path "<u><a href="file:~/.grammar/peg/export/plugins">~/.grammar/peg/export/plugins</a></u>"

       [8]    the path "<u><a href="file:~/.grammar/peg/plugins">~/.grammar/peg/plugins</a></u>"

       [9]    the path "<u><a href="file:~/.grammar/plugins">~/.grammar/plugins</a></u>"

       [10]   the registry entry "HKEY_CURRENT_USER\SOFTWARE\GRAMMAR\PEG\EXPORT\PLUGINS"

       [11]   the registry entry "HKEY_CURRENT_USER\SOFTWARE\GRAMMAR\PEG\PLUGINS"

       [12]   the registry entry "HKEY_CURRENT_USER\SOFTWARE\GRAMMAR\PLUGINS"

       The last three are used only when the package is run on a machine using the Windows(tm) operating system.

       The whole system is delivered with three predefined export plugins, namely

       container
              See <u>PEG</u> <u>Export</u> <u>Plugin.</u> <u>To</u> <u>CONTAINER</u> <u>format</u> for details.

       json   See <u>PEG</u> <u>Export</u> <u>Plugin.</u> <u>To</u> <u>JSON</u> <u>format</u> for details.

       peg    See <u>PEG</u> <u>Export</u> <u>Plugin.</u> <u>To</u> <u>PEG</u> <u>format</u> for details.

       For readers wishing to write their own export plugin for some format, i.e. <u>plugin</u>  <u>writer</u>s,  reading  and
       understanding  the  <u>Parser</u>  <u>Tools</u>  <u>Export</u> <u>API</u> specification is an absolute necessity, as it documents the
       interaction between this package and its plugins in detail.

</pre><h4><b>API</b></h4><pre>
   <b>PACKAGE</b> <b>COMMANDS</b>
       <b>::pt::peg::export</b> <u>objectName</u>
              This command creates a new export manager object with an associated  Tcl  command  whose  name  is
              <u>objectName</u>.  This  <u>object</u>  command  is explained in full detail in the sections <b>Object</b> <b>command</b> and
              <b>Object</b> <b>methods</b>. The object command will be created under the current namespace if  the  <u>objectName</u>
              is not fully qualified, and in the specified namespace otherwise.

   <b>OBJECT</b> <b>COMMAND</b>
       All objects created by the <b>::pt::peg::export</b> command have the following general form:

       <b>objectName</b> <b>method</b> ?<u>arg</u> <u>arg</u> <u>...</u>?
              The  method  <b>method</b>  and  its <u>arg</u>'uments determine the exact behavior of the command.  See section
              <b>Object</b> <b>methods</b> for the detailed specifications.

   <b>OBJECT</b> <b>METHODS</b>
       <u>objectName</u> <b>destroy</b>
              This method destroys the object it is invoked for.

       <u>objectName</u> <b>export</b> <b>serial</b> <u>serial</u> ?<u>format</u>?
              This method takes the canonical serialization of a parsing expression grammar stored in <u>serial</u> and
              converts it to the specified <u>format</u>, using the export plugin for the format. This will  fail  with
              an  error  if  no  plugin  could  be found for the format.  The string generated by the conversion
              process is returned as the result of this method.

              If no format is specified the method defaults to <b>text</b>.

              The specification of  what  a  <u>canonical</u>  serialization  is  can  be  found  in  the  section  <b>PEG</b>
              <b>serialization</b> <b>format</b>.

              The  plugin  has  to  conform  to  the  interface  documented  in  the  <u>Parser</u>  <u>Tools</u>  <u>Export</u>  <u>API</u>
              specification.

       <u>objectName</u> <b>export</b> <b>object</b> <u>object</u> ?<u>format</u>?
              This method is a convenient wrapper around the <b>export</b> <b>serial</b>  method  described  by  the  previous
              item.   It  expects  that  <u>object</u> is an object command supporting a <b>serialize</b> method returning the
              canonical serialization of a parsing expression grammar. It invokes that method, feeds the  result
              into <b>export</b> <b>serial</b> and returns the resulting string as its own result.

       <u>objectName</u> <b>configuration</b> <b>names</b>
              This  method  returns  a list containing the names of all configuration options currently known to
              the object.

       <u>objectName</u> <b>configuration</b> <b>get</b>
              This method returns a dictionary containing the names and  values  of  all  configuration  options
              currently known to the object.

       <u>objectName</u> <b>configuration</b> <b>set</b> <u>name</u> ?<u>value</u>?
              This method sets the configuration option <u>name</u> to the specified <u>value</u> and returns the new value of
              the option.

              If no value is specified it simply returns the current value, without changing it.

              Note  that  these  configuration  options  and their values are simply passed to a plugin when the
              actual export is performed. It is the plugin which checks the validity, not the manager.

       <u>objectName</u> <b>configuration</b> <b>unset</b> <u>pattern</u>...
              This method unsets all configuration options matching the specified glob <u>pattern</u>s. If  no  pattern
              is specified it will unset all currently defined configuration options.

</pre><h4><b>PEG</b> <b>SERIALIZATION</b> <b>FORMAT</b></h4><pre>
       Here we specify the format used by the Parser Tools to serialize Parsing Expression Grammars as immutable
       values for transport, comparison, etc.

       We  distinguish between <u>regular</u> and <u>canonical</u> serializations.  While a PEG may have more than one regular
       serialization only exactly one of them will be <u>canonical</u>.

       regular serialization

              [1]    The serialization of any PEG is a nested Tcl dictionary.

              [2]    This dictionary holds a single key, <b>pt::grammar::peg</b>, and its value. This value  holds  the
                     contents of the grammar.

              [3]    The contents of the grammar are a Tcl dictionary holding the set of nonterminal symbols and
                     the starting expression. The relevant keys and their values are

                     <b>rules</b>  The  value  is  a Tcl dictionary whose keys are the names of the nonterminal symbols
                            known to the grammar.

                            [1]    Each nonterminal symbol may occur only once.

                            [2]    The empty string is not a legal nonterminal symbol.

                            [3]    The value for each symbol is a Tcl dictionary itself. The relevant  keys  and
                                   their values in this dictionary are

                                   <b>is</b>     The  value  is  the serialization of the parsing expression describing
                                          the symbols sentennial structure,  as  specified  in  the  section  <b>PE</b>
                                          <b>serialization</b> <b>format</b>.

                                   <b>mode</b>   The  value  can  be one of three values specifying how a parser should
                                          handle the semantic value produced by the symbol.

                                          <b>value</b>  The semantic value of the nonterminal  symbol  is  an  abstract
                                                 syntax   tree   consisting  of  a  single  node  node  for  the
                                                 nonterminal itself, which has the ASTs of  the  symbol's  right
                                                 hand side as its children.

                                          <b>leaf</b>   The  semantic  value  of  the nonterminal symbol is an abstract
                                                 syntax  tree  consisting  of  a  single  node  node   for   the
                                                 nonterminal,  without  any  children. Any ASTs generated by the
                                                 symbol's right hand side are discarded.

                                          <b>void</b>   The nonterminal has no semantic value. Any  ASTs  generated  by
                                                 the symbol's right hand side are discarded (as well).

                     <b>start</b>  The  value  is  the serialization of the start parsing expression of the grammar, as
                            specified in the section <b>PE</b> <b>serialization</b> <b>format</b>.

              [4]    The terminal symbols of the grammar are specified implicitly as the  set  of  all  terminal
                     symbols used in the start expression and on the RHS of the grammar rules.

       canonical serialization
              The  canonical  serialization  of  a grammar has the format as specified in the previous item, and
              then additionally satisfies the constraints below, which make it unique  among  all  the  possible
              serializations of this grammar.

              [1]    The keys found in all the nested Tcl dictionaries are sorted in ascending dictionary order,
                     as generated by Tcl's builtin command <b>lsort</b> <b>-increasing</b> <b>-dict</b>.

              [2]    The string representation of the value is the canonical representation of a Tcl dictionary.
                     I.e. it does not contain superfluous whitespace.

   <b>EXAMPLE</b>
       Assuming the following PEG for simple mathematical expressions

              PEG calculator (Expression)
                  Digit      &lt;- '0'/'1'/'2'/'3'/'4'/'5'/'6'/'7'/'8'/'9'       ;
                  Sign       &lt;- '-' / '+'                                     ;
                  Number     &lt;- Sign? Digit+                                  ;
                  Expression &lt;- Term (AddOp Term)*                            ;
                  MulOp      &lt;- '*' / '/'                                     ;
                  Term       &lt;- Factor (MulOp Factor)*                        ;
                  AddOp      &lt;- '+'/'-'                                       ;
                  Factor     &lt;- '(' Expression ')' / Number                   ;
              END;

       then its canonical serialization (except for whitespace) is

              pt::grammar::peg {
                  rules {
                      AddOp      {is {/ {t -} {t +}}                                                                mode value}
                      Digit      {is {/ {t 0} {t 1} {t 2} {t 3} {t 4} {t 5} {t 6} {t 7} {t 8} {t 9}}                mode value}
                      Expression {is {x {n Term} {* {x {n AddOp} {n Term}}}}                                        mode value}
                      Factor     {is {/ {x {t (} {n Expression} {t )}} {n Number}}                                  mode value}
                      MulOp      {is {/ {t *} {t /}}                                                                mode value}
                      Number     {is {x {? {n Sign}} {+ {n Digit}}}                                                 mode value}
                      Sign       {is {/ {t -} {t +}}                                                                mode value}
                      Term       {is {x {n Factor} {* {x {n MulOp} {n Factor}}}}                                    mode value}
                  }
                  start {n Expression}
              }

</pre><h4><b>PE</b> <b>SERIALIZATION</b> <b>FORMAT</b></h4><pre>
       Here  we specify the format used by the Parser Tools to serialize Parsing Expressions as immutable values
       for transport, comparison, etc.

       We distinguish between <u>regular</u> and <u>canonical</u> serializations.  While a parsing expression  may  have  more
       than one regular serialization only exactly one of them will be <u>canonical</u>.

       Regular serialization

              <b>Atomic</b> <b>Parsing</b> <b>Expressions</b>

                     [1]    The string <b>epsilon</b> is an atomic parsing expression. It matches the empty string.

                     [2]    The string <b>dot</b> is an atomic parsing expression. It matches any character.

                     [3]    The string <b>alnum</b> is an atomic parsing expression. It matches any Unicode alphabet or
                            digit  character.  This  is a custom extension of PEs based on Tcl's builtin command
                            <b>string</b> <b>is</b>.

                     [4]    The string <b>alpha</b> is an atomic parsing expression. It matches  any  Unicode  alphabet
                            character.  This  is a custom extension of PEs based on Tcl's builtin command <b>string</b>
                            <b>is</b>.

                     [5]    The string <b>ascii</b> is an atomic parsing expression. It matches any  Unicode  character
                            below U0080. This is a custom extension of PEs based on Tcl's builtin command <b>string</b>
                            <b>is</b>.

                     [6]    The  string  <b>control</b> is an atomic parsing expression. It matches any Unicode control
                            character. This is a custom extension of PEs based on Tcl's builtin  command  <b>string</b>
                            <b>is</b>.

                     [7]    The  string  <b>digit</b>  is  an  atomic  parsing expression. It matches any Unicode digit
                            character. Note that this includes characters outside of the [0..9] range. This is a
                            custom extension of PEs based on Tcl's builtin command <b>string</b> <b>is</b>.

                     [8]    The string <b>graph</b> is an atomic parsing expression. It matches  any  Unicode  printing
                            character,  except  for  space.  This  is  a  custom extension of PEs based on Tcl's
                            builtin command <b>string</b> <b>is</b>.

                     [9]    The string <b>lower</b> is an atomic parsing expression. It matches any Unicode  lower-case
                            alphabet character. This is a custom extension of PEs based on Tcl's builtin command
                            <b>string</b> <b>is</b>.

                     [10]   The  string  <b>print</b>  is an atomic parsing expression. It matches any Unicode printing
                            character, including space. This is a custom extension of PEs based on Tcl's builtin
                            command <b>string</b> <b>is</b>.

                     [11]   The string <b>punct</b> is an atomic parsing expression. It matches any Unicode punctuation
                            character. This is a custom extension of PEs based on Tcl's builtin  command  <b>string</b>
                            <b>is</b>.

                     [12]   The  string  <b>space</b>  is  an  atomic  parsing expression. It matches any Unicode space
                            character. This is a custom extension of PEs based on Tcl's builtin  command  <b>string</b>
                            <b>is</b>.

                     [13]   The  string <b>upper</b> is an atomic parsing expression. It matches any Unicode upper-case
                            alphabet character. This is a custom extension of PEs based on Tcl's builtin command
                            <b>string</b> <b>is</b>.

                     [14]   The string <b>wordchar</b> is an atomic parsing expression. It  matches  any  Unicode  word
                            character.  This  is  any  alphanumeric  character  (see  alnum),  and any connector
                            punctuation characters (e.g.  underscore). This is a custom extension of  PEs  based
                            on Tcl's builtin command <b>string</b> <b>is</b>.

                     [15]   The  string <b>xdigit</b> is an atomic parsing expression. It matches any hexadecimal digit
                            character. This is a custom extension of PEs based on Tcl's builtin  command  <b>string</b>
                            <b>is</b>.

                     [16]   The  string  <b>ddigit</b>  is  an  atomic parsing expression. It matches any decimal digit
                            character. This is a custom extension of PEs based on Tcl's builtin command <b>regexp</b>.

                     [17]   The expression [list t <b>x</b>] is an atomic parsing expression. It matches  the  terminal
                            string <b>x</b>.

                     [18]   The  expression  [list  n  <b>A</b>]  is  an  atomic  parsing  expression.  It  matches the
                            nonterminal <b>A</b>.

              <b>Combined</b> <b>Parsing</b> <b>Expressions</b>

                     [1]    For parsing expressions <b>e1</b>, <b>e2</b>, ... the result of [list / <b>e1</b> <b>e2</b> ... ] is  a  parsing
                            expression as well.  This is the <u>ordered</u> <u>choice</u>, aka <u>prioritized</u> <u>choice</u>.

                     [2]    For  parsing  expressions <b>e1</b>, <b>e2</b>, ... the result of [list x <b>e1</b> <b>e2</b> ... ] is a parsing
                            expression as well.  This is the <u>sequence</u>.

                     [3]    For a parsing expression <b>e</b> the result of [list * <b>e</b>] is a parsing expression as well.
                            This is the <u>kleene</u> <u>closure</u>, describing zero or more repetitions.

                     [4]    For a parsing expression <b>e</b> the result of [list + <b>e</b>] is a parsing expression as well.
                            This is the <u>positive</u> <u>kleene</u> <u>closure</u>, describing one or more repetitions.

                     [5]    For a parsing expression <b>e</b> the result of [list &amp; <b>e</b>] is a parsing expression as well.
                            This is the <u>and</u> <u>lookahead</u> <u>predicate</u>.

                     [6]    For a parsing expression <b>e</b> the result of [list ! <b>e</b>] is a parsing expression as well.
                            This is the <u>not</u> <u>lookahead</u> <u>predicate</u>.

                     [7]    For a parsing expression <b>e</b> the result of [list ? <b>e</b>] is a parsing expression as well.
                            This is the <u>optional</u> <u>input</u>.

       Canonical serialization
              The canonical serialization of a parsing expression has the format as specified  in  the  previous
              item,  and  then  additionally satisfies the constraints below, which make it unique among all the
              possible serializations of this parsing expression.

              [1]    The string representation of the value is the canonical representation of a pure Tcl  list.
                     I.e. it does not contain superfluous whitespace.

              [2]    Terminals are <u>not</u> encoded as ranges (where start and end of the range are identical).

   <b>EXAMPLE</b>
       Assuming the parsing expression shown on the right-hand side of the rule

                  Expression &lt;- Term (AddOp Term)*

       then its canonical serialization (except for whitespace) is

                  {x {n Term} {* {x {n AddOp} {n Term}}}}

</pre><h4><b>BUGS,</b> <b>IDEAS,</b> <b>FEEDBACK</b></h4><pre>
       This  document,  and  the package it describes, will undoubtedly contain bugs and other problems.  Please
       report such in the category <u>pt</u> of the  <u>Tcllib</u>  <u>Trackers</u>  [<a href="http://core.tcl.tk/tcllib/reportlist">http://core.tcl.tk/tcllib/reportlist</a>].   Please
       also report any ideas for enhancements you may have for either package and/or documentation.

       When proposing code changes, please provide <u>unified</u> <u>diffs</u>, i.e the output of <b>diff</b> <b>-u</b>.

       Note  further  that  <u>attachments</u>  are strongly preferred over inlined patches. Attachments can be made by
       going to the <b>Edit</b> form of the ticket immediately after its creation, and then using the left-most  button
       in the secondary navigation bar.

</pre><h4><b>KEYWORDS</b></h4><pre>
       EBNF,   LL(k),  PEG,  TDPL,  context-free  languages,  expression,  grammar,  matching,  parser,  parsing
       expression, parsing expression grammar, push down automaton, recursive descent, state,  top-down  parsing
       languages, transducer

</pre><h4><b>CATEGORY</b></h4><pre>
       Parsing and Grammars

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2009 Andreas Kupries &lt;<a href="mailto:andreas_kupries@users.sourceforge.net">andreas_kupries@users.sourceforge.net</a>&gt;

tcllib                                                1.0.2                                <u>pt::peg::<a href="../man3tcl/export.3tcl.html">export</a></u>(3tcl)
</pre>
 </div>
</div></section>
</div>
</body>
</html>