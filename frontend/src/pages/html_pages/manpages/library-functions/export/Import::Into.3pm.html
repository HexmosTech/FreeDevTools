<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Import::Into - Import packages into other packages</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libimport-into-perl">libimport-into-perl_1.002005-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Import::Into - Import packages into other packages

</pre><h4><b>SYNOPSIS</b></h4><pre>
         package My::MultiExporter;

         use Import::Into;

         # simple
         sub import {
           Thing1-&gt;import::into(scalar caller);
         }

         # multiple
         sub import {
           my $target = caller;
           Thing1-&gt;import::into($target);
           Thing2-&gt;import::into($target, qw(import arguments));
         }

         # by level
         sub import {
           Thing1-&gt;import::<a href="../man1/into.1.html">into</a>(1);
         }

         # with exporter
         use base qw(Exporter);
         sub import {
           shift-&gt;<a href="../man1/export_to_level.1.html">export_to_level</a>(1);
           Thing1-&gt;import::<a href="../man1/into.1.html">into</a>(1);
         }

         # no My::MultiExporter == no Thing1
         sub unimport {
           Thing1-&gt;unimport::out_of(scalar caller);
         }

       People wanting to re-export your module should also be using Import::Into.  Any exporter or pragma will
       work seamlessly.

       Note: You do <b>not</b> need to make any changes to Thing1 to be able to call "import::into" on it. This is a
       global method, and is callable on any package (and in fact on any object as well, although it's rarer
       that you'd want to do that).

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Writing exporters is a pain. Some use Exporter, some use Sub::Exporter, some use Moose::Exporter, some
       use Exporter::Declare ... and some things are pragmas.

       Exporting on someone else's behalf is harder.  The exporters don't provide a consistent API for this, and
       pragmas need to have their import method called directly, since they effect the current unit of
       compilation.

       "Import::Into" provides global methods to make this painless.

</pre><h4><b>METHODS</b></h4><pre>
   <b>$package-&gt;import::into(</b> <b>$target,</b> <b>@arguments</b> <b>);</b>
       A global method, callable on any package.  Loads and imports the given package into $target.  @arguments
       are passed along to the package's import method.

       $target can be an package name to export to, an integer for the caller level to export to, or a hashref
       with the following options:

       package
           The target package to export to.

       filename
           The  apparent  filename  to  export  to.  Some exporting modules, such as autodie or strictures, care
           about the filename they are being imported to.

       line
           The apparent line number to export to.  To be combined with the "filename" option.

       level
           The caller level to export to.  This will  automatically  populate  the  "package",  "filename",  and
           "line" options, making it the easiest most constent option.

       version
           A version number to check for the module.  The equivalent of specifying the version number on a "use"
           line.

   <b>$package-&gt;unimport::out_of(</b> <b>$target,</b> <b>@arguments</b> <b>);</b>
       Equivalent to "import::into", but dispatches to $package's "unimport" method instead of "import".

</pre><h4><b>WHY</b> <b>USE</b> <b>THIS</b> <b>MODULE</b></h4><pre>
       The  APIs  for  exporting modules aren't consistent.  Exporter subclasses provide export_to_level, but if
       they overrode their import method all bets  are  off.   Sub::Exporter  provides  an  into  parameter  but
       figuring  out something used it isn't trivial. Pragmas need to have their "import" method called directly
       since they affect the current unit of compilation.

       It's ... annoying.

       However, there is an approach that actually works for all of these types.

         eval "package $target; use $thing;"

       will work for anything checking caller, which is everything except pragmas.   But  it  doesn't  work  for
       pragmas - pragmas need:

         $thing-&gt;import;

       because  they're  designed  to  affect  the code currently being compiled - so within an eval, that's the
       scope of the eval itself, not the module that just "use"d you - so

         sub import {
           eval "use strict;"
         }

       doesn't do what you wanted, but

         sub import {
           strict-&gt;import;
         }

       will apply strict to the calling file correctly.

       Of course, now you have two new problems - first, that you still need to know if  something's  a  pragma,
       and second that you can't use either of these approaches alone on something like Moose or Moo that's both
       an exporter and a pragma.

       So, a solution for that is:

         use Module::Runtime;
         my $sub = eval "package $target; sub { use_module(shift)-&gt;import(\@_) }";
         $sub-&gt;($thing, @import_args);

       which  means  that  import  is called from the right place for pragmas to take effect, and from the right
       package for caller checking to work - and so behaves correctly for all types of  exporter,  for  pragmas,
       and for hybrids.

       Additionally, some import routines check the filename they are being imported to.  This can be dealt with
       by  generating  a  #line  directive in the eval, which will change what "caller" reports for the filename
       when called in the importer. The filename and line number to use in the directive then need to be fetched
       using "caller":

         my ($target, $file, $line) = <a href="../man1/caller.1.html">caller</a>(1);
         my $sub = eval qq{
           package $target;
         #line $line "$file"
           sub { use_module(shift)-&gt;import(\@_) }
         };
         $sub-&gt;($thing, @import_args);

       And you need to switch between these implementations  depending  on  if  you  are  targeting  a  specific
       package, or something in your call stack.

       Remembering  all  this,  however,  is  excessively  irritating.  So  I wrote a module so I didn't have to
       anymore. Loading Import::Into creates a global method "import::into" which you can call on any package to
       import it into another package. So now you can simply write:

         use Import::Into;

         $thing-&gt;import::into($target, @import_args);

       This works because of how perl resolves method calls - a call to a simple method name is resolved against
       the package of the class or object, so

         $thing-&gt;method_name(@args);

       is roughly equivalent to:

         my $code_ref = $thing-&gt;can('method_name');
         $code_ref-&gt;($thing, @args);

       while if a "::" is found, the lookup is made relative to the package name  (i.e.  everything  before  the
       last "::") so

         $thing-&gt;Package::Name::method_name(@args);

       is roughly equivalent to:

         my $code_ref = Package::Name-&gt;can('method_name');
         $code_ref-&gt;($thing, @args);

       So since Import::Into defines a method "into" in package "import" the syntax reliably calls that.

       For    more    craziness    of    this    order,    have   a   look   at   the   article   I   wrote   at
       &lt;<a href="http://shadow.cat/blog/matt-s-trout/madness-with-methods">http://shadow.cat/blog/matt-s-trout/madness-with-methods</a>&gt; which covers coderef abuse and  the  "${\...}"
       syntax.

       And that's it.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       I   gave   a   lightning   talk   on   this   module   (and   curry   and  Safe::Isa)  at  YAPC::NA  2013
       &lt;https://www.youtube.com/watch?v=wFXWV2yY7gE&amp;t=46m05s&gt;.

</pre><h4><b>ACKNOWLEDGEMENTS</b></h4><pre>
       Thanks to Getty for asking "how can I get "use strict; use warnings;" turned on for all consumers  of  my
       code?" and then "why is this not a module?!".

</pre><h4><b>AUTHOR</b></h4><pre>
       mst - Matt S. Trout (cpan:MSTROUT) &lt;<a href="mailto:mst@shadowcat.co.uk">mst@shadowcat.co.uk</a>&gt;

</pre><h4><b>CONTRIBUTORS</b></h4><pre>
       haarg - Graham Knop (cpan:HAARG) &lt;<a href="mailto:haarg@haarg.org">haarg@haarg.org</a>&gt;

       Mithaldu - Christian Walde (cpan:MITHALDU) &lt;<a href="mailto:walde.christian@gmail.com">walde.christian@gmail.com</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright (c) 2012 the Import::Into "AUTHOR" and "CONTRIBUTORS" as listed above.

</pre><h4><b>LICENSE</b></h4><pre>
       This library is free software and may be distributed under the same terms as perl itself.

perl v5.34.0                                       2022-06-14                                  <u>Import::<a href="../man3pm/Into.3pm.html">Into</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>