<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Net::CLI::Interact::Role::Prompt - Command-line prompt management</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libnet-cli-interact-perl">libnet-cli-interact-perl_2.400002-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Net::CLI::Interact::Role::Prompt - Command-line prompt management

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This is another core component of Net::CLI::Interact, and its role is to keep track of the current prompt
       on the connected command line interface. The idea is that most CLI have a prompt where you issue
       commands, and are returned some output which this module gathers. The prompt is a demarcation between
       each command and its response data.

       Note that although we "keep track" of the prompt, Net::CLI::Interact is not a state machine, and the
       choice of command issued to the connected device bears no relation to the current (or last matched)
       prompt.

</pre><h4><b>INTERFACE</b></h4><pre>
   <b>set_prompt(</b> <b>$prompt_name</b> <b>)</b>
       This method will be used most commonly by applications to select and set a prompt from the Phrasebook
       which matches the current context of the connected CLI session. This allows a sequence of commands to be
       sent which share the same Prompt.

       The name you pass in is looked up in the loaded Phrasebook and the entry's regular expression stored
       internally. An exception is thrown if the named Prompt is not known.

       Typically you would either refer to a Prompt in a Macro, or set the prompt you are expecting once for a
       sequence of commands in a particular CLI context.

       When a Macro completes and it has been defined in the Phrasebook with an explicit named Prompt at the
       end, we can assume the user is indicating some change of context. Therefore the "prompt" is <u>automatically</u>
       <u>updated</u> on such occasions to have the regular expression from that named Prompt.

   <b>prompt_re</b>
       Returns the current Prompt in the form of a regular expression reference. The Prompt is used as a default
       to catch the end of command response output, when a Macro has not been set up with explicit Prompt
       matching.

       Typically you would either refer to a Prompt in a Macro, or set the prompt you are expecting once for a
       sequence of commands in a particular CLI context.

   <b>unset_prompt</b>
       Use this method to empty the current "prompt" setting (see above). The effect is that the module will
       automatically set the Prompt for itself based on the last line of output received from the connected CLI.
       Do not use this option unless you know what you are doing.

   <b>has_set_prompt</b>
       Returns True if there is currently a Prompt set, otherwise returns False.

   <b>prompt_looks_like(</b> <b>$name</b> <b>)</b>
       Returns True if the current prompt matches the given named prompt. This is useful when you wish to make a
       more specific check on the current prompt.

   <b>find_prompt(</b> <b>$wake_up?</b> <b>)</b>
       A helper method that consumes output from the connected CLI session until a line matches any one of the
       named Prompts in the loaded Phrasebook, at which point no more output is consumed. As a consequence the
       "prompt" will be set (see above).

       This might be used when you're connecting to a device which maintains CLI state between session
       disconnects (for example a serial console), and you need to discover the current state. However,
       "find_prompt" is executed automatically for you if you call a "cmd" or "macro" before any interaction
       with the CLI.

       The current device output will be scanned against all known named Prompts. If nothing is found, the
       default behaviour is to die. Passing a positive number to the method (as $wake_up) will instead send the
       content of our "wake_up_msg" slot (see below), typically a carriage return, and try to match again. The
       idea is that by sending one carriage return, the connected device will print its CLI prompt. This "send
       and try to match" process will be repeated up to "$wake_up" times.

   <b>wake_up_msg</b>
       Text sent to a device within the "find_prompt" method if no output has so far matched any known named
       Prompt. Default is the value of the <u>output</u> <u>record</u> <u>separator</u> from the Transport (one newline).

   <b>last_prompt</b>
       Returns the Prompt which most recently was matched and terminated gathering of output from the connected
       CLI. This is a simple text string.

   <b>last_prompt_re</b>
       Returns the text which was most recently matched and terminated gathering of output from the connected
       CLI, as a quote-escaped regular expression with line start and end anchors.

perl v5.36.0                                       2023-10-28              <u>Net::CLI::Interact::Role::<a href="../man3pm/Prompt.3pm.html">Prompt</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>