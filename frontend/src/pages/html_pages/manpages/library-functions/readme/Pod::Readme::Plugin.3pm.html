<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pod::Readme::Plugin - Plugin role for Pod::Readme</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libpod-readme-perl">libpod-readme-perl_1.2.3-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Pod::Readme::Plugin - Plugin role for Pod::Readme

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Pod::Readme v1.0 and later supports plugins that extend the capabilities of the module.

</pre><h4><b>WRITING</b> <b>PLUGINS</b></h4><pre>
       Writing plugins is straightforward. Plugins are Moo::Role modules in the "Pod::Readme::Plugin" namespace.
       For example,

         package Pod::Readme::Plugin::myplugin;

         use Moo::Role;

         sub cmd_myplugin {
             my ($self, @args) = @_;
             my $res = $self-&gt;parse_cmd_args( [qw/ arg1 arg2 /], @args );

             ...
         }

       When Pod::Readme encounters POD with

         =for readme plugin myplugin arg1 arg2

       the plugin role will be loaded, and the "cmd_myplugin" method will be run.

       Note that you do not need to specify a "cmd_myplugin" method.

       Any method prefixed with "cmd_" will be a command that can be called using the "=for readme command"
       syntax.

       A plugin parses arguments using the "parse_cmd_arguments" method and writes output using the write
       methods noted above.

       See some of the included plugins, such as Pod::Readme::Plugin::version for examples.

       Any attributes in the plugin should be prefixed with the name of the plugin, to avoid any conflicts with
       attribute and method names from other plugins, e.g.

         use Types::Standard qw/ Int /;

         has 'myplugin_heading_level' =&gt; (
           is      =&gt; 'rw',
           isa     =&gt; Int,
           default =&gt; 1,
           lazy    =&gt; 1,
         );

       Attributes should be lazy to ensure that their defaults are properly set.

       Be aware that changing default values of an attribute based on arguments means that the next time a
       plugin method is run, the defaults will be changed.

       Custom types in Pod::Readme::Types may be useful for attributes when writing plugins, e.g.

         use Pod::Readme::Types qw/ File HeadingLevel /;

         has 'myplugin_file' =&gt; (
           is      =&gt; 'rw',
           isa     =&gt; File,
           coerce  =&gt; sub { File-&gt;coerce(@_) },
           default =&gt; 'Changes',
           lazy =&gt; 1,
         );

         # We add this file to the list of dependencies

         around 'depends_on' =&gt; sub {
           my ($orig, $self) = @_;
           return ($self-&gt;myplugin_file, $self-&gt;$orig);
         };

</pre><h4><b>ATTRIBUTES</b></h4><pre>
   <b>"verbatim_indent"</b>
       The number of columns to indent a verbatim paragraph.

</pre><h4><b>METHODS</b></h4><pre>
   <b>"parse_cmd_args"</b>
         my $hash_ref = $self-&gt;parse_cmd_args( \@allowed_keys, @args);

       This command parses arguments for a plugin and returns a hash reference containing the argument values.

       The @args parameter is a list of arguments passed to the command method by Pod::Readme::Filter.

       If an argument contains an equals sign, then it is assumed to take a string.  (Strings containing
       whitespace should be surrounded by quotes.)

       Otherwise, an argument is assumed to be boolean, which defaults to true. If the argument is prefixed by
       "no-" or "no_" then it is given a false value.

       If the @allowed_keys parameter is given, then it will reject argument keys that are not in that list.

       For example,

         my $res = $self-&gt;parse_cmd_args(
                     undef,
                     'arg1',
                     'no-arg2',
                     'arg3="This is a string"',
                     'arg4=value',
         );

       will return a hash reference containing

         {
            arg1 =&gt; 1,
            arg2 =&gt; 0,
            arg3 =&gt; 'This is a string',
            arg4 =&gt; 'value',
         }

   <b>"write_verbatim"</b>
         $self-&gt;write_verbatim($text);

       A utility method to write verbatim text, indented by "verbatim_indent".

   <b>"write_para"</b>
         $self-&gt;write_para('This is a paragraph');

       Utility method to write a POD paragraph.

   <b>"write_head1"</b>
   <b>"write_head2"</b>
   <b>"write_head3"</b>
   <b>"write_head4"</b>
   <b>"write_over"</b>
   <b>"write_item"</b>
   <b>"write_back"</b>
   <b>"write_begin"</b>
   <b>"write_end"</b>
   <b>"write_for"</b>
   <b>"write_encoding"</b>
   <b>"write_cut"</b>
   <b>"write_pod"</b>
         $self-&gt;write_head1($text);

       Utility methods to write POD specific commands to the "output_file".

       These methods ensure the POD commands have extra newlines for compatibility with older POD parsers.

perl v5.28.0                                       2018-11-26                           <u>Pod::Readme::<a href="../man3pm/Plugin.3pm.html">Plugin</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>