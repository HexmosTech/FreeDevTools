<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>libpfm_intel_knl - support for Intel Knights Landing core PMU</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libpfm4-dev">libpfm4-dev_4.13.0+git99-gc5587f9-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       libpfm_intel_knl - support for Intel Knights Landing core PMU

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;perfmon/pfmlib.h&gt;</b>

       <b>PMU</b> <b>name:</b> <b>knl</b>
       <b>PMU</b> <b>desc:</b> <b>Intel</b> <b>Knights</b> <b>Landing</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  library  supports  the  Intel  Knights Landing core PMU. It should be noted that this PMU model only
       covers each core's PMU and not the socket level PMU.

       On Knights Landing, the number of generic counters is 4. There  is  4-way  HyperThreading  support.   The
       <b>pfm_get_pmu_info()</b> function returns the maximum number of generic counters in <b>num_cntrs.</b>

</pre><h4><b>MODIFIERS</b></h4><pre>
       The following modifiers are supported on Intel Knights Landing processors:

       <b>u</b>      Measure at user level which includes privilege levels 1, 2, 3. This corresponds to <b>PFM_PLM3</b>.  This
              is a boolean modifier.

       <b>k</b>      Measure at kernel level which includes privilege level 0. This corresponds to <b>PFM_PLM0</b>.  This is a
              boolean modifier.

       <b>i</b>      Invert  the  meaning  of  the  event.  The counter will now count cycles in which the event is <b>not</b>
              occurring. This is a boolean modifier

       <b>e</b>      Enable edge detection, i.e., count only when there is a state transition from no occurrence of the
              event to at least one occurrence. This modifier must be combined with a counter mask modifier  (m)
              with a value greater or equal to one.  This is a boolean modifier.

       <b>c</b>      Set  the  counter  mask  value. The mask acts as a threshold. The counter will count the number of
              cycles in which the number of occurrences of the event is greater or equal to the threshold.  This
              is an integer modifier with values in the range [0:255].

       <b>t</b>      Measure  on  any of the 4 hyper-threads at the same time assuming hyper-threading is enabled. This
              is   a   boolean   modifier.    This   modifier   is   only   available    on    fixed    counters
              (unhalted_reference_cycles,   instructions_retired,   unhalted_core_cycles).    Depending  on  the
              underlying kernel interface, the event may be programmed on a fixed counter or a generic  counter,
              except for unhalted_reference_cycles, in which case, this modifier may be ignored or rejected.

</pre><h4><b>OFFCORE_RESPONSE</b> <b>events</b></h4><pre>
       Intel  Knights  Landing  provides  two  offcore_response  events.  They are called OFFCORE_RESPONSE_0 and
       OFFCORE_RESPONSE_1.

       Those events need special treatment in the performance monitoring infrastructure because each event  uses
       an  extra  register  to store some settings. Thus, in case multiple offcore_response events are monitored
       simultaneously, the kernel needs to manage the sharing of that extra register.

       The offcore_response events are exposed as normal events by the library. The extra settings  are  exposed
       as  regular  umasks.  The  library  takes  care of encoding the events according to the underlying kernel
       interface.

       On Intel Knights Landing, the umasks are divided into 4  categories:  request,  supplier  and  snoop  and
       average  latency. Offcore_response event has two modes of operations: normal and average latency.  In the
       first mode, the two offcore_respnse events operate independently of each other. The user must provide  at
       least one umask for each of the first 3 categories: request, supplier, snoop. In the second mode, the two
       offcore_response events are combined to compute an average latency per request type.

       For the normal mode, there is a special supplier (response) umask called <b>ANY_RESPONSE</b>. When this umask is
       used  then  it  overrides  any  supplier  and  snoop  umasks.  In  other  words, users can specify either
       <b>ANY_RESPONSE</b> <b>OR</b> any combinations of supplier + snoops. In case no supplier or  snoop  is  specified,  the
       library defaults to using <b>ANY_RESPONSE</b>.

       For instance, the following are valid event selections:

       <b>OFFCORE_RESPONSE_0:DMND_DATA_RD:ANY_RESPONSE</b>

       <b>OFFCORE_RESPONSE_0:ANY_REQUEST</b>

       <b>OFFCORE_RESPONSE_0:ANY_RFO:DDR_NEAR</b>

       But the following is illegal:

       <b>OFFCORE_RESPONSE_0:ANY_RFO:DDR_NEAR:ANY_RESPONSE</b>

       In  average  latency mode, <b>OFFCORE_RESPONSE_0</b> must be programmed to select the request types of interest,
       for instance, <b>DMND_DATA_RD</b>, and the <b>OUTSTANDING</b> umask must be set and no others. the library will enforce
       that restriction as soon as the <b>OUTSTANDING</b> umask is used. Then <b>OFFCORE_RESPONSE_1</b> must be set  with  the
       same  request  types  and  the  <b>ANY_RESPONSE</b>  umask.  It  should be noted that the library encodes events
       independently of each other and therefore cannot verify that the requests are matching  between  the  two
       events.  Example of average latency settings:

       <b>OFFCORE_RESPONSE_0:DMND_DATA_RD:OUTSTANDING+OFFCORE_RESPONSE_1:DMND_DATA_RD:ANY_RESPONSE</b>

       <b>OFFCORE_RESPONSE_0:ANY_REQUEST:OUTSTANDING+OFFCORE_RESPONSE_1:ANY_REQUEST:ANY_RESPONSE</b>

       The  average  latency  for the request(s) is obtained by dividing the counts of <b>OFFCORE_RESPONSE_0</b> by the
       count of <b>OFFCORE_RESPONSE_1</b>. The ratio is expressed in core cycles.

</pre><h4><b>AUTHORS</b></h4><pre>
       Stephane Eranian &lt;<a href="mailto:eranian@gmail.com">eranian@gmail.com</a>&gt;

                                                   July, 2016                                          <u><a href="../man3/LIBPFM.3.html">LIBPFM</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>