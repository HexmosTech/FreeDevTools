<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>clEnqueueReadBufferRect - Enqueue commands to read from a rectangular region from a buffer object to host</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/opencl-1.2-man-doc">opencl-1.2-man-doc_1.0~svn33624-5.1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       clEnqueueReadBufferRect - Enqueue commands to read from a rectangular region from a buffer object to host
       memory.

       <b>cl_int</b> <b>clEnqueueReadBufferRect(cl_command_queue</b> <u>command_queue</u><b>,</b> <b>cl_mem</b> <u>buffer</u><b>,</b> <b>cl_bool</b> <u>blocking_read</u><b>,</b>
                                      <b>const</b> <b>size_t</b> <b>*</b> <u>buffer_origin</u><b>,</b> <b>const</b> <b>size_t</b> <b>*</b> <u>host_origin</u><b>,</b>
                                      <b>const</b> <b>size_t</b> <b>*</b> <u>region</u><b>,</b> <b>size_t</b> <u>buffer_row_pitch</u><b>,</b> <b>size_t</b> <u>buffer_slice_pitch</u><b>,</b>
                                      <b>size_t</b> <u>host_row_pitch</u><b>,</b> <b>size_t</b> <u>host_slice_pitch</u><b>,</b> <b>void</b> <b>*</b><u>ptr</u><b>,</b>
                                      <b>cl_uint</b> <u>num_events_in_wait_list</u><b>,</b> <b>const</b> <b>cl_event</b> <b>*</b><u>event_wait_list</u><b>,</b>
                                      <b>cl_event</b> <b>*</b><u>event</u><b>);</b>

</pre><h4><b>PARAMETERS</b></h4><pre>
       <u>command_queue</u>
           Refers to the command-queue in which the read command will be queued.  <u>command_queue</u> and <u>buffer</u> must
           be created with the same OpenCL context.

       <u>buffer</u>
           Refers to a valid buffer object.

       <u>blocking_read</u>
           Indicates if the read operations are <u>blocking</u> or non-blocking.

           If <u>blocking_read</u> is <b>CL_TRUE</b> i.e. the read command is blocking, <b>clEnqueueReadBufferRect</b> does not
           return until the buffer data has been read and copied into memory pointed to by <u>ptr</u>.

           If <u>blocking_read</u> is <b>CL_FALSE</b> i.e. the read command is <u>non-blocking</u>, <b>clEnqueueReadBufferRect</b> queues a
           non-blocking read command and returns. The contents of the buffer that <u>ptr</u> points to cannot be used
           until the read command has completed. The <u>event</u> argument argument returns an event object which can
           be used to query the execution status of the read command. When the read command has completed, the
           contents of the buffer that <u>ptr</u> points to can be used by the application.

       <u>buffer_origin</u>
           The (<u>x,</u> <u>y,</u> <u>z</u>) offset in the memory region associated with <u>buffer</u>. For a 2D rectangle region, the <u>z</u>
           value given by <u>buffer_origin</u>[2] should be 0. The offset in bytes is computed as <u>buffer_origin</u>[2] *
           <u>buffer_slice_pitch</u> + <u>buffer_origin</u>[1] * <u>buffer_row_pitch</u> + <u>buffer_origin</u>[0].

       <u>host_origin</u>
           The (<u>x,</u> <u>y,</u> <u>z</u>) offset in the memory region pointed to by <u>ptr</u>. For a 2D rectangle region, the <u>z</u> value
           given by <u>host_origin</u>[2] should be 0. The offset in bytes is computed as <u>host_origin</u>[2] *
           <u>host_slice_pitch</u> + <u>host_origin</u>[1] * <u>host_row_pitch</u> + <u>host_origin</u>[0].

       <u>region</u>
           The (<u>width,</u> <u>height,</u> <u>depth</u>) in bytes of the 2D or 3D rectangle being read or written. For a 2D
           rectangle copy, the <u>depth</u> value given by <u>region</u>[2] should be 1.

       <u>buffer_row_pitch</u>
           The length of each row in bytes to be used for the memory region associated with <u>buffer</u>. If
           <u>buffer_row_pitch</u> is 0, <u>buffer_row_pitch</u> is computed as <u>region</u>[0].

       <u>buffer_slice_pitch</u>
           The length of each 2D slice in bytes to be used for the memory region associated with <u>buffer</u>. If
           <u>buffer_slice_pitch</u> is 0, <u>buffer_slice_pitch</u> is computed as <u>region</u>[1] * <u>buffer_row_pitch</u>.

       <u>host_row_pitch</u>
           The length of each row in bytes to be used for the memory region pointed to by <u>ptr</u>. If <u>host_row_pitch</u>
           is 0, <u>host_row_pitch</u> is computed as <u>region</u>[0].

       <u>host_slice_pitch</u>
           The length of each 2D slice in bytes to be used for the memory region pointed to by <u>ptr</u>. If
           <u>host_slice_pitch</u> is 0, <u>host_slice_pitch</u> is computed as <u>region</u>[1] * <u>host_row_pitch</u>.

       <u>ptr</u>
           The pointer to buffer in host memory where data is to be read into.

        <u>event_wait_list</u> ,  <u>num_events_in_wait_list</u>

           <u>event_wait_list</u> and <u>num_events_in_wait_list</u> specify events that need to complete before this
           particular command can be executed. If <u>event_wait_list</u> is NULL, then this particular command does not
           wait on any event to complete. If <u>event_wait_list</u> is NULL, <u>num_events_in_wait_list</u> must be 0. If
           <u>event_wait_list</u> is not NULL, the list of events pointed to by <u>event_wait_list</u> must be valid and
           <u>num_events_in_wait_list</u> must be greater than 0. The events specified in <u>event_wait_list</u> act as
           synchronization points. The context associated with events in <u>event_wait_list</u> and <u>command_queue</u> must
           be the same. The memory associated with <u>event_wait_list</u> can be reused or freed after the function
           returns.

        <u>event</u>
           Returns an event object that identifies this particular read command and can be used to query or
           queue a wait for this particular command to complete.  <u>event</u> can be NULL in which case it will not be
           possible for the application to query the status of this command or queue a wait for this command to
           complete. If the <u>event_wait_list</u> and the event arguments are not NULL, the <u>event</u> argument should not
           refer to an element of the <u>event_wait_list</u> array.

</pre><h4><b>NOTES</b></h4><pre>
       Calling <b>clEnqueueReadBufferRect</b> to read a region of the buffer object with the <u>ptr</u> argument value set to
       <u>host_ptr</u> and <u>host_origin</u>, <u>buffer_origin</u> values are the same, where <u>host_ptr</u> is a pointer to the memory
       region specified when the buffer object being read is created with <b>CL_MEM_USE_HOST_PTR</b>, must meet the
       same requirements given for <b><a href="../man3clc/clEnqueueReadBuffer.3clc.html">clEnqueueReadBuffer</a></b>(3clc).

       Calling <b>clEnqueueWriteBufferRect</b> to update the latest bits in a region of the buffer object with the <u>ptr</u>
       argument value set to <u>host_ptr</u> and <u>host_origin</u>, <u>buffer_origin</u> values are the same, where <u>host_ptr</u> is a
       pointer to the memory region specified when the buffer object being written is created with
       <b>CL_MEM_USE_HOST_PTR</b>, must meet the following requirements in order to avoid undefined behavior:

       •    The host memory region given by (<u>buffer_originregion</u>) contains the latest bits when the enqueued
           write command begins execution.

       •    The buffer object or memory objects created from this buffer object are not mapped.

       •    The buffer object or memory objects created from this buffer object are not used by any
           command-queue until the write command has finished execution.

</pre><h4><b>ERRORS</b></h4><pre>
       <b>clEnqueueReadBufferRect</b> returns CL_SUCCESS if the function is executed successfully. Otherwise, it
       returns one of the following errors:

       •   CL_INVALID_COMMAND_QUEUE if <u>command_queue</u> is not a valid command-queue.

       •   CL_INVALID_CONTEXT if the context associated with <u>command_queue</u> and <u>buffer</u> are not the same or if the
           context associated with <u>command_queue</u> and events in <u>event_wait_list</u> are not the same.

       •   CL_INVALID_MEM_OBJECT if <u>buffer</u> is not a valid buffer object.

       •   CL_INVALID_VALUE if the region being read specified by (<u>buffer_origin</u>, <u>region</u>, <u>buffer_row_pitch</u>,
           <u>buffer_slice_pitch</u>) is out of bounds.

       •   CL_INVALID_VALUE if <u>ptr</u> is a NULL value.

       •   CL_INVALID_VALUE if any <u>region</u> array element is 0.

       •   CL_INVALID_VALUE if <u>buffer_row_pitch</u> is not 0 and is less than <u>region</u>[0].

       •   CL_INVALID_VALUE if <u>host_row_pitch</u> is not 0 and is less than <u>region</u>[0].

       •   CL_INVALID_VALUE if <u>buffer_slice_pitch</u> is not 0 and is less than <u>region</u>[1] * <u>buffer_row_pitch</u> and not
           a multiple of <u>buffer_row_pitch</u>.

       •   CL_INVALID_VALUE if <u>host_slice_pitch</u> is not 0 and is less than <u>region</u>[1] * <u>host_row_pitch</u> and not a
           multiple of <u>host_row_pitch</u>.

       •   CL_INVALID_EVENT_WAIT_LIST if <u>event_wait_list</u> is NULL and <u>num_events_in_wait_list</u> &gt; 0, or
           <u>event_wait_list</u> is not NULL and <u>num_events_in_wait_list</u> is 0, or if event objects in <u>event_wait_list</u>
           are not valid events.

       •   CL_MISALIGNED_SUB_BUFFER_OFFSET if <u>buffer</u> is a sub-buffer object and <u>offset</u> specified when the
           sub-buffer object is created is not aligned to <b>CL_DEVICE_MEM_BASE_ADDR_ALIGN</b> value for device
           associated with <u>queue</u>.

       •   CL_EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST if the read and write operations are blocking and the
           execution status of any of the events in <u>event_wait_list</u> is a negative integer value.

       •   CL_MEM_OBJECT_ALLOCATION_FAILURE if there is a failure to allocate memory for data store associated
           with <u>buffer</u>.

       •   CL_INVALID_OPERATION if <b>clEnqueueReadBufferRect</b> is called on <u>buffer</u> which has been created with
           <b>CL_MEM_HOST_WRITE_ONLY</b> or <b>CL_MEM_HOST_NO_ACCESS</b>.

       •   CL_OUT_OF_RESOURCES if there is a failure to allocate resources required by the OpenCL implementation
           on the device.

       •   CL_OUT_OF_HOST_MEMORY if there is a failure to allocate resources required by the OpenCL
           implementation on the host.

</pre><h4><b>SPECIFICATION</b></h4><pre>
       <b>OpenCL</b> <b>Specification</b>[1]

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3clc/clEnqueueCopyBuffer.3clc.html">clEnqueueCopyBuffer</a></b>(3clc), <b><a href="../man3clc/clEnqueueCopyBufferRect.3clc.html">clEnqueueCopyBufferRect</a></b>(3clc), <b><a href="../man3clc/clEnqueueWriteBuffer.3clc.html">clEnqueueWriteBuffer</a></b>(3clc),
       <b><a href="../man3clc/clEnqueueWriteBufferRect.3clc.html">clEnqueueWriteBufferRect</a></b>(3clc), <b><a href="../man3clc/clEnqueueReadBuffer.3clc.html">clEnqueueReadBuffer</a></b>(3clc)

</pre><h4><b>AUTHORS</b></h4><pre>
       <b>The</b> <b>Khronos</b> <b>Group</b>

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright © 2007-2011 The Khronos Group Inc.
       Permission is hereby granted, free of charge, to any person obtaining a copy of this software and/or
       associated documentation files (the "Materials"), to deal in the Materials without restriction, including
       without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
       copies of the Materials, and to permit persons to whom the Materials are furnished to do so, subject to
       the condition that this copyright notice and permission notice shall be included in all copies or
       substantial portions of the Materials.

</pre><h4><b>NOTES</b></h4><pre>
        1. OpenCL Specification
           page 74, section 5.2.2 - Reading, Writing and Copying Buffer Objects

The Khronos Group                                  11/18/2024                         <u><a href="../man3clc/CLENQUEUEREADBUFFERR.3clc.html">CLENQUEUEREADBUFFERR</a></u>(3clc)
</pre>
 </div>
</div></section>
</div>
</body>
</html>