<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>io_uring_setup_reg_wait - Sets up and registers fixed wait regions</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/liburing-dev">liburing-dev_2.9-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       io_uring_setup_reg_wait - Sets up and registers fixed wait regions

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;liburing.h&gt;</b>

       <b>struct</b> <b>io_uring_reg_wait</b> <b>*io_uring_setup_reg_wait(struct</b> <b>io_uring</b> <b>*</b><u>ring</u><b>,</b>
                                                         <b>unsigned</b> <u>nentries</u><b>,</b>
                                                         <b>int</b> <b>*</b><u>err</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b><a href="../man3/io_uring_setup_reg_wait.3.html">io_uring_setup_reg_wait</a></b>(3) function allocates and registers a fixed wait region of <u>nentries</u> entries.
       Upon successful return, the function returns a non-NULL pointer. On error, it returns <b>NULL</b> and  fills  in
       <u>err</u> with the error value.

       A registered wait region is a contiguous range of <u>struct</u>io_uring_reg_wait<u>,</u> which look as follows:

       struct io_uring_reg_wait {
           struct __kernel_timespec ts;
           __u32                    min_wait_usec;
           __u32                    flags;
           __u64                    sigmask;
           __u32                    sigmask_sz;
           __u32                    pad[3];
           __u64                    pad2[2];
       };
       where  <u>ts</u>  is the wait related information for this wait, <u>min_wait_usec</u> is the minimum wait period (for a
       two-stage wait), if set to non-zero, <u>flags</u> tells the kernel about the wait region, <u>sigmask</u> is  a  pointer
       to a signal mask, if used, and <u>sigmask_sz</u> is the size of the signal mask, if used.

       Currently  the  only  valid flag is <b>IORING_REG_WAIT_TS</b> <b>,</b> which, if set, indicates that the value in <u>ts</u> is
       valid and should be used for the wait operation.

       A signal mask is used for the wait, if <u>sigmask</u> is set to a  valid,  non-zero,  pointer  value.  If  used,
       <u>sigmask_sz</u> must also be set.

       Each of the wait regions are indicated by the offset of the structure. The first wait region is index <b>0</b> <b>,</b>
       the next is index <b>1</b> <b>,</b> and so forth, up to the registered number of regions set by <u>nentries.</u>

       The    wait    regions   may   be   modified   by   an   application   at   any   time   before   calling
       <b><a href="../man3/io_uring_submit_and_reg_wait.3.html">io_uring_submit_and_reg_wait</a></b>(3)<b>.</b>  If modified while a wait region for that given offset is  currently  in
       use  by the kernel, the results are undefined - the kernel may see the new value in time to use it, or it
       may not.

       The main purpose of registered wait regions and the associated submit-and-wait helpers is to  reduce  the
       overhead   of   a   wait   operation.   A  normal  wait  for  events  with  a  timeout  will  pass  in  a
       <u>struct</u>io_uring_getevents_arg which will need to  be  copied  for  each  wait.  For  high  frequency  wait
       operations,  this  adds  noticeable overhead for each wait. With registered wait regions, no such copying
       needs to take place for each wait.

       Once a wait region has been setup, it persists for the  life  time  of  the  ring.   It's  currently  not
       possible  to  unregister  or  resize a wait region.  Additionally, a wait region may currently only use a
       single page of memory.  On a 4k page size system, this  means  an  application  is  limited  to  <b>64</b>  wait
       regions.  That  should  be enough, as each wait index may be modified as needed. With at least 64 indices
       available, hopefully applications can just use the appropriately setup wait region for each specific type
       of wait, with different indices having different wait settings.

       While a region cannot get unregistered from the kernel, once a ring has been closed, the application  may
       free  the associated memory by calling <b><a href="../man3/io_uring_free_reg_wait.3.html">io_uring_free_reg_wait</a></b>(3)<b>.</b>  An application may also do this before
       closing a ring, but then wait regions may no longer be modified by the application.

       Available since kernel 6.13.

</pre><h4><b>RETURN</b> <b>VALUE</b></h4><pre>
       On success <b><a href="../man3/io_uring_setup_reg_wait.3.html">io_uring_setup_reg_wait</a></b>(3) returns a pointer to the start of the wait regions. On failure,  it
       returns <b>NULL</b> and sets <u>err</u> to the appropriate <b>-errno</b> value.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man3/io_uring_submit_and_wait_reg.3.html">io_uring_submit_and_wait_reg</a></b>(3), <b><a href="../man3/io_uring_free_reg_wait.3.html">io_uring_free_reg_wait</a></b>(3)

liburing-2.9                                    November 2, 2024                      <u><a href="../man3/io_uring_setup_reg_wait.3.html">io_uring_setup_reg_wait</a></u>(3)
</pre>
 </div>
</div></section>
</div>
</body>
</html>