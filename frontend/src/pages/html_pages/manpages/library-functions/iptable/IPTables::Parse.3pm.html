<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IPTables::Parse - Perl extension for parsing iptables and ip6tables policies</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libiptables-parse-perl">libiptables-parse-perl_1.6-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       IPTables::Parse - Perl extension for parsing iptables and ip6tables policies

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use IPTables::Parse;

         my %opts = (
             'use_ipv6' =&gt; 0,         # can set to 1 to force ip6tables usage
             'ipt_rules_file' =&gt; '',  # optional file path from
                                      # which to read iptables rules
             'debug'    =&gt; 0,
             'verbose'  =&gt; 0
         );

         my $ipt_obj = IPTables::Parse-&gt;new(%opts)
             or die "[*] Could not acquire IPTables::Parse object";

         my $rv = 0;

         ### look for default DROP rules in the filter table INPUT chain
         my ($ipt_hr, $rv) = $ipt_obj-&gt;default_drop('filter', 'INPUT');
         if ($rv) {
             if (defined $ipt_hr-&gt;{'all'}) {
                 print "The INPUT chain has a default DROP rule for all protocols.\n";
             } else {
                 my $found = 0;
                 for my $proto (qw/tcp udp icmp/) {
                     if (defined $ipt_hr-&gt;{$proto}) {
                         print "The INPUT chain drops $proto by default.\n";
                         $found = 1;
                     }
                 }
                 unless ($found) {
                     print "The INPUT chain does not have any default DROP rule.\n";
                 }
             }
         } else {
             print "[-] Could not parse $ipt_obj-&gt;{'_ipt_bin_name'} policy\n";
         }

         ### look for default LOG rules in the filter table INPUT chain
         ($ipt_hr, $rv) = $ipt_obj-&gt;default_log('filter', 'INPUT');
         if ($rv) {
             if (defined $ipt_hr-&gt;{'all'}) {
                 print "The INPUT chain has a default LOG rule for all protocols.\n";
             } else {
                 my $found = 0;
                 for my $proto (qw/tcp udp icmp/) {
                     if (defined $ipt_hr-&gt;{$proto}) {
                         print "The INPUT chain logs $proto by default.\n";
                         $found = 1;
                     }
                 }
                 unless ($found) {
                     print "The INPUT chain does not have any default LOG rule.\n";
                 }
             }
         } else {
             print "[-] Could not parse $ipt_obj-&gt;{'_ipt_bin_name'} policy\n";
         }

         ### print all chains in the filter table
         for my $chain (@{$ipt_obj-&gt;list_table_chains('filter')}) {
             print $chain, "\n";
         }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The "IPTables::Parse" package provides an interface to parse iptables or ip6tables rules on Linux systems
       through the direct execution of iptables/ip6tables commands, or from parsing a file that contains an
       iptables/ip6tables policy listing. Note that the 'firewalld' infrastructure on Fedora21 is also supported
       through execution of the 'firewall-cmd' binary.  By default, the path to iptables is assumed to be
       '<a href="file:///usr/lib/w3m/cgi-bin/w3mman2html.cgi?iptables">/usr/sbin/iptables</a>', but if the firewall is 'firewalld', then the '/usr/bin/firewall-cmd' is used.

       With this module, you can get the current policy applied to a table/chain, look for a specific user-
       defined chain, check for a default DROP policy, or determine whether or not a default LOG rule exists.
       Also, you can get a listing of all rules in a chain with each rule parsed into its own hash.

       Note that if you initialize the IPTables::Parse object with the 'ipt_rules_file' key, then all parsing
       routines will open the specified file for iptables rules data. So, you can create this file with a
       command like 'iptables -t filter -nL -v &gt; ipt.rules', and then initialize the object with
       IPTables::Parse-&gt;new('ipt_rules_file' =&gt; 'ipt.rules'). Further, if you are running on a system without
       iptables installed, but you have an iptables policy written to the ipt.rules file, then you can pass in
       'skip_ipt_exec_check=&gt;1' in order to analyze the file without having IPTables::Parse check for the
       iptables binary.

       In summary, in addition to the hash keys mentioned above, optional keys that can be passed to <b>new()</b>
       include 'iptables' (set path to iptables binary), 'firewall_cmd' (set path to 'firewall-cmd' binary for
       systems with 'firewalld'), 'fwd_args' (set 'firewall-cmd' usage args; defaults to '--direct --passthrough
       ipv4'), 'ipv6' (set IPv6 mode for ip6tables), 'debug', 'verbose', and 'lockless_ipt_exec' (disable usage
       of the iptables '-w' argument that acquires an exclusive lock on command execution).

</pre><h4><b>FUNCTIONS</b></h4><pre>
       The IPTables::Parse extension provides an object interface to the following functions:

       chain_policy($table, $chain)
           This function returns the policy (e.g. 'DROP', 'ACCEPT', etc.) for the specified table and chain:

             print "INPUT policy: ",
                   $ipt_obj-&gt;chain_policy('filter', 'INPUT'), "\n";

       chain_rules($table, $chain)
           This  function  parses  the specified chain and table and returns an array reference for all rules in
           the chain.  Each element in the array reference is a hash  with  the  following  keys  (that  contain
           values  depending  on  the  rule): "src", "dst", "protocol", "s_port", "d_port", "target", "packets",
           "bytes", "intf_in", "intf_out", "to_ip", "to_port", "state", "raw", and "extended".   The  "extended"
           element  contains  the  rule output past the protocol information, and the "raw" element contains the
           complete rule itself as reported by iptables or ip6tables.  Here is an example  of  checking  whether
           the second rule in the INPUT chain (array index 1) allows traffic from any IP to TCP port 80:

             $rules_ar = $ipt_obj-&gt;chain_rules('filter', 'INPUT);

             if ($rules_ar-&gt;[1]-&gt;{'src'} eq '0.0.0.0/0'
                     and $rules_ar-&gt;[1]-&gt;{'protocol'} eq 'tcp'
                     and $rules_ar-&gt;[1]-&gt;{'d_port'}   eq '80'
                     and $rules_ar-&gt;[1]-&gt;{'target'}   eq 'ACCEPT') {

                 print "traffic accepted to TCP port 80 from anywhere\n";
             }

       default_drop($table, $chain)
           This  function parses the running iptables or ip6tables policy in order to determine if the specified
           chain contains a default DROP rule.  Two values are returned, a hash reference  whose  keys  are  the
           protocols  that  are  dropped  by  default (if a global ACCEPT rule has not accepted matching packets
           first), along with a return value that tells the caller if parsing the iptables or  ip6tables  policy
           was  successful.   Note that if all protocols are dropped by default, then the hash key 'all' will be
           defined.

             ($ipt_hr, $rv) = $ipt_obj-&gt;default_drop('filter', 'INPUT');

       default_log($table, $chain)
           This function parses the running iptables or ip6tables policy in order to determine if the  specified
           chain  contains  a  default  LOG  rule.  Two values are returned, a hash reference whose keys are the
           protocols that are logged by default (if a global ACCEPT  rule  has  not  accepted  matching  packets
           first),  along  with a return value that tells the caller if parsing the iptables or ip6tables policy
           was successful.  Note that if all protocols are logged by default, then the hash key  'all'  will  be
           defined.  An example invocation is:

             ($ipt_hr, $rv) = $ipt_obj-&gt;default_log('filter', 'INPUT');

       list_table_chains($table)
           This  function  parses  the specified table for all chains that are defined within the table. Data is
           returned as an array reference. For example, if there are no  user-defined  chains  in  the  'filter'
           table, then the returned array reference will contain the strings 'INPUT', 'FORWARD', and 'OUTPUT'.

             for my $chain (@{$ipt_obj-&gt;list_table_chains('filter')}) {
                 print $chain, "\n";
             }

</pre><h4><b>AUTHOR</b></h4><pre>
       Michael Rash, &lt;<a href="mailto:mbr@cipherdyne.org">mbr@cipherdyne.org</a>&gt;

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       The IPTables::Parse module is used by the IPTables::ChainMgr extension in support of the psad and fwsnort
       projects to parse iptables or ip6tables policies (see the <b><a href="../man8/psad.8.html">psad</a></b>(8), and <b><a href="../man8/fwsnort.8.html">fwsnort</a></b>(8) man pages).  As always,
       the  <b><a href="../man8/iptables.8.html">iptables</a></b>(8)  and  <b><a href="../man8/ip6tables.8.html">ip6tables</a></b>(8)  man pages provide the best information on command line execution and
       theory behind iptables and ip6tables.

       Although there is no mailing that is devoted specifically to  the  IPTables::Parse  extension,  questions
       about the extension will be answered on the following lists:

         The psad mailing list: <a href="http://lists.sourceforge.net/lists/listinfo/psad-discuss">http://lists.sourceforge.net/lists/listinfo/psad-discuss</a>
         The fwsnort mailing list: <a href="http://lists.sourceforge.net/lists/listinfo/fwsnort-discuss">http://lists.sourceforge.net/lists/listinfo/fwsnort-discuss</a>

       The latest version of the IPTables::Parse extension can be found on CPAN and also here:

         <a href="http://www.cipherdyne.org/modules/">http://www.cipherdyne.org/modules/</a>

       Source control is provided by git:

         https://github.com/mrash/IPTables-Parse.git

</pre><h4><b>CREDITS</b></h4><pre>
       Thanks to the following people:

         Franck Joncourt &lt;<a href="mailto:franck.mail@dthconnex.com">franck.mail@dthconnex.com</a>&gt;
         Stuart Schneider
         Grant Ferley
         Fabien Mazieres
         Miloslav Trmač

</pre><h4><b>AUTHOR</b></h4><pre>
       The  IPTables::Parse  extension  was written by Michael Rash <u>&lt;<a href="mailto:mbr@cipherdyne.org">mbr@cipherdyne.org</a>&gt;</u> to support the psad and
       fwsnort projects.  Please send email to this address  if  there  are  any  questions,  comments,  or  bug
       reports.

</pre><h4><b>VERSION</b></h4><pre>
       Version 1.6 (November, 2015)

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       Copyright (C) 2005-2015 Michael Rash.  All rights reserved.

       This  module  is free software.  You can redistribute it and/or modify it under the terms of the Artistic
       License 2.0.  More information can be found here: <a href="http://www.perl.com/perl/misc/Artistic.html">http://www.perl.com/perl/misc/Artistic.html</a>

       This program is distributed "as is" in the hope that it will be useful, but without any warranty; without
       even the implied warranty of merchantability or fitness for a particular purpose.

perl v5.36.0                                       2022-11-19                               <u>IPTables::<a href="../man3pm/Parse.3pm.html">Parse</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>