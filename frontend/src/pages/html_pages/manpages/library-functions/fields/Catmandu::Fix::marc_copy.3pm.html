<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Catmandu::Fix::marc_copy - copy marc data in a structured way to a new field</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcatmandu-marc-perl">libcatmandu-marc-perl_1.320-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Catmandu::Fix::marc_copy - copy marc data in a structured way to a new field

</pre><h4><b>SYNOPSIS</b></h4><pre>
           # Cut the 001 field out of the MARC record into the fixed001
           marc_copy(001, fixed001)

           # Cut all 650 fields out of the MARC record into the subjects array
           marc_copy(650, subjects)

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Copy MARC data referred by MARC_TAG in a structured way to JSON path.

       In contrast to Catmandu::Fix::marc_map and Catmandu::Fix::marc_spec marc_copy will not only copy data
       content (values) but also all data elements like tag, indicators and subfield codes into a nested data
       structure.

</pre><h4><b>METHODS</b></h4><pre>
   <b>marc_copy(MARC_PATH,</b> <b>JSON_PATH,</b> <b>[equals:</b> <b>REGEX])</b>
       Copy this MARC fields referred by a MARC_PATH to a JSON_PATH. When an "equals" value has been provided,
       then only the MARC_PATHs with a value equal to "equals" will be copied to JSON_PATH. When the MARC_PATH
       points to a subfield, then the subfield value need to match "equals". When the MARC_PATH points multiple
       subfields, then a concatinated string value needs to match "equals":

           Data:
           100 $aMy$bField.

           # copy only the 100 fields which have a $a subfield
           marc_copy(100a,tmp)

           # copy only the 100 fields with have a $a subfield matching 'My'
           marc_copy(100a,tmp,equals:"My")

           # copy only the 100 fields with have a concatinated string value 'MyField.'
           # (equals is an regex, the period "." needs to be escaped "\.")
           marc_copy(100,tmp,equals:"MyField\.")

           # copy only the 100 fields which have a "." at the end
           marc_copy(100,tmp,equals:"\.$")

       More examples:

           # Copy all the 300 fields
           marc_copy(300,tmp)

           # Copy all the 300 fields with indicator 1 = 1
           marc_copy(300[1],tmp)

           # Copy all the 300 fields which have subfield c
           marc_copy(300c,tmp)

           # Copy all the 300 fields which have subfield c equal to 'ABC'
           marc_copy(300c,tmp,equals:"^ABC")

           The JSON_PATH C&lt;tmp&gt; will contain an array with one item per field that was copied.
           Each item is a hash containing the following fields:

             tmp.*.tag        - The names of the MARC field
             tmp.*.ind1       - The value of the first indicator
             tmp.*.ind2       - The value of the second indicator
             tmp.*.subfields  - An array of subfield items. Each subfield item is a
                                hash of the subfield code and subfield value

           E.g.

               tmp:
               - tag: '300'
                 ind1: ' '
                 ind2: ' '
                 subfields:
                 - a: 'blabla:'
                 - v: 'test123'
                 - c: 'ok123'

           These JSON paths can be used like:

               # Set the first indicator of all 300 fields
               do marc_each(var:this)
                 if all_match(this.tag,300)

                   # Set the first indicator to 1
                   set_field(this.ind1,1)

                   marc_paste(this)
                 end
               end

               # Capitalize all the v subfields of 300
               do marc_each(var:this)
                   if all_match(this.tag,300)

                    do list(path:this.subfields, var:loop)
                       if (exists(loop.v))
                           upcase(loop.v)
                       end
                    end

                    marc_paste(this)
                 end
               end

</pre><h4><b>INLINE</b></h4><pre>
       This Fix can be used inline in a Perl script:

           use Catmandu::Fix::marc_copy as =&gt; 'marc_copy';

           my $data = { record =&gt; ['650', ' ', 0, 'a', 'Perl'] };

           $data = marc_copy($data,'650','subject');

           print $data-&gt;{subject}-&gt;[0]-&gt;{tag} , "\n"; # '650'
           print $data-&gt;{subject}-&gt;[0]-&gt;{ind1} , "\n"; # ' '
           print $data-&gt;{subject}-&gt;[0]-&gt;{ind2} , "\n"; # 0
           print $data-&gt;{subject}-&gt;[0]-&gt;{subfields}-&gt;[0]-&gt;{a} , "\n"; # 'Perl'

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       •   Catmandu::Fix::marc_cut

       •   Catmandu::Fix::marc_paste

</pre><h4><b>LICENSE</b> <b>AND</b> <b>COPYRIGHT</b></h4><pre>
       This  program  is  free software; you can redistribute it and/or modify it under the terms of either: the
       GNU General Public License as published by the Free Software Foundation; or the Artistic License.

       See <a href="http://dev.perl.org/licenses/">http://dev.perl.org/licenses/</a> for more information.

perl v5.38.2                                       2024-08-03                      <u>Catmandu::Fix::<a href="../man3pm/marc_copy.3pm.html">marc_copy</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>