<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML::FormHandler::Manual::Validation - validating fields</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libhtml-formhandler-perl">libhtml-formhandler-perl_0.40068-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       HTML::FormHandler::Manual::Validation - validating fields

</pre><h4><b>VERSION</b></h4><pre>
       version 0.40068

</pre><h4><b>SYNOPSIS</b></h4><pre>
       Manual Index

       There are many options for validating fields in FormHandler. Some validation is from field attributes,
       some from form or field methods, some from 'apply' actions on the fields.

</pre><h4><b>Field</b> <b>attributes</b> <b>for</b> <b>validation</b></h4><pre>
       Each individual field may have additional attributes that relate to validation, which are not documented
       here. See the individual field documentation, linked from HTML::FormHandler::Manual::Fields.

   <b>required,</b> <b>required_when</b>
       Setting the 'required' flag on a field initiates a check for the existence of some value. If the field
       does not have a value, the 'required' error message is issued.

          has_field 'section' =&gt; ( required =&gt; 1,
              messages =&gt; { required =&gt; 'Please provide a section' } );

       Note that a required flag on a subfield -- a field inside a compound field or repeatable field -- does
       not cause the containing field to be required.  You need to set 'required' all the way up, if that's the
       behavior that you want.

       If a field is empty and *not* required, no other field validation will be performed unless the
       'validate_when_empty' flag (see below) is set. The form's 'validate' method, however, will always be
       called.

       There is also the 'required_when' attribute, which works the same way as the 'when' key on the apply
       actions.

           has_field 'fee' =&gt; ( required_when =&gt; { 'fie' =&gt; 2 } );

       When a 'required' or 'required_when' check fails, a 'missing' flag is set in the result:

           if ( $field-&gt;missing ) { ... }

   <b>range_start,</b> <b>range_end</b>
       Starting and ending range for number fields.

   <b>unique</b>
       Attribute used by the DBIC model to check for uniqueness.

   <b>validate_when_empty</b>
       If its 'validate_when_empty' flag is set to a true value, then a field will always undergo validation
       when its form is processed, even when that field is empty.

</pre><h4><b>Validation</b> <b>methods</b></h4><pre>
   <b>validate_method</b>
       You can provide a validation method for a field by setting a coderef with 'validate_method'.

           has_field 'fox' =&gt; ( validate_method =&gt; \&amp;check_fox );
           sub check_fox {
               my $self = shift; # self is the fox field
               unless( $self-&gt;value eq .... ) {
                   $self-&gt;add_error('....');
               }
           }

   <b>validate_&lt;field_name&gt;</b>
       If you provide a 'validate_&lt;field_name&gt;' method it will be automatically used.

           has_field 'cat';
           sub validate_cat {
               my ( $self, $field ) = @_; # self is the form
               unless ( $field-&gt;value eq  ... ) {
                   $field-&gt;add_error( '...' );
               }
           }

       If the field name has periods in it, they should be replaced with underscores.

   <b>form</b> <b>validate</b> <b>method</b>
       A form validation method can be used to do cross-validation or validation checks that need information
       from more than one field.

           sub validate {
               my $self = shift;
               $self-&gt;field('foo')-&gt;add_error('....')
                   if( $self-&gt;field('foo')-&gt;value eq '..' &amp;&amp;
                           $self-&gt;field('bar')-&gt;value eq '..' );
           }

   <b>field</b> <b>validate</b> <b>method</b>
       You can create a custom field to contain a commonly used validation. The validation in a custom field can
       be done with 'apply' or by using a 'validate' method.

           package MyApp::Form::Field::Custom;
           use HTML::FormHandler::Moose;
           extends 'HTML::FormHandler::Field'; # or a subclass of Field

           sub validate {
               ....
           }

</pre><h4><b>Apply</b> <b>Actions:</b> <b>Filters,</b> <b>transformations,</b> <b>and</b> <b>constraints</b></h4><pre>
       The actions in the 'apply' array (stored in the 'actions' attribute) will be performed in the order they
       are specified, allowing fine-grained control over inflation and validation. You can check constraints
       after transformations and vice versa. You can weave all three types of actions in any order you need.

       The two valid 'apply' array elements are 1) Moose types and 2) hashrefs with one of three keys: 'check',
       'transform', and 'type'. The hashrefs will usually also have an additional key, 'message', with a string,
       array or coderef providing an error message, which is localized.

       The 'check' key can point to a regex, arrayref of strings, or coderef. The value of the 'transform' key
       should be a coderef. The value of the 'type' key is a Moose type.

       In addition to the check and type keys, you can provide a 'when' key to only perform this validation when
       a particular field is a particular value:

           has_field 'fee';
           has_field 'fie' =&gt; ( apply =&gt; [
               { when =&gt; { fee =&gt; 1 }, check =&gt; qr/when/, message =&gt; 'Wrong fie' },
           ]);
           has_field 'fo';
           has_field 'fum_comp' =&gt; ( type =&gt; 'Compound' );
           has_field 'fum_comp.one';
           has_field 'fum_comp.two' =&gt; ( apply =&gt; [
               { when =&gt; { '+fee' =&gt; [1,2,3] }, check =&gt; qr/when/, message =&gt; 'Wrong two' },
           ]);

       The field name key in the 'when' hashref is assumed to be a field at the same "level" as this field (i.e.
       a sibling field in a compound). If you want to specify a field name from the form, prepend the name with
       a '+'.

       The 'when' hashref can contain multiple key/value pairs. This simply extends its test across multiple
       fields; all fields named in the hashref's keys must match their respective values in order for the
       overall 'when' test to pass.

            when =&gt; { foo =&gt; 3 }        # when the foo field value is 3
            when =&gt; { foo =&gt; [1,2,3]}   # when foo is 1, 2, or 3
            when =&gt; { foo =&gt; sub { $_[0] &gt; 0 }}  # when foo is greater than 0
            when =&gt; { foo =&gt; sub { $_[0] ne ''}} # when foo is the empty string

       Transformations and coercions are called in an eval to catch the errors. Warnings are trapped in a
       sigwarn handler.

       If the conditions get too complicated to easily fit into a when condition, you can always create a
       validation method instead.

       See also HTML::FormHandler::Field and HTML::FormHandler::Validate.  See
       HTML::FormHandler::Manual::InflationDeflation for information on inflation and deflation.

   <b>Moose</b> <b>types</b>
       Moose types can be used to do both constraints and transformations. If a coercion exists it will be
       applied, resulting in a transformation. After coercing, the result is checked.  You can use type
       constraints from MooseX::Types libraries or defined using Moose::Util::TypeConstraints.

       FormHandler supplies a library of Moose types in HTML::FormHandler::Types.

           use HTML::FormHandler::Types ('NotAllDigits');
           has_field 'foo' =&gt; ( apply =&gt; [ NotAllDigits ] );

       You can create your own library of types, too. Or you can create a type constraint in the form:

         use Moose::Util::TypeConstraints;
         subtype 'GreaterThan10'
            =&gt; as 'Int'
            =&gt; where { $_ &gt; 10 }
            =&gt; message { "This number ($_) is not greater than 10" };

         has_field 'text_gt' =&gt; ( apply=&gt; [ 'GreaterThan10' ] );

       Moose types can also be used for their coercions to do transformations.

         subtype 'MyInt'
             =&gt; as 'Int';
         coerce 'MyInt'
             =&gt; from 'MyStr'
             =&gt; via { return $1 if /(\d+)/ };

       You can also use the 'type' keyword with a Moose type if you want to change the message:

           has_field 'text_gt' =&gt; ( apply =&gt; [
               { type =&gt; 'GreaterThan10',
                 message =&gt; 'Number is too small' } ] );

   <b>transform</b>
       A 'transform' changes the format of a field's value, and does not need a message. It takes a coderef.

          has_field 'another_field' =&gt; (
             apply =&gt; [ { transform =&gt; sub{ sprintf '&lt;%.1g&gt;', $_[0] } } ]
          );

       Note that transformed values are not displayed in the HTML form unless the 'fif_from_value' flag is set.
       The transformed values are saved to the database or returned in "$form-&gt;value".

   <b>'check'</b> <b>regex</b>
       Checks that field value matches the regex.

          has_field 'some_field' =&gt; (
             apply =&gt; [ { check =&gt; qr/aaa/, message =&gt; 'Must contain aaa' } ],
          );

       You can use regex libraries like Regexp::Common too:

           use Regexp::Common ('URI');
           ...
           has_field 'my_url' =&gt; ( apply =&gt; [
               { check =&gt; qr/$RE{URI}{HTTP}/,
                  message =&gt; 'Invalid URL' } ] );

   <b>'check'</b> <b>arrayref</b> <b>(matches)</b>
       Provide an arrayref of strings to match against.

          has_field 'set_error' =&gt; (
             apply =&gt; [
                { check   =&gt; [ 'abc', 'bbb' ],
                   message =&gt; 'Must be "aaa" or "bbb"' }
             ]
          );

   <b>'check'</b> <b>coderef</b>
       Provide a validation function to check. A 'check' coderef will be passed the current value of the field
       and should return true or false. Note that the field is passed in as the second argument, to allow simple
       functions to work properly.

          has_field 'callback_pass' =&gt; (
             apply =&gt; [
                { check =&gt; \&amp;check_callback_pass,
                    message =&gt; 'Must contain number greater than 10', }
              ]
          );
          sub check_callback_pass {
              my ( $value, $field ) = @_;
              if( $value =~ /(\d+)/ ) {
                  return $1 &gt; 10;
              }
          }

   <b>message</b>
       The message for the above checks can also be an arrayref or coderef.  The arrayref is useful for
       localized messages. You can also provide error messages for Moose types.

          has_field 'message_sub' =&gt; (
             apply =&gt; [
                { check   =&gt; [ 'abc' ],
                   message =&gt; \&amp;err_message }
             ]
          );
          sub err_message {
              my ($value, $field ) = @_;
              return $field-&gt;name . ': Must be "abc"';
          }
          has_field 'message_arrayref' =&gt; (
             apply =&gt; [ { check =&gt; qr/aaa/,
                 message =&gt; ['Must contain [_1]', 'aaa'] } ],
          );
          has_field 'my_moose_type_field' =&gt; (
             apply =&gt; [ { type =&gt; SomeType,
                message =&gt; 'Invalid ...' } ] );

   <b>actions</b> <b>in</b> <b>a</b> <b>field</b> <b>class</b>
       To declare actions inside a field class use HTML::FormHandler::Moose and 'apply' sugar:

          package MyApp::Field::Test;
          use HTML::FormHandler::Moose;
          extends 'HTML::FormHandler::Field;

          apply [ 'SomeConstraint', { check =&gt; ..., message =&gt; .... } ];

          1;

       Actions specified with apply are cumulative. Actions may be specified in field classes and additional
       actions added in the 'has_field' declaration.

       You can see examples of field classes with 'apply' actions in the source for
       HTML::FormHandler::Field::Money and HTML::FormHandler::Field::Email, and in t/constraints.t.

</pre><h4><b>Dependency</b></h4><pre>
       The 'dependency' attribute is an array of arrays of field names.  During validation, if any field in a
       given group has a value that matches the pattern /\S/ (non-blank), the 'required' flag is set for all of
       the fields in the group.

          has '+dependency' =&gt; ( default =&gt; sub {
                   [
                      ['address', 'city', 'state', 'zip'],
                      ['cc_no', 'cc_expires'],
                   ],
               },
           );

       You can also use the 'required_when' flag to do something similar.

</pre><h4><b>AUTHOR</b></h4><pre>
       FormHandler Contributors - see HTML::FormHandler

</pre><h4><b>COPYRIGHT</b> <b>AND</b> <b>LICENSE</b></h4><pre>
       This software is copyright (c) 2017 by Gerda Shank.

       This is free software; you can redistribute it and/or modify it under the same terms as the Perl 5
       programming language system itself.

perl v5.34.0                                       2022-03-25              <u>HTML::FormHand...ual::<a href="../man3pm/Validation.3pm.html">Validation</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>