<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MARC::Field - Perl extension for handling MARC fields</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libmarc-record-perl">libmarc-record-perl_2.0.7-3_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       MARC::Field - Perl extension for handling MARC fields

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use MARC::Field;

         # If your system uses wacky control field tags, add them
         MARC::Field-&gt;allow_controlfield_tags('FMT', 'LLE');

         my $field = MARC::Field-&gt;new( 245, '1', '0',
              'a' =&gt; 'Raccoons and ripe corn / ',
              'c' =&gt; 'Jim Arnosky.'
         );
         $field-&gt;add_subfields( "a", "1st ed." );

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Defines MARC fields for use in the MARC::Record module.  I suppose you could use them on their own, but
       that wouldn't be very interesting.

</pre><h4><b>EXPORT</b></h4><pre>
       None by default.  Any errors are stored in $MARC::Field::ERROR, which $MARC::Record usually bubbles up to
       $MARC::Record::ERROR.

</pre><h4><b>CLASS</b> <b>VARIABLES</b></h4><pre>
       <b>extra_controlfield_tags</b>: Some systems (notably Ex Libris's Aleph) throw extra control fields in their
       MARC (e.g., Aleph's MARC-XML tends to have a "FMT" control field). We keep a class-level hash to track to
       track them; it can be manipulated with "allow_controlfield_tags" and c&lt;disallow_controlfield_tags&gt;.

</pre><h4><b>METHODS</b></h4><pre>
   <b>new()</b>
       The constructor, which will return a MARC::Field object. Typically you will pass in the tag number,
       indicator 1, indicator 2, and then a list of any subfield/data pairs. For example:

         my $field = MARC::Field-&gt;new(
              245, '1', '0',
              'a' =&gt; 'Raccoons and ripe corn / ',
              'c' =&gt; 'Jim Arnosky.'
         );

       Or if you want to add a control field (&lt; 010) that does not have indicators.

         my $field = MARC::Field-&gt;new( '001', ' 14919759' );

   <b>tag()</b>
       Returns the three digit tag for the field.

   <b>set_tag(tag)</b>
       Changes the tag number of this field. Updates the control status accordingly.  Will "croak" if an invalid
       value is passed in.

   <b>indicator(indno)</b>
       Returns the specified indicator.  Returns "undef" and logs a warning if field is a control field and thus
       doesn't have indicators.  If the field is not a control field, croaks if the <u>indno</u> is not 1 or 2.

   <b>set_indicator($indno,</b> <b>$indval)</b>
       Set the indicator position <u>$indno</u> to the value specified by <u>$indval</u>.  Croaks if the indicator position,
       is invalid, the field is a control field and thus doesn't have indicators, or if the new indicator value
       is invalid.

   <b>allow_controlfield_tags($tag,</b> <b>$tag2,</b> <b>...)</b>
       Add $tags to class-level list of strings to consider valid control fields tags (in addition to 001
       through 009).  Tags must have three characters.

   <b>disallow_controlfield_tags($tag,</b> <b>$tag2,</b> <b>...)</b> <b>=head2</b> <b>disallow_controlfield_tags('*')</b>
       Revoke the validity of a control field tag previously added with allow_controlfield_tags. As a special
       case, if you pass the string '*' it will clear out all previously-added tags.

       NOTE that this will only deal with stuff added with allow_controlfield_tags; you can't disallow '001'.

   <b>is_valid_tag($tag)</b> <b>--</b> <b>is</b> <b>the</b> <b>given</b> <b>tag</b> <b>valid?</b>
       Generally called as a class method (e.g., MARC::Field-&gt;is_valid_tag('001'))

   <b>is_valid_indicator($indval)</b> <b>--</b> <b>is</b> <b>the</b> <b>given</b> <b>indicator</b> <b>value</b> <b>valid?</b>
       Generally called as a class method (e.g., MARC::Field-&gt;is_valid_indicator('4'))

   <b>is_controlfield_tag($tag)</b> <b>--</b> <b>does</b> <b>the</b> <b>given</b> <b>tag</b> <b>denote</b> <b>a</b> <b>control</b> <b>field?</b>
       Generally called as a class method (e.g., MARC::Field-&gt;is_controlfield_tag('001'))

   <b>is_control_field()</b>
       Tells whether this field is one of the control tags from 001-009.

   <b>subfield(code)</b>
       When called in a scalar context returns the text from the first subfield matching the subfield code.

           my $subfield = $field-&gt;subfield( 'a' );

       Or if you think there might be more than one you can get all of them by calling in a list context:

           my @subfields = $field-&gt;subfield( 'a' );

       If no matching subfields are found, "undef" is returned in a scalar context and an empty list in a list
       context.

       If the tag is a control field, "undef" is returned and $MARC::Field::ERROR is set.

   <b>subfields()</b>
       Returns all the subfields in the field.  What's returned is a list of list refs, where the inner list is
       a subfield code and the subfield data.

       For example, this might be the subfields from a 245 field:

               (
                 [ 'a', 'Perl in a nutshell :' ],
                 [ 'b', 'A desktop quick reference.' ],
               )

   <b>data()</b>
       Returns the data part of the field, if the tag number is less than 10.

   <b>add_subfields(code,text[,code,text</b> <b>...])</b>
       Adds subfields to the end of the subfield list.

           $field-&gt;add_subfields( 'c' =&gt; '1985' );

       Returns the number of subfields added, or "undef" if there was an error.

   <b>delete_subfield()</b>
       <b>delete_subfield()</b> allows you to remove subfields from a field:

           # delete any subfield a in the field
           $field-&gt;delete_subfield(code =&gt; 'a');

           # delete any subfield a or u in the field
           $field-&gt;delete_subfield(code =&gt; ['a', 'u']);

           # delete any subfield code matching a compiled regular expression
           $field-&gt;delete_subfield(code =&gt; qr/[^a-z0-9]/);

       If you want to only delete subfields at a particular position you can use the pos parameter:

           # delete subfield u at the first position
           $field-&gt;delete_subfield(code =&gt; 'u', pos =&gt; 0);

           # delete subfield u at first or second position
           $field-&gt;delete_subfield(code =&gt; 'u', pos =&gt; [0,1]);

           # delete the second subfield, no matter what it is
           $field-&gt;delete_subfield(pos =&gt; 1);

       You can specify a regex to for only deleting subfields that match:

          # delete any subfield u that matches zombo.com
          $field-&gt;delete_subfield(code =&gt; 'u', match =&gt; qr/zombo.com/);

          # delete any subfield that matches quux
          $field-&gt;delete_subfield(match =&gt; qr/quux/);

       You can also pass a single subfield label:

         # delete all subfield u
         $field-&gt;delete_subfield('u');

   <b>delete_subfields()</b>
       Delete all subfields with a given subfield code. This is here for backwards compatibility, you should use
       the more flexible <b>delete_subfield()</b>.

   <b>update()</b>
       Allows you to change the values of the field. You can update indicators and subfields like this:

         $field-&gt;update( ind2 =&gt; '4', a =&gt; 'The ballad of Abe Lincoln');

       If you attempt to update a subfield which does not currently exist in the field, then a new subfield will
       be appended to the field. If you don't like this auto-vivification you must check for the existence of
       the subfield prior to update.

         if ( $field-&gt;subfield( 'a' ) ) {
           $field-&gt;update( 'a' =&gt; 'Cryptonomicon' );
         }

       If you want to update a field that has no indicators or subfields (000-009) just call <b>update()</b> with one
       argument, the string that you would like to set the field to.

         $field = $record-&gt;field( '003' );
         $field-&gt;update('IMchF');

       Note: when doing subfield updates be aware that "update()" will only update the first occurrence. If you
       need to do anything more complicated you will probably need to create a new field and use
       "replace_with()".

       Returns the number of items modified.

   <b>replace_with()</b>
       Allows you to replace an existing field with a new one. You need to pass "replace()" a MARC::Field object
       to replace the existing field with. For example:

         $field = $record-&gt;field('245');
         my $new_field = new MARC::Field('245','0','4','The ballad of Abe Lincoln.');
         $field-&gt;replace_with($new_field);

       Doesn't return a meaningful or reliable value.

   <b>as_string(</b> <b>[$subfields]</b> <b>[,</b> <b>$delimiter]</b> <b>)</b>
       Returns a string of all subfields run together. A space is added to the result between each subfield,
       unless the delimiter parameter is passed.  The tag number and subfield character are not included.

       Subfields appear in the output string in the order in which they occur in the field.

       If $subfields is specified, then only those subfields will be included.

         my $field = MARC::Field-&gt;new(
                       245, '1', '0',
                               'a' =&gt; 'Abraham Lincoln',
                               'h' =&gt; '[videorecording] :',
                               'b' =&gt; 'preserving the union /',
                               'c' =&gt; 'A&amp;E Home Video.'
                       );
         print $field-&gt;as_string( 'abh' ); # Only those three subfields
         # prints 'Abraham Lincoln [videorecording] : preserving the union /'.
         print $field-&gt;as_string( 'ab', '--' ); # Only those two subfields, with a delimiter
         # prints 'Abraham Lincoln--preserving the union /'.

       Note that subfield h comes before subfield b in the output.

   <b>as_formatted()</b>
       Returns a pretty string for printing in a MARC dump.

   <b>as_usmarc()</b>
       Returns a string for putting into a USMARC file.  It's really only useful for
       "MARC::Record::as_usmarc()".

   <b>clone()</b>
       Makes a copy of the field.  Note that this is not just the same as saying

           my $newfield = $field;

       since that just makes a copy of the reference.  To get a new object, you must

           my $newfield = $field-&gt;clone;

       Returns a MARC::Field record.

   <b>warnings()</b>
       Returns the warnings that were created when the record was read.  These are things like "Invalid
       indicators converted to blanks".

       The warnings are items that you might be interested in, or might not.  It depends on how stringently
       you're checking data.  If you're doing some grunt data analysis, you probably don't care.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       See the "SEE ALSO" section for MARC::Record.

</pre><h4><b>TODO</b></h4><pre>
       See the "TODO" section for MARC::Record.

</pre><h4><b>LICENSE</b></h4><pre>
       This code may be distributed under the same terms as Perl itself.

       Please note that these modules are not products of or supported by the employers of the various
       contributors to the code.

</pre><h4><b>AUTHOR</b></h4><pre>
       Andy Lester, "&lt;<a href="mailto:andy@petdance.com">andy@petdance.com</a>&gt;"

perl v5.36.0                                       2022-10-13                                   <u>MARC::<a href="../man3pm/Field.3pm.html">Field</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>