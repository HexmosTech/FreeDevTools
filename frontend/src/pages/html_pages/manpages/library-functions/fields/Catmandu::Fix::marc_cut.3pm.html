<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Catmandu::Fix::marc_cut - cut marc data in a structured way to a new field</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcatmandu-marc-perl">libcatmandu-marc-perl_1.320-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Catmandu::Fix::marc_cut - cut marc data in a structured way to a new field

</pre><h4><b>SYNOPSIS</b></h4><pre>
           # Cut the 001 field out of the MARC record into the fixed001
           marc_cut(001, fixed001)

           # Cut all 650 fields out of the MARC record into the subjects array
           marc_cut(650, subjects)

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This Fix work like Catmandu::Fix::marc_copy except it will also remove all mathincg fields from the MARC
       record

</pre><h4><b>METHODS</b></h4><pre>
   <b>marc_cut(MARC_PATH,</b> <b>JSON_PATH,</b> <b>[equals:</b> <b>REGEX])</b>
       Cut this MARC fields referred by a MARC_PATH to a JSON_PATH. hen an "equals" value has been provided,
       then only the MARC_PATHs with a value equal to "equals" will be cut to JSON_PATH. When the MARC_PATH
       points to a subfield, then the subfield value need to match "equals". When the MARC_PATH points multiple
       subfields, then a concatinated string value needs to match "equals":

           Data:
           100 $aMy$bField.

           # cut only the 100 fields which have a $a subfield
           marc_cut(100a,tmp)

           # cut only the 100 fields with have a $a subfield matching 'My'
           marc_cut(100a,tmp,equals:"My")

           # cut only the 100 fields with have a concatinated string value 'MyField.'
           # (equals is an regex, the period "." needs to be escaped "\.")
           marc_cut(100,tmp,equals:"MyField\.")

           # cut only the 100 fields which have a "." at the end
           marc_cut(100,tmp,equals:"\.$")

       More examples:

           # Cut all the 300 fields
           marc_cut(300,tmp)

           # Cut all the 300 fields with indicator 1 = 1
           marc_cut(300[1],tmp)

           # Cut all the 300 fields which have subfield c
           marc_cut(300c,tmp)

           # Cut all the 300 fields which have subfield c equal to 'ABC'
           marc_cut(300c,tmp,equals:"^ABC")

       The JSON_PATH "tmp" will contain an array with one item per field that was cut.  Each item is a hash
       containing the following fields:

         tmp.*.tag        - The names of the MARC field
         tmp.*.ind1       - The value of the first indicator
         tmp.*.ind2       - The value of the second indicator
         tmp.*.subfields  - An array of subfield items. Each subfield item is a
                            hash of the subfield code and subfield value

       E.g.

           tmp:
           - tag: '300'
             ind1: ' '
             ind2: ' '
             subfields:
             - a: 'blabla:'
             - v: 'test123'
             - c: 'ok123'

       These JSON paths can be used like:

           # Set the first indicator of all 300 fields
           do marc_each(var:this)
             if all_match(this.tag,300)

               # Set the first indicator to 1
               set_field(this.ind1,1)

               marc_paste(this)
             end
           end

           # Capitalize all the v subfields of 300
           do marc_each(var:this)
             if all_match(this.tag,300)

                do list(path:this.subfields, var:loop)
                   if (exists(loop.v))
                       upcase(loop.v)
                   end
                end

                marc_paste(this)
             end
           end

</pre><h4><b>INLINE</b></h4><pre>
       This Fix can be used inline in a Perl script:

           use Catmandu::Fix::marc_copy as =&gt; 'marc_cut';

           my $data = { record =&gt; ['650', ' ', 0, 'a', 'Perl'] };

           $data = marc_cut($data,'650','subject');

           print $data-&gt;{subject}-&gt;[0]-&gt;{tag} , "\n"; # '650'
           print $data-&gt;{subject}-&gt;[0]-&gt;{ind1} , "\n"; # ' '
           print $data-&gt;{subject}-&gt;[0]-&gt;{ind2} , "\n"; # 0
           print $data-&gt;{subject}-&gt;[0]-&gt;{subfields}-&gt;[0]-&gt;{a} , "\n"; # 'Perl'

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       •   Catmandu::Fix::marc_copy

       •   Catmandu::Fix::marc_paste

</pre><h4><b>LICENSE</b> <b>AND</b> <b>COPYRIGHT</b></h4><pre>
       This  program  is  free software; you can redistribute it and/or modify it under the terms of either: the
       GNU General Public License as published by the Free Software Foundation; or the Artistic License.

       See <a href="http://dev.perl.org/licenses/">http://dev.perl.org/licenses/</a> for more information.

perl v5.38.2                                       2024-08-03                       <u>Catmandu::Fix::<a href="../man3pm/marc_cut.3pm.html">marc_cut</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>