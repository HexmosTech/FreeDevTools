<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CGI::FormBuilder::Field - Base class for FormBuilder fields</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libcgi-formbuilder-perl">libcgi-formbuilder-perl_3.10-6_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       CGI::FormBuilder::Field - Base class for FormBuilder fields

</pre><h4><b>SYNOPSIS</b></h4><pre>
           use CGI::FormBuilder::Field;

           # delegated straight from FormBuilder
           my $f = CGI::FormBuilder::Field-&gt;new($form, name =&gt; 'whatever');

           # attribute functions
           my $n = $f-&gt;name;         # name of field
           my $n = "$f";             # stringify to $f-&gt;name

           my $t = $f-&gt;type;         # auto-type
           my @v = $f-&gt;value;        # auto-stickiness
           my @o = $f-&gt;options;      # options, aligned and sorted

           my $l = $f-&gt;label;        # auto-label
           my $h = $f-&gt;tag;          # field XHTML tag (name/type/value)
           my $s = $f-&gt;script;       # per-field JS validation script

           my $m = $f-&gt;message;      # error message if invalid
           my $m = $f-&gt;jsmessage;    # JavaScript error message

           my $r = $f-&gt;required;     # required?
           my $k = $f-&gt;validate;     # run validation check

           my $v = $f-&gt;tag_value;    # value in tag (stickiness handling)
           my $v = $f-&gt;cgi_value;    # CGI value if any
           my $v = $f-&gt;def_value;    # manually-specified value

           $f-&gt;field(opt =&gt; 'val');  # FormBuilder field() call

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module is internally used by <b>FormBuilder</b> to create and maintain field information. Usually, you will
       not want to directly access this set of data structures. However, one big exception is if you are going
       to micro-control form rendering. In this case, you will need to access the field objects directly.

       To do so, you will want to loop through the fields in order:

           for my $field ($form-&gt;field) {

               # $field holds an object stringified to a field name
               if ($field =~ /_date$/) {
                   $field-&gt;<a href="../man0/sticky.0.html">sticky</a>(0);  # clear CGI value
                   print "Enter $field here:", $field-&gt;tag;
               } else {
                   print $field-&gt;label, ': ', $field-&gt;tag;
               }
           }

       As illustrated, each $field variable actually holds a stringifiable object. This means if you print them
       out, you will get the field name, allowing you to check for certain fields. However, since it is an
       object, you can then run accessor methods directly on that object.

       The most useful method is "tag()". It generates the HTML input tag for the field, including all option
       and type handling, and returns a string which you can then print out or manipulate appropriately.

       Second to this method is the "script" method, which returns the appropriate JavaScript validation routine
       for that field. This is useful at the top of your form rendering, when you are printing out the leading
       "&lt;head&gt;" section of your HTML document. It is called by the $form method of the same name.

       The following methods are provided for each $field object.

</pre><h4><b>METHODS</b></h4><pre>
   <b>new($form,</b> <b>%args)</b>
       This creates a new $field object. The first argument must be a reference to the top-level $form object,
       for callbacks. The remaining arguments should be hash, of which one "key/value" pair must specify the
       "name" of the field. Normally you should not touch this method. Ever.

   <b>field(%args)</b>
       This is a delegated field call. This is how <b>FormBuilder</b> tweaks its fields.  Once you have a $field
       object, you call this method the exact same way that you would call the main "field()" method, minus the
       field name. Again you should use the top-level call instead.

   <b>inflate($subref)</b>
       This sets the inflate attribute: subroutine reference used to inflate values returned by <b>value()</b> into
       objects or whatever you want.  If no parameter, returns the inflate subroutine reference that is set.
       For example:

        use DateTime::Format::Strptime;
        my $date_format = DateTime::Format::Strptime-&gt;new(
           pattern   =&gt; '%D',    # for MM/DD/YYYY american dates
           locale    =&gt; 'en_US',
           time_zone =&gt; 'America/Los_Angeles',
        );
        $field-&gt;inflate( sub { return $date_format-&gt;format_datetime(shift) } );

   <b>invalid</b>
       This returns the opposite value that "validate()" would return, with some extra magic that keeps state
       for form rendering purposes.

   <b>jsfunc()</b>
       Returns the appropriate JavaScript validation code (see above).

   <b>label($str)</b>
       This sets and returns the field's label. If unset, it will be generated from the name of the field.

   <b>tag($type)</b>
       Returns an XHTML form input tag (see above). By default it renders the tag based on the type set from the
       top-level field method:

           $form-&gt;field(name =&gt; 'poetry', type =&gt; 'textarea');

       However, if you are doing custom rendering you can override this temporarily by passing in the type
       explicitly. This is usually not useful unless you have a custom rendering module that forcibly overrides
       types for certain fields.

   <b>type($type)</b>
       This sets and returns the field's type. If unset, it will automatically generate the appropriate field
       type, depending on the number of options and whether multiple values are allowed:

           Field options?
               No = text (done)
               Yes:
                   Less than 'selectnum' setting?
                       No = select (done)
                       Yes:
                           Is the 'multiple' option set?
                           Yes = checkbox (done)
                           No:
                               Have just one single option?
                                   Yes = checkbox (done)
                                   No = radio (done)

       For an example, view the inside guts of this module.

   <b>validate($pattern)</b>
       This returns 1 if the field passes the validation pattern(s) and "required" status previously set via
       <b>required()</b> and (possibly) the top-level <b>new()</b> call in FormBuilder. Usually running per-field <b>validate()</b>
       calls is not what you want. Instead, you want to run the one on $form, which in turn calls each
       individual field's and saves some temp state.

   <b>value($val)</b>
       This sets the field's value. It also returns the appropriate value: CGI if set, otherwise the manual
       default value. Same as using "field()" to retrieve values.

   <b>tag_value()</b>
       This obeys the "sticky" flag to give a different interpretation of CGI values. <b>Use</b> <b>this</b> <b>to</b> <b>get</b> <b>the</b> <b>value</b>
       <b>if</b> <b>generating</b> <b>your</b> <b>own</b> <b>tag.</b> Otherwise, ignore it completely.

   <b>cgi_value()</b>
       This always returns the CGI value, regardless of "sticky".

   <b>def_value()</b>
       This always returns the default value, regardless of "sticky".

   <b>tag_name()</b>
       This returns the tag name of the current item. This was added so you could subclass, say,
       "CGI::FormBuilder::Field::select" and change the HTML tag to "&lt;b:select&gt;" instead. This is an
       experimental feature and subject to change wildly (suggestions welcome).

   <b>accessors</b>
       In addition to the above methods, accessors are provided for directly manipulating values as if from a
       "field()" call:

           Accessor                Same as...
           ----------------------- -----------------------------------
           $f-&gt;force(0|1)          $form-&gt;field(force =&gt; 0|1)
           $f-&gt;options(\@opt)      $form-&gt;field(options =&gt; \@opt)
           $f-&gt;multiple(0|1)       $form-&gt;field(multiple =&gt; 0|1)
           $f-&gt;message($mesg)      $form-&gt;field(message =&gt; $mesg)
           $f-&gt;jsmessage($mesg)    $form-&gt;field(jsmessage =&gt; $mesg)
           $f-&gt;jsclick($code)      $form-&gt;field(jsclick =&gt; $code)
           $f-&gt;sticky(0|1)         $form-&gt;field(sticky =&gt; 0|1);
           $f-&gt;force(0|1)          $form-&gt;field(force =&gt; 0|1);
           $f-&gt;growable(0|1)       $form-&gt;field(growable =&gt; 0|1);
           $f-&gt;other(0|1)          $form-&gt;field(other =&gt; 0|1);

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       CGI::FormBuilder

</pre><h4><b>REVISION</b></h4><pre>
       $Id: Field.pm 100 2007-03-02 18:13:13Z nwiger $

</pre><h4><b>AUTHOR</b></h4><pre>
       Copyright (c) Nate Wiger &lt;<a href="http://nateware.com">http://nateware.com</a>&gt;. All Rights Reserved.

       This module is free software; you may copy this under the terms of the GNU General Public License, or the
       Artistic License, copies of which should have accompanied your Perl kit.

perl v5.36.0                                       2022-10-15                       <u>CGI::FormBuilder::<a href="../man3pm/Field.3pm.html">Field</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>