<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Text::RecordParser - read record-oriented files</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/libtext-recordparser-perl">libtext-recordparser-perl_1.6.5-4_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       Text::RecordParser - read record-oriented files

</pre><h4><b>SYNOPSIS</b></h4><pre>
         use Text::RecordParser;

         # use default record (\n) and field (,) separators
         my $p = Text::RecordParser-&gt;new( $file );

         # or be explicit
         my $p = Text::RecordParser-&gt;new({
             filename        =&gt; $file,
             field_separator =&gt; "\t",
         });

         $p-&gt;filename('foo.csv');

         # Split records on two newlines
         $p-&gt;record_separator("\n\n");

         # Split fields on tabs
         $p-&gt;field_separator("\t");

         # Skip lines beginning with hashes
         $p-&gt;comment( qr/^#/ );

         # Trim whitespace
         $p-&gt;<a href="../man1/trim.1.html">trim</a>(1);

         # Use the fields in the first line as column names
         $p-&gt;bind_header;

         # Get a list of the header fields (in order)
         my @columns = $p-&gt;field_list;

         # Extract a particular field from the next row
         my ( $name, $age ) = $p-&gt;extract( qw[name age] );

         # Return all the fields from the next row
         my @fields = $p-&gt;fetchrow_array;

         # Define a field alias
         $p-&gt;set_field_alias( name =&gt; 'handle' );

         # Return all the fields from the next row as a hashref
         my $record = $p-&gt;fetchrow_hashref;
         print $record-&gt;{'name'};
         # or
         print $record-&gt;{'handle'};

         # Return the record as an object with fields as accessors
         my $object = $p-&gt;fetchrow_object;
         print $object-&gt;name; # or $object-&gt;handle;

         # Get all data as arrayref of arrayrefs
         my $data = $p-&gt;fetchall_arrayref;

         # Get all data as arrayref of hashrefs
         my $data = $p-&gt;fetchall_arrayref( { Columns =&gt; {} } );

         # Get all data as hashref of hashrefs
         my $data = $p-&gt;fetchall_hashref('name');

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This module is for reading record-oriented data in a delimited text file.  The most common example have
       records separated by newlines and fields separated by commas or tabs, but this module aims to provide a
       consistent interface for handling sequential records in a file however they may be delimited.  Typically
       this data lists the fields in the first line of the file, in which case you should call "bind_header" to
       bind the field name (or not, and it will be called implicitly).  If the first line contains data, you can
       still bind your own field names via "bind_fields".  Either way, you can then use many methods to get at
       the data as arrays or hashes.

</pre><h4><b>METHODS</b></h4><pre>
   <b>new</b>
       This is the object constructor.  It takes a hash (or hashref) of arguments.  Each argument can also be
       set through the method of the same name.

       •   filename

           The  path  to  the file being read.  If the filename is passed and the fh is not, then it will open a
           filehandle on that file and sets "fh" accordingly.

       •   comment

           A compiled regular expression identifying comment lines that should be skipped.

       •   data

           The data to read.

       •   fh

           The filehandle of the file to read.

       •   field_separator | fs

           The field separator (default is comma).

       •   record_separator | rs

           The record separator (default is newline).

       •   field_filter

           A callback applied to all the fields as they are read.

       •   header_filter

           A callback applied to the column names.

       •   trim

           Boolean to enable trimming of leading and trailing whitespace from fields  (useful  if  splitting  on
           whitespace only).

       See methods for each argument name for more information.

       Alternately, if you supply a single argument to "new", it will be treated as the "filename" argument.

   <b>bind_fields</b>
         $p-&gt;bind_fields( qw[ name rank serial_number ] );

       Takes  an array of field names and memorizes the field positions for later use.  If the input file has no
       header line but you still wish to retrieve the fields by name (or even if you want to call  "bind_header"
       and then give your own field names), simply pass in the an array of field names you wish to use.

       Pass in an empty array reference to unset:

         $p-&gt;bind_field( [] ); # unsets fields

   <b>bind_header</b>
         $p-&gt;bind_header;
         my $name = $p-&gt;extract('name');

       Takes  the  fields from the next row under the cursor and assigns the field names to the values.  Usually
       you would call this immediately after opening the file in order to bind the field names in the first row.

   <b>comment</b>
         $p-&gt;comment( qr/^#/ );  # Perl-style comments
         $p-&gt;comment( qr/^--/ ); # SQL-style comments

       Takes a regex to apply to a record to see if it looks like a comment to skip.

   <b>data</b>
         $p-&gt;data( $string );
         $p-&gt;data( \$string );
         $p-&gt;data( @lines );
         $p-&gt;data( [$line1, $line2, $line3] );
         $p-&gt;data( IO::File-&gt;new('&lt;data') );

       Allows a scalar, scalar reference, glob, array, or array reference as the thing to read instead of a file
       handle.

       It's not advised to pass a filehandle to "data" as it will read the entire contents of  the  file  rather
       than one line at a time if you set it via "fh".

   <b>extract</b>
         my ( $foo, $bar, $baz ) = $p-&gt;extract( qw[ foo bar baz ] );

       Extracts  a  list of fields out of the last row read.  The field names must correspond to the field names
       bound either via "bind_fields" or "bind_header".

   <b>fetchrow_array</b>
         my @values = $p-&gt;fetchrow_array;

       Reads a row from the file and returns an array or array reference of the fields.

   <b>fetchrow_hashref</b>
         my $record = $p-&gt;fetchrow_hashref;
         print "Name = ", $record-&gt;{'name'}, "\n";

       Reads a line of the file and returns it as a hash reference.  The keys of the hashref are the field names
       bound via "bind_fields" or "bind_header".  If you do not bind fields prior to calling  this  method,  the
       "bind_header" method will be implicitly called for you.

   <b>fetchrow_object</b>
         while ( my $object = $p-&gt;fetchrow_object ) {
             my $id   = $object-&gt;id;
             my $name = $object-&gt;naem; # &lt;-- this will throw a runtime error
         }

       This  will return the next data record as a Text::RecordParser::Object object that has read-only accessor
       methods of the field names and any aliases.  This allows you to  enforce  field  names,  further  helping
       ensure  that  your  code  is  reading  the  input  file  correctly.   That  is,  if  you  are  using  the
       "fetchrow_hashref" method to read each line, you may misspell the hash key and introduce a  bug  in  your
       code.   With  this  method,  Perl  will  throw an error if you attempt to read a field not defined in the
       file's headers.  Additionally, any defined field aliases will be created as additional accessor methods.

   <b>fetchall_arrayref</b>
         my $records = $p-&gt;fetchall_arrayref;
         for my $record ( @$records ) {
             print "Name = ", $record-&gt;[0], "\n";
         }

         my $records = $p-&gt;fetchall_arrayref( { Columns =&gt; {} } );
         for my $record ( @$records ) {
             print "Name = ", $record-&gt;{'name'}, "\n";
         }

       Like DBI's fetchall_arrayref, returns an arrayref of arrayrefs.  Also accepts optional "{ Columns  =&gt;  {}
       }" argument to return an arrayref of hashrefs.

   <b>fetchall_hashref</b>
         my $records = $p-&gt;fetchall_hashref('id');
         for my $id ( keys %$records ) {
             my $record = $records-&gt;{ $id };
             print "Name = ", $record-&gt;{'name'}, "\n";
         }

       Like DBI's fetchall_hashref, this returns a hash reference of hash references.  The keys of the top-level
       hashref  are the field values of the field argument you supply.  The field name you supply can be a field
       created by a "field_compute".

   <b>fh</b>
         open my $fh, '&lt;', $file or die $!;
         $p-&gt;fh( $fh );

       Gets or sets the filehandle of the file being read.

   <b>field_compute</b>
       A callback applied to the fields identified by position (or field name if "bind_fields" or  "bind_header"
       was called).

       The callback will be passed two arguments:

       1.  The current field

       2.  A  reference  to  all the other fields, either as an array or hash reference, depending on the method
           which you called.

       If data looks like this:

         parent    children
         Mike      Greg,Peter,Bobby
         Carol     Marcia,Jane,Cindy

       You could split the "children" field into an array reference with the values like so:

         $p-&gt;field_compute( 'children', sub { [ split /,/, shift() ] } );

       The field position or name doesn't actually have to exist, which means you  could  create  new,  computed
       fields on-the-fly.  E.g., if you data looks like this:

           1,3,5
           32,4,1
           9,5,4

       You could write a field_compute like this:

           $p-&gt;field_compute( 3,
               sub {
                   my ( $cur, $others ) = @_;
                   my $sum;
                   $sum += $_ for @$others;
                   return $sum;
               }
           );

       Field "3" will be created as the sum of the other fields.  This allows you to further write:

           my $data = $p-&gt;fetchall_arrayref;
           for my $rec ( @$data ) {
               print "$rec-&gt;[0] + $rec-&gt;[1] + $rec-&gt;[2] = $rec-&gt;[3]\n";
           }

       Prints:

           1 + 3 + 5 = 9
           32 + 4 + 1 = 37
           9 + 5 + 4 = 18

   <b>field_filter</b>
         $p-&gt;field_filter( sub { $_ = shift; uc(lc($_)) } );

       A  callback  which is applied to each field.  The callback will be passed the current value of the field.
       Whatever is passed back will become the new value of the field.   The  above  example  capitalizes  field
       values.  To unset the filter, pass in the empty string.

   <b>field_list</b>
         $p-&gt;bind_fields( qw[ foo bar baz ] );
         my @fields = $p-&gt;field_list;
         print join ', ', @fields; # prints "foo, bar, baz"

       Returns the fields bound via "bind_fields" (or "bind_header").

   <b>field_positions</b>
         my %positions = $p-&gt;field_positions;

       Returns  a hash of the fields and their positions bound via "bind_fields" (or "bind_header").  Mostly for
       internal use.

   <b>field_separator</b>
         $p-&gt;field_separator("\t");     # splits fields on tabs
         $p-&gt;field_separator('::');     # splits fields on double colons
         $p-&gt;field_separator(qr/\s+/);  # splits fields on whitespace
         my $sep = $p-&gt;field_separator; # returns the current separator

       Gets and sets the token to use as the field delimiter.  Regular expressions can be specified using  qr/<a href="file:/.">/.</a>
       If  not  specified,  it will take a guess based on the filename extension ("comma" for ".txt," ".dat," or
       ".csv"; "tab" for ".tab").  The default is a comma.

   <b>filename</b>
         $p-&gt;filename('/path/to/file.dat');

       Gets or sets the complete path to the file to be read.  If a file is already opened, then the  handle  on
       it will be closed and a new one opened on the new file.

   <b>get_field_aliases</b>
         my @aliases = $p-&gt;get_field_aliases('name');

       Allows  you  to  define  alternate names for fields, e.g., sometimes your input file calls city "town" or
       "township," sometimes a file uses "Moniker" instead of "name."

   <b>header_filter</b>
         $p-&gt;header_filter( sub { $_ = shift; s/\s+/_/g; lc $_ } );

       A callback applied to column header names.  The callback will be passed the current value of the  header.
       Whatever  is returned will become the new value of the header.  The above example collapses spaces into a
       single underscore and lowercases the letters.  To unset a filter, pass in the empty string.

   <b>record_separator</b>
         $p-&gt;record_separator("\n//\n");
         $p-&gt;field_separator("\n");

       Gets and sets the token to use as the record separator.  The default is a newline ("\n").

       The above example would read a file that looks like this:

         field1
         field2
         field3
         //
         data1
         data2
         data3
         //

   <b>set_field_alias</b>
         $p-&gt;set_field_alias({
             name =&gt; 'Moniker,handle',        # comma-separated string
             city =&gt; [ qw( town township ) ], # or anonymous arrayref
         });

       Allows you to define alternate names for fields, e.g., sometimes your input file  calls  city  "town"  or
       "township," sometimes a file uses "Moniker" instead of "name."

   <b>trim</b>
         my $trim_value = $p-&gt;<a href="../man1/trim.1.html">trim</a>(1);

       Provide "true" argument to remove leading and trailing whitespace from fields.  Use a "false" argument to
       disable.

</pre><h4><b>AUTHOR</b></h4><pre>
       Ken Youens-Clark &lt;<a href="mailto:kclark@cpan.org">kclark@cpan.org</a>&gt;

</pre><h4><b>SOURCE</b></h4><pre>
       <a href="http://github.com/kyclark/text-recordparser">http://github.com/kyclark/text-recordparser</a>

</pre><h4><b>CREDITS</b></h4><pre>
       Thanks to the following:

       •   Benjamin Tilly

           For Text::xSV, the inspirado for this module

       •   Tim Bunce et al.

           For DBI, from which many of the methods were shamelessly stolen

       •   Tom Aldcroft

           For contributing code to make it easy to parse whitespace-delimited data

       •   Liya Ren

           For catching the column-ordering error when parsing with "no-headers"

       •   Sharon Wei

           For catching bug in "extract" that sets up infinite loops

       •   Lars Thegler

           For bug report on missing "script_files" arg in Build.PL

</pre><h4><b>BUGS</b></h4><pre>
       None known.  Please use <a href="http://rt.cpan.org/">http://rt.cpan.org/</a> for reporting bugs.

</pre><h4><b>LICENSE</b> <b>AND</b> <b>COPYRIGHT</b></h4><pre>
       Copyright (C) 2006-10 Ken Youens-Clark.  All rights reserved.

       This  program  is  free  software;  you  can  redistribute it and/or modify it under the terms of the GNU
       General Public License as published by the Free Software Foundation; version 2.

       This program is distributed in the hope that it will be useful, but WITHOUT ANY  WARRANTY;  without  even
       the  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
       License for more details.

perl v5.36.0                                       2022-10-14                            <u>Text::<a href="../man3pm/RecordParser.3pm.html">RecordParser</a></u>(3pm)
</pre>
 </div>
</div></section>
</div>
</body>
</html>