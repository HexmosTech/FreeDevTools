<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>drbdsetup - Setup tool for DRBD</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/drbd-utils">drbd-utils_9.22.0-1.1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       drbdsetup - Setup tool for DRBD

</pre><h4><b>SYNOPSIS</b></h4><pre>

       <b>drbdsetup</b> new-resource <u>resource</u> [--cpu-mask {<u>val</u>}] [--on-no-data-accessible {io-error | suspend-io}]

       <b>drbdsetup</b> new-minor <u>resource</u> <u>minor</u> <u>volume</u>

       <b>drbdsetup</b> del-resource <u>resource</u>

       <b>drbdsetup</b> del-minor <u>minor</u>

       <b>drbdsetup</b> attach <u>minor</u> <u>lower_dev</u> <u>meta_data_dev</u> <u>meta_data_index</u> [--size {<u>val</u>}] [--max-bio-bvecs {<u>val</u>}]
                 [--on-io-error {pass_on | call-local-io-error | detach}]
                 [--fencing {dont-care | resource-only | resource-and-stonith}] [--disk-barrier]
                 [--disk-flushes] [--disk-drain] [--md-flushes] [--resync-rate {<u>val</u>}] [--resync-after {<u>val</u>}]
                 [--al-extents {<u>val</u>}] [--al-updates] [--discard-zeroes-if-aligned] [--disable-write-same]
                 [--c-plan-ahead {<u>val</u>}] [--c-delay-target {<u>val</u>}] [--c-fill-target {<u>val</u>}] [--c-max-rate {<u>val</u>}]
                 [--c-min-rate {<u>val</u>}] [--disk-timeout {<u>val</u>}]
                 [--read-balancing {prefer-local | prefer-remote | round-robin | least-pending | when-congested-remote | 32K-striping | 64K-striping | 128K-striping | 256K-striping | 512K-striping | 1M-striping}]
                 [--rs-discard-granularity {<u>val</u>}]

       <b>drbdsetup</b> connect <u>resource</u> <u>local_addr</u> <u>remote_addr</u> [--tentative] [--discard-my-data]
                 [--protocol {A | B | C}] [--timeout {<u>val</u>}] [--max-epoch-size {<u>val</u>}] [--max-buffers {<u>val</u>}]
                 [--unplug-watermark {<u>val</u>}] [--connect-int {<u>val</u>}] [--ping-int {<u>val</u>}] [--sndbuf-size {<u>val</u>}]
                 [--rcvbuf-size {<u>val</u>}] [--ko-count {<u>val</u>}] [--allow-two-primaries] [--cram-hmac-alg {<u>val</u>}]
                 [--shared-secret {<u>val</u>}]
                 [--after-sb-0pri {disconnect | discard-younger-primary | discard-older-primary | discard-zero-changes | discard-least-changes | discard-local | discard-remote}]
                 [--after-sb-1pri {disconnect | consensus | discard-secondary | call-pri-lost-after-sb | violently-as0p}]
                 [--after-sb-2pri {disconnect | call-pri-lost-after-sb | violently-as0p}] [--always-asbp]
                 [--rr-conflict {disconnect | call-pri-lost | violently}] [--ping-timeout {<u>val</u>}]
                 [--data-integrity-alg {<u>val</u>}] [--tcp-cork] [--on-congestion {block | pull-ahead | disconnect}]
                 [--congestion-fill {<u>val</u>}] [--congestion-extents {<u>val</u>}] [--csums-alg {<u>val</u>}]
                 [--csums-after-crash-only] [--verify-alg {<u>val</u>}] [--use-rle] [--socket-check-timeout {<u>val</u>}]

       <b>drbdsetup</b> disk-options <u>minor</u> [--on-io-error {pass_on | call-local-io-error | detach}]
                 [--fencing {dont-care | resource-only | resource-and-stonith}] [--disk-barrier]
                 [--disk-flushes] [--disk-drain] [--md-flushes] [--resync-rate {<u>val</u>}] [--resync-after {<u>val</u>}]
                 [--al-extents {<u>val</u>}] [--al-updates] [--discard-zeroes-if-aligned] [--disable-write-same]
                 [--c-plan-ahead {<u>val</u>}] [--c-delay-target {<u>val</u>}] [--c-fill-target {<u>val</u>}] [--c-max-rate {<u>val</u>}]
                 [--c-min-rate {<u>val</u>}] [--disk-timeout {<u>val</u>}]
                 [--read-balancing {prefer-local | prefer-remote | round-robin | least-pending | when-congested-remote | 32K-striping | 64K-striping | 128K-striping | 256K-striping | 512K-striping | 1M-striping}]
                 [--rs-discard-granularity {<u>val</u>}]

       <b>drbdsetup</b> net-options <u>local_addr</u> <u>remote_addr</u> [--protocol {A | B | C}] [--timeout {<u>val</u>}]
                 [--max-epoch-size {<u>val</u>}] [--max-buffers {<u>val</u>}] [--unplug-watermark {<u>val</u>}] [--connect-int {<u>val</u>}]
                 [--ping-int {<u>val</u>}] [--sndbuf-size {<u>val</u>}] [--rcvbuf-size {<u>val</u>}] [--ko-count {<u>val</u>}]
                 [--allow-two-primaries] [--cram-hmac-alg {<u>val</u>}] [--shared-secret {<u>val</u>}]
                 [--after-sb-0pri {disconnect | discard-younger-primary | discard-older-primary | discard-zero-changes | discard-least-changes | discard-local | discard-remote}]
                 [--after-sb-1pri {disconnect | consensus | discard-secondary | call-pri-lost-after-sb | violently-as0p}]
                 [--after-sb-2pri {disconnect | call-pri-lost-after-sb | violently-as0p}] [--always-asbp]
                 [--rr-conflict {disconnect | call-pri-lost | violently}] [--ping-timeout {<u>val</u>}]
                 [--data-integrity-alg {<u>val</u>}] [--tcp-cork] [--on-congestion {block | pull-ahead | disconnect}]
                 [--congestion-fill {<u>val</u>}] [--congestion-extents {<u>val</u>}] [--csums-alg {<u>val</u>}]
                 [--csums-after-crash-only] [--verify-alg {<u>val</u>}] [--use-rle] [--socket-check-timeout {<u>val</u>}]

       <b>drbdsetup</b> resource-options <u>resource</u> [--cpu-mask {<u>val</u>}] [--on-no-data-accessible {io-error | suspend-io}]

       <b>drbdsetup</b> disconnect <u>local_addr</u> <u>remote_addr</u> [--force]

       <b>drbdsetup</b> detach <u>minor</u> [--force]

       <b>drbdsetup</b> primary <u>minor</u> [--force]

       <b>drbdsetup</b> secondary <u>minor</u>

       <b>drbdsetup</b> down <u>resource</u>

       <b>drbdsetup</b> verify <u>minor</u> [--start {<u>val</u>}] [--stop {<u>val</u>}]

       <b>drbdsetup</b> invalidate <u>minor</u>

       <b>drbdsetup</b> invalidate-remote <u>minor</u>

       <b>drbdsetup</b> wait-connect <u>minor</u> [--wfc-timeout {<u>val</u>}] [--degr-wfc-timeout {<u>val</u>}]
                 [--outdated-wfc-timeout {<u>val</u>}] [--wait-after-sb {<u>val</u>}]

       <b>drbdsetup</b> wait-sync <u>minor</u> [--wfc-timeout {<u>val</u>}] [--degr-wfc-timeout {<u>val</u>}] [--outdated-wfc-timeout {<u>val</u>}]
                 [--wait-after-sb {<u>val</u>}]

       <b>drbdsetup</b> role <u>minor</u>

       <b>drbdsetup</b> cstate <u>minor</u>

       <b>drbdsetup</b> dstate <u>minor</u>

       <b>drbdsetup</b> resize <u>minor</u> [--size {<u>val</u>}] [--assume-peer-has-space] [--assume-clean] [--al-stripes {<u>val</u>}]
                 [--al-stripe-size-kB {<u>val</u>}]

       <b>drbdsetup</b> check-resize <u>minor</u>

       <b>drbdsetup</b> pause-sync <u>minor</u>

       <b>drbdsetup</b> resume-sync <u>minor</u>

       <b>drbdsetup</b> outdate <u>minor</u>

       <b>drbdsetup</b> show-gi <u>minor</u>

       <b>drbdsetup</b> get-gi <u>minor</u>

       <b>drbdsetup</b> show {<u>resource</u> | <u>minor</u> | <u>all</u>}

       <b>drbdsetup</b> suspend-io <u>minor</u>

       <b>drbdsetup</b> resume-io <u>minor</u>

       <b>drbdsetup</b> status {<u>resource</u> | <u>all</u>} [--color {<u>val</u>}]

       <b>drbdsetup</b> events2 {<u>resource</u> | <u>all</u>}

       <b>drbdsetup</b> events {<u>resource</u> | <u>minor</u> | <u>all</u>}

       <b>drbdsetup</b> new-current-uuid <u>minor</u> [--clear-bitmap]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       drbdsetup is used to associate DRBD devices with their backing block devices, to set up DRBD device pairs
       to mirror their backing block devices, and to inspect the configuration of running DRBD devices.

</pre><h4><b>NOTE</b></h4><pre>
       drbdsetup is a low level tool of the DRBD program suite. It is used by the data disk and drbd scripts to
       communicate with the device driver.

</pre><h4><b>COMMANDS</b></h4><pre>
       Each drbdsetup sub-command might require arguments and bring its own set of options. All values have
       default units which might be overruled by K, M or G. These units are defined in the usual way (e.g. K =
       2^10 = 1024).

   <b>Common</b> <b>options</b>
       All drbdsetup sub-commands accept these two options

       <b>--create-device</b>
           In case the specified DRBD device (minor number) does not exist yet, create it implicitly.

   <b>new-resource</b>
       Resources are the primary objects of any DRBD configuration. A resource must be created with the
       <b>new-resource</b> command before any volumes or minor devices can be created. Connections are referenced by
       name.

   <b>new-minor</b>
       A <u>minor</u> is used as a synonym for replicated block device. It is represented in the <a href="file:/dev/">/dev/</a> directory by a
       block device. It is the application's interface to the DRBD-replicated block devices. These block devices
       get addressed by their minor numbers on the drbdsetup commandline.

       A pair of replicated block devices may have different minor numbers on the two machines. They are
       associated by a common <u>volume-number</u>. Volume numbers are local to each connection. Minor numbers are
       global on one node.

   <b>del-resource</b>
       Destroys a resource object. This is only possible if the resource has no volumes.

   <b>del-minor</b>
       Minors can only be destroyed if its disk is detached.

   <b>attach,</b> <b>disk-options</b>
       Attach associates <u>device</u> with <u>lower_device</u> to store its data blocks on. The <b>-d</b> (or <b>--disk-size</b>) should
       only be used if you wish not to use as much as possible from the backing block devices. If you do not use
       <b>-d</b>, the <u>device</u> is only ready for use as soon as it was connected to its peer once. (See the <b>net</b> command.)

       With the disk-options command it is possible to change the options of a minor while it is attached.

       <b>--disk-size</b> <u>size</u>
           You can override DRBD's size determination method with this option. If you need to use the device
           before it was ever connected to its peer, use this option to pass the <u>size</u> of the DRBD device to the
           driver. Default unit is sectors (1s = 512 bytes).

           If you use the <u>size</u> parameter in drbd.conf, we strongly recommend to add an explicit unit postfix.
           drbdadm and drbdsetup used to have mismatching default units.

       <b>--on-io-error</b> <u>err_handler</u>
           If the driver of the <u>lower_device</u> reports an error to DRBD, DRBD will mark the disk as inconsistent,
           call a helper program, or detach the device from its backing storage and perform all further IO by
           requesting it from the peer. The valid <u>err_handlers</u> are: <b>pass_on</b>, <b>call-local-io-error</b> and <b>detach</b>.

       <b>--fencing</b> <u>fencing_policy</u>
           Under <b>fencing</b> we understand preventive measures to avoid situations where both nodes are primary and
           disconnected (AKA split brain).

           Valid fencing policies are:

           <b>dont-care</b>
               This is the default policy. No fencing actions are done.

           <b>resource-only</b>
               If a node becomes a disconnected primary, it tries to outdate the peer's disk. This is done by
               calling the fence-peer handler. The handler is supposed to reach the other node over alternative
               communication paths and call 'drbdadm outdate res' there.

           <b>resource-and-stonith</b>
               If a node becomes a disconnected primary, it freezes all its IO operations and calls its
               fence-peer handler. The fence-peer handler is supposed to reach the peer over alternative
               communication paths and call 'drbdadm outdate res' there. In case it cannot reach the peer, it
               should stonith the peer. IO is resumed as soon as the situation is resolved. In case your handler
               fails, you can resume IO with the <b>resume-io</b> command.

       <b>--disk-barrier</b>,
       <b>--disk-flushes</b>,
       <b>--disk-drain</b>
           DRBD has four implementations to express write-after-write dependencies to its backing storage
           device. DRBD will use the first method that is supported by the backing storage device and that is
           not disabled. By default the <u>flush</u> method is used.

           Since drbd-8.4.2 <b>disk-barrier</b> is disabled by default because since linux-2.6.36 (or 2.6.32 RHEL6)
           there is no reliable way to determine if queuing of IO-barriers works.  <u>Dangerous</u> only enable if you
           are told so by one that knows for sure.

           When selecting the method you should not only base your decision on the measurable performance. In
           case your backing storage device has a volatile write cache (plain disks, RAID of plain disks) you
           should use one of the first two. In case your backing storage device has battery-backed write cache
           you may go with option 3. Option 4 (disable everything, use "none") <u>is</u> <u>dangerous</u> on most IO stacks,
           may result in write-reordering, and if so, can theoretically be the reason for data corruption, or
           disturb the DRBD protocol, causing spurious disconnect/reconnect cycles.  <u>Do</u> <u>not</u> <u>use</u> <b>no-disk-drain</b>.

           Unfortunately device mapper (LVM) might not support barriers.

           The letter after "wo:" in /proc/drbd indicates with method is currently in use for a device: b, f, d,
           n. The implementations:

           barrier
               The first requires that the driver of the backing storage device support barriers (called 'tagged
               command queuing' in SCSI and 'native command queuing' in SATA speak). The use of this method can
               be enabled by setting the <b>disk-barrier</b> options to <b>yes</b>.

           flush
               The second requires that the backing device support disk flushes (called 'force unit access' in
               the drive vendors speak). The use of this method can be disabled setting <b>disk-flushes</b> to <b>no</b>.

           drain
               The third method is simply to let write requests drain before write requests of a new reordering
               domain are issued. That was the only implementation before 8.0.9.

           none
               The fourth method is to not express write-after-write dependencies to the backing store at all,
               by also specifying <b>--no-disk-drain</b>. This <u>is</u> <u>dangerous</u> on most IO stacks, may result in
               write-reordering, and if so, can theoretically be the reason for data corruption, or disturb the
               DRBD protocol, causing spurious disconnect/reconnect cycles.  <u>Do</u> <u>not</u> <u>use</u> <b>--no-disk-drain</b>.

       <b>--md-flushes</b>
           Disables the use of disk flushes and barrier BIOs when accessing the meta data device. See the notes
           on <b>--disk-flushes</b>.

       <b>--max-bio-bvecs</b>
           In some special circumstances the device mapper stack manages to pass BIOs to DRBD that violate the
           constraints that are set forth by DRBD's merge_bvec() function and which have more than one bvec. A
           known example is: phys-disk -&gt; DRBD -&gt; LVM -&gt; Xen -&gt; misaligned partition (63) -&gt; DomU FS. Then you
           might see "bio would need to, but cannot, be split:" in the Dom0's kernel log.

           The best workaround is to proper align the partition within the VM (E.g. start it at sector 1024).
           That costs 480 KiB of storage. Unfortunately the default of most Linux partitioning tools is to start
           the first partition at an odd number (63). Therefore most distributions install helpers for virtual
           linux machines will end up with misaligned partitions. The second best workaround is to limit DRBD's
           max bvecs per BIO (i.e., the <b>max-bio-bvecs</b> option) to 1, but that might cost performance.

           The default value of <b>max-bio-bvecs</b> is 0, which means that there is no user imposed limitation.

       <b>--resync-rate</b> <u>rate</u>
           To ensure smooth operation of the application on top of DRBD, it is possible to limit the bandwidth
           that may be used by background synchronization. The default is 250 KiB/sec, the default unit is
           KiB/sec.

       <b>--resync-after</b> <u>minor</u>
           Start resync on this device only if the device with <u>minor</u> is already in connected state. Otherwise
           this device waits in SyncPause state.

       <b>--al-extents</b> <u>extents</u>
           DRBD automatically performs hot area detection. With this parameter you control how big the hot area
           (=active set) can get. Each extent marks 4M of the backing storage. In case a primary node leaves the
           cluster unexpectedly, the areas covered by the active set must be resynced upon rejoining of the
           failed node. The data structure is stored in the meta-data area, therefore each change of the active
           set is a write operation to the meta-data device. A higher number of extents gives longer resync
           times but less updates to the meta-data. The default number of <u>extents</u> is 1237. (Minimum: 7, Maximum:
           65534)

           See also <b><a href="../man5/drbd.conf.5.html">drbd.conf</a></b>(5) and <b><a href="../man8/drbdmeta.8.html">drbdmeta</a></b>(8) for additional limitations and necessary preparation.

       <b>--al-updates</b> <b>{yes</b> <b>|</b> <b>no}</b>
           DRBD's activity log transaction writing makes it possible, that after the crash of a primary node a
           partial (bit-map based) resync is sufficient to bring the node back to up-to-date. Setting <b>al-updates</b>
           to <b>no</b> might increase normal operation performance but causes DRBD to do a full resync when a crashed
           primary gets reconnected. The default value is <b>yes</b>.

       <b>--c-plan-ahead</b> <u>plan_time</u>,
       <b>--c-fill-target</b> <u>fill_target</u>,
       <b>--c-delay-target</b> <u>delay_target</u>,
       <b>--c-max-rate</b> <u>max_rate</u>
           The dynamic resync speed controller gets enabled with setting <u>plan_time</u> to a positive value. It aims
           to fill the buffers along the data path with either a constant amount of data <u>fill_target</u>, or aims to
           have a constant delay time of <u>delay_target</u> along the path. The controller has an upper bound of
           <u>max_rate</u>.

           By <u>plan_time</u> the agility of the controller is configured. Higher values yield for slower/lower
           responses of the controller to deviation from the target value. It should be at least 5 times RTT.
           For regular data paths a <u>fill_target</u> in the area of 4k to 100k is appropriate. For a setup that
           contains drbd-proxy it is advisable to use <u>delay_target</u> instead. Only when <u>fill_target</u> is set to 0
           the controller will use <u>delay_target</u>. 5 times RTT is a reasonable starting value.  <u>Max_rate</u> should be
           set to the bandwidth available between the DRBD-hosts and the machines hosting DRBD-proxy, or to the
           available disk-bandwidth.

           The default value of <u>plan_time</u> is 0, the default unit is 0.1 seconds.  <u>Fill_target</u> has 0 and sectors
           as default unit.  <u>Delay_target</u> has 1 (100ms) and 0.1 as default unit.  <u>Max_rate</u> has 10240 (100MiB/s)
           and KiB/s as default unit.

       <b>--c-min-rate</b> <u>min_rate</u>
           We track the disk IO rate caused by the resync, so we can detect non-resync IO on the lower level
           device. If the lower level device seems to be busy, and the current resync rate is above <u>min_rate</u>, we
           throttle the resync.

           The default value of <u>min_rate</u> is 4M, the default unit is k. If you want to not throttle at all, set
           it to zero, if you want to throttle always, set it to one.

       <b>-t</b>, <b>--disk-timeout</b> <u>disk_timeout</u>
           If the lower-level device on which a DRBD device stores its data does not finish an I/O request
           within the defined <b>disk-timeout</b>, DRBD treats this as a failure. The lower-level device is detached,
           and the device's disk state advances to Diskless. If DRBD is connected to one or more peers, the
           failed request is passed on to one of them.

           This option is <u>dangerous</u> <u>and</u> <u>may</u> <u>lead</u> <u>to</u> <u>kernel</u> <u>panic!</u>

           "Aborting" requests, or force-detaching the disk, is intended for completely blocked/hung local
           backing devices which do no longer complete requests at all, not even do error completions. In this
           situation, usually a hard-reset and failover is the only way out.

           By "aborting", basically faking a local error-completion, we allow for a more graceful swichover by
           cleanly migrating services. Still the affected node has to be rebooted "soon".

           By completing these requests, we allow the upper layers to re-use the associated data pages.

           If later the local backing device "recovers", and now DMAs some data from disk into the original
           request pages, in the best case it will just put random data into unused pages; but typically it will
           corrupt meanwhile completely unrelated data, causing all sorts of damage.

           Which means delayed successful completion, especially for READ requests, is a reason to panic(). We
           assume that a delayed *error* completion is OK, though we still will complain noisily about it.

           The default value of <b>disk-timeout</b> is 0, which stands for an infinite timeout. Timeouts are specified
           in units of 0.1 seconds. This option is available since DRBD 8.3.12.

       <b>--discard-zeroes-if-aligned</b> <b>{yes</b> <b>|</b> <b>no}</b>
           Setting <b>discard-zeroes-if-aligned</b> to <b>no</b> will cause DRBD to always fall-back to zero-out on the
           receiving side, and to not even announce discard capabilities on the Primary, if the respective
           backend announces discard_zeroes_data=false.

           Setting <b>discards-zeroes-if-aligned</b> to <b>yes</b> will allow DRBD to use discards, and to announce
           discard_zeroes=true, even on backends that announce discard_zeroes_data=false.

           We used to ignore the discard_zeroes_data setting completely. To not break established and expected
           behaviour, the default value is <b>yes</b>.

           This option is available since 8.4.7. See also <b><a href="../man5/drbd.conf.5.html">drbd.conf</a></b>(5).

       <b>--disable-write-same</b> <b>{yes</b> <b>|</b> <b>no}</b>

           Some disks announce WRITE_SAME support to the kernel but fail with an I/O error upon actually
           receiving such a request. This mostly happens when using virtualized disks -- notably, this behavior
           has been observed with VMware's virtual disks.

           When <b>disable-write-same</b> is set to <b>yes</b>, WRITE_SAME detection is manually overriden and support is
           disabled.

           The default value of <b>disable-write-same</b> is <b>no</b>. This option is available since 8.4.7.

       <b>--read-balancing</b> <u>method</u>
           The supported <u>methods</u> for load balancing of read requests are <b>prefer-local</b>, <b>prefer-remote</b>,
           <b>round-robin</b>, <b>least-pending</b> and <b>when-congested-remote</b>, <b>32K-striping</b>, <b>64K-striping</b>, <b>128K-striping</b>,
           <b>256K-striping</b>, <b>512K-striping</b> and <b>1M-striping</b>.

           The default value of <b>read-balancing</b> is <b>prefer-local</b>. This option is available since 8.4.1.

       <b>--rs-discard-granularity</b> <u>bytes</u>
           When <b>rs-discard-granularity</b> is set to a non zero, positive value then DRBD tries to do a resync
           operation in requests of this size. In case such a block contains only zero bytes on the sync source
           node, the sync target node will issue a discard/trim/unmap command for the area.

           The value is constrained by the discard granularity of the backing block device. In case
           <b>rs-discard-granularity</b> is not a multiplier of the discard granularity of the backing block device
           DRBD rounds it up. The feature only gets active if the backing block device reads back zeroes after a
           discard command.

           The default value of <b>rs-discard-granularity</b> is 0. This option is available since 8.4.7.

   <b>connect,</b> <b>net-options</b>
       Connect sets up the <u>device</u> to listen on <u>af:local_addr:port</u> for incoming connections and to try to connect
       to <u>af:remote_addr:port</u>. If <u>port</u> is omitted, 7788 is used as default. If <u>af</u> is omitted <b>ipv4</b> gets used.
       Other supported address families are <b>ipv6</b>, <b>ssocks</b> for Dolphin Interconnect Solutions' "super sockets" and
       <b>sdp</b> for Sockets Direct Protocol (Infiniband).

       The net-options command allows you to change options while the connection is established.

       <b>--protocol</b> <u>protocol</u>
           On the TCP/IP link the specified <u>protocol</u> is used. Valid protocol specifiers are A, B, and C.

           Protocol A: write IO is reported as completed, if it has reached local disk and local TCP send
           buffer.

           Protocol B: write IO is reported as completed, if it has reached local disk and remote buffer cache.

           Protocol C: write IO is reported as completed, if it has reached both local and remote disk.

       <b>--connect-int</b> <u>time</u>
           In case it is not possible to connect to the remote DRBD device immediately, DRBD keeps on trying to
           connect. With this option you can set the time between two retries. The default value is 10. The unit
           is seconds.

       <b>--ping-int</b> <u>time</u>
           If the TCP/IP connection linking a DRBD device pair is idle for more than <u>time</u> seconds, DRBD will
           generate a keep-alive packet to check if its partner is still alive. The default value is 10. The
           unit is seconds.

       <b>--timeout</b> <u>val</u>
           If the partner node fails to send an expected response packet within <u>val</u> tenths of a second, the
           partner node is considered dead and therefore the TCP/IP connection is abandoned. The default value
           is 60 (= 6 seconds).

       <b>--sndbuf-size</b> <u>size</u>
           The socket send buffer is used to store packets sent to the secondary node, which are not yet
           acknowledged (from a network point of view) by the secondary node. When using protocol A, it might be
           necessary to increase the size of this data structure in order to increase asynchronicity between
           primary and secondary nodes. But keep in mind that more asynchronicity is synonymous with more data
           loss in the case of a primary node failure. Since 8.0.13 resp. 8.2.7 setting the <u>size</u> value to 0
           means that the kernel should autotune this. The default <u>size</u> is 0, i.e. autotune.

       <b>--rcvbuf-size</b> <u>size</u>
           Packets received from the network are stored in the socket receive buffer first. From there they are
           consumed by DRBD. Before 8.3.2 the receive buffer's size was always set to the size of the socket
           send buffer. Since 8.3.2 they can be tuned independently. A value of 0 means that the kernel should
           autotune this. The default <u>size</u> is 0, i.e. autotune.

       <b>--ko-count</b> <u>count</u>
           In case the secondary node fails to complete a single write request for <u>count</u> times the <u>timeout</u>, it
           is expelled from the cluster, i.e. the primary node goes into StandAlone mode. To disable this
           feature, you should explicitly set it to 0; defaults may change between versions.

       <b>--max-epoch-size</b> <u>val</u>
           With this option the maximal number of write requests between two barriers is limited. Typically set
           to the same as <b>--max-buffers</b>, or the allowed maximum. Values smaller than 10 can lead to degraded
           performance. The default value is 2048.

       <b>--max-buffers</b> <u>val</u>
           With this option the maximal number of buffer pages allocated by DRBD's receiver thread is limited.
           Typically set to the same as <b>--max-epoch-size</b>. Small values could lead to degraded performance. The
           default value is 2048, the minimum 32. Increase this if you cannot saturate the IO backend of the
           receiving side during linear write or during resync while otherwise idle.

           See also <b><a href="../man5/drbd.conf.5.html">drbd.conf</a></b>(5)

       <b>--unplug-watermark</b> <u>val</u>
           This setting has no effect with recent kernels that use explicit on-stack plugging (upstream Linux
           kernel 2.6.39, distributions may have backported).

           When the number of pending write requests on the standby (secondary) node exceeds the
           unplug-watermark, we trigger the request processing of our backing storage device. Some storage
           controllers deliver better performance with small values, others deliver best performance when the
           value is set to the same value as max-buffers, yet others don't feel much effect at all. Minimum 16,
           default 128, maximum 131072.

       <b>--allow-two-primaries</b>
           With this option set you may assign primary role to both nodes. You only should use this option if
           you use a shared storage file system on top of DRBD. At the time of writing the only ones are: OCFS2
           and GFS. If you use this option with any other file system, you are going to crash your nodes and to
           corrupt your data!

       <b>--cram-hmac-alg</b> <u>alg</u>
           You need to specify the HMAC algorithm to enable peer authentication at all. You are strongly
           encouraged to use peer authentication. The HMAC algorithm will be used for the challenge response
           authentication of the peer. You may specify any digest algorithm that is named in /proc/crypto.

       <b>--shared-secret</b> <u>secret</u>
           The shared secret used in peer authentication. May be up to 64 characters.

       <b>--after-sb-0pri</b> <u>asb-0p-policy</u>
           possible policies are:

           <b>disconnect</b>
               No automatic resynchronization, simply disconnect.

           <b>discard-younger-primary</b>
               Auto sync from the node that was primary before the split-brain situation occurred.

           <b>discard-older-primary</b>
               Auto sync from the node that became primary as second during the split-brain situation.

           <b>discard-zero-changes</b>
               In case one node did not write anything since the split brain became evident, sync from the node
               that wrote something to the node that did not write anything. In case none wrote anything this
               policy uses a random decision to perform a "resync" of 0 blocks. In case both have written
               something this policy disconnects the nodes.

           <b>discard-least-changes</b>
               Auto sync from the node that touched more blocks during the split brain situation.

           <b>discard-node-NODENAME</b>
               Auto sync to the named node.

       <b>--after-sb-1pri</b> <u>asb-1p-policy</u>
           possible policies are:

           <b>disconnect</b>
               No automatic resynchronization, simply disconnect.

           <b>consensus</b>
               Discard the version of the secondary if the outcome of the <b>after-sb-0pri</b> algorithm would also
               destroy the current secondary's data. Otherwise disconnect.

           <b>discard-secondary</b>
               Discard the secondary's version.

           <b>call-pri-lost-after-sb</b>
               Always honor the outcome of the <b>after-sb-0pri</b> algorithm. In case it decides the current secondary
               has the correct data, call the <b>pri-lost-after-sb</b> on the current primary.

           <b>violently-as0p</b>
               Always honor the outcome of the <b>after-sb-0pri</b> algorithm. In case it decides the current secondary
               has the correct data, accept a possible instantaneous change of the primary's data.

       <b>--after-sb-2pri</b> <u>asb-2p-policy</u>
           possible policies are:

           <b>disconnect</b>
               No automatic resynchronization, simply disconnect.

           <b>call-pri-lost-after-sb</b>
               Always honor the outcome of the <b>after-sb-0pri</b> algorithm. In case it decides the current secondary
               has the right data, call the <b>pri-lost-after-sb</b> on the current primary.

           <b>violently-as0p</b>
               Always honor the outcome of the <b>after-sb-0pri</b> algorithm. In case it decides the current secondary
               has the right data, accept a possible instantaneous change of the primary's data.

       <b>--always-asbp</b>
           Normally the automatic after-split-brain policies are only used if current states of the UUIDs do not
           indicate the presence of a third node.

           With this option you request that the automatic after-split-brain policies are used as long as the
           data sets of the nodes are somehow related. This might cause a full sync, if the UUIDs indicate the
           presence of a third node. (Or double faults have led to strange UUID sets.)

       <b>--rr-conflict</b> <u>role-resync-conflict-policy</u>
           This option sets DRBD's behavior when DRBD deduces from its meta data that a resynchronization is
           needed, and the SyncTarget node is already primary. The possible settings are: <b>disconnect</b>,
           <b>call-pri-lost</b> and <b>violently</b>. While <b>disconnect</b> speaks for itself, with the <b>call-pri-lost</b> setting the
           <b>pri-lost</b> handler is called which is expected to either change the role of the node to secondary, or
           remove the node from the cluster. The default is <b>disconnect</b>.

           With the <b>violently</b> setting you allow DRBD to force a primary node into SyncTarget state. This means
           that the data exposed by DRBD changes to the SyncSource's version of the data instantaneously. USE
           THIS OPTION ONLY IF YOU KNOW WHAT YOU ARE DOING.

       <b>--data-integrity-alg</b> <u>hash_alg</u>
           DRBD can ensure the data integrity of the user's data on the network by comparing hash values.
           Normally this is ensured by the 16 bit checksums in the headers of TCP/IP packets. This option can be
           set to any of the kernel's data digest algorithms. In a typical kernel configuration you should have
           at least one of <b>md5</b>, <b>sha1</b>, and <b>crc32c</b> available. By default this is not enabled.

           See also the notes on data integrity on the drbd.conf manpage.

       <b>--no-tcp-cork</b>
           DRBD usually uses the TCP socket option TCP_CORK to hint to the network stack when it can expect more
           data, and when it should flush out what it has in its send queue. There is at least one network stack
           that performs worse when one uses this hinting method. Therefore we introduced this option, which
           disable the setting and clearing of the TCP_CORK socket option by DRBD.

       <b>--ping-timeout</b> <u>ping_timeout</u>
           The time the peer has to answer to a keep-alive packet. In case the peer's reply is not received
           within this time period, it is considered dead. The default unit is tenths of a second, the default
           value is 5 (for half a second).

       <b>--discard-my-data</b>
           Use this option to manually recover from a split-brain situation. In case you do not have any
           automatic after-split-brain policies selected, the nodes refuse to connect. By passing this option
           you make this node a sync target immediately after successful connect.

       <b>--tentative</b>
           Causes DRBD to abort the connection process after the resync handshake, i.e. no resync gets
           performed. You can find out which resync DRBD would perform by looking at the kernel's log file.

       <b>--on-congestion</b> <u>congestion_policy</u>,
       <b>--congestion-fill</b> <u>fill_threshold</u>,
       <b>--congestion-extents</b> <u>active_extents_threshold</u>
           By default DRBD blocks when the available TCP send queue becomes full. That means it will slow down
           the application that generates the write requests that cause DRBD to send more data down that TCP
           connection.

           When DRBD is deployed with DRBD-proxy it might be more desirable that DRBD goes into AHEAD/BEHIND
           mode shortly before the send queue becomes full. In AHEAD/BEHIND mode DRBD does no longer replicate
           data, but still keeps the connection open.

           The advantage of the AHEAD/BEHIND mode is that the application is not slowed down, even if
           DRBD-proxy's buffer is not sufficient to buffer all write requests. The downside is that the peer
           node falls behind, and that a resync will be necessary to bring it back into sync. During that resync
           the peer node will have an inconsistent disk.

           Available <u>congestion_policy</u>s are <b>block</b> and <b>pull-ahead</b>. The default is <b>block</b>.  <u>Fill_threshold</u> might be
           in the range of 0 to 10GiBytes. The default is 0 which disables the check.  <u>Active_extents_threshold</u>
           has the same limits as <b>al-extents</b>.

           The AHEAD/BEHIND mode and its settings are available since DRBD 8.3.10.

       <b>--verify-alg</b> <u>hash-alg</u>
           During online verification (as initiated by the <b>verify</b> sub-command), rather than doing a bit-wise
           comparison, DRBD applies a hash function to the contents of every block being verified, and compares
           that hash with the peer. This option defines the hash algorithm being used for that purpose. It can
           be set to any of the kernel's data digest algorithms. In a typical kernel configuration you should
           have at least one of <b>md5</b>, <b>sha1</b>, and <b>crc32c</b> available. By default this is not enabled; you must set
           this option explicitly in order to be able to use on-line device verification.

           See also the notes on data integrity on the drbd.conf manpage.

       <b>--csums-alg</b> <u>hash-alg</u>
           A resync process sends all marked data blocks from the source to the destination node, as long as no
           <b>csums-alg</b> is given. When one is specified the resync process exchanges hash values of all marked
           blocks first, and sends only those data blocks over, that have different hash values.

           This setting is useful for DRBD setups with low bandwidth links. During the restart of a crashed
           primary node, all blocks covered by the activity log are marked for resync. But a large part of those
           will actually be still in sync, therefore using <b>csums-alg</b> will lower the required bandwidth in
           exchange for CPU cycles.

       <b>--use-rle</b>
           During resync-handshake, the dirty-bitmaps of the nodes are exchanged and merged (using bit-or), so
           the nodes will have the same understanding of which blocks are dirty. On large devices, the fine
           grained dirty-bitmap can become large as well, and the bitmap exchange can take quite some time on
           low-bandwidth links.

           Because the bitmap typically contains compact areas where all bits are unset (clean) or set (dirty),
           a simple run-length encoding scheme can considerably reduce the network traffic necessary for the
           bitmap exchange.

           For backward compatibility reasons, and because on fast links this possibly does not improve transfer
           time but consumes cpu cycles, this defaults to off.

           Introduced in 8.3.2.

       <b>--socket-check-timeout</b>
           In setups involving a DRBD-proxy and connections that experience a lot of buffer-bloat it might be
           necessary to set <b>ping-timeout</b> to an unusual high value. By default DRBD uses the same value to wait
           if a newly established TCP-connection is stable. Since the DRBD-proxy is usually located in the same
           data center such a long wait time may hinder DRBD's connect process.

           In such setups <b>socket-check-timeout</b> should be set to at least to the round trip time between DRBD and
           DRBD-proxy. I.e. in most cases to 1.

           The default unit is tenths of a second, the default value is 0 (which causes DRBD to use the value of
           <b>ping-timeout</b> instead). Introduced in 8.4.5.

   <b>resource-options</b>
       Changes the options of the resource at runtime.

       <b>--cpu-mask</b> <u>cpu-mask</u>
           Sets the cpu-affinity-mask for DRBD's kernel threads of this device. The default value of <u>cpu-mask</u> is
           0, which means that DRBD's kernel threads should be spread over all CPUs of the machine. This value
           must be given in hexadecimal notation. If it is too big it will be truncated.

       <b>--on-no-data-accessible</b> <u>ond-policy</u>
           This setting controls what happens to IO requests on a degraded, disk less node (I.e. no data store
           is reachable). The available policies are <b>io-error</b> and <b>suspend-io</b>.

           If <u>ond-policy</u> is set to <b>suspend-io</b> you can either resume IO by attaching/connecting the last lost
           data storage, or by the <b>drbdadm</b> <b>resume-io</b> <u>res</u> command. The latter will result in IO errors of course.

           The default is <b>io-error</b>. This setting is available since DRBD 8.3.9.

   <b>primary</b>
       Sets the <u>device</u> into primary role. This means that applications (e.g. a file system) may open the <u>device</u>
       for read and write access. Data written to the <u>device</u> in primary role are mirrored to the device in
       secondary role.

       Normally it is not possible to set both devices of a connected DRBD device pair to primary role. By using
       the <b>--allow-two-primaries</b> option, you override this behavior and instruct DRBD to allow two primaries.

       <b>--overwrite-data-of-peer</b>
           Alias for --force.

       <b>--force</b>
           Becoming primary fails if the local replica is not up-to-date. I.e. when it is inconsistent, outdated
           of consistent. By using this option you can force it into primary role anyway. USE THIS OPTION ONLY
           IF YOU KNOW WHAT YOU ARE DOING.

   <b>secondary</b>
       Brings the <u>device</u> into secondary role. This operation fails as long as at least one application (or file
       system) has opened the device.

       It is possible that both devices of a connected DRBD device pair are secondary.

   <b>verify</b>
       This initiates on-line device verification. During on-line verification, the contents of every block on
       the local node are compared to those on the peer node. Device verification progress can be monitored via
       /proc/drbd. Any blocks whose content differs from that of the corresponding block on the peer node will
       be marked out-of-sync in DRBD's on-disk bitmap; they are <u>not</u> brought back in sync automatically. To do
       that, simply disconnect and reconnect the resource.

       If on-line verification is already in progress (and this node is "VerifyS"), this command silently
       "succeeds". In this case, any start-sector (see below) will be ignored, and any stop-sector (see below)
       will be honored. This can be used to stop a running verify, or to update/shorten/extend the coverage of
       the currently running verify.

       This command will fail if the <u>device</u> is not part of a connected device pair.

       See also the notes on data integrity on the drbd.conf manpage.

       <b>--start</b> <u>start-sector</u>
           Since version 8.3.2, on-line verification should resume from the last position after connection loss.
           It may also be started from an arbitrary position by setting this option. If you had reached some
           stop-sector before, and you do not specify an explicit start-sector, verify should resume from the
           previous stop-sector.

           Default unit is sectors. You may also specify a unit explicitly. The <b>start-sector</b> will be rounded
           down to a multiple of 8 sectors (4kB).

       <b>-S</b>, <b>--stop</b> <u>stop-sector</u>
           Since version 8.3.14, on-line verification can be stopped before it reaches end-of-device.

           Default unit is sectors. You may also specify a unit explicitly. The <b>stop-sector</b> may be updated by
           issuing an additional drbdsetup verify command on the same node while the verify is running. This can
           be used to stop a running verify, or to update/shorten/extend the coverage of the currently running
           verify.

   <b>invalidate</b>
       This forces the local device of a pair of connected DRBD devices into SyncTarget state, which means that
       all data blocks of the device are copied over from the peer.

       This command will fail if the <u>device</u> is not either part of a connected device pair, or disconnected
       Secondary.

   <b>invalidate-remote</b>
       This forces the local device of a pair of connected DRBD devices into SyncSource state, which means that
       all data blocks of the device are copied to the peer.

       On a disconnected Primary device, this will set all bits in the out of sync bitmap. As a side affect this
       suspends updates to the on disk activity log. Updates to the on disk activity log resume automatically
       when necessary.

   <b>wait-connect</b>
       Returns as soon as the <u>device</u> can communicate with its partner device.

       <b>--wfc-timeout</b> <u>wfc_timeout</u>,
       <b>--degr-wfc-timeout</b> <u>degr_wfc_timeout</u>,
       <b>--outdated-wfc-timeout</b> <u>outdated_wfc_timeout</u>,
       <b>--wait-after-sb</b>
           This command will fail if the <u>device</u> cannot communicate with its partner for <u>timeout</u> seconds. If the
           peer was working before this node was rebooted, the <u>wfc_timeout</u> is used. If the peer was already down
           before this node was rebooted, the <u>degr_wfc_timeout</u> is used. If the peer was successfully outdated
           before this node was rebooted the <u>outdated_wfc_timeout</u> is used. The default value for all those
           timeout values is 0 which means to wait forever. The unit is seconds. In case the connection status
           goes down to StandAlone because the peer appeared but the devices had a split brain situation, the
           default for the command is to terminate. You can change this behavior with the <b>--wait-after-sb</b>
           option.

   <b>wait-sync</b>
       Returns as soon as the <u>device</u> leaves any synchronization into connected state. The options are the same
       as with the <u>wait-connect</u> command.

   <b>disconnect</b>
       Removes the information set by the <b>net</b> command from the <u>device</u>. This means that the <u>device</u> goes into
       unconnected state and will no longer listen for incoming connections.

   <b>detach</b>
       Removes the information set by the <b>disk</b> command from the <u>device</u>. This means that the <u>device</u> is detached
       from its backing storage device.

       <b>-f</b>, <b>--force</b>
           A regular detach returns after the disk state finally reached diskless. As a consequence detaching
           from a frozen backing block device never terminates.

           On the other hand A forced detach returns immediately. It allows you to detach DRBD from a frozen
           backing block device. Please note that the disk will be marked as failed until all pending IO
           requests where finished by the backing block device.

   <b>down</b>
       Removes all configuration information from the <u>device</u> and forces it back to unconfigured state.

   <b>role</b>
       Shows the current roles of the <u>device</u> and its peer, as <u>local</u>/<u>peer</u>.

   <b>state</b>
       Deprecated alias for "role"

   <b>cstate</b>
       Shows the current connection state of the <u>device</u>.

   <b>dstate</b>
       Shows the current states of the backing storage devices, as <u>local</u>/<u>peer</u>.

   <b>resize</b>
       This causes DRBD to reexamine the size of the <u>device</u>'s backing storage device. To actually do online
       growing you need to extend the backing storages on both devices and call the <b>resize</b> command on one of
       your nodes.

       The <b>--size</b> option can be used to online shrink the usable size of a drbd device. It's the users
       responsibility to make sure that a file system on the device is not truncated by that operation.

       The <b>--assume-peer-has-space</b> allows you to resize a device which is currently not connected to the peer.
       Use with care, since if you do not resize the peer's disk as well, further connect attempts of the two
       will fail.

       When the <b>--assume-clean</b> option is given DRBD will skip the resync of the new storage. Only do this if you
       know that the new storage was initialized to the same content by other means.

       The options <b>--al-stripes</b> and <b>--al-stripe-size-kB</b> may be used to change the layout of the activity log
       online. In case of internal meta data this may invovle shrinking the user visible size at the same time
       (unsing the <b>--size</b>) or increasing the avalable space on the backing devices.

   <b>check-resize</b>
       To enable DRBD to detect offline resizing of backing devices this command may be used to record the
       current size of backing devices. The size is stored in files in /var/lib/drbd/ named drbd-minor-??.lkbd

       This command is called by <b>drbdadm</b> <b>resize</b> <u>res</u> after <b>drbdsetup</b> <u>device</u> <b>resize</b> returned.

   <b>pause-sync</b>
       Temporarily suspend an ongoing resynchronization by setting the local pause flag. Resync only progresses
       if neither the local nor the remote pause flag is set. It might be desirable to postpone DRBD's
       resynchronization after eventual resynchronization of the backing storage's RAID setup.

   <b>resume-sync</b>
       Unset the local sync pause flag.

   <b>outdate</b>
       Mark the data on the local backing storage as outdated. An outdated device refuses to become primary.
       This is used in conjunction with <b>fencing</b> and by the peer's <b>fence-peer</b> handler.

   <b>show-gi</b>
       Displays the device's data generation identifiers verbosely.

   <b>get-gi</b>
       Displays the device's data generation identifiers.

   <b>show</b>
       Shows all available configuration information of a resource, or of all resources. Available options:

       <b>--show-defaults</b>
           Show all configuration parameters, even the ones with default values. Normally, parameters with
           default values are not shown.

   <b>suspend-io</b>
       This command is of no apparent use and just provided for the sake of completeness.

   <b>resume-io</b>
       If the fence-peer handler fails to stonith the peer node, and your <b>fencing</b> policy is set to
       resource-and-stonith, you can unfreeze IO operations with this command.

   <b>status</b>
       Show the status of a resource, or of all resources. The output consists of one paragraph for each
       configured resource. Each paragraph contains one line for each resource, followed by one line for each
       device, and one line for each connection. The device and connection lines are indented. The connection
       lines are followed by one line for each peer device; these lines are indented against the connection
       line.

       Long lines are wrapped around at terminal width, and indented to indicate how the lines belongs together.
       Available options:

       <b>--verbose</b>
           Include more information in the output even when it is likely redundant or irrelevant.

       <b>--statistics</b>
           Include data transfer statistics in the output.

       <b>--color={always</b> <b>|</b> <b>auto</b> <b>|</b> <b>never}</b>
           Colorize the output. With <b>--color=auto</b>, <b>drbdsetup</b> emits color codes only when standard output is
           connected to a terminal.

       For example, the non-verbose output for a resource with only one connection and only one volume could
       look like this:

           fs-backoffice role:Primary
             disk:UpToDate
             peer role:Secondary
               replication:Established peer-disk:UpToDate

       With the <b>--verbose</b> <b>--statistics</b> options, the same resource could be reported as:

           fs-data role:Primary suspended:no
               write-ordering:drain
             volume:0 minor:1 disk:UpToDate
                 size:10616472 read:134465 written:144800 al-writes:18 bm-writes:0
                 upper-pending:0 lower-pending:0 al-suspended:no blocked:no
             peer connection:Connected role:Secondary congested:no
               volume:0 replication:Established peer-disk:UpToDate resync-suspended:no
                   received:122596 sent:22204 out-of-sync:0 pending:0 unacked:0

   <b>events2</b>
       Show the current state of all configured DRBD objects, followed by all changes to the state.

       The output format is meant to be human as well as machine readable. Each line starts with the event
       number, which is followed by an asterisk if the event continues in the next line. The second word in each
       line indicates the kind of event: <b>exists</b> for an existing object; <b>create</b>, <b>destroy</b>, and <b>change</b> if an object
       is created, destroyed, or changed; or <b>call</b> or <b>response</b> if an event handler is called or it returns. The
       third word indicates the object the event applies to: <b>resource</b>, <b>device</b>, <b>connection</b>, <b>peer-device</b>, <b>helper</b>,
       or a dash (<b>-</b>) to indicate that the current state has been dumped completely.

       The remaining words identify the object and describe the state that he object is in. Available options:

       <b>--now</b>
           Terminate after reporting the current state. The default is to continuously listen and report state
           changes.

       <b>--statistics</b>
           Include statistics in the output.

   <b>events</b>
       Deprecated. If possible, change to the events2 subcommand instead.

       Displays every state change of DRBD and all calls to helper programs. This might be used to get notified
       of DRBD's state changes by piping the output to another program.

       <b>--all-devices</b>
           Display the events of all DRBD minors.

       <b>--unfiltered</b>
           This is a debugging aid that displays the content of all received netlink messages.

   <b>new-current-uuid</b>
       Generates a new current UUID and rotates all other UUID values. This has at least two use cases, namely
       to skip the initial sync, and to reduce network bandwidth when starting in a single node configuration
       and then later (re-)integrating a remote site.

       Available option:

       <b>--clear-bitmap</b>
           Clears the sync bitmap in addition to generating a new current UUID.

       This can be used to skip the initial sync, if you want to start from scratch. This use-case does only
       work on "Just Created" meta data. Necessary steps:

        1. On <u>both</u> nodes, initialize meta data and configure the device.

           <b>drbdadm</b> <b>--</b> <b>--force</b> <b>create-md</b> <u>res</u>

        2. They need to do the initial handshake, so they know their sizes.

           <b>drbdadm</b> <b>up</b> <u>res</u>

        3. They are now Connected Secondary/Secondary Inconsistent/Inconsistent. Generate a new current-uuid and
           clear the dirty bitmap.

           <b>drbdadm</b> <b>new-current-uuid</b> <b>--clear-bitmap</b> <u>res</u>

        4. They are now Connected Secondary/Secondary UpToDate/UpToDate. Make one side primary and create a file
           system.

           <b>drbdadm</b> <b>primary</b> <u>res</u>

           <b>mkfs</b> <b>-t</b> <u>fs-type</u> <b>$(drbdadm</b> <b>sh-dev</b> <u>res</u><b>)</b>

       One obvious side-effect is that the replica is full of old garbage (unless you made them identical using
       other means), so any online-verify is expected to find any number of out-of-sync blocks.

       <u>You</u> <u>must</u> <u>not</u> <u>use</u> <u>this</u> <u>on</u> <u>pre-existing</u> <u>data!</u>  Even though it may appear to work at first glance, once you
       switch to the other node, your data is toast, as it never got replicated. So <u>do</u> <u>not</u> <u>leave</u> <u>out</u> <u>the</u> <u>mkfs</u>
       (or equivalent).

       This can also be used to shorten the initial resync of a cluster where the second node is added after the
       first node is gone into production, by means of disk shipping. This use-case works on disconnected
       devices only, the device may be in primary or secondary role.

       The necessary steps on the current active server are:

        1. <b>drbdsetup</b> <b>new-current-uuid</b> <b>--clear-bitmap</b> <u>minor</u>

        2. Take the copy of the current active server. E.g. by pulling a disk out of the RAID1 controller, or by
           copying with dd. You need to copy the actual data, and the meta data.

        3. <b>drbdsetup</b> <b>new-current-uuid</b> <u>minor</u>

       Now add the disk to the new secondary node, and join it to the cluster. You will get a resync of that
       parts that were changed since the first call to <b>drbdsetup</b> in step 1.

</pre><h4><b>EXAMPLES</b></h4><pre>
       For examples, please have a look at the <b>DRBD</b> <b>User's</b> <b>Guide</b>[1].

</pre><h4><b>VERSION</b></h4><pre>
       This document was revised for version 8.3.2 of the DRBD distribution.

</pre><h4><b>AUTHOR</b></h4><pre>
       Written by Philipp Reisner &lt;<a href="mailto:philipp.reisner@linbit.com">philipp.reisner@linbit.com</a>&gt; and Lars Ellenberg &lt;<a href="mailto:lars.ellenberg@linbit.com">lars.ellenberg@linbit.com</a>&gt;

</pre><h4><b>REPORTING</b> <b>BUGS</b></h4><pre>
       Report bugs to &lt;<a href="mailto:drbd-user@lists.linbit.com">drbd-user@lists.linbit.com</a>&gt;.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright 2001-2008 LINBIT Information Technologies, Philipp Reisner, Lars Ellenberg. This is free
       software; see the source for copying conditions. There is NO warranty; not even for MERCHANTABILITY or
       FITNESS FOR A PARTICULAR PURPOSE.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man5/drbd.conf.5.html">drbd.conf</a></b>(5), <b><a href="../man8/drbd.8.html">drbd</a></b>(8), <b><a href="../man8/drbddisk.8.html">drbddisk</a></b>(8), <b><a href="../man8/drbdadm.8.html">drbdadm</a></b>(8), <b>DRBD</b> <b>User's</b> <b>Guide</b>[1], <b>DRBD</b> <b>web</b> <b>site</b>[2]

</pre><h4><b>NOTES</b></h4><pre>
        1. DRBD User's Guide
           <a href="http://www.drbd.org/users-guide/">http://www.drbd.org/users-guide/</a>

        2. DRBD web site
           <a href="http://www.drbd.org/">http://www.drbd.org/</a>

DRBD 8.4.0                                         6 May 2011                                       <u><a href="../man8/DRBDSETUP.8.html">DRBDSETUP</a></u>(8)
</pre>
 </div>
</div></section>
</div>
</body>
</html>