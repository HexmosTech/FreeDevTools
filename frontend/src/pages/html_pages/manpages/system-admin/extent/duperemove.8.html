<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>duperemove - Find duplicate extents and print them to stdout</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/duperemove">duperemove_0.11.2-3build2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       duperemove - Find duplicate extents and print them to stdout

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>duperemove</b> <u>[options]</u> <u>files...</u>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>duperemove</b>  is  a  simple tool for finding duplicated extents and submitting them for deduplication. When
       given a list of files it will hash the contents of their extents and compare those hashes to each  other,
       finding  and categorizing extents that match each other. When given the <b>-d</b> option, <b>duperemove</b> will submit
       those extents for deduplication using the Linux kernel extent-same ioctl.

       <b>duperemove</b> can store the hashes it computes in a <u>hashfile</u>. If given an existing hashfile, <b>duperemove</b> will
       only compute hashes for those files which have changed since the last run.  Thus you can  run  <b>duperemove</b>
       repeatedly  on  your  data  as  it  changes,  without  having to re-checksum unchanged data.  For more on
       hashfiles see the <b>--hashfile</b> option below as well as the <u>Examples</u> section.

       <b>duperemove</b> can also take input from the <b>fdupes</b> program, see the <b>--fdupes</b> option below.

</pre><h4><b>GENERAL</b></h4><pre>
       Duperemove has two major modes of operation one of which is a subset of the other.

   <b>Readonly</b> <b>/</b> <b>Non-deduplicating</b> <b>Mode</b>
       When run without <b>-d</b> (the default) duperemove will print out one or more tables of matching extents it has
       determined would be ideal candidates for deduplication. As a result, readonly mode is useful  for  seeing
       what duperemove might do when run with <b>-d</b>.

       Generally,  duperemove  does  not  concern  itself  with  the underlying representation of the extents it
       processes. Some of them could be compressed, undergoing I/O, or even have already been  deduplicated.  In
       dedupe mode, the kernel handles those details and therefore we try not to replicate that work.

   <b>Deduping</b> <b>Mode</b>
       This  functions  similarly  to  readonly mode with the exception that the duplicated extents found in our
       "read, hash, and compare" step will actually be submitted for deduplication. Extents  that  have  already
       been  deduped  will  be  skipped.  An  estimate  of the total data deduplicated will be printed after the
       operation is complete. This estimate is calculated by comparing the total amount of shared bytes in  each
       file before and after the dedupe.

</pre><h4><b>OPTIONS</b></h4><pre>
       <u>files</u>  can refer to a list of regular files and directories or be a hyphen (-) to read them from standard
       input.  If a directory is specified, all regular files within it will also  be  scanned.  Duperemove  can
       also be told to recursively scan directories with the '-r' switch.

       <b>-r</b>     Enable recursive dir traversal.

       <b>-d</b>     De-dupe the results - only works on <u>btrfs</u> and <u>xfs.</u>

       <b>-A</b>     Opens files readonly when deduping. Primarily for use by privileged users on readonly snapshots.

       <b>-h</b>     Print numbers in human-readable format.

       <b>-q</b>     Quiet mode. Duperemove will only print errors and a short summary of any dedupe.

       <b>--hashfile=hashfile</b>
              Use  a  file  for  storage of hashes instead of memory. This option drastically reduces the memory
              footprint of duperemove and is recommended when your data set is more  than  a  few  files  large.
              <u>Hashfiles</u>  are  also  reusable,  allowing  you  to  further  reduce  the amount of hashing done on
              subsequent dedupe runs.

              If <u>hashfile</u> does not exist it will be created.  If it exists, <b>duperemove</b> will check the file paths
              stored inside of it for changes.  Files which have changed will be  rescanned  and  their  updated
              hashes will be written to the <u>hashfile</u>.  Deleted files will be removed from the <u>hashfile</u>.

              New  files  are  only  added to the <u>hashfile</u> if they are discoverable via the <u>files</u> argument.  For
              that reason you probably want to provide the same <u>files</u> list and  <b>-r</b>  arguments  on  each  run  of
              <b>duperemove</b>.  The file discovery algorithm is efficient and will only visit each file once, even if
              it is already in the <u>hashfile</u>.

              Adding a new path to a hashfile is as simple as adding it to the <u>files</u> argument.

              When  deduping  from a hashfile, duperemove will avoid deduping files which have not changed since
              the last dedupe.

       <b>-L</b>     Print all files in the hashfile and exit. Requires the <b>--hashfile</b> option.  Will  print  additional
              information about each file when run with <b>-v</b>.

       <b>-R</b> <b>[file]</b>
              Remove  file  from the db and exit. Can be specified multiple times. Duperemove will read the list
              from standard input if a hyphen (-) is provided. Requires the <b>--hashfile</b> option.

              <b>Note:</b> If you are piping filenames from another duperemove instance it is advisable to do so into a
              temporary file first as running duperemove simultaneously on the same hashfile  may  corrupt  that
              hashfile.

       <b>--fdupes</b>
              Run in <b>fdupes</b> mode. With this option you can pipe the output of <b>fdupes</b> to duperemove to dedupe any
              duplicate files found. When receiving a file list in this manner, duperemove will skip the hashing
              phase.

       <b>-v</b>     Be verbose.

       <b>--skip-zeroes</b>
              Read  data  blocks  and  skip  any  zeroed  blocks, useful for speedup duperemove, but can prevent
              deduplication of zeroed files.

       <b>-b</b> <b>size</b>
              Use the specified block size for reading file extents. Defaults to 128K.

       <b>--io-threads=N</b>
              Use N threads for  I/O.  This  is  used  by  the  file  hashing  and  dedupe  stages.  Default  is
              automatically detected based on number of host cpus.

       <b>--cpu-threads=N</b>
              Use  N threads for CPU bound tasks. This is used by the duplicate extent finding stage. Default is
              automatically detected based on number of host cpus.

              <b>Note:</b> Hyperthreading can adversely affect performance of the extent finding stage.  If  duperemove
              detects  an  Intel  CPU  with  hyperthreading it will use half the number of cores reported by the
              system for cpu bound tasks.

       <b>--dedupe-options=</b><u>options</u>
              Comma separated list of options which alter how we dedupe. Prepend 'no' to an option in  order  to
              turn it off.

              <b>[no]partial</b>
                     Duperemove  can often find more dedupe by comparing portions of extents to each other. This
                     can be a lengthy, CPU intensive task so it is turned off by default.

                     The code behind this option is under active development and as a result  the  semantics  of
                     the <u>partial</u> argument may change.

              <b>[no]same</b>
                     Defaults to <b>off</b>. Allow dedupe of extents within the same file.

              <b>[no]fiemap</b>
                     Defaults  to  <b>on</b>.  Duperemove uses the <u>fiemap</u> ioctl during the dedupe stage to optimize out
                     already deduped extents as well as to provide an estimate of the space saved  after  dedupe
                     operations are complete.

                     Unfortunately,  some  versions of Btrfs exhibit extremely poor performance in fiemap as the
                     number of references on a file extent goes up. If you are  experiencing  the  dedupe  phase
                     slowing  down  or 'locking up' this option may give you a significant amount of performance
                     back.

                     <b>Note:</b> This does not turn off all usage of fiemap, to disable fiemap during  the  file  scan
                     stage, you will also want to use the <b>--lookup-extents=no</b> option.

              <b>[no]block</b>
                     Deprecated.

       <b>--help</b> Prints help text.

       <b>--lookup-extents=[yes|no]</b>
              Defaults  to  <b>yes</b>.  Allows  duperemove  to  skip checksumming some blocks by checking their extent
              state.

       <b>--read-hashes=hashfile</b>
              <b>This</b> <b>option</b> <b>is</b> <b>primarily</b> <b>for</b> <b>testing.</b> See the <b>--hashfile</b> option if you want to use hashfiles.

              Read hashes from a hashfile. A file list is not required with this option. Dedupe can be  done  if
              duperemove is run from the same base directory as is stored in the hash file (basically duperemove
              has to be able to find the files).

       <b>--write-hashes=hashfile</b>
              <b>This</b> <b>option</b> <b>is</b> <b>primarily</b> <b>for</b> <b>testing.</b> See the <b>--hashfile</b> option if you want to use hashfiles.

              Write hashes to a hashfile. These can be read in at a later date and deduped from.

       <b>--debug</b>
              Print debug messages, forces <b>-v</b> if selected.

       <b>--hash-threads=N</b>
              Deprecated, see <b>--io-threads</b> above.

       <b>--hash=alg</b>
              You  can  choose  between  murmur3  and  xxhash. The default is murmur3 as it is very fast and can
              generate 128 bit digests for a very small chance of collision. Xxhash may be faster but  generates
              only  64  bit  digests.  Both  hashes  are  fast  enough that the default should work well for the
              overwhelming majority of users.

       <b>--exclude=PATTERN</b>
              You an exclude certain files and folders from the deduplication process. This might  be  benefical
              for skipping subvolume snapshot mounts, for instance. You need to provide full path for exclusion.
              For  example providing just a file name with a wildcard i.e <b>duperemove</b> <b>--exclude</b> <b>file-*</b> won't ever
              match because internally duperemove works with absolute paths. Another thing to keep  in  mind  is
              that  shells  usually expand glob pattern so the passed in pattern ought to also be quoted. Taking
              everything into consideration the correct way to pass an exclusion pattern is <b>duperemove</b> <b>--exclude</b>
              <b>"/path/to/dir/file*"</b> <b>/path/to/dir</b>

</pre><h4><b>EXAMPLES</b></h4><pre>
   <b>Simple</b> <b>Usage</b>
       Dedupe the files in directory /foo, recurse into all subdirectories. You only want to use this for  small
       data sets.

              duperemove -dr /foo

       Use duperemove with fdupes to dedupe identical files below directory foo.

              fdupes -r /foo | duperemove --fdupes

   <b>Using</b> <b>Hashfiles</b>
       Duperemove  can  optionally  store  the  hashes  it  calculates in a hashfile. Hashfiles have two primary
       advantages - memory usage and re-usability. When using a hashfile, duperemove will stream computed hashes
       to it, instead of main memory.

       If Duperemove is run with an existing hashfile, it will only scan those files which  have  changed  since
       the  last  time  the  hashfile was updated. The <u>files</u> argument controls which directories duperemove will
       scan for newly added files. In the simplest usage, you rerun duperemove with the same parameters  and  it
       will only scan changed or newly added files - see the first example below.

       Dedupe the files in directory foo, storing hashes in foo.hash. We can run this command multiple times and
       duperemove will only checksum and dedupe changed or newly added files.

              duperemove -dr --hashfile=foo.hash foo/

       Don't scan for new files, only update changed or deleted files, then dedupe.

              duperemove -dr --hashfile=foo.hash

       Add directory bar to our hashfile and discover any files that were recently added to foo.

              duperemove -dr --hashfile=foo.hash foo/ bar/

       List the files tracked by foo.hash.

              duperemove -L --hashfile=foo.hash

</pre><h4><b>FAQ</b></h4><pre>
   <b>Is</b> <b>there</b> <b>an</b> <b>upper</b> <b>limit</b> <b>to</b> <b>the</b> <b>amount</b> <b>of</b> <b>data</b> <b>duperemove</b> <b>can</b> <b>process?</b>
       Duperemove  v0.11  is  fast at reading and cataloging data. Dedupe runs will be memory limited unless the
       '--hashfile' option is used. '--hashfile' allows duperemove to temporarily  store  duplicated  hashes  to
       disk,  thus removing the large memory overhead and allowing for a far larger amount of data to be scanned
       and deduped. Realistically though you will be limited by the speed  of  your  disks  and  cpu.  In  those
       situations  where  resources  are  limited  you  may  have success by breaking up the input data set into
       smaller pieces.

       When using a hashfile, duperemove will only store duplicate hashes in  memory.  During  normal  operation
       then  the  hash  tree will make up the largest portion of duperemove memory usage. As of Duperemove v0.11
       hash entries are 88 bytes in size. If you know the number of duplicate blocks in your data  set  you  can
       get a rough approximation of memory usage by multiplying with the hash entry size.

       Actual  performance  numbers  are  dependent  on hardware - up to date testing information is kept on the
       duperemove wiki (see below for the link).

   <b>How</b> <b>large</b> <b>of</b> <b>a</b> <b>hashfile</b> <b>will</b> <b>duperemove</b> <b>create?</b>
       Hashfiles are essentially sqlite3 database files with several tables, the largest of which are the  files
       and  extents  tables.  Each  extents  table  entry is about 72 bytes though that may grow as features are
       added. The size of a files table entry depends on the file path but a good estimate is around  270  bytes
       per file. The number of extents in a data set is directly proportional to file fragmentation level.

       If  you  know  the total number of extents and files in your data set then you can calculate the hashfile
       size as:

       <b>Hashfile</b> <b>Size</b> <b>=</b> <b>Num</b> <b>Hashes</b> <b>X</b> <b>72</b> <b>+</b> <b>Num</b> <b>Files</b> <b>X</b> <b>270</b>

       Using a real world example of 1TB (8388608 128K blocks) of data over 1000 files:

       8388608 * 72 + 270 * 1000 = 755244720 or about <b>720MB</b> <b>for</b> <b>1TB</b> <b>spread</b> <b>over</b> <b>1000</b> <b>files.</b>

       <b>Note</b> <b>that</b> <b>none</b> <b>of</b> <b>this</b> <b>takes</b> <b>database</b> <b>overhead</b> <b>into</b> <b>account.</b>

   <b>Is</b> <b>is</b> <b>safe</b> <b>to</b> <b>interrupt</b> <b>the</b> <b>program</b> <b>(Ctrl-C)?</b>
       Yes, Duperemove uses a transactional database engine and organizes db changes to take advantage of  those
       features.  The  result  is  that you should be able to ctrl-c the program at any point and re-run without
       experiencing corruption of your hashfile.

   <b>I</b> <b>got</b> <b>two</b> <b>identical</b> <b>files,</b> <b>why</b> <b>are</b> <b>they</b> <b>not</b> <b>deduped?</b>
       Duperemove by default works on extent granularity. What this means is if there are two  files  which  are
       logically identical (have the same content) but are laid out on disk with different extent structure they
       won't  be  deduped.  For example if 2 files are 128k each and their content are identical but one of them
       consists of a single 128k extent and the other of 2 x 64k  extents  then  they  won't  be  deduped.  This
       behavior  is  dependent  on  the  current  implementation and is subject to change as duperemove is being
       improved.

   <b>How</b> <b>can</b> <b>I</b> <b>find</b> <b>out</b> <b>my</b> <b>space</b> <b>savings</b> <b>after</b> <b>a</b> <b>dedupe?</b>
       Duperemove will print out an estimate of the saved space after a dedupe operation for you.

       You can get a more accurate picture by running 'btrfs fi df' before and after each duperemove run.

       Be careful about using the 'df' tool on btrfs - it is common for space reporting  to  be  'behind'  while
       delayed updates get processed, so an immediate df after deduping might not show any savings.

   <b>Why</b> <b>is</b> <b>the</b> <b>total</b> <b>deduped</b> <b>data</b> <b>report</b> <b>an</b> <b>estimate?</b>
       At  the moment duperemove can detect that some underlying extents are shared with other files, but it can
       not resolve which files those extents are shared with.

       Imagine duperemove is examing a series of files and it notes a shared data region in one  of  them.  That
       data  could  be shared with a file outside of the series. Since duperemove can't resolve that information
       it will account the shared data  against  our  dedupe  operation  while  in  reality,  the  kernel  might
       deduplicate it further for us.

   <b>Why</b> <b>are</b> <b>my</b> <b>files</b> <b>showing</b> <b>dedupe</b> <b>but</b> <b>my</b> <b>disk</b> <b>space</b> <b>is</b> <b>not</b> <b>shrinking?</b>
       This is a little complicated, but it comes down to a feature in Btrfs called _bookending_. The Btrfs wiki
       explains this in detail: <a href="http://en.wikipedia.org/wiki/Btrfs">http://en.wikipedia.org/wiki/Btrfs</a>#Extents.

       Essentially  though,  the  underlying  representation  of an extent in Btrfs can not be split (with small
       exception). So sometimes we can end up in a situation where a file extent gets partially deduped (and the
       extents marked as shared) but the underlying extent item is not freed or truncated.

   <b>Is</b> <b>duperemove</b> <b>safe</b> <b>for</b> <b>my</b> <b>data?</b>
       Yes. To be specific, duperemove does not deduplicate the data itself.  It  simply  finds  candidates  for
       dedupe  and  submits  them  to the Linux kernel extent-same ioctl. In order to ensure data integrity, the
       kernel locks out other access to the file and does a byte-by-byte  compare  before  proceeding  with  the
       dedupe.

   <b>What</b> <b>is</b> <b>the</b> <b>cost</b> <b>of</b> <b>deduplication?</b>
       Deduplication  will  lead  to  increased  fragmentation. The blocksize chosen can have an effect on this.
       Larger blocksizes will fragment less but may not save you as much space. Conversely, smaller block  sizes
       may save more space at the cost of increased fragmentation.

</pre><h4><b>NOTES</b></h4><pre>
       Deduplication is currently only supported by the <u>btrfs</u> and <u>xfs</u> filesystem.

       The Duperemove project page can be found at https://github.com/markfasheh/duperemove

       There is also a wiki at https://github.com/markfasheh/duperemove/wiki

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man8/hashstats.8.html">hashstats</a>(8)</b> <b><a href="../man5/filesystems.5.html">filesystems</a>(5)</b> <b><a href="../man8/btrfs.8.html">btrfs</a>(8)</b> <b><a href="../man8/xfs.8.html">xfs</a>(8)</b> <b><a href="../man1/fdupes.1.html">fdupes</a>(1)</b>

Version 0.11                                     September 2016                                    <u><a href="../man8/duperemove.8.html">duperemove</a></u>(8)
</pre>
 </div>
</div></section>
</div>
</body>
</html>