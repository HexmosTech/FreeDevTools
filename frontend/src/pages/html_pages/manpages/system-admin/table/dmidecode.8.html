<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>dmidecode - DMI table decoder</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/dmidecode">dmidecode_3.6-2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       dmidecode - DMI table decoder

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>dmidecode</b> [<u>OPTIONS</u>]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>dmidecode</b>  is  a  tool  for dumping a computer's DMI (some say SMBIOS) table contents in a human-readable
       format. This table contains a description of the system's hardware components, as well  as  other  useful
       pieces  of  information  such as serial numbers and BIOS revision. Thanks to this table, you can retrieve
       this information without having to probe for the actual hardware.  While this is a good point in terms of
       report speed and safeness, this also makes the presented information possibly unreliable.

       The DMI table doesn't only describe what the system is currently made of, it also can report the possible
       evolutions (such as the fastest supported CPU or the maximal amount of memory supported).

       SMBIOS stands for System Management BIOS,  while  DMI  stands  for  Desktop  Management  Interface.  Both
       standards are tightly related and developed by the DMTF (Desktop Management Task Force).

       As  you  run it, <b>dmidecode</b> will try to locate the DMI table. It will first try to read the DMI table from
       sysfs, and next try reading directly from memory if  sysfs  access  failed.   If  <b>dmidecode</b>  succeeds  in
       locating a valid DMI table, it will then parse this table and display a list of records like this one:

       Handle 0x0002, DMI type 2, 8 bytes.  Base Board Information
               Manufacturer: Intel
               Product Name: C440GX+
               Version: 727281-001
               Serial Number: INCY92700942

       Each record has:

       • A  handle.  This  is  a  unique  identifier, which allows records to reference each other. For example,
         processor records usually reference cache memory records using their handles.

       • A type. The SMBIOS specification defines different types of elements a computer can be made of. In this
         example, the type is 2, which means that the record contains "Base Board Information".

       • A size. Each record has a 4-byte header (2 for the handle, 1 for the type, 1 for the size), the rest is
         used by the record data. This value doesn't take text strings into account (these are placed at the end
         of the record), so the actual length of the record may be (and is often)  greater  than  the  displayed
         value.

       • Decoded values. The information presented of course depends on the type of record. Here, we learn about
         the board's manufacturer, model, version and serial number.

</pre><h4><b>OPTIONS</b></h4><pre>
       <b>-d</b>, <b>--dev-mem</b> <u>FILE</u>
              Read memory from device <u>FILE</u> (default: <u>/dev/mem</u>)

       <b>-q</b>, <b>--quiet</b>
              Be  less  verbose.  Unknown,  inactive  and  OEM-specific entries are not displayed. Meta-data and
              handle references are hidden.

           <b>--no-quirks</b>
              Decode everything exactly as it is in the table, without trying to fix up common mistakes or  hide
              irrelevant fields.  This mode is primarily aimed at firmware developers.

       <b>-s</b>, <b>--string</b> <u>KEYWORD</u>
              Only  display  the  value  of the DMI string identified by <u>KEYWORD</u>.  It must be a keyword from the
              following list: <b>bios-vendor</b>, <b>bios-version</b>,  <b>bios-release-date</b>,  <b>bios-revision</b>,  <b>firmware-revision</b>,
              <b>system-manufacturer</b>,   <b>system-product-name</b>,   <b>system-version</b>,  <b>system-serial-number</b>,  <b>system-uuid</b>,
              <b>system-sku-number</b>,      <b>system-family</b>,       <b>baseboard-manufacturer</b>,       <b>baseboard-product-name</b>,
              <b>baseboard-version</b>,     <b>baseboard-serial-number</b>,     <b>baseboard-asset-tag</b>,     <b>chassis-manufacturer</b>,
              <b>chassis-type</b>,   <b>chassis-version</b>,   <b>chassis-serial-number</b>,   <b>chassis-asset-tag</b>,   <b>processor-family</b>,
              <b>processor-manufacturer</b>,  <b>processor-version</b>,  <b>processor-frequency</b>.   Each  keyword corresponds to a
              given DMI type and a given offset within this entry type.  Not all strings may  be  meaningful  or
              even  defined  on all systems. Some keywords may return more than one result on some systems (e.g.
              <b>processor-version</b> on a multi-processor system).  If <u>KEYWORD</u> is not provided or not valid,  a  list
              of  all  valid  keywords is printed and <b>dmidecode</b> exits with an error.  This option cannot be used
              more than once.

              Note: on Linux, most of these strings can alternatively be read  directly  from  <b>sysfs</b>,  typically
              from  files  under  <u><a href="file:/sys/devices/virtual/dmi/id">/sys/devices/virtual/dmi/id</a></u>.  Most of these files are even readable by regular
              users.

           <b>--list-strings</b>
              List available string keywords, which can then be passed to the <b>--string</b> option.

       <b>-t</b>, <b>--type</b> <u>TYPE</u>
              Only display the entries of type <u>TYPE</u>. It can be either a DMI type number,  or  a  comma-separated
              list  of  type  numbers,  or  a keyword from the following list: <b>bios</b>, <b>system</b>, <b>baseboard</b>, <b>chassis</b>,
              <b>processor</b>, <b>memory</b>, <b>cache</b>, <b>connector</b>, <b>slot</b>.  Refer to the DMI TYPES section below for details.   If
              this option is used more than once, the set of displayed entries will be the union of all the giv‐
              en  types.   If  <u>TYPE</u>  is  not  provided or not valid, a list of all valid keywords is printed and
              <b>dmidecode</b> exits with an error.

           <b>--list-types</b>
              List available type keywords, which can then be passed to the <b>--type</b> option.

       <b>-H</b>, <b>--handle</b> <u>HANDLE</u>
              Only display the entry whose handle matches <u>HANDLE</u>.  <u>HANDLE</u> is a 16-bit integer.

       <b>-u</b>, <b>--dump</b>
              Do not decode the entries, dump their contents as hexadecimal instead.  Note that this is still  a
              text  output,  no binary data will be thrown upon you. The strings attached to each entry are dis‐
              played as both hexadecimal and ASCII. This option is mainly useful for debugging.

           <b>--dump-bin</b> <u>FILE</u>
              Do not decode the entries, instead dump the DMI data to a file in binary form. The generated  file
              is suitable to pass to <b>--from-dump</b> later.  <u>FILE</u> must not exist.

           <b>--from-dump</b> <u>FILE</u>
              Read the DMI data from a binary file previously generated using <b>--dump-bin</b>.

           <b>--no-sysfs</b>
              Do not attempt to read DMI data from sysfs files. This is mainly useful for debugging.

           <b>--oem-string</b> <u>N</u>
              Only display the value of the OEM string number <u>N</u>. The first OEM string has number <b>1</b>. With special
              value <b>count</b>, return the number of OEM strings instead.

       <b>-h</b>, <b>--help</b>
              Display usage information and exit

       <b>-V</b>, <b>--version</b>
              Display the version and exit

       Options <b>--string</b>, <b>--type,</b> <b>--dump-bin</b> and <b>--oem-string</b> determine the output format and are mutually exclu‐
       sive.

       Please note in case of <b>dmidecode</b> is run on a system with BIOS that boasts new SMBIOS specification, which
       is not supported by the tool yet, it will print out relevant message in addition to requested data on the
       very top of the output. Thus informs the output data is not reliable.

</pre><h4><b>DMI</b> <b>TYPES</b></h4><pre>
       The SMBIOS specification defines the following DMI types:
       Type   Information
       ────────────────────────────────────────────
          0   BIOS
          1   System
          2   Baseboard
          3   Chassis
          4   Processor
          5   Memory Controller
          6   Memory Module
          7   Cache
          8   Port Connector
          9   System Slots
         10   On Board Devices
         11   OEM Strings
         12   System Configuration Options
         13   BIOS Language
         14   Group Associations
         15   System Event Log
         16   Physical Memory Array
         17   Memory Device
         18   32-bit Memory Error
         19   Memory Array Mapped Address
         20   Memory Device Mapped Address
         21   Built-in Pointing Device
         22   Portable Battery
         23   System Reset
         24   Hardware Security
         25   System Power Controls
         26   Voltage Probe
         27   Cooling Device
         28   Temperature Probe
         29   Electrical Current Probe
         30   Out-of-band Remote Access
         31   Boot Integrity Services
         32   System Boot
         33   64-bit Memory Error
         34   Management Device
         35   Management Device Component
         36   Management Device Threshold Data
         37   Memory Channel
         38   IPMI Device
         39   Power Supply
         40   Additional Information
         41   Onboard Devices Extended Information
         42   Management Controller Host Interface

       Additionally,  type 126 is used for disabled entries and type 127 is an end-of-table marker. Types 128 to
       255 are for OEM-specific data.  <b>dmidecode</b> will display these entries by default, but it can  only  decode
       them when the vendors have contributed documentation or code for them.

       Keywords  can  be used instead of type numbers with <b>--type</b>.  Each keyword is equivalent to a list of type
       numbers:

       Keyword     Types
       ──────────────────────────────
       bios        0, 13
       system      1, 12, 15, 23, 32
       baseboard   2, 10, 41
       chassis     3
       processor   4
       memory      5, 6, 16, 17
       cache       7
       connector   8
       slot        9

       Keywords are matched case-insensitively. The following command lines are equivalent:

       • dmidecode --type 0 --type 13

       • dmidecode --type 0,13

       • dmidecode --type bios

       • dmidecode --type BIOS

</pre><h4><b>BINARY</b> <b>DUMP</b> <b>FILE</b> <b>FORMAT</b></h4><pre>
       The binary dump files generated by <b>--dump-bin</b> and read using <b>--from-dump</b> are formatted as follows:

       • The SMBIOS or DMI entry point is located at offset 0x00.  It is crafted to hard-code the table  address
         at offset 0x20.

       • The DMI table is located at offset 0x20.

</pre><h4><b>UUID</b> <b>FORMAT</b></h4><pre>
       There is some ambiguity about how to interpret the UUID fields prior to SMBIOS specification version 2.6.
       There  was  no mention of byte swapping, and RFC 4122 says that no byte swapping should be applied by de‐
       fault. However, SMBIOS specification version 2.6 (and later) explicitly states that the first 3 fields of
       the UUID should be read as little-endian numbers (byte-swapped).  Furthermore, it implies that  the  same
       was  already true for older versions of the specification, even though it was not mentioned. In practice,
       many hardware vendors were not byte-swapping the UUID. So, in order to preserve compatibility, it was de‐
       cided to interpret the UUID fields according to RFC 4122 (no byte swapping) when the  SMBIOS  version  is
       older  than 2.6, and to interpret the first 3 fields as little-endian (byte-swapped) when the SMBIOS ver‐
       sion is 2.6 or later. The Linux kernel follows the same logic.

</pre><h4><b>FILES</b></h4><pre>
       <u>/dev/mem</u>
       <u><a href="file:/sys/firmware/dmi/tables/smbios_entry_point">/sys/firmware/dmi/tables/smbios_entry_point</a></u> (Linux only)
       <u><a href="file:/sys/firmware/dmi/tables/DMI">/sys/firmware/dmi/tables/DMI</a></u> (Linux only)

</pre><h4><b>BUGS</b></h4><pre>
       More often than not, information contained in the DMI tables is inaccurate, incomplete or simply wrong.

</pre><h4><b>AUTHORS</b></h4><pre>
       Alan Cox, Jean Delvare

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man8/biosdecode.8.html">biosdecode</a></b>(8), <b><a href="../man4/mem.4.html">mem</a></b>(4), <b><a href="../man8/ownership.8.html">ownership</a></b>(8), <b><a href="../man8/vpddecode.8.html">vpddecode</a></b>(8)

dmidecode                                         February 2023                                     <u><a href="../man8/DMIDECODE.8.html">DMIDECODE</a></u>(8)
</pre>
 </div>
</div></section>
</div>
</body>
</html>