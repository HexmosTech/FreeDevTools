<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pam_cgfs - cgroup management for unprivileged LXC containers.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/lxc">lxc_6.0.4-4ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       pam_cgfs - cgroup management for unprivileged LXC containers.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>pam_cgfs.so</b> {-c <u>kernel_controller,name=named_controller</u>}

</pre><h4><b>DESCRIPTION</b></h4><pre>
       LXC  has  supported  fully  unprivileged containers since LXC 1.0.  Fully unprivileged containers are the
       safest containers and are run by normal (non-root) users. This is achieved by using  user  namespaces  by
       mapping between a range of UIDs and GIDs on the host to a different (unprivileged) range of UIDs and GIDs
       in  the  container.  That  means  the  uid 0 (root) in the container is mapped to an unprivileged user id
       (something like 1000000) outside of the container and only has rights on resources that it owns itself.

       Cgroup management of fully unprivileged containers means restricting the resources used by these contain‐
       ers like limiting the CPU usage of a container, or the number of processes it is allowed to spawn, or the
       memory it is allowed to consume. It is clear that the fully unprivileged containers  are  run  by  normal
       users  and  there  is a need to limit and manage resource consumption among the containers.  But unprivi‐
       leged cgroup management is not easy with most init systems.  So, the pam_cgfs.so came into existence.

       The <b>pam_cgfs.so</b> module can handle pure cgroupfs v1 (<u><a href="file:/sys/fs/cgroup/">/sys/fs/cgroup/</a>$controller</u>) and mixed  mounts,  where
       some  controllers are mounted in a standard cgroupfs v1 hierarchy (<u><a href="file:/sys/fs/cgroup/">/sys/fs/cgroup/</a>$controller</u>) and others
       in cgroupfs v2 hierarchy (<u>/sys/fs/cgroup/unified</u>).  Writeable cgroups are either  created  for  all  con‐
       trollers  or, if specified, for only controllers listed as arguments on the command line.  Pure cgroup v2
       mount is not covered by the pam_cgfs.so module.

       The cgroup created <u>user/$user/n</u> will be for the nth session under cgroup kernel controller hierarchy.

       Systems with a systemd init system are treated  specifically,  both  with  respect  to  cgroupfs  v1  and
       cgroupfs  v2. For both, cgroupfs v1 and cgroupfs v2, the module checks whether systemd already placed the
       user in a cgroup it created <u>user.slice/user-$uid/session-n.scope</u> by checking whether $uid ==  login  uid.
       If  so,  the  login  user  chown  the  <u>session-n.scope</u>,  else  a  cgroup  is  created  as  outlined above
       (<u>user/$user/n</u>) and chown it to login uid. If the init system has already placed the login user  inside  a
       session specific group, the <b>pam_cgfs.so</b> module is smart enough to detect it and re-use the cgroup.

       In  essence,  the  <b>pam_cgfs.so</b>  module  takes care of placing unprivileged (non-root) users into writable
       cgroups at login and also cleaning up these cgroup hierarchies on logout, so they are  free  to  delegate
       resources to containers as needed that have been provided to them.

</pre><h4><b>OPTIONS</b></h4><pre>
       <b>-c</b> <u>controller-list</u>
              Takes  a string argument which sets the list of kernel controllers and named controllers delimited
              by commas in-between “,”. Named controllers need to be  specified  in  the  form  “name=$namedcon‐
              troller”.  Can  use  “all” enable all cgroup resource controller hierarchies. Specifying “all” and
              other controllers explicitly returns PAM_SESSION_ERR.

</pre><h4><b>MODULE</b> <b>TYPES</b> <b>PROVIDED</b></h4><pre>
       Only <b>session</b> module type is provided (and needed).

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       PAM_SUCCESS
              Writeable cgroups have been created for the user.

       PAM_SESSION_ERR
              Failed to create writable cgroups for the user.

</pre><h4><b>FILES</b></h4><pre>
       <a href="file:/etc/pam.d/common-session">/etc/pam.d/common-session</a>{,-noninteractive}
              Default configuration is added at the end of these files.

</pre><h4><b>EXAMPLE</b></h4><pre>
       session optional    pam_cgfs.so -c freezer,memory,named=systemd
       # default configuration
       # user writable cgroups are created under freezer, memory and named cgroup systemd hierarchies.
       # <a href="file:/sys/fs/cgroup/">/sys/fs/cgroup/</a>$controller/user/$user/n for freezer,memory.
       # /sys/fs/cgroup/systemd/user.slice/user-$uid/session-n.scope for systemd.

       session optional    pam_cgfs.so -c all
       # user writable cgroups are created under all cgroup controllers.

       session optional    pam_cgfs.so -c all,memory,freezer
       # invalid argument and returns PAM_SESSION_ERR

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/lxc-cgroup.1.html">lxc-cgroup</a></b>(1), <b><a href="../man7/cgroups.7.html">cgroups</a></b>(7), <b><a href="../man7/user_namespaces.7.html">user_namespaces</a></b>(7), <b><a href="../man7/namespaces.7.html">namespaces</a></b>(7), <b><a href="../man8/pam.8.html">pam</a></b>(8)

                                                   2025-06-09                                        <u><a href="../man8/pam_cgfs.8.html">pam_cgfs</a></u>(8)
</pre>
 </div>
</div></section>
</div>
</body>
</html>