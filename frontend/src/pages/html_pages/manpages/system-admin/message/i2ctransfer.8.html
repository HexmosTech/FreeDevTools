<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>i2ctransfer - send user-defined I2C messages in one transfer</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/i2c-tools">i2c-tools_4.4-2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       i2ctransfer - send user-defined I2C messages in one transfer

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>i2ctransfer</b> [<b>-a</b>] [<b>-b</b>] [<b>-f</b>] [<b>-v</b>] [<b>-y</b>] <u>i2cbus</u> <u>desc</u> [<u>data</u>] [<u>desc</u> [<u>data</u>]] ...
       <b>i2ctransfer</b> <b>-h</b>
       <b>i2ctransfer</b> <b>-V</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>i2ctransfer</b>  is  a  program  to  create  I2C  messages  and send them combined as one transfer.  For read
       messages, the contents of the received buffers are printed to stdout, one line per read message.
       Please note the difference between a <u>transfer</u> and a <u>message</u> here.  A transfer  may  consist  of  multiple
       messages  and  is  started  with a START condition and ends with a STOP condition as described in the I2C
       specification.  Messages within the transfer are concatenated using the REPEATED START condition which is
       described there as well.  There are some advantages of having multiple messages in one transfer.   First,
       some  devices  keep  their  internal  states for REPEATED START but reset them after a STOP.  Second, you
       cannot get interrupted during one transfer, but it might happen between multiple transfers.  Interruption
       could happen on hardware level by another I2C master on the bus, or at software level by another I2C user
       who got its transfer scheduled between yours.  This program helps you to create proper transfers for your
       needs.

</pre><h4><b>OPTIONS</b></h4><pre>
       <b>-a</b>     Allow using addresses between 0x00 - 0x07 and 0x78 - 0x7f. Not recommended.

       <b>-b</b>     Print data from read messages as binary data. Disables <u>-v</u> (verbose).  Useful  for  piping  into  a
              pretty printing tool like <b>hexdump</b> or for redirecting into a file to be analyzed later.

       <b>-f</b>     Force  access  to  the  device even if it is already busy.  By default, <b>i2ctransfer</b> will refuse to
              access a device which is already under the control  of  a  kernel  driver.   Using  this  flag  is
              dangerous,  it can seriously confuse the kernel driver in question.  It can also cause <b>i2ctransfer</b>
              to silently write to the wrong register.  So use at your own risk and only if you know what you're
              doing.

       <b>-h</b>     Display the help and exit.

       <b>-v</b>     Enable verbose output.  It will print infos about all  messages  sent,  i.e.  not  only  for  read
              messages but also for write messages.

       <b>-V</b>     Display the version and exit.

       <b>-y</b>     Disable  interactive  mode.   By  default,  <b>i2ctransfer</b> will wait for a confirmation from the user
              before messing with the I2C bus.  When this flag is used, it will perform the operation  directly.
              This is mainly meant to be used in scripts.

</pre><h4><b>ARGUMENTS</b></h4><pre>
       The  first  parameter  <u>i2cbus</u> indicates the number or name of the I2C bus to be used.  This number should
       correspond to one of the busses listed by <b>i2cdetect</b> <b>-l.</b>

       The next parameter is one or multiple <u>desc</u> blocks.  The number of blocks is limited by the  Linux  Kernel
       and defined by I2C_RDWR_IOCTL_MAX_MSGS (42 as of v4.10).  <u>desc</u> blocks are composed like this:

       <u>{r|w}&lt;length_of_message&gt;[@address]</u>

       <b>{r|w}</b>  specifies if the message is read or write

       <b>&lt;length_of_message&gt;</b>
              specifies the number of bytes read or written in this message.  It is parsed as an unsigned 16 bit
              integer, but note that the Linux Kernel applies an additional upper limit (8192 as of v4.10).  For
              read  messages  to  targets  which  support SMBus Block transactions, it can also be '?', then the
              target will determine the length.

       <b>[@address]</b>
              specifies the 7-bit address of the chip to be accessed for this message, and is  an  integer.   If
              omitted,  reuse  the  previous  address.   Normally,  addresses outside the range of 0x08-0x77 and
              addresses with a kernel driver attached to them will be blocked.  This can be overridden  with  <u>-a</u>
              (all)  or  <u>-f</u>  (force).   Be  very  careful  when using these!  10-bit addresses are currently not
              supported at all.

       If the I2C message is a write, then a <u>data</u> block with the data to be written  follows.   It  consists  of
       <u>&lt;length_of_message&gt;</u>  bytes  which  can be marked with the usual prefixes for hexadecimal, octal, etc.  To
       make it easier to create larger data blocks easily, the data byte can have a suffix.

       =      keep value constant until end of message (i.e. 0= means 0, 0, 0, ...)

       +      increase value by 1 until end of message (i.e. 0+ means 0, 1, 2, ...)

       -      decrease value by 1 until end of message (i.e. 0xff- means 0xff, 0xfe, 0xfd, ...)

       p      use value as seed for an 8 bit pseudo random sequence (i.e. 0p means 0x00, 0x50, 0xb0, ...)

</pre><h4><b>EXAMPLES</b></h4><pre>
       On bus 0, from an EEPROM at address 0x50, read 8 byte from offset 0x64 (first message writes one byte  to
       set the memory pointer to 0x64, second message reads from the same chip):
              # i2ctransfer 0 w1@0x50 0x64 r8

       For  the  same  EEPROM,  at  offset 0x42 write 0xff 0xfe ... 0xf0 (one write message; first byte sets the
       memory pointer to 0x42, 0xff is the first data byte, all following data bytes are decreased by one):

              # i2ctransfer 0 w17@0x50 0x42 0xff-
</pre><h4><b>WARNING</b></h4><pre>
       <b>i2ctransfer</b> can be extremely dangerous if used improperly.  It can confuse your I2C bus, cause data loss,
       or have more serious side effects.  Writing to a serial EEPROM on a memory DIMM (chip  addresses  between
       0x50  and 0x57) may DESTROY your memory, leaving your system unbootable!  Be extremely careful using this
       program.

</pre><h4><b>BUGS</b></h4><pre>
       To report bugs or send fixes, please write to the Linux I2C mailing list &lt;<a href="mailto:linux-i2c@vger.kernel.org">linux-i2c@vger.kernel.org</a>&gt; with
       Cc to the current maintainer: Jean Delvare &lt;<a href="mailto:jdelvare@suse.de">jdelvare@suse.de</a>&gt;.

</pre><h4><b>AUTHORS</b></h4><pre>
       Wolfram Sang, based on <b>i2cget</b> by Jean Delvare

       This manual page was originally written by Wolfram Sang based on the manual for <b>i2cset</b> by  David  Z  Maze
       &lt;<a href="mailto:dmaze@debian.org">dmaze@debian.org</a>&gt;.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man8/i2cdetect.8.html">i2cdetect</a></b>(8),<b><a href="../man8/i2cdump.8.html">i2cdump</a></b>(8),<b><a href="../man8/i2cget.8.html">i2cget</a></b>(8),<b><a href="../man8/i2cset.8.html">i2cset</a></b>(8)

                                                    May 2022                                      <u><a href="../man8/i2ctransfer.8.html">i2ctransfer</a></u>(8)
</pre>
 </div>
</div></section>
</div>
</body>
</html>