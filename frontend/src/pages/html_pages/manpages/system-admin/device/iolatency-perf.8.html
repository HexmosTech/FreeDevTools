<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>iolatency - summarize block device I/O latency as a histogram. Uses Linux ftrace.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/perf-tools-unstable">perf-tools-unstable_1.0.1~20200130+git49b8cdf-1ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       iolatency - summarize block device I/O latency as a histogram. Uses Linux ftrace.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>iolatency</b> [-hQT] [-d device] [-i iotype] [interval [count]]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This shows the distribution of latency, allowing modes and latency outliers to be identified and studied.
       For more details of block device I/O, use <a href="../man8/iosnoop.8.html">iosnoop</a>(8).

       This  is  a proof of concept tool using ftrace, and involves user space processing and related overheads.
       See the OVERHEAD section.

       NOTE: Due to the way trace buffers are switched per interval, there is the possibility of losing a  small
       number  of  I/O  (usually less than 1%). The summary therefore shows the general distribution, but may be
       slightly incomplete. If 100% of I/O must be studied, use <a href="../man8/iosnoop.8.html">iosnoop</a>(8) and post-process.  Also note that I/O
       may be missed when the trace buffer is full: see the interval section in OPTIONS.

       Since this uses ftrace, only the root user can use this tool.

</pre><h4><b>REQUIREMENTS</b></h4><pre>
       FTRACE CONFIG, and the  tracepoints  block:block_rq_issue  and  block:block_rq_complete,  which  you  may
       already have enabled and available on recent Linux kernels. And awk.

</pre><h4><b>OPTIONS</b></h4><pre>
       -d device
              Only  show  I/O issued by this device. (eg, "202,1"). This matches the DEV column in the iolatency
              output, and is filtered in-kernel.

       -i iotype
              Only show I/O issued that matches this I/O type. This matches the TYPE  column  in  the  iolatency
              output,  and  wildcards  ("*")  can  be used at the beginning or end (only). Eg, "*R*" matches all
              reads. This is filtered in-kernel.

       -h     Print usage message.

       -Q     Include block I/O queueing time. This uses block I/O  queue  insertion  as  the  start  tracepoint
              (block:block_rq_insert), instead of block I/O issue (block:block_rq_issue).

       -T     Include timestamps with each summary output.

       interval
              Interval between summary histograms, in seconds.

              During the interval, trace output will be buffered in-kernel, which is then read and processed for
              the  summary. This buffer has a fixed size per-CPU (see /sys/kernel/debug/tracing/buffer_size_kb).
              If you think events are missing, try increasing that size (the bufsize_kb setting  in  iolatency).
              With the default setting (4 Mbytes), I'd expect this to happen around 50k I/O per summary.

       count  Number of summaries to print.

</pre><h4><b>EXAMPLES</b></h4><pre>
       Default output, print a summary of block I/O latency every 1 second:
              # <b>iolatency</b>

       Include block I/O queue time:
              <b>iolatency</b> <b>-Q</b>

       Print 5 x 1 second summaries:
              # <b>iolatency</b> <b>1</b> <b>5</b>

       Trace reads only:
              # <b>iolatency</b> <b>-i</b> <b>'*R*'</b>

       Trace I/O issued to device 202,1 only:
              # <b>iolatency</b> <b>-d</b> <b>202,1</b>

</pre><h4><b>FIELDS</b></h4><pre>
       &gt;=(ms) Latency was greater than or equal-to this value, in milliseconds.

       &lt;(ms)  Latency was less than this value, in milliseconds.

       I/O    Number of block device I/O in this latency range, during the interval.

       Distribution
              ASCII histogram representation of the I/O column.

</pre><h4><b>OVERHEAD</b></h4><pre>
       Block  device  I/O  issue  and  completion  events  are traced and buffered in-kernel, then processed and
       summarized in user space. There may be measurable overhead with this  approach,  relative  to  the  block
       device IOPS.

       The  overhead  may be acceptable in many situations. If it isn't, this tool can be reimplemented in C, or
       using a different tracer (eg, perf_events, SystemTap, ktap.)

</pre><h4><b>SOURCE</b></h4><pre>
       This is from the perf-tools collection.

              https://github.com/brendangregg/perf-tools

       Also look under the examples directory for a text file containing example usage, output,  and  commentary
       for this tool.

</pre><h4><b>OS</b></h4><pre>
       Linux

</pre><h4><b>STABILITY</b></h4><pre>
       Unstable - in development.

</pre><h4><b>AUTHOR</b></h4><pre>
       Brendan Gregg

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man8/iosnoop.8.html">iosnoop</a>(8), <a href="../man1/iostat.1.html">iostat</a>(1)

USER COMMANDS                                      2014-07-12                                       <u><a href="../man8/iolatency.8.html">iolatency</a></u>(8)
</pre>
 </div>
</div></section>
</div>
</body>
</html>