<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>flashrom - detect, read, write, verify and erase flash chips</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/flashrom">flashrom_1.4.0-3ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       <b>flashrom</b> - detect, read, write, verify and erase flash chips

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>flashrom</b> [-h|-R|-L|-z|
           -p &lt;programmername&gt;[:&lt;parameters&gt;] [-c &lt;chipname&gt;]
             (--flash-name|--flash-size|
               [-E|-x|-r &lt;file&gt;|-w &lt;file&gt;|-v &lt;file&gt;]
               [(-l &lt;file&gt;|--ifd|--fmap|--fmap-file &lt;file&gt;)
                 [-i &lt;include&gt;[:&lt;file&gt;]]]
               [--wp-status] [--wp-list] [--wp-enable|--wp-disable]
               [--wp-range &lt;start&gt;,&lt;length&gt;|--wp-region &lt;region&gt;]
               [-n] [-N] [-f])]
         [-V[V[V]]] [-o &lt;logfile&gt;] [--progress]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>flashrom</b>  is  a  utility  for detecting, reading, writing, verifying and erasing flash chips.  It's often
       used to flash BIOS/EFI/coreboot/firmware images in-system using a supported mainboard.  However, it  also
       supports  various external PCI/USB/parallel-port/serial-port based devices which can program flash chips,
       including some network cards (NICs), SATA/IDE controller cards, graphics cards, the  Bus  Pirate  device,
       various FTDI FT2232/FT4232H/FT4233H/FT232H based USB devices, and more.

       It  supports a wide range of DIP32, PLCC32, DIP8, SO8/SOIC8, TSOP32, TSOP40, TSOP48, and BGA chips, which
       use various protocols such as LPC, FWH, parallel flash, or SPI.

</pre><h4><b>OPTIONS</b></h4><pre>
       You can specify one of <b>-h</b>, <b>-R</b>, <b>-L</b>, <b>-z</b>, <b>-E</b>, <b>-r</b>, <b>-w</b>, <b>-v</b> or no operation.  If  no  operation  is  specified,
       <b>flashrom</b>  will only probe for flash chips. It is recommended that if you try <b>flashrom</b> the first time on a
       system, you run it in probe-only mode and check the output.  Also you are advised to  make  a  backup  of
       your current ROM contents with <b>-r</b> before you try to write a new image.  All operations involving any chip
       access (probe/read/write/...) require the <b>-p/--programmer</b> option to be used (please see below).

       <b>-r,</b> <b>--read</b> <b>&lt;file&gt;</b>
              Read  flash ROM contents and save them into the given <b>&lt;file&gt;</b>.  If the file already exists, it will
              be overwritten.

       <b>-w,</b> <b>--write</b> <b>(&lt;file&gt;|-)</b>
              Write <b>&lt;file&gt;</b> into flash ROM. If <b>-</b> is provided instead, contents will be  read  from  stdin.   This
              will first automatically erase the chip, then write to it.

              In the process the chip is also read several times. First an in-memory backup is made for disaster
              recovery  and  to  be able to skip regions that are already equal to the image file.  This copy is
              updated along with the write operation. In case of erase errors it  is  even  re-read  completely.
              After  writing  has  finished and if verification is enabled, the whole flash chip is read out and
              compared with the input image.

       <b>-n,</b> <b>--noverify</b>
              Skip the automatic verification of flash ROM contents after writing.  Using  this  option  is  <b>not</b>
              recommended,  you  should only use it if you know what you are doing and if you feel that the time
              for verification takes too long.

              Typical usage is:

                 flashrom -p prog -n -w &lt;file&gt;

              This option is only useful in combination with <b>--write</b>.

       <b>-N,</b> <b>--noverify-all</b>
              Skip not included regions during automatic verification after writing (cf. <b>-l</b> and <b>-i</b>).  You should
              only use this option if you are sure that communication with the flash chip is reliable (e.g. when
              using the <b>internal</b> programmer).  Even if <b>flashrom</b> is instructed not to touch parts  of  the  flash
              chip, their contents could be damaged (e.g. due to misunderstood erase commands).

              This  option  is  required to flash an Intel system with locked ME flash region using the <b>internal</b>
              programmer.  It may be enabled by default in this case in the future.

       <b>-v,</b> <b>--verify</b> <b>(&lt;file&gt;|-)</b>
              Verify the flash ROM contents against the given <b>&lt;file&gt;</b>.  If <b>-</b> is provided instead,  contents  will
              be written to the stdout.

       <b>-E,</b> <b>--erase</b>
              Erase the flash ROM chip.

       <b>-x,</b> <b>--extract</b>
              Extract every region defined on the layout from flash ROM chip to a file with the same name as the
              extracted region (replacing spaces with underscores).

       <b>-V,</b> <b>--verbose</b>
              More  verbose  output.  This  option can be supplied multiple times (max. 3 times, i.e. <b>-VVV</b> ) for
              even more debug output.

       <b>-c,</b> <b>--chip</b> <b>&lt;chipname&gt;</b>
              Probe only for the specified flash ROM chip. This  option  takes  the  chip  name  as  printed  by
              <b>flashrom</b>  <b>-L</b>  without  the  vendor  name  as  parameter.  Please  note  that the chip name is case
              sensitive.

       <b>-f,</b> <b>--force</b>
              Force one or more of the following actions:

              • Force chip read and pretend the chip is there.

              • Force chip access even if the chip is bigger than the maximum supported size for the flash bus.

              • Force erase even if erase is known bad.

              • Force write even if write is known bad.

       <b>-l,</b> <b>--layout</b> <b>&lt;file&gt;</b>
              Read ROM layout from <b>&lt;file&gt;</b>.

              <b>flashrom</b> supports ROM layouts. This allows you to flash certain parts of the flash chip  only.   A
              ROM layout file contains multiple lines with the following syntax:

                 startaddr:endaddr imagename

              <b>startaddr</b>  and  <b>endaddr</b>  are  hexadecimal  addresses  within  the ROM file and do not refer to any
              physical address.  Please note that using a  0x  prefix  for  those  hexadecimal  numbers  is  not
              necessary,  but  you  can't specify decimal/octal numbers.  <b>imagename</b> is an arbitrary name for the
              region/image from <b>startaddr</b> to <b>endaddr</b> (both addresses included).

              Example:

                 00000000:00008fff gfxrom
                 00009000:0003ffff normal
                 00040000:0007ffff fallback

              If you only want to update the image named <b>normal</b> in a ROM based on the layout above, run:

                 flashrom -p prog --layout rom.layout --image normal -w some.rom

              To update only the images named <b>normal</b> and <b>fallback</b>, run:

                 flashrom -p prog -l rom.layout -i normal -i fallback -w some.rom

              Overlapping sections are not supported.

       <b>--fmap</b> Read layout from fmap in flash chip.

              <b>flashrom</b> supports the fmap binary format which is commonly used by  coreboot  for  partitioning  a
              flash chip.  The on-chip fmap will be read and used to generate the layout.

              If you only want to update the <b>COREBOOT</b> region defined in the fmap, run:

                 flashrom -p prog --fmap --image COREBOOT -w some.rom

       <b>--fmap-file</b> <b>&lt;file&gt;</b>
              Read layout from a <b>&lt;file&gt;</b> containing binary fmap (e.g. coreboot roms).

              <b>flashrom</b>  supports  the  fmap  binary format which is commonly used by coreboot for partitioning a
              flash chip.  The fmap in the specified file will be read and used to generate the layout.

              If you only want to update the <b>COREBOOT</b> region defined in the binary fmap file, run:

                 flashrom -p prog --fmap-file some.rom --image COREBOOT -w some.rom

       <b>--ifd</b>  Read ROM layout from Intel Firmware Descriptor.

              <b>flashrom</b> supports ROM layouts given by an Intel Firmware Descriptor (IFD).  The on-chip descriptor
              will be read and used to generate the layout. If you need to change the layout, you have to update
              the IFD only first.

              The following ROM images may be present in an IFD:
                 <b>fd</b>    - the IFD itself
                 <b>bios</b>  - the host firmware aka. BIOS
                 <b>me</b>    - Intel Management Engine firmware
                 <b>gbe</b>   - gigabit ethernet firmware
                 <b>pd</b>    - platform specific data

       <b>-i,</b> <b>--include</b> <b>&lt;region&gt;[:&lt;file&gt;]</b>
              Read or write only <b>&lt;region&gt;</b> to or from ROM.  The <b>-i</b> option may be used multiple times if the  user
              wishes to read or write multiple regions using a single command.

              The  user may optionally specify a corresponding <b>&lt;file&gt;</b> for any region they wish to read or write.
              A read operation will read the corresponding regions from ROM and write individual files for  each
              one.  A write option will read file(s) and write to the corresponding region(s) in ROM.

              For  write  operations, files specified using <b>-i</b> take precedence over content from the argument to
              <b>-w</b>.

              <b>Examples:</b>
                     To read regions named <b>foo</b> and <b>bar</b> in layout file <b>&lt;layout&gt;</b> into region-sized  files  <b>foo.bin</b>
                     and <b>bar.bin</b>, run:

                        flashrom -p prog -l &lt;layout&gt; -i foo:foo.bin -i bar:bar.bin -r rom.bin

                     To  write  files <b>foo.bin</b> and <b>bar.bin</b> into regions named <b>foo</b> and <b>bar</b> in layout file <b>&lt;layout&gt;</b>
                     to the ROM, run:

                        flashrom -p prog -l &lt;layout&gt; -i foo:foo.bin -i bar:bar.bin -w rom.bin

       <b>--wp-status</b>
              Prints the flash's current status register protection mode and write protection range.

       <b>--wp-list</b>
              Prints a list of all protection ranges that the flash supports.

       <b>--wp-enable</b>
              Enables hardware status register protection (SRP) if the flash supports it.  Once SRP is  enabled,
              operations  that  change  the flash's status registers (including <b>--wp-disable</b> and <b>--wp-range</b>) can
              only be performed if the flash's #WP pin is at an inactive logic level.

       <b>--wp-disable</b>
              Disables status register protection if the flash allows it.

       <b>--wp-range</b> <b>&lt;start&gt;,&lt;length&gt;</b>
              Configures the flash to protect a range of addresses from &lt;start&gt; to (&lt;start&gt;  +  &lt;length&gt;  -  1),
              bounds inclusive.  The range must be supported by the flash, see <b>--wp-list</b>.

       <b>--wp-region</b> <b>&lt;region&gt;</b>
              Same  as  <b>--wp-range</b>  but  protects the range occupied by an image region.  This option requires a
              image layout to be specified, see <b>--layout</b>.  The region  must  be  supported  by  the  flash,  see
              <b>--wp-list</b>.

       <b>--flash-name</b>
              Prints out the detected flash chip's name.

       <b>--flash-size</b>
              Prints out the detected flash chip's size.

       <b>--flash-contents</b> <b>&lt;ref-file&gt;</b>
              The  file  contents  of  <b>&lt;ref-file&gt;</b>  will  be  used  to decide which parts of the flash need to be
              written.  Providing this saves an initial read of  the  full  flash  chip.   Be  careful,  if  the
              provided data doesn't actually match the flash contents, results are undefined.

       <b>-L,</b> <b>--list-supported</b>
              List the flash chips, chipsets, mainboards, and external programmers (including PCI, USB, parallel
              port, and serial port based devices) supported by <b>flashrom</b>.

              There  are  many  unlisted  boards  which  will  work  out  of the box, without special support in
              <b>flashrom</b>.  Please let us know if you can verify that other boards work or do not work out  of  the
              box.

              <b>IMPORTANT</b>:  For  verification  you  have to test an ERASE and/or WRITE operation, so make sure you
              only do that if you have proper means to recover from failure!

       <b>-z,</b> <b>--list-supported-wiki</b>
              Same as <b>--list-supported</b>, but outputs the supported hardware in MediaWiki syntax, so that  it  can
              be  easily pasted into the <u>supported</u> <u>hardware</u> <u>wiki</u> <u>page</u> &lt;<b>https://flashrom.org/Supported_hardware</b>&gt;.
              Please note that MediaWiki output is not compiled in by default.

       <b>-p,</b> <b>--programmer</b> <b>&lt;name&gt;[:parameter[,parameter[,parameter]]]</b>
              Specify the programmer device. This is mandatory for all  operations  involving  any  chip  access
              (probe/read/write/...).  Currently supported are:

              • <b>internal</b>            (for in-system flashing in the mainboard)

              • <b>dummy</b>               (virtual programmer for testing <b>flashrom</b>)

              • <b>nic3com</b>             (for flash ROMs on 3COM network cards)

              • <b>nicrealtek</b>          (for flash ROMs on Realtek and SMC 1211 network cards)

              • <b>nicnatsemi</b>          (for flash ROMs on National Semiconductor DP838* network cards)

              • <b>nicintel</b>            (for parallel flash ROMs on Intel 10/100Mbit network cards)

              • <b>gfxnvidia</b>           (for flash ROMs on NVIDIA graphics cards)

              • <b>drkaiser</b>            (for flash ROMs on Dr. Kaiser PC-Waechter PCI cards)

              • <b>satasii</b>             (for flash ROMs on Silicon Image SATA/IDE controllers)

              • <b>satamv</b>              (for flash ROMs on Marvell SATA controllers)

              • <b>atahpt</b>              (for flash ROMs on Highpoint ATA/RAID controllers)

              • <b>atavia</b>              (for flash ROMs on VIA VT6421A SATA controllers)

              • <b>atapromise</b>          (for flash ROMs on Promise PDC2026x ATA/RAID controllers)

              • <b>it8212</b>              (for flash ROMs on ITE IT8212F ATA/RAID controller)

              • <b>ft2232_spi</b>           (for  SPI  flash ROMs attached to an FT2232/FT4232H/FT232H family based USB
                SPI programmer)

              • <b>serprog</b>             (for flash ROMs attached to a programmer speaking  serprog,  including  some
                Arduino-based devices)

              • <b>buspirate_spi</b>       (for SPI flash ROMs attached to a Bus Pirate)

              • <b>dediprog</b>            (for SPI flash ROMs attached to a Dediprog SF100)

              • <b>rayer_spi</b>            (for  SPI  flash  ROMs  attached to a parallel port by one of various cable
                types)

              • <b>raiden_debug_spi</b>    (For Chrome EC based debug tools - SuzyQable, Servo V4, C2D2 &amp; uServo)

              • <b>pony_spi</b>            (for SPI flash ROMs attached to a SI-Prog serial port bitbanging adapter)

              • <b>nicintel_spi</b>        (for SPI flash ROMs on Intel Gigabit network cards)

              • <b>ogp_spi</b>             (for SPI flash ROMs on Open Graphics Project graphics card)

              • <b>linux_mtd</b>           (for SPI flash ROMs accessible via /dev/mtdX on Linux)

              • <b>linux_spi</b>           (for SPI flash ROMs accessible via /dev/spidevX.Y on Linux)

              • <b>usbblaster_spi</b>      (for SPI flash ROMs attached to an Altera USB-Blaster compatible cable)

              • <b>nicintel_eeprom</b>     (for SPI EEPROMs on Intel Gigabit network cards)

              • <b>mstarddc_spi</b>        (for SPI flash ROMs accessible through DDC in MSTAR-equipped displays)

              • <b>pickit2_spi</b>         (for SPI flash ROMs accessible via Microchip PICkit2)

              • <b>ch341a_spi</b>          (for SPI flash ROMs attached to WCH CH341A)

              • <b>ch347_api</b>           (for SPI flash ROMs attached to WHC CH347)

              • <b>digilent_spi</b>        (for SPI flash ROMs attached to iCEblink40 development boards)

              • <b>jlink_spi</b>           (for SPI flash ROMs attached to SEGGER J-Link and compatible devices)

              • <b>ni845x_spi</b>          (for SPI flash ROMs attached to National Instruments USB-8451 or USB-8452)

              • <b>stlinkv3_spi</b>        (for SPI flash ROMs attached to STMicroelectronics STLINK V3 devices)

              • <b>realtek_mst_i2c_spi</b> (for SPI flash ROMs attached to Realtek DisplayPort hubs accessible  through
                I2C)

              • <b>parade_lspcon</b>       (for SPI flash ROMs attached to Parade Technologies LSPCONs (PS175))

              • <b>mediatek_i2c_spi</b>     (for  SPI  flash  ROMs attached to some Mediatek display devices accessible
                over I2C)

              • <b>dirtyjtag_spi</b>       (for SPI flash ROMs attached to DirtyJTAG-compatible devices)

              • <b>asm106x</b>             (for SPI flash ROMs attached to asm106x PCI SATA controllers)

              Some programmers have optional or mandatory parameters  which  are  described  in  detail  in  the
              <b>PROGRAMMER-SPECIFIC</b>  <b>INFORMATION</b>  section. Support for some programmers can be disabled at compile
              time.  <b>flashrom</b> <b>-h</b> lists all supported programmers.

       <b>-h,</b> <b>--help</b>
              Show a help text and exit.

       <b>-o,</b> <b>--output</b> <b>&lt;logfile&gt;</b>
              Save the full debug log to <b>&lt;logfile&gt;</b>.  If the file already exists, it will be overwritten. This is
              the recommended way to gather logs from  <b>flashrom</b>  because  they  will  be  verbose  even  if  the
              on-screen messages are not verbose and don't require output redirection.

       <b>--progress</b>
              [Experimental feature] Show progress percentage of operations on the standard output.

       <b>-R,</b> <b>--version</b>
              Show version information and exit.

</pre><h4><b>PROGRAMMER-SPECIFIC</b> <b>INFORMATION</b></h4><pre>
       Some programmer drivers accept further parameters to set programmer-specific parameters. These parameters
       are  separated  from  the  programmer  name  by  a  colon.  While some programmers take arguments atfixed
       positions, other programmers use a key/value interface in which the key and  value  is  separated  by  an
       equal sign and different pairs are separated by a comma or a colon.

   <b>internal</b> <b>programmer</b>
       <b>Board</b> <b>Enables</b>
              Some  mainboards  require  to  run mainboard specific code to enable flash erase and write support
              (and probe support on old systems with parallel flash).  The mainboard  brand  and  model  (if  it
              requires  specific  code)  is  usually autodetected using one of the following mechanisms: If your
              system is running coreboot, the mainboard type is determined from the coreboot table.   Otherwise,
              the  mainboard is detected by examining the onboard PCI devices and possibly DMI info.  If PCI and
              DMI do not contain information to uniquely identify the mainboard (which is the exception), or  if
              you want to override the detected mainboard model, you can specify the mainboard using the:

                 flashrom -p internal:mainboard=&lt;vendor&gt;:&lt;board&gt;

              syntax.

              See  the  <b>Known</b>  <b>boards</b> or <b>Known</b> <b>laptops</b> section in the output of <b>flashrom</b> <b>-L</b> for a list of boards
              which require the specification of the board name, if no coreboot table is found.

              Some of these board-specific flash enabling functions (called <b>board</b> <b>enables</b> ) in <b>flashrom</b> have not
              yet been tested.  If your mainboard is detected needing  an  untested  board  enable  function,  a
              warning  message  is  printed  and  the  board enableis not executed, because a wrong board enable
              function might cause the system to  behave  erratically,  as  board  enable  functions  touch  the
              low-level  internals  of  a  mainboard.   Not executing a board enable function (if one is needed)
              might cause detection or erasing failure.  If your board protects only part of the flash (commonly
              the top end, called boot block),  <b>flashrom</b>  might  encounter  an  error  only  after  erasing  the
              unprotected  part,  so  running without the board-enable function might be dangerous for erase and
              write (which includes erase).

              The suggested procedure for a mainboard with untested board specific code is to first try to probe
              the ROM (just invoke <b>flashrom</b> and check that it detects your flash chip type) without running  the
              board  enable  code  (i.e.  without any parameters). If it finds your chip, fine. Otherwise, retry
              probing your chip with the board-enable code running, using:

                 flashrom -p internal:boardenable=force

              If your chip is still not detected, the board enable code seems to be broken  or  the  flash  chip
              unsupported.   Otherwise,  make a backup of your current ROM contents (using <b>-r</b>) and store it to a
              medium outside of your computer, like a USB drive or a network share. If you  needed  to  run  the
              board  enable  code  already  for  probing,  use  it for reading too.  If reading succeeds and the
              contents of the read file look legit you can try to write the new image.  You  should  enable  the
              board enable code in any case now, as it has been written because it is known that writing/erasing
              without  the board enable is going to fail. In any case (success or failure), please report to the
              <b>flashrom</b> mailing list, see below.

       <b>Coreboot</b>
              On systems running coreboot, <b>flashrom</b> checks whether the desired  image  matches  your  mainboard.
              This  needs  some special board ID to be present in the image.  If <b>flashrom</b> detects that the image
              you want to write and the current board do not match, it will refuse to write the image unless you
              specify:

                 flashrom -p internal:boardmismatch=force

       <b>ITE</b> <b>IT87</b> <b>Super</b> <b>I/O</b>
              If your mainboard is manufactured by GIGABYTE and supports DualBIOS it is very likely that it uses
              an ITE IT87 series Super I/O to switch between the two flash chips.   Only  one  of  them  can  be
              accessed at a time and you can manually select which one to use with the:

                 flashrom -p internal:dualbiosindex=chip

              syntax where <b>chip</b> is the index of the chip to use (0 = main, 1 = backup).  You can check which one
              is currently selected by leaving out the <b>chip</b> parameter.

              If  your mainboard uses an ITE IT87 series Super I/O for LPC&lt;-&gt;SPI flash bus translation, <b>flashrom</b>
              should autodetect that configuration.  If you want to set the I/O base port of the IT87 series SPI
              controller manually instead of using the value provided by the BIOS, use the:

                 flashrom -p internal:it87spiport=portnum

              syntax where <b>portnum</b> is the I/O port number (must be a multiple  of  8).   In  the  unlikely  case
              <b>flashrom</b>  doesn't  detect  an  active  IT87  LPC&lt;-&gt;SPI  bridge, please send a bug report so we can
              diagnose the problem.

       <b>AMD</b> <b>chipsets</b>
              Beginning with the SB700 chipset there is an integrated microcontroller (IMC) based  on  the  8051
              embedded  in  every  AMD  southbridge.   Its firmware resides in the same flash chip as the host's
              which makes writing to the flash risky if the  IMC  is  active.   Flashrom  tries  to  temporarily
              disable  the  IMC but even then changing the contents of the flash can have unwanted effects: when
              the IMC continues (at the latest after a reboot) it will continue executing code from  the  flash.
              If the code was removed or changed in an unfortunate way it is unpredictable what the IMC will do.
              Therefore,  if <b>flashrom</b> detects an active IMC it will disable write support unless the user forces
              it with the:

                 flashrom -p internal:amd_imc_force=yes

              syntax. The user is responsible for supplying a suitable image or leaving out the IMC region  with
              the  help of a layout file.  This limitation might be removed in the future when we understand the
              details better and have received enough feedback from users.  Please report the outcome if you had
              to use this option to write a chip.

              An optional <b>spispeed</b> parameter specifies the frequency of the SPI bus where applicable  (i.e.SB600
              or later with an SPI flash chip directly attached to the chipset).  Syntax is:

                 flashrom -p internal:spispeed=frequency

              where <b>frequency</b> can be <b>'16.5</b> <b>MHz'</b>, <b>'22</b> <b>MHz'</b>, <b>'33</b> <b>MHz'</b>, <b>'66</b> <b>MHz'</b>, <b>'100</b> <b>MHZ'</b>, or <b>'800</b> <b>kHz'</b>.  Support
              of individual frequencies depends on the generation of the chipset:

              • SB6xx,  SB7xx, SP5xxx: from 16.5 MHz up to and including 33 MHz.  The default is to use 16.5 MHz
                and disable Fast Reads.

              • SB8xx, SB9xx, Hudson: from 16.5 MHz up to and including 66 MHz.  The default is to use 16.5  MHz
                and disable Fast Reads.

              • Yangtze (with SPI 100 engine as found in Kabini and Tamesh): all of them.  The default is to use
                the frequency that is currently configured.

              An  optional <b>spireadmode</b> parameter specifies the read mode of the SPI bus where applicable (Bolton
              or later).  Syntax is:

                 flashrom -p internal:spireadmode=mode

              where <b>mode</b> can be <b>'Normal</b> <b>(up</b> <b>to</b> <b>33</b> <b>MHz)'</b>, <b>'Normal</b> <b>(up</b> <b>to</b> <b>66</b> <b>MHz)'</b>, <b>'Dual</b> <b>IO</b>  <b>(1-1-2)'</b>,  <b>'Quad</b>  <b>IO</b>
              <b>(1-1-4)'</b>, <b>'Dual</b> <b>IO</b> <b>(1-2-2)'</b>, <b>'Quad</b> <b>IO</b> <b>(1-4-4)'</b>, or <b>'Fast</b> <b>Read'</b>.

              The default is to use the read mode that is currently configured.

       <b>Intel</b> <b>chipsets</b>
              If  you  have an Intel chipset with an ICH8 or later southbridge with SPI flash attached, and if a
              valid descriptor was written to it (e.g. by the vendor), the chipset provides an  alternative  way
              to  access the flash chip(s) named <b>Hardware</b> <b>Sequencing</b>.  It is much simpler than the normal access
              method (called <b>Software</b> <b>Sequencing</b>), but does not allow the software to choose the SPI commands to
              be sent. You can use the:

                 flashrom -p internal:ich_spi_mode=value

              syntax where <b>value</b> can be <b>auto</b>, <b>swseq</b> or <b>hwseq</b>. By default (or when setting <b>ich_spi_mode=auto</b>) the
              module tries to use swseq and only activates hwseq if need  be  (e.g.  if  important  opcodes  are
              inaccessible  due  to  lockdown;  or  if  more than one flash chip is attached). The other options
              (swseq, hwseq) select the respective mode (if possible).

              ICH8 and later southbridges may also have locked address ranges of  different  kinds  if  a  valid
              descriptor  was  written to it.  The flash address space is then partitioned in multiple so called
              "Flash Regions" containing the host firmware, the ME firmware and so on  respectively.  The  flash
              descriptor  can  also specify up to 5 so called <b>Protected</b> <b>Regions</b>, which are freely chosen address
              ranges independent from the aforementioned <b>Flash</b> <b>Regions</b>.  All of them can be  write  and/or  read
              protected individually.

              If  you  have  an  Intel chipset with an ICH2 or later southbridge and if you want to set specific
              IDSEL values for a non-default flash chip or an embedded controller (EC), you can use the:

                 flashrom -p internal:fwh_idsel=value

              syntax where <b>value</b> is the 48-bit hexadecimal raw value to be written in the IDSEL registers of the
              Intel southbridge.  The upper 32 bits use one hex digit each per 512 kB range  between  0xffc00000
              and  0xffffffff, and the lower 16 bits use one hex digit each per 1024 kB range between 0xff400000
              and 0xff7fffff.  The rightmost hex digit corresponds with the lowest address  range.  All  address
              ranges  have  a  corresponding  sister range 4 MB below with identical IDSEL settings. The default
              value for ICH7 is given in the example below.

              Example:

                 flashrom -p internal:fwh_idsel=0x001122334567

       <b>Laptops</b>
              Using <b>flashrom</b> on older laptops that don't boot from the SPI bus is dangerous and may easily  make
              your  hardware unusable (see also the <b>BUGS</b> section). The embedded controller (EC) in some machines
              may interact badly with flashing.  More information is <u>in</u> <u>the</u> <u>wiki</u> &lt;<b>https://flashrom.org/Laptops</b>&gt;.
              Problems occur when the flash chip is shared between BIOS and EC firmware, and the latter does not
              expect <b>flashrom</b> to access the chip. While <b>flashrom</b> tries to change the contents of that memory the
              EC might need to fetch new instructions or data from it and could stop working correctly.  Probing
              for  and reading from the chip may also irritate your EC and cause fan failure, backlight failure,
              sudden poweroff, and other nasty effects. <b>flashrom</b> will attempt to detect if it is running on such
              a laptop and limit probing to SPI buses. If you want to probe the LPC bus anyway at your own risk,
              use:

                 flashrom -p internal:laptop=force_I_want_a_brick

              We will not help you if you force flashing on a laptop because this is a really dumb idea.

              You have been warned.

              Currently we rely on the chassis type encoded in the  DMI/SMBIOS  data  to  detect  laptops.  Some
              vendors  did  not  implement  those  bits  correctly  or  set them to generic and/or dummy values.
              <b>flashrom</b> will then issue a warning and restrict buses like above.  In this case you can use:

                 flashrom -p internal:laptop=this_is_not_a_laptop

              to tell <b>flashrom</b> (at your own risk) that it is not running on a laptop.

   <b>dummy</b> <b>programmer</b>
       The dummy programmer operates on a buffer in memory only. It provides a safe and fast way to test various
       aspects of <b>flashrom</b> and is mainly used in development and while debugging.  It is able  to  emulate  some
       chips to a certain degree (basic identify/read/erase/write operations work).

       An optional parameter specifies the bus types it should support. For that you have to use the:

          flashrom -p dummy:bus=[type[+type[+type]]]

       syntax where <b>type</b> can be <b>parallel</b>, <b>lpc</b>, <b>fwh</b>, <b>spi</b> in any order. If you specify bus without type, all buses
       will be disabled. If you do not specify bus, all buses will be enabled.

       Example:

          flashrom -p dummy:bus=lpc+fwh

       The  dummy programmer supports flash chip emulation for automated self-tests without hardware access.  If
       you want to emulate a flash chip, use the:

          flashrom -p dummy:emulate=chip

       syntax where <b>chip</b> is one of the following chips (please specify only the chip name, not the vendor):

       • ST           <b>M25P10.RES</b>      SPI flash chip (128 kB, RES, page write)

       • SST          <b>SST25VF040.REMS</b> SPI flash chip (512 kB, REMS, byte write)

       • SST          <b>SST25VF032B</b>     SPI flash chip (4096 kB, RDID, AAI write)

       • Macronix     <b>MX25L6436</b>       SPI flash chip (8192 kB, RDID, SFDP)

       • Winbond      <b>W25Q128FV</b>       SPI flash chip (16384 kB, RDID)

       • Spansion     <b>S25FL128L</b>       SPI flash chip (16384 kB, RDID)

       • Dummy vendor <b>VARIABLE_SIZE</b>   SPI flash chip (configurable size, page write)

       Example:

          flashrom -p dummy:emulate=SST25VF040.REMS

       To use <b>VARIABLE_SIZE</b> chip, <b>size</b> must be specified to configure the size of the flash chip as a  power  of
       two.

       Example:

          flashrom -p dummy:emulate=VARIABLE_SIZE,size=16777216,image=dummy.bin

       <b>Persistent</b> <b>images</b>
              If you use flash chip emulation, flash image persistence is available as well by using the:

                 flashrom -p dummy:emulate=chip,image=image.rom

              syntax  where <b>image.rom</b> is the file where the simulated chip contents are read on <b>flashrom</b> startup
              and where the chip contents on <b>flashrom</b> shutdown are written to.

              Example:

                 flashrom -p dummy:emulate=M25P10.RES,image=dummy.bin

       <b>SPI</b> <b>write</b> <b>chunk</b> <b>size</b>
              If you use SPI flash chip emulation for a chip which supports SPI  page  write  with  the  default
              opcode, you can set the maximum allowed write chunk size with the:

                 flashrom -p dummy:emulate=chip,spi_write_256_chunksize=size

              syntax where <b>size</b> is the number of bytes (min.&amp; 1, max.&amp; 256).  Example:

                 flashrom -p dummy:emulate=M25P10.RES,spi_write_256_chunksize=5

       <b>SPI</b> <b>blacklist</b>
              To  simulate  a  programmer  which refuses to send certain SPI commands to the flash chip, you can
              specify a blacklist of SPI commands with the:

                 flashrom -p dummy:spi_blacklist=commandlist

              syntax where <b>ommandlist</b> is a list of two-digit hexadecimal representations of  SPI  commands.   If
              commandlist  is  e.g.  0302,  <b>flashrom</b> will behave as if the SPI controller refuses to run command
              0x03 (READ) and command 0x02 (WRITE).  commandlist may be up  to  512  characters  (256  commands)
              long.  Implementation note: <b>flashrom</b> will detect an error during command execution.

       <b>SPI</b> <b>ignorelist</b>
              To  simulate a flash chip which ignores (doesn't support) certain SPI commands, you can specify an
              ignorelist of SPI commands with the:

                 flashrom -p dummy:spi_ignorelist=commandlist

              syntax where <b>commandlist</b> is a list of two-digit hexadecimal representations of SPI  commands.   If
              commandlist is e.g. 0302, the emulated flash chip will ignore command 0x03 (READ) and command 0x02
              (WRITE).   <b>commandlist</b>  may  be  up  to  512 characters (256 commands) long.  Implementation note:
              <b>flashrom</b> won't detect an error during command execution.

       <b>SPI</b> <b>status</b> <b>register</b>
              You can specify the initial content of the chip's status register with the:

                 flashrom -p dummy:spi_status=content"

              syntax where <b>content</b> is a hexadecimal value of up to 24 bits. For example, <b>0x332211</b>  assigns  0x11
              to  SR1,  0x22 to SR2 and 0x33 to SR3. Shorter value is padded to 24 bits with zeroes on the left.
              See datasheet for chosen chip for details about the registers content.

       <b>Write</b> <b>protection</b>
              Chips with emulated WP: <b>W25Q128FV</b>, <b>S25FL128L</b>.

              You can simulate state of hardware protection pin (WP) with the:

                 flashrom -p dummy:hwwp=state

              syntax where <b>state</b> is <b>yes</b> or <b>no</b> (default value). <b>yes</b> means active state of the  pin  implies  that
              chip is write-protected (on real hardware the pin is usually negated, but not here).

   <b>nic3com,</b>  <b>nicrealtek,</b>  <b>nicnatsemi,</b>  <b>nicintel,</b>  <b>nicintel_eeprom,</b>  <b>nicintel_spi,</b>  <b>gfxnvidia,</b> <b>ogp_spi,</b> <b>drkaiser,</b>
       <b>satasii,</b> <b>satamv,</b> <b>atahpt,</b> <b>atavia,</b> <b>atapromise,</b> <b>it8212</b> <b>programmers</b>
       These programmers have an option to specify the PCI address of the card your want to use, which  must  be
       specified  if  more  than  one card supported by the selected programmer is installed in your system. The
       syntax is:

          flashrom -p xxxx:pci=bb:dd.f

       where <b>xxxx</b> is the name of the programmer, <b>bb</b> is the PCI bus number, <b>dd</b> is the PCI device number, and <b>b</b> is
       the PCI function number of the desired device. Example:

          flashrom -p nic3com:pci=05:04.0

   <b>atavia</b> <b>programmer</b>
       Due to the mysterious address handling of the VIA VT6421A controller the user can specify an offset  with
       the:

          flashrom -p atavia:offset=addr

       syntax  where  <b>addr</b>  will be interpreted as usual (leading 0x (0) for hexadecimal (octal) values, or else
       decimal).  For more information please see <u>its</u> <u>wiki</u> <u>page</u> &lt;<b>https://flashrom.org/VT6421A"itswikipage</b>&gt;.

   <b>atapromise</b> <b>programmer</b>
       This programmer is currently limited to 32 kB, regardless of the actual size  of  the  flash  chip.  This
       stems  from the fact that, on the tested device (a Promise Ultra100), not all of the chip's address lines
       were actually connected.  You may use this programmer to flash firmware updates, since these are only  16
       kB in size (padding to 32 kB is required).

   <b>nicintel_eeprom</b> <b>programmer</b>
       This  is  the  first  programmer  module  in <b>flashrom</b> that does not provide access to NOR flash chips but
       EEPROMs mounted on gigabit Ethernet cards based on Intel's 82580 NIC. Because  EEPROMs  normally  do  not
       announce  their  size nor allow themselves to be identified, the controller relies on correct size values
       written to predefined addresses within the chip.  <b>Flashrom</b> follows this scheme but  assumes  the  minimum
       size  of 16 kB (128 kb) if an unprogrammed EEPROM/card is detected.  Intel specifies following EEPROMs to
       be compatible: Atmel AT25128, AT25256, Micron (ST) M95128, M95256 and OnSemi (Catalyst) CAT25CS128.

   <b>ft2232_spi</b> <b>programmer</b>
       This module supports various programmers based on FTDI  FT2232/FT4232H/FT232H  chips  including  the  DLP
       Design  DLP-USB1232H,  openbiosprog-spi, Amontec JTAGkey/JTAGkey-tiny/JTAGkey-2, Dangerous Prototypes Bus
       Blaster,  Olimex  ARM-USB-TINY/-H,  Olimex  ARM-USB-OCD/-H,   OpenMoko   Neo1973   Debug   board   (V2+),
       TIAO/DIYGADGET  USB  Multi-Protocol  Adapter (TUMPA), TUMPA Lite, GOEPEL PicoTAP, Google Servo v1/v2, Tin
       Can Tools Flyswatter/Flyswatter 2 and Kristech KT-LINK.

       An optional parameter specifies the controller type, channel/interface/port it should support.  For  that
       you have to use the:

          flashrom \-p ft2232_spi:type=model,port=interface

       syntax   where   <b>model</b>   can   be  <b>2232H</b>,  <b>4232H</b>,  <b>232H</b>,  <b>jtagkey</b>,  <b>busblaster</b>,  <b>openmoko</b>,  <b>arm-usb-tiny</b>,
       <b>arm-usb-tiny-h</b>, <b>arm-usb-ocd</b>, <b>arm-usb-ocd-h</b>, <b>tumpa</b>, <b>tumpalite</b>, <b>picotap</b>,  <b>google-servo,</b>  <b>``google-servo-v2</b>,
       <b>google-servo-v2-legacy</b>  or  <b>kt-link</b>.   <b>interface</b>  can  be  <b>A</b>, <b>B</b>, <b>C</b>, or <b>D</b>. The default model is <b>4232H</b>, the
       default interface is <b>A</b> and GPIO is not used by default.

       If there is more than one ft2232_spi-compatible device connected, you can select which one should be used
       by specifying its serial number with the:

          flashrom -p ft2232_spi:serial=number

       syntax where <b>number</b> is the serial number of the device (which can be found for example in the  output  of
       lsusb -v).

       All  models supported by the <b>ft2232_spi</b> driver can configure the SPI clock rate by setting a divisor. The
       expressible divisors are all <b>even</b> numbers between 2 and 2^17 (=131072) resulting in SPI clock frequencies
       of 6 MHz down to about 92 Hz for 12 MHz inputs (non-H chips) and 30 MHz down to about 458 Hz for  60  MHz
       inputs  ('H'  chips).  The  default  divisor  is  set to 2, but you can use another one by specifying the
       optional <b>divisor</b> parameter with the:

          flashrom -p ft2232_spi:divisor=div

       syntax. Using the parameter <b>csgpiol</b> (DEPRECATED - use <b>gpiol</b> instead) an additional CS# pin can be chosen,
       where the value can be a number between 0 and 3, denoting GPIOL0-GPIOL3 correspondingly. Example:

          flashrom -p ft2232_spi:csgpiol=3

       The parameter <b>gpiolX=[HLC]</b> allows use of the GPIOL pins either as generic gpios with a fixed value during
       flashing or as additional CS# signal, where <b>X</b> can be a number between 0  and  3,  denoting  GPIOL0-GPIOL3
       correspondingly.  The parameter may be specified multiple times, one time per GPIOL pin. Valid values are
       <b>H</b>, <b>L</b> and <b>C</b>:

       • <b>H</b> - Set GPIOL output high

       • <b>L</b> - Set GPIOL output low

       • <b>C</b> - Use GPIOL as additional CS# output

       Example:

          flashrom -p ft2232_spi:gpiol0=H

       <b>Note</b> that not all GPIOL pins are freely usable with all programmers as some have special functionality.

   <b>serprog</b> <b>programmer</b>
       This  module  supports  all  programmers  speaking the serprog protocol. This includes some Arduino-based
       devices as well as various programmers by Urja Rannikko, Juhana Helovuo, Stefan  Tauner,  Chi  Zhang  and
       many others.

       A  mandatory  parameter  specifies  either  a serial device (and baud rate) or an IP/port combination for
       communicating with the programmer. The device/baud combination has to start with <b>dev=</b>  and  separate  the
       optional baud rate with a colon.  For example:

          flashrom -p serprog:dev=/dev/ttyS0:115200

       If  no  baud  rate  is  given  the  default values by the operating system/hardware will be used.  For IP
       connections you have to use the:

          flashrom -p serprog:ip=ipaddr:port

       syntax. In case the device supports it, you can set the SPI clock frequency with  the  optional  <b>spispeed</b>
       parameter.   The  frequency  is  parsed  as  hertz,  unless an <b>M</b>, or <b>k</b> suffix is given, then megahertz or
       kilohertz are used respectively.  Example that sets the frequency to 2 MHz:

          flashrom -p serprog:dev=/dev/device:baud,spispeed=2M

       Optional <b>cs</b> parameter can be used to switch which chip select number  is  used.  This  allows  connecting
       multiple chips at once and selecting which one to flash by software means (rather than rewiring):

          flashrom -p serprog:dev=/dev/device:baud,cs=0

       The  particular programmer implementation needs to support this feature, for it to work. If the requested
       chip select isn't available, flashrom will fail safely.

       More information about serprog is available in this document: <u>Serial</u> <u>Flasher</u> <u>Protocol</u> <u>Specification</u>.

   <b>buspirate_spi</b> <b>programmer</b>
       A required <b>dev</b> parameter specifies the  Bus  Pirate  device  node  and  an  optional  <b>spispeed</b>  parameter
       specifies the frequency of the SPI bus. The parameter delimiter is a comma. Syntax is:

          flashrom -p buspirate_spi:dev=/dev/device,spispeed=frequency

       where  <b>frequency</b>  can  be  <b>30k</b>,  <b>125k</b>,  <b>250k</b>, <b>1M</b>, <b>2M</b>, <b>2.6M</b>, <b>4M</b> or <b>8M</b> (in Hz).  The default is the maximum
       frequency of 8 MHz.

       The baud rate for communication between the host and the Bus Pirate can be specified  with  the  optional
       <b>serialspeed</b> parameter. Syntax is:

          flashrom -p buspirate_spi:serialspeed=baud

       where <b>baud</b> can be <b>115200</b>, <b>230400</b>, <b>250000</b> or <b>2000000</b> (<b>2M</b>).  The default is <b>2M</b> baud for Bus Pirate hardware
       version 3.0 and greater, and 115200 otherwise.

       An optional pullups parameter specifies the use of the Bus Pirate internal pull-up resistors. This may be
       needed  if  you are working with a flash ROM chip that you have physically removed from the board. Syntax
       is:

          flashrom -p buspirate_spi:pullups=state

       where <b>state</b> can be <b>on</b> or <b>off</b>.  More information about the Bus Pirate pull-up resistors and their  purpose
       is           available           <u>in</u>           <u>a</u>           <u>guide</u>           <u>by</u>          <u>dangerousprototypes</u>
       &lt;<b><a href="http://dangerousprototypes.com/docs/Practical_guide_to_Bus_Pirate_pull-up_resistors">http://dangerousprototypes.com/docs/Practical_guide_to_Bus_Pirate_pull-up_resistors</a></b>&gt;.

       When working with low-voltage chips, the internal 10k pull-ups of the Bus Pirate might be  too  high.  In
       such cases, it's necessary to create an external pull-up using lower-value resistors.

       For  this,  you can use the <b>hiz</b> parameter. This way, the Bus Pirate will operate as an open drain. Syntax
       is:

          flashrom -p buspirate_spi:hiz=state

       where <b>state</b> can be <b>on</b> or <b>off</b>.

       The state of the Bus Pirate power supply pins is controllable through an optional <b>psus</b> parameter.  Syntax
       is:

          flashrom -p buspirate_spi:psus=state

       where  <b>state</b>  can be <b>on</b> or <b>off</b>.  This allows the bus pirate to power the ROM chip directly. This may also
       be used to provide the required pullup voltage (when using the <b>pullups</b> option),  by  connecting  the  Bus
       Pirate's Vpu input to the appropriate Vcc pin.

       An optional aux parameter specifies the state of the Bus Pirate auxiliary pin.  This may be used to drive
       the auxiliary pin high or low before a transfer.  Syntax is:

          flashrom -p buspirate_spi:aux=state

       where <b>state</b> can be <b>high</b> or <b>low</b>. The default <b>state</b> is <b>high</b>.

   <b>pickit2_spi</b> <b>programmer</b>
       An  optional  <b>voltage</b> parameter specifies the voltage the PICkit2 should use. The default unit is Volt if
       no unit is specified.  You can use <b>mV</b>, <b>millivolt</b>, <b>V</b> or <b>Volt</b> as unit specifier. Syntax is:

          flashrom \-p pickit2_spi:voltage=value

       where <b>value</b> can be <b>0V</b>, <b>1.8V</b>, <b>2.5V</b>, <b>3.5V</b> or the equivalent in mV.

       An optional <b>spispeed</b> parameter specifies the frequency of the SPI bus. Syntax is:

          flashrom -p pickit2_spi:spispeed=frequency

       where <b>frequency</b> can be <b>250k</b>, <b>333k</b>, <b>500k</b> or <b>1M</b> (in Hz). The default is a frequency of 1 MHz.

   <b>dediprog</b> <b>programmer</b>
       An optional <b>voltage</b> parameter specifies the voltage the Dediprog should use. The default unit is Volt  if
       no unit is specified.  You can use <b>mV</b>, <b>milliVolt</b>, <b>V</b> or <b>Volt</b> as unit specifier. Syntax is:

          flashrom -p dediprog:voltage=value

       where <b>value</b> can be <b>0V</b>, <b>1.8V</b>, <b>2.5V</b>, <b>3.5V</b> or the equivalent in mV.

       An  optional  <b>device</b>  parameter  specifies  which  of multiple connected Dediprog devices should be used.
       Please be aware that the order depends on libusb's  usb_get_busses()  function  and  that  the  numbering
       starts at 0.  Usage example to select the second device:

          flashrom -p dediprog:device=1

       An  optional  <b>spispeed</b> parameter specifies the frequency of the SPI bus. The firmware on the device needs
       to be 5.0.0 or newer.  Syntax is:

          flashrom -p dediprog:spispeed=frequency

       where <b>frequency</b> can be <b>375k</b>, <b>750k</b>, <b>1.5M</b>, <b>2.18M</b>, <b>3M</b>, <b>8M</b>, <b>12M</b> or <b>24M</b> (in Hz).  The default is  a  frequency
       of 12 MHz.

       An optional <b>target</b> parameter specifies which target chip should be used. Syntax is:

          flashrom -p dediprog:target=value

       where <b>value</b> can be <b>1</b> or <b>2</b> to select target chip 1 or 2 respectively. The default is target chip 1.

   <b>rayer_spi</b> <b>programmer</b>
       The  default  I/O  base  address  used for the parallel port is 0x378 and you can use the optional <b>iobase</b>
       parameter to specify an alternate base I/O address with the:

          flashrom -p rayer_spi:iobase=baseaddr

       syntax where <b>baseaddr</b> is base I/O port address of the parallel port, which must be a  multiple  of  four.
       Make sure to not forget the "0x" prefix for hexadecimal port addresses.

       The  default  cable type is the RayeR cable. You can use the optional <b>type</b> parameter to specify the cable
       type with the:

          flashrom -p rayer_spi:type=model

       syntax where <b>model</b> can be <b>rayer</b> for the RayeR cable, <b>byteblastermv</b> for the Altera  ByteBlasterMV,  <b>stk200</b>
       for  the  Atmel,  <b>STK200/300</b>, <b>wiggler</b> for the Macraigor Wiggler, <b>xilinx</b> for the Xilinx Parallel Cable III
       (DLC 5), or <b>spi_tt</b> for SPI Tiny Tools-compatible hardware.

       More    information    about    the    RayeR    hardware    is    available    at     <u>RayeR's</u>     <u>website</u>
       &lt;<b><a href="http://rayer.g6.cz/elektro/spipgm.htm">http://rayer.g6.cz/elektro/spipgm.htm</a></b>&gt;.   The Altera ByteBlasterMV datasheet can be obtained from <u>Altera</u>
       &lt;<b><a href="http://www.altera.co.jp/literature/ds/dsbytemv.pdf">http://www.altera.co.jp/literature/ds/dsbytemv.pdf</a></b>&gt;.  For more information about the  Macraigor  Wiggler
       see <u>their</u> <u>company</u> <u>homepage</u> &lt;<b><a href="http://www.macraigor.com/wiggler.htm">http://www.macraigor.com/wiggler.htm</a></b>&gt;.  The schematic of the Xilinx DLC 5 was
       published in <u>a</u> <u>Xilinx</u> <u>guide</u> &lt;<b><a href="http://www.xilinx.com/support/documentation/user_guides/xtp029.pdf">http://www.xilinx.com/support/documentation/user_guides/xtp029.pdf</a></b>&gt;.

   <b>raiden_debug_spi</b> <b>programmer</b>
       Some  devices  such  as  the  GSC  knows  how it is wired to AP and EC flash chips, and can be told which
       specific device to talk to using the <b>target</b> parameter:

          flashrom -p raiden_debug_spi:target={ap,ec}

       Other devices such as Servo Micro and HyperDebug are generic, and do not know how  they  are  wired,  the
       caller  is  responsible  for first configure the appropriate MUXes or buffers, and then tell the debugger
       which port to use (Servo Micro has just one SPI port, HyperDebug is  the  first  of  this  kind  to  have
       multiple):

          flashrom -p raiden_debug_spi:target=N

       where <b>N</b> is an non-negative integer (default <b>0</b>).

       The default is to use the first available servo. You can use the optional <b>serial</b> parameter to specify the
       servo USB device serial number to use specifically with:

          flashrom -p raiden_debug_spi:serial=XXX

       The  servo  device  serial number can be found via <b>lsusb</b>.  Raiden will poll the <b>ap</b> target waiting for the
       system power to settle on the AP and EC flash devices.

       The optional <b>custom_rst=true</b> parameter alters the behavior of the reset process:

          flashrom -p raiden_debug_spi:custom_rst=&lt;true|false&gt;

       syntax, where:

       <b>custom_rst=false</b> is the implicit default timeout of 3ms

       and <b>custom_rst=true</b> set <b>RAIDEN_DEBUG_SPI_REQ_ENABLE_AP_CUSTOM</b> instead of  <b>RAIDEN_DEBUG_SPI_REQ_ENABLE_AP</b>.
       This custom reset will modify the timeout from 3ms to 10ms and will not set <b>EC_RST_L</b>, meaning neither the
       EC nor the AP will be reset. With this setting, it's the user's responsibility to manage the reset signal
       manually or by configuring the GPIO.  Failure to handle the reset signal appropriately will likely result
       in flashing errors.

       More   information   about   the   ChromiumOS   servo   hardware   is   available   at   <u>servos</u>   <u>website</u>
       &lt;<b>https://chromium.googlesource.com/chromiumos/third_party/hdctools/+/HEAD/docs/servo_v4.md</b>&gt;.

   <b>pony_spi</b> <b>programmer</b>
       The serial port (like /dev/ttyS0, /dev/ttyUSB0 on Linux or  COM3  on  windows)  is  specified  using  the
       mandatory  <b>dev</b>  parameter.  The  adapter  type  is  selectable between SI-Prog (used for SPI devices with
       PonyProg 2000) or a custom made serial bitbanging programmer named "serbang". The optional <b>type</b> parameter
       accepts the values <b>si_prog</b> (default) or <b>serbang</b>.

       Information about the SI-Prog adapter can be found at <u>its</u> <u>website</u> &lt;<b><a href="http://www.lancos.com/siprogsch.html">http://www.lancos.com/siprogsch.html</a></b>&gt;.

       An example call to <b>flashrom</b> is:

          flashrom -p pony_spi:dev=/dev/ttyS0,type=serbang

       Please note that while USB-to-serial adapters work under certain circumstances, this slows down operation
       considerably.

   <b>ogp_spi</b> <b>programmer</b>
       The flash ROM chip to access must be specified with the <b>rom</b> parameter:

          flashrom -p ogp_spi:rom=name

       Where <b>name</b> is either <b>cprom</b> or <b>s3</b> for the configuration ROM and <b>bprom</b> or <b>bios</b> for the BIOS ROM.   If  more
       than  one  card  supported by the <b>ogp_spi</b> programmer is installed in your system, you have to specify the
       PCI address of the card you want to use with the <b>pci=</b> parameter  as  explained  in  the  <b>nic3com</b>  et  al.
       section above.

   <b>linux_mtd</b> <b>programmer</b>
       You may specify the MTD device to use with the:

          flashrom -p linux_mtd:dev=/dev/mtdX

       syntax  where  <b>/dev/mtdX</b>  is the Linux device node for your MTD device. If left unspecified the first MTD
       device found (e.g. /dev/mtd0) will be used by default.

       Please note that the linux_mtd driver only works on Linux.

   <b>linux_spi</b> <b>programmer</b>
       You have to specify the SPI controller to use with the:

          flashrom -p linux_spi:dev=/dev/spidevX.Y

       syntax where <b>/dev/spidevX.Y</b> is the Linux device node for your SPI controller.

       In case the device supports it, you can set the SPI clock frequency with the optional <b>spispeed</b> parameter.
       The frequency is parsed as kilohertz. Example that sets the frequency to 8 MHz:

          flashrom -p linux_spi:dev=/dev/spidevX.Y,spispeed=8000

       Please note that the linux_spi driver only works on Linux.

   <b>mstarddc_spi</b> <b>programmer</b>
       The Display Data Channel (DDC) is an I2C bus present on VGA and DVI connectors,  that  allows  exchanging
       information  between  a  computer  and  attached  displays.  Its  most  common  uses  are getting display
       capabilities through EDID (at I2C address 0x50) and sending commands to  the  display  using  the  DDC/CI
       protocol  (at  address  0x37).   On  displays driven by MSTAR SoCs, it is also possible to access the SoC
       firmware flash (connected to the Soc through another SPI bus) using an In-System Programming (ISP)  port,
       usually at address 0x49. This <b>flashrom</b> module allows the latter via Linux's I2C driver.

       <b>IMPORTANT:</b>  Before  using this programmer, the display <b>MUST</b> be in standby mode, and only connected to the
       computer that will run <b>flashrom</b> using a VGA cable, to an inactive VGA output. It absolutely <b>MUST</b>  <b>NOT</b>  be
       used as a display during the procedure!

       You have to specify the DDC/I2C controller and I2C address to use with the:

          flashrom -p mstarddc_spi:dev=/dev/i2c-X:YY

       syntax  where  <b>/dev/i2c-X</b> is the Linux device node for your I2C controller connected to the display's DDC
       channel, and <b>YY</b> is the (hexadecimal) address of the MSTAR  ISP  port  (address  0x49  is  usually  used).
       Example that uses I2C controller /dev/i2c-1 and address 0x49:

          flashrom -p mstarddc_spi:dev=/dev/i2c-1:49

       It  is  also possible to inhibit the reset command that is normally sent to the display once the <b>flashrom</b>
       operation is completed using the optional <b>noreset</b> parameter. A value of 1 prevents <b>flashrom</b> from  sending
       the reset command.  Example that does not reset the display at the end of the operation:

          flashrom -p mstarddc_spi:dev=/dev/i2c-1:49,noreset=1

       Please  note  that sending the reset command is also inhibited if an error occurred during the operation.
       To send the reset command afterwards, you can simply run <b>flashrom</b> once more,  in  chip  probe  mode  (not
       specifying an operation), without the <b>noreset</b> parameter, once the flash read/write operation you intended
       to perform has completed successfully.

       Please also note that the mstarddc_spi driver only works on Linux.

   <b>ch341a_spi</b> <b>programmer</b>
       The WCH CH341A programmer does not support any parameters currently. SPI frequency is fixed at 2 MHz, and
       CS0 is used as per the device.

   <b>ch347_spi</b> <b>programmer</b>
       The  WCH CH347 programmer does not currently support any parameters. SPI frequency is fixed at 2 MHz, and
       CS0 is used as per the device.

   <b>ni845x_spi</b> <b>programmer</b>
       An optional <b>voltage</b> parameter could be used to specify the IO voltage. This parameter  is  available  for
       the  NI  USB-8452 device.  The default unit is Volt if no unit is specified. You can use <b>mV</b>, <b>milliVolt</b>, <b>V</b>
       or <b>Volt</b> as unit specifier.  Syntax is:

          flashrom -p ni845x_spi:voltage=value

       where <b>value</b> can be <b>1.2V</b>, <b>1.5V</b>, <b>1.8V</b>, <b>2.5V</b>, <b>3.3V</b> or the equivalent in mV.

       In the case if none of the programmer's supported IO voltage is within the supported voltage range of the
       detected flash chip the <b>flashrom</b> will abort the operation (to prevent damaging the flash chip).  You  can
       override  this  behaviour  by  passing <b>yes</b> to the <b>ignore_io_voltage_limits</b> parameter (for e.g. if you are
       using an external voltage translator circuit). Syntax is:

          flashrom -p ni845x_spi:ignore_io_voltage_limits=yes

       You can use the <b>serial</b> parameter to explicitly specify which connected NI USB-845x device should be used.
       You should use your device's 7 digit hexadecimal serial number. Usage example to select the  device  with
       1230A12 serial number:

          flashrom -p ni845x_spi:serial=1230A12

       An optional <b>spispeed</b> parameter specifies the frequency of the SPI bus. Syntax is:

          flashrom -p ni845x_spi:spispeed=frequency

       where  <b>frequency</b> should a number corresponding to the desired frequency in kHz.  The maximum <b>frequency</b> is
       12 MHz (12000 kHz) for the USB-8451 and 50 MHz (50000 kHz) for the USB-8452.  The default is a  frequency
       of 1 MHz (1000 kHz).

       An optional <b>cs</b> parameter specifies which target chip select line should be used. Syntax is:

          flashrom -p ni845x_spi:csnumber=value

       where <b>value</b> should be between <b>0</b> and <b>7</b>. By default the CS0 is used.

   <b>digilent_spi</b> <b>programmer</b>
       An optional <b>spispeed</b> parameter specifies the frequency of the SPI bus. Syntax is:

          flashrom -p digilent_spi:spispeed=frequency

       where  <b>frequency</b>  can  be <b>62.5k</b>, <b>125k</b>, <b>250k</b>, <b>500k</b>, <b>1M</b>, <b>2M</b> or <b>4M</b> (in Hz).  The default is a frequency of 4
       MHz.

   <b>dirtyjtag_spi</b> <b>programmer</b>
       An optional <b>freq</b> parameter specifies the frequency of the SPI bus. Syntax is:

          flashrom -p dirtyjtag_spi:spispeed=frequency

       where <b>spispeed</b> can be any value in hertz, kilohertz  or  megahertz  supported  by  the  programmer.   The
       default is a frequency of 100 KHz.

   <b>jlink_spi</b> <b>programmer</b>
       This module supports SEGGER J-Link and compatible devices.

       The  <b>MOSI</b>  signal of the flash chip must be attached to <b>TDI</b> pin of the programmer, <b>MISO</b> to <b>TDO</b> and <b>SCK</b> to
       <b>TCK</b>. The chip select (<b>CS</b>) signal of the flash chip can be attached to different pins  of  the  programmer
       which can be selected with the:

          flashrom -p jlink_spi:cs=pin

       syntax  where <b>pin</b> can be either <b>TRST</b>, <b>RESET</b> or <b>TMS</b>. The default pin for chip select is <b>RESET</b>.  Note that,
       when using <b>RESET</b>, it is normal that the indicator LED blinks orange or red.

       Additionally, the <b>Tref</b> pin of the programmer must be attached to the logic level of the flash chip.   The
       programmer measures the voltage on this pin and generates the reference voltage for its input comparators
       and adapts its output voltages to it.

       Pinout for devices with 20-pin JTAG connector:

            +-------+
            |  1  2 |     1: VTref     2:
            |  3  4 |     3: TRST      4: GND
            |  5  6 |     5: TDI       6: GND
          +-+  7  8 |     7: TMS       8: GND
          |    9 10 |     9: TCK      10: GND
          |   11 12 |    11:          12: GND
          +-+ 13 14 |    13: TDO      14:
            | 15 16 |    15: RESET    16:
            | 17 18 |    17:          18:
            | 19 20 |    19: PWR_5V   20:
            +-------+

       If  there  is  more  than  one  compatible  device  connected, you can select which one should be used by
       specifying its serial number with the:

          flashrom -p jlink_spi:serial=number

       syntax where <b>number</b> is the serial number of the device (which can be found for example in the  output  of
       <b>lsusb</b> <b>-v</b>).

       The SPI speed can be selected by using the:

          flashrom -p jlink_spi:spispeed=frequency

       syntax where <b>frequency</b> is the SPI clock frequency in kHz. The maximum speed depends on the device in use.

       The  <b>power=on</b>  option  can be used to activate the 5 V power supply (PWR_5V) of the J-Link during a flash
       operation.

   <b>stlinkv3_spi</b> <b>programmer</b>
       This module supports SPI flash programming through the STMicroelectronics STLINK V3 programmer/debugger's
       SPI bridge interface:

          flashrom -p stlinkv3_spi

       If there is more than one compatible device connected, you  can  select  which  one  should  be  used  by
       specifying its serial number with the:

          flashrom -p stlinkv3_spi:serial=number

       syntax  where  <b>number</b> is the serial number of the device (which can be found for example in the output of
       <b>lsusb</b> <b>-v</b>).

       The SPI speed can be selected by using the:

          flashrom -p stlinkv3_spi:spispeed=frequency

       syntax where <b>frequency</b> is the SPI clock frequency in kHz. If the passed frequency is not supported by the
       adapter the nearest lower supported frequency will be used.

   <b>realtek_mst_i2c_spi,</b> <b>parade_lspcon</b> <b>and</b> <b>mediatek_i2c_spi</b> <b>programmers</b>
       These programmers tunnel SPI commands through I2C-connected devices. The I2C bus over which communication
       occurs must be specified either by device path with the <b>devpath</b> option:

          flashrom -p realtek_mst_i2c_spi:devpath=/dev/i2c-8

       or by a bus number with the <b>bus</b> option, which implies a device  path  like  <b>/dev/i2c-N</b>  where  <b>N</b>  is  the
       specified bus number:

          flashrom -p parade_lspcon:bus=8

   <b>realtek_mst_i2c_spi</b> <b>programmer</b>
       This  programmer  supports  SPI  flash  programming  for  chips attached to Realtek DisplayPort MST hubs,
       themselves accessed through I2C (tunneling SPI flash commands through the MST hub's I2C  connection  with
       the host).

   <b>In-system</b> <b>programming</b> <b>(ISP)</b> <b>mode</b>
       The  <b>reset_mcu</b> and <b>enter_isp</b> options provide control over device mode changes, where each can be set to <b>0</b>
       or <b>1</b> to enable or disable the corresponding mode transition.

       <b>enter_isp</b> defaults to <b>1</b>, and if enabled will issue commands to the MST hub when  beginning  operation  to
       put it into ISP mode.

       <b>reset_mcu</b>  defaults  to  <b>0</b>,  and  if  enabled  will  issue  a reset command to the MST hub on programming
       completion, causing it to exit ISP mode and to reload its own firmware from flash.

       <b>allow_brick</b> defaults to <b>no</b>, however must be set explicitly to <b>yes</b> to allow the driver to run if  you  are
       sure you have a MST chip.

       The  hub must be in ISP mode for SPI flash access to be possible, so it is usually only useful to disable
       <b>enter_isp</b> if an earlier invocation avoided resetting it on completion. For instance, to erase  the  flash
       and  rewrite  it  with  the  contents  of  a  file  without  resetting  in between (which could render it
       nonfunctional if attempting to load firmware from a blank flash):

          flashrom -p realtek_mst_i2c_spi:bus=0,enter_isp=1,reset_mcu=0 -E

          flashrom -p realtek_mst_i2c_spi:bus=0,enter_isp=0,reset_mcu=1 -w new.bin

   <b>parade_lspcon</b> <b>programmer</b>
       This  programmer  supports  SPI  flash  programming   for   chips   attached   to   Parade   Technologies
       DisplayPort-to-HDMI level shifter/protocol converters (LSPCONs), e.g. the PS175. Communication to the SPI
       flash is tunneled through the LSPCON over I2C.

   <b>mediatek_i2c_spi</b> <b>programmer</b>
       This  programmer  supports SPI flash programming for chips attached to some Mediatek display controllers,
       themselves accessed through I2C (tunneling SPI flash commands through an I2C connection with the host).

       The programmer is designed to support the TSUMOP82JUQ integrated display driver and scaler as used in the
       Google  Meet  Series  One  Desk  27  (which  runs  a  version  of  ChromeOS  and  uses  <b>flashrom</b>  in  its
       <b>tsum-scaler-updater</b> scripts that ship with the OS). Other chips may use compatible protocols but have not
       been  tested  with  this  programmer,  and external chip IOs may need to be controlled through other non-
       <b>flashrom</b> means to configure the chip in order for it to operate as expected.

       <b>devpath</b> and <b>bus</b> options select the I2C bus to use, as described previously. <b>allow_brick</b> defaults  to  <b>no</b>,
       and  must explicitly be set to <b>yes</b> in order for the programmer to operate. This is required because there
       is no mechanism in the driver to positively identify that a given I2C bus  is  actually  connected  to  a
       supported device.

</pre><h4><b>EXAMPLES</b></h4><pre>
       To back up and update your BIOS, run:

          flashrom -p internal -r backup.rom -o backuplog.txt
          flashrom -p internal -w newbios.rom -o writelog.txt

       Please  make  sure  to copy backup.rom to some external media before you try to write. That makes offline
       recovery easier.

       If writing fails and <b>flashrom</b> complains about the chip being in an unknown state, you can try to  restore
       the backup by running:

          flashrom -p internal -w backup.rom -o restorelog.txt

       If   you   encounter  any  problems,  please  contact  us  and  supply  backuplog.txt,  writelog.txt  and
       restorelog.txt.  See section <b>BUGS</b> for contact info.

</pre><h4><b>EXIT</b> <b>STATUS</b></h4><pre>
       <b>flashrom</b> exits with 0 on success, 1 on most failures but with 3 if a call to mmap() fails.

</pre><h4><b>REQUIREMENTS</b></h4><pre>
       <b>flashrom</b> needs different access permissions for different programmers.

       • internal

            • needs raw memory access

            • PCI configuration space access

            • raw I/O port access (x86)

            • MSR access (x86)

       • atavia

            • needs PCI configuration space access

       • nic3com, nicrealtek, nicnatsemi

            • need PCI configuration space read access

            • raw I/O port access

       • atahpt

            • needs PCI configuration space access

            • raw I/O port access

       • gfxnvidia, drkaiser, it8212

            • need PCI configuration space access

            • raw memory access

       • rayer_spi

            • needs raw I/O port access

       • raiden_debug_spi

            • needs access to the respective USB device via libusb API version 1.0

       • satasii, nicintel, nicintel_eeprom, nicintel_spi

            • need PCI configuration space read access

            • raw memory access

       • satamv, atapromise

            • need PCI configuration space read access

            • raw I/O port access

            • raw memory access

       • serprog

            • needs TCP access to the network or userspace access to a serial port

       • buspirate_spi

            • needs userspace access to a serial port

       • ft2232_spi, usbblaster_spi, pickit2_spi

            • need access to the respective USB device via libusb API version 1.0

       • ch341a_spi, dediprog

            • need access to the respective USB device via libusb API version 1.0

       • dummy

            • needs no access permissions at all

       • internal, nic3com, nicrealtek,  nicnatsemi,  gfxnvidia,  drkaiser,  satasii,  satamv,  atahpt,  atavia,
         atapromise, asm106x

            • have to be run as superuser/root

            • need raw access permission

       • serprog,  buspirate_spi,  dediprog,  usbblaster_spi, ft2232_spi, pickit2_spi, ch341a_spi, digilent_spi,
         dirtyjtag_spi

            • can be run as normal user on most operating systems if appropriate device permissions are set

       • ogp

            • needs PCI configuration space read access and raw memory access

       • realtek_mst_i2c_spi, parade_lspcon

         • need userspace access to the selected I2C bus

       On OpenBSD, you can obtain raw access permission by setting:

          securelevel=-1

       in <b>/etc/rc.securelevel</b> and rebooting, or rebooting into single user mode.

</pre><h4><b>BUGS</b></h4><pre>
       You can report bugs, ask us questions or send success reports via our communication channels listed here:
       <u>Contact</u> &lt;<b>https://www.flashrom.org/Contact</b>&gt;

       Also, we provide a <u>pastebin</u> <u>service</u> &lt;<b>https://paste.flashrom.org</b>&gt;  that  is  very  useful  to  share  logs
       without spamming the communication channels.

</pre><h4><b>LAPTOPS</b></h4><pre>
       Using  <b>flashrom</b>  on  older laptops is dangerous and may easily make your hardware unusable. <b>flashrom</b> will
       attempt to detect if it is running on a susceptible laptop and restrict  flash-chip  probing  for  safety
       reasons.  Please see the detailed discussion of this topic and associated <b>flashrom</b> options in the <b>Laptops</b>
       paragraph in the <b>internal</b> <b>programmer</b> subsection of the <b>PROGRAMMER-SPECIFIC</b> <b>INFORMATION</b>  section  and  the
       information <u>in</u> <u>our</u> <u>wiki</u> &lt;<b>https://flashrom.org/Laptops</b>&gt;.

       One-time programmable (OTP) memory and unique IDs

       Some  flash chips contain OTP memory often denoted as <b>security</b> <b>registers</b>. They usually have a capacity in
       the range of some bytes to a few hundred bytes and can be used to give devices unique IDs  etc.  <b>flashrom</b>
       is not able to read or write these memories and may therefore not be able to duplicate a chip completely.
       For chip types known to include OTP memories a warning is printed when they are detected.

       Similar  to  OTP memories are unique, factory programmed, unforgeable IDs. They are not modifiable by the
       user at all.

</pre><h4><b>LICENSE</b></h4><pre>
       <b>flashrom</b> is covered by the GNU General Public License (GPL),  version  2.  Some  files  are  additionally
       available under any later version of the GPL.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Please see the individual files.

</pre><h4><b>AUTHORS</b></h4><pre>
       Andrew  Morgan,  Anastasia Klimchuk, Carl-Daniel Hailfinger, Claus Gindhart, David Borg, David Hendricks,
       Dominik Geyer, Edward O'Callaghan, Eric Biederman, Giampiero Giancipoli, Helge Wagner,  Idwer  Vollering,
       Joe  Bao, Joerg Fischer, Joshua Roys, Kyösti Mälkki, Luc Verhaegen, Li-Ta Lo, Mark Marshall, Markus Boas,
       Mattias Mattsson, Michael Karcher, Nikolay Petukhov, Patrick Georgi, Peter Lemenkov, Peter Stuge, Reinder
       E.N. de Haan, Ronald G. Minnich, Ronald Hoogenboom, Sean Nelson, Stefan Reinauer, Stefan  Tauner,  Stefan
       Wildemann,  Stephan  Guilloux,  Steven  James,  Urja  Rannikko, Uwe Hermann, Wang Qingpei, Yinghai Lu and
       others, please see the <b>flashrom</b> git history for details.

       All still active authors can be reached via <u>the</u> <u>mailing</u> <u>list</u> &lt;<b><a href="mailto:flashrom@flashrom.org">flashrom@flashrom.org</a></b>&gt;.

       This manual page was written by <u>Uwe</u> <u>Hermann</u> &lt;<b><a href="mailto:uwe@hermann-uwe.de">uwe@hermann-uwe.de</a></b>&gt;, Carl-Daniel Hailfinger,  Stefan  Tauner
       and others.  It is licensed under the terms of the GNU GPL (version 2 or later).

                                                  Oct 17, 2024                                       <u><a href="../man8/FLASHROM.8.html">FLASHROM</a></u>(8)
</pre>
 </div>
</div></section>
</div>
</body>
</html>