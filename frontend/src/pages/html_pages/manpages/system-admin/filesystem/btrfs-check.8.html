<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>btrfs-check - check or repair a btrfs filesystem</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/btrfs-progs">btrfs-progs_6.14-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       btrfs-check - check or repair a btrfs filesystem

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>btrfs</b> <b>check</b> [options] &lt;device&gt;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The filesystem checker is used to verify structural integrity of a filesystem and attempt to repair it if
       requested.  It is recommended to unmount the filesystem prior to running the check, but it is possible to
       start checking a mounted filesystem (see <u>--force</u>).

       By default, <b>btrfs</b> <b>check</b> will not modify the device but you can reaffirm that by the option <u>--readonly</u>.

       <b>btrfsck</b> is an alias of <b>btrfs</b> <b>check</b> command and is now deprecated.

       <b>NOTE:</b>
          Even  though  the filesystem checker requires a device argument, it scans for all devices belonging to
          the same filesystem, thus it should not cause  a  difference  using  different  devices  of  the  same
          filesystem.   Furthermore  <u><a href="../man8/btrfs-check.8.html">btrfs-check</a>(8)</u>  will  automatically choose the good mirror, thus as long as
          there is a good copy for metadata, it will not report such case as an error.

       <b>WARNING:</b>
          Do not use <u>--repair</u> unless you are advised to do so by a developer or an experienced  user,  and  then
          only  after  having accepted that no <u>fsck</u> successfully repair all types of filesystem corruption. E.g.
          some other software or hardware bugs can fatally damage a volume.

       The structural integrity check verifies if internal filesystem objects or  data  structures  satisfy  the
       constraints, point to the right objects or are correctly connected together.

       There  are several cross checks that can detect wrong reference counts of shared extents, backreferences,
       missing extents of inodes, directory and inode connectivity etc.

       The amount of memory required can be high, depending on the size of the  filesystem,  similarly  the  run
       time. Check the modes that can also affect that.

</pre><h4><b>SAFE</b> <b>OR</b> <b>ADVISORY</b> <b>OPTIONS</b></h4><pre>
       <b>-b|--backup</b>
              use the first valid set of backup roots stored in the superblock

              This can be combined with <u>--super</u> if some of the superblocks are damaged.

       <b>--check-data-csum</b>
              verify checksums of data blocks

              This  expects that the filesystem is otherwise OK, and is basically an offline <u>scrub</u> that does not
              repair data from spare copies.

       <b>--chunk-root</b> <u>&lt;bytenr&gt;</u>
              use the given offset <u>bytenr</u> for the chunk tree root

       <b>-E|--subvol-extents</b> <b>&lt;subvolid&gt;</b>
              show extent state for the given subvolume

       <b>--mode</b> <u>&lt;MODE&gt;</u>
              select mode of operation regarding memory and IO

              The <u>MODE</u> can be one of:

              <b>original</b>
                     The metadata are read into memory and verified, thus the requirements  are  high  on  large
                     filesystems  and  can even lead to out-of-memory conditions.  The possible workaround is to
                     export the block device over network to a machine with enough memory.

              <b>lowmem</b> This mode is supposed to address the high memory consumption at the cost  of  increased  IO
                     when it needs to re-read blocks.  This may increase run time.

       <b>-p|--progress</b>
              indicate progress at various checking phases

       <b>-Q|--qgroup-report</b>
              verify qgroup accounting and compare against filesystem accounting

       <b>-r|--tree-root</b> <b>&lt;bytenr&gt;</b>
              use the given offset 'bytenr' for the tree root

       <b>--readonly</b>
              (default)  run  in read-only mode, this option exists to calm potential panic when users are going
              to run the checker

       <b>-s|--super</b> <b>&lt;N&gt;</b>
              use Nth superblock copy, valid values are 0, 1 or 2 if the respective superblock offset is  within
              the device size

              This can be used to use a different starting point if some of the primary superblock is damaged.

</pre><h4><b>DANGEROUS</b> <b>OPTIONS</b></h4><pre>
       <b>--repair</b>
              enable the repair mode and attempt to fix problems where possible

              <b>NOTE:</b>
                 There's  a  warning and 10 second delay when this option is run without <u>--force</u> to give users a
                 chance to think twice before running repair, the warnings in documentation  have  shown  to  be
                 insufficient.

       <b>--init-csum-tree</b>
              create a new checksum tree and recalculate checksums in all files

              <b>WARNING:</b>
                 Do not blindly use this option to fix checksum mismatch problems.

       <b>--init-extent-tree</b>
              build the extent tree from scratch

              <b>WARNING:</b>
                 Do not use unless you know what you're doing.

       <b>--force</b>
              allow  work  on  a  mounted filesystem and skip mount checks. Note that this should work fine on a
              quiescent or read-only mounted filesystem but may crash if the device is changed externally,  e.g.
              by the kernel module.

              <b>NOTE:</b>
                 It is possible to run with --repair but on a mounted filesystem that will most likely lead to a
                 corruption  unless  the  filesystem  is  in  a  quiescent  state  which  may not be possible to
                 guarantee.

              This option also skips the delay and warning in the repair mode (see <u>--repair</u>).

</pre><h4><b>DEPRECATED</b> <b>OR</b> <b>REMOVED</b> <b>OPTIONS</b></h4><pre>
       <b>--clear-space-cache</b> <b>v1|v2</b>
              completely remove the free space cache of the given version

              See also the <u>clear_cache</u> mount option.

              <b>WARNING:</b>
                 This option is deprecated, please use <u>btrfs</u> <u>rescue</u> <u>clear-space-cache</u> instead, this option would
                 be removed in the future eventually.

</pre><h4><b>EXIT</b> <b>STATUS</b></h4><pre>
       <b>btrfs</b> <b>check</b> returns a zero exit status if it succeeds. Non zero is returned in case of failure.

</pre><h4><b>AVAILABILITY</b></h4><pre>
       <b>btrfs</b> is part of btrfs-progs.  Please refer to the documentation at <u>https://btrfs.readthedocs.io</u>.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man8/mkfs.btrfs.8.html">mkfs.btrfs</a>(8)</u>, <u><a href="../man8/btrfs-scrub.8.html">btrfs-scrub</a>(8)</u>, <u><a href="../man8/btrfs-rescue.8.html">btrfs-rescue</a>(8)</u>

6.14                                              Apr 17, 2025                                    <u><a href="../man8/BTRFS-CHECK.8.html">BTRFS-CHECK</a></u>(8)
</pre>
 </div>
</div></section>
</div>
</body>
</html>