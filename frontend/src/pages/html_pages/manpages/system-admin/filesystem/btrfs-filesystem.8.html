<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>btrfs-filesystem - command group that primarily does work on the whole filesystems</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/btrfs-progs">btrfs-progs_6.14-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       btrfs-filesystem - command group that primarily does work on the whole filesystems

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>btrfs</b> <b>filesystem</b> &lt;subcommand&gt; &lt;args&gt;

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>btrfs</b>  <b>filesystem</b>  is  used  to  perform  several whole filesystem level tasks, including all the regular
       filesystem operations like resizing, space stats, label setting/getting, and defragmentation.  There  are
       other whole filesystem tasks like scrub or balance that are grouped in separate commands (<u><a href="../man8/btrfs-scrub.8.html">btrfs-scrub</a>(8)</u>,
       <u><a href="../man8/btrfs-balance.8.html">btrfs-balance</a>(8)</u>).

</pre><h4><b>SUBCOMMAND</b></h4><pre>
       <b>df</b> <b>[options]</b> <b>&lt;path&gt;</b>
              Show a terse summary information about allocation of block group types of a given mount point. The
              original  purpose  of  this  command  was  a  debugging  helper.  The  output  needs to be further
              interpreted and is not suitable for quick overview.

              An example with description:

              • device size: <u>1.9TiB</u>, one device, no RAID

              • filesystem size: <u>1.9TiB</u>

              • created with: <b>mkfs.btrfs</b> <b>-d</b> <b>single</b> <b>-m</b> <b>single</b>

                 $ btrfs filesystem df /path
                 Data, single: total=1.15TiB, used=1.13TiB
                 System, single: total=32.00MiB, used=144.00KiB
                 Metadata, single: total=12.00GiB, used=6.45GiB
                 GlobalReserve, single: total=512.00MiB, used=0.00B

              • <u>Data</u>, <u>System</u> and <u>Metadata</u> are separate block group types.  <u>GlobalReserve</u> is  an  artificial  and
                internal emergency space, see below.

              • <u>single</u> -- the allocation profile, defined at mkfs time

              • <u>total</u>  --  sum  of  space  reserved  for  all  allocation  profiles  of the given type, i.e. all
                Data/single. Note that it's not total size of filesystem.

              • <u>used</u> -- sum of used space of the above, i.e. file extents, metadata blocks

              <u>GlobalReserve</u> is an artificial and internal emergency space. It is used e.g.  when the  filesystem
              is  full.  Its <u>total</u> size is dynamic based on the filesystem size, usually not larger than 512MiB,
              <u>used</u> may fluctuate.

              The GlobalReserve is a portion  of  Metadata.  In  case  the  filesystem  metadata  is  exhausted,
              <u>GlobalReserve/total</u>  <u>+</u>  <u>Metadata/used</u>  <u>=</u> <u>Metadata/total</u>. Otherwise there appears to be some unused
              space of Metadata.

              <b>Options</b>

              <b>-b|--raw</b>
                     raw numbers in bytes, without the <u>B</u> suffix

              <b>-h|--human-readable</b>
                     print human friendly numbers, base 1024, this is the default

              <b>-H</b>     print human friendly numbers, base 1000

              <b>--iec</b>  select the 1024 base for the following options, according to the IEC standard

              <b>--si</b>   select the 1000 base for the following options, according to the SI standard

              <b>-k|--kbytes</b>
                     show sizes in KiB, or kB with --si

              <b>-m|--mbytes</b>
                     show sizes in MiB, or MB with --si

              <b>-g|--gbytes</b>
                     show sizes in GiB, or GB with --si

              <b>-t|--tbytes</b>
                     show sizes in TiB, or TB with --si

              If conflicting options are passed, the last one takes precedence.

       <b>defragment</b> <b>[options]</b> <b>&lt;file&gt;|&lt;dir&gt;</b> <b>[&lt;file&gt;|&lt;dir&gt;...]</b>
              Defragment file data on a mounted filesystem. Requires kernel 2.6.33 and newer.

              If <u>-r</u> is passed, files in <u>dir</u> will be defragmented  recursively  (not  descending  to  subvolumes,
              mount  points  and  directory symlinks).  The start position and the number of bytes to defragment
              can be specified by start and length using <u>-s</u> and <u>-l</u> options below.   Extents  bigger  than  value
              given  by  <u>-t</u>  will  be skipped, otherwise this value is used as a target extent size, but is only
              advisory and may not be reached if the free space is too fragmented.  Use 0  to  take  the  kernel
              default,  which  is  256KiB  but  may  change  in the future.  You can also turn on compression in
              defragment operations.

              <b>WARNING:</b>
                 Defragmenting with Linux kernel versions &lt; 3.9 or ≥ 3.14-rc2  as  well  as  with  Linux  stable
                 kernel  versions  ≥  3.10.31, ≥ 3.12.12 or ≥ 3.13.4 will break up the reflinks of COW data (for
                 example files copied with <b>cp</b> <b>--reflink</b>, snapshots  or  de-duplicated  data).   This  may  cause
                 considerable increase of space usage depending on the broken up reflinks.

              <b>NOTE:</b>
                 Directory  arguments without <u>-r</u> do not defragment files recursively but will defragment certain
                 internal trees (extent tree and the subvolume tree). This  has  been  confusing  and  could  be
                 removed in the future.

              For  <u>start</u>,  <u>len</u>,  <u>size</u>  it  is  possible  to  append units designator: <u>K</u>, <u>M</u>, <u>G</u>, <u>T</u>, <u>P</u>, or <u>E</u>, which
              represent KiB, MiB, GiB, TiB, PiB, or EiB, respectively (case does not matter).

              <b>Options</b>

              <b>-c[&lt;algo&gt;]</b>
                     compress file contents while  defragmenting.  Optional  argument  selects  the  compression
                     algorithm,  <u>zlib</u>  (default),  <u>lzo</u>  or  <u>zstd</u>.  Currently  it's  not  possible  to  select no
                     compression. See also section <u>EXAMPLES</u>.

              <b>-L|--level</b> <b>&lt;level&gt;</b>
                     Since kernel 6.14 the compresison can also take the level parameter which will be used only
                     for the defragmentation and overrides the eventual mount option compression  level.   Valid
                     levels  depend on the compression algorithms: <u>zlib</u> 1..9, <u>lzo</u> does not have any levels, <u>zstd</u>
                     the standard levels 1..15 and also the realtime -1..-15.

              <b>-r</b>     defragment files recursively in given directories, does not descend to subvolumes or  mount
                     points

              <b>-f</b>     flush data for each file before going to the next file.

                     This  will limit the amount of dirty data to current file, otherwise the amount accumulates
                     from several files and will increase system load. This can also lead to ENOSPC  if  there's
                     too  much  dirty  data  to write and it's not possible to make the reservations for the new
                     data (i.e. how the COW design works).

              <b>-s</b> <b>&lt;start&gt;[kKmMgGtTpPeE]</b>
                     defragmentation will start from the given offset, default is beginning of a file

              <b>-l</b> <b>&lt;len&gt;[kKmMgGtTpPeE]</b>
                     defragment only up to <u>len</u> bytes, default is the file size

              <b>-t</b> <b>&lt;size&gt;[kKmMgGtTpPeE]</b>
                     target extent size, do not touch extents bigger than <u>size</u>, default: 32MiB

                     The value is only advisory and the final size of the extents may differ, depending  on  the
                     state  of  the  free space and fragmentation or other internal logic. Reasonable values are
                     from tens to hundreds of megabytes.

              <b>--step</b> <u>SIZE</u>
                     Perform defragmentation in the range in SIZE steps and flush  (<u>-f</u>)  after  each  one.   The
                     range  is  default  (the whole file) or given by <u>-s</u> and <u>-l</u>, split into the steps or done in
                     one go if the step is larger. Minimum range size is 256KiB.   With  verbosity  options  the
                     progress of defragmentation will be also printed.

              <b>-v</b>     (deprecated) alias for global <u>-v</u> option

       <b>du</b> <b>[options]</b> <b>&lt;path&gt;</b> <b>[&lt;path&gt;..]</b>
              Calculate  disk  usage  of  the  target files using FIEMAP. For individual files, it will report a
              count of total bytes, and exclusive (not shared) bytes. We also calculate  a  'set  shared'  value
              which is described below.

              Each  argument  to  <b>btrfs</b>  <b>filesystem</b> <b>du</b> will have a <u>set</u> <u>shared</u> value calculated for it. We define
              each <u>set</u> as those files found by  a  recursive  search  of  an  argument  (recursion  descends  to
              subvolumes  but  not  mount  points).  The  <u>set</u>  <u>shared</u>  value  then  is a sum of all shared space
              referenced by the set.

              <u>set</u> <u>shared</u> takes into account overlapping shared extents, hence it isn't as simple  as  adding  up
              shared extents.

              <b>Options</b>

              <b>-s|--summarize</b>
                     display only a total for each argument

              <b>--raw</b>  raw numbers in bytes, without the <u>B</u> suffix.

              <b>--human-readable</b>
                     print human friendly numbers, base 1024, this is the default

              <b>--iec</b>  select the 1024 base for the following options, according to the IEC standard.

              <b>--si</b>   select the 1000 base for the following options, according to the SI standard.

              <b>--kbytes</b>
                     show sizes in KiB, or kB with --si.

              <b>--mbytes</b>
                     show sizes in MiB, or MB with --si.

              <b>--gbytes</b>
                     show sizes in GiB, or GB with --si.

              <b>--tbytes</b>
                     show sizes in TiB, or TB with --si.

       <b>label</b> <b>[&lt;device&gt;|&lt;mountpoint&gt;]</b> <b>[&lt;newlabel&gt;]</b>
              Show  or  update  the  label  of  a filesystem. This works on a mounted filesystem or a filesystem
              image.

              The <u>newlabel</u> argument is optional. Current label is printed if the argument is omitted.

              <b>NOTE:</b>
                 The maximum allowable length shall be less than 256 chars and must not contain a  newline.  The
                 trailing newline is stripped automatically.

       <b>mkswapfile</b> <b>[-s</b> <b>size]</b> <b>file</b>
              Create  a  new  file that's suitable and formatted as a swapfile. Default size is 2GiB, fixed page
              size 4KiB, minimum size is 40KiB.

              A swapfile must be created in a specific way: NOCOW  and  preallocated.   Subvolume  containing  a
              swapfile cannot be snapshotted and blocks of an activated swapfile cannot be balanced.

              Swapfile  creation  can  be  achieved  by  standalone commands too. Activation needs to be done by
              command <u><a href="../man8/swapon.8.html">swapon</a>(8)</u>. See also command <b>btrfs</b> <b>inspect-internal</b> <b>map-swapfile</b> and the  <u>Swapfile</u>  <u>feature</u>
              description.

              <b>NOTE:</b>
                 The  command is a simplified version of 'mkswap', if you want to set label, page size, or other
                 parameters please use 'mkswap' proper.

              <b>Options</b>

              <b>-s|--size</b> <b>SIZE</b>
                     Create swapfile of a given size SIZE (accepting k/m/g/e/p suffix).

              <b>-U|--uuid</b> <b>UUID</b>
                     specify UUID to use, or a special  value:  clear  (all  zeros),  random,  time  (time-based
                     random)

       <b>resize</b> <b>[options]</b> <b>[&lt;devid&gt;:][+/-]&lt;size&gt;[kKmMgGtTpPeE]|[&lt;devid&gt;:]max</b> <b>&lt;path&gt;</b>
              Resize a mounted filesystem identified by <u>path</u>. A particular device can be resized by specifying a
              <u>devid</u>.

              <b>WARNING:</b>
                 If  <u>path</u>  is a file containing a BTRFS image then resize does not work as expected and does not
                 resize the image. This would resize the underlying filesystem instead.

              The <u>devid</u> can be found in the output of <b>btrfs</b> <b>filesystem</b> <b>show</b> and defaults to 1 if not  specified.
              The  <u>size</u> parameter specifies the new size of the filesystem.  If the prefix <u>+</u> or <u>-</u> is present the
              size is increased or decreased by the quantity <u>size</u>.  If no units are specified, bytes are assumed
              for <u>size</u>.  Optionally,  the  size  parameter  may  be  suffixed  by  one  of  the  following  unit
              designators:  <u>K</u>,  <u>M</u>,  <u>G</u>, <u>T</u>, <u>P</u>, or <u>E</u>, which represent KiB, MiB, GiB, TiB, PiB, or EiB, respectively
              (case does not matter).

              If <u>max</u> is passed, the filesystem will occupy all available space on the  device  respecting  <u>devid</u>
              (remember, devid 1 by default).

              The  resize  command  does  not  manipulate  the  size  of  underlying  partition.  If you wish to
              enlarge/reduce a filesystem, you must make sure you expand  the  partition  before  enlarging  the
              filesystem  and  shrink the partition after reducing the size of the filesystem.  This can be done
              using <u><a href="../man8/fdisk.8.html">fdisk</a>(8)</u> or <u><a href="../man8/parted.8.html">parted</a>(8)</u> to delete the existing partition and recreate it with the new  desired
              size.   When  recreating  the  partition  make  sure  to use the same starting partition offset as
              before.

              The size of the portion that the filesystem uses of an underlying device can be determined via the
              <b>btrfs</b> <b>filesystem</b> <b>show</b> <b>--raw</b> command on the filesystem’s mount point (where  it’s  given  for  each
              <u>devid</u>  after  the string <u>size</u> or via the <b>btrfs</b> <b>inspect-internal</b> <b>dump-super</b> command on the specific
              device (where it’s given as the value of <u>dev_item.total_bytes</u>, which is not to  be  confused  with
              <u>total_bytes</u>).  The value is also the address of the first byte not used by the filesystem.

              Growing  is usually instant as it only updates the size. However, shrinking could take a long time
              if there are data in the device area that's beyond the new end. Relocation of the data takes time.

              Note that there's a lower limit on  the  new  size  (either  specified  as  an  absolute  size  or
              difference)  that is checked by kernel and rejected eventually as invalid. Lower values will print
              a warning but still pass the request to kernel. The currently known value is 256MiB.

              See also section <u>EXAMPLES</u>.

              <b>Options</b>

              <b>--enqueue</b>
                     wait if there's another exclusive operation running, otherwise continue

       <b>show</b> <b>[options]</b> <b>[&lt;path&gt;|&lt;uuid&gt;|&lt;device&gt;|&lt;label&gt;]</b>
              Show the btrfs filesystem with some additional info about devices and space allocation.

              If no option none of <u>path</u>/<u>uuid</u>/<u>device</u>/<u>label</u> is passed, information about all the BTRFS filesystems
              is shown, both mounted and unmounted.

              <b>Options</b>

              <b>-m|--mounted</b>
                     probe kernel for mounted BTRFS filesystems

              <b>-d|--all-devices</b>
                     scan  all  devices  under  <b><a href="file:/dev">/dev</a></b>,  otherwise  the  devices  list  is  extracted   from   the
                     <b><a href="file:/proc/partitions">/proc/partitions</a></b>  file.  This  is a fallback option if there's no device node manager (like
                     udev) available in the system.

              <b>--raw</b>  raw numbers in bytes, without the <u>B</u> suffix

              <b>--human-readable</b>
                     print human friendly numbers, base 1024, this is the default

              <b>--iec</b>  select the 1024 base for the following options, according to the IEC standard

              <b>--si</b>   select the 1000 base for the following options, according to the SI standard

              <b>--kbytes</b>
                     show sizes in KiB, or kB with --si

              <b>--mbytes</b>
                     show sizes in MiB, or MB with --si

              <b>--gbytes</b>
                     show sizes in GiB, or GB with --si

              <b>--tbytes</b>
                     show sizes in TiB, or TB with --si

       <b>sync</b> <b>&lt;path&gt;</b>
              Force a sync of the filesystem at <u>path</u>, similar to the <u><a href="../man1/sync.1.html">sync</a>(1)</u> command.  In  addition,  it  starts
              cleaning  of  deleted  subvolumes.  To  wait  for the subvolume deletion to complete use the <b>btrfs</b>
              <b>subvolume</b> <b>sync</b> command.

       <b>usage</b> <b>[options]</b> <b>&lt;path&gt;</b> <b>[&lt;path&gt;...]</b>
              Show detailed information about internal filesystem usage. This is supposed to replace  the  <b>btrfs</b>
              <b>filesystem</b> <b>df</b> command in the long run.

              The  level of detail can differ if the command is run under a regular or the root user (due to use
              of restricted ioctl). For both there's a summary section with information about space usage:

                 $ btrfs filesystem usage /path
                 WARNING: cannot read detailed chunk info, RAID5/6 numbers will be incorrect, run as root
                 Overall:
                     Device size:                   1.82TiB
                     Device allocated:              1.17TiB
                     Device unallocated:          669.99GiB
                     Device missing:                  0.00B
                     Device slack:                  1.00GiB
                     Used:                          1.14TiB
                     Free (estimated):            692.57GiB      (min: 692.57GiB)
                     Free (statfs, df)            692.57GiB
                     Data ratio:                       1.00
                     Metadata ratio:                   1.00
                     Global reserve:              512.00MiB      (used: 0.00B)
                     Multiple profiles:                  no

              • <u>Device</u> <u>size</u> -- sum of raw device capacity available to the filesystem, note that this may not be
                the same as the total device size (the difference is accounted as slack)

              • <u>Device</u> <u>allocated</u> -- sum of total space allocated for data/metadata/system  profiles,  this  also
                accounts space reserved but not yet used for extents

              • <u>Device</u>  <u>unallocated</u> -- the remaining unallocated space for future allocations (difference of the
                above two numbers)

              • <u>Device</u> <u>missing</u> -- sum of capacity of all missing devices

              • <u>Device</u> <u>slack</u> -- sum of slack space on all devices (difference between entire device size and the
                space occupied by filesystem)

              • <u>Used</u> -- sum of the used space of data/metadata/system profiles, not including the reserved space

              • <u>Free</u> <u>(estimated)</u> -- approximate size of the remaining free  space  usable  for  data,  including
                currently  allocated  space and estimating the usage of the unallocated space based on the block
                group profiles, the <u>min</u> is the lower bound of the estimate in case multiple profiles are present

              • <u>Free</u> <u>(statfs,</u> <u>df)</u> -- the amount of space available for data as reported  by  the  <b>statfs/statvfs</b>
                syscall,  also returned as <u>Avail</u> in the output of <b>df</b>. The value is calculated in a different way
                and may not match the estimate in some cases (e.g.  multiple profiles).

              • <u>Data</u> <u>ratio</u> -- ratio of total space for data including redundancy or parity  to  the  effectively
                usable  data space, e.g. single is 1.0, RAID1 is 2.0 and for RAID5/6 it depends on the number of
                devices

              • <u>Metadata</u> <u>ratio</u> -- ditto, for metadata

              • <u>Global</u> <u>reserve</u> -- portion of  metadata  currently  used  for  global  block  reserve,  used  for
                emergency purposes (like deletion on a full filesystem)

              • <u>Multiple</u> <u>profiles</u> -- what block group types (data, metadata) have more than one profile (single,
                raid1, ...), see <u><a href="../man5/btrfs.5.html">btrfs</a>(5)</u> section <u>FILESYSTEMS</u> <u>WITH</u> <u>MULTIPLE</u> <u>PROFILES</u>.

              And on a zoned filesystem there are two more lines in the <u>Device</u> section:

                 Device zone unusable:          5.13GiB
                 Device zone size:            256.00MiB

              • <u>Device</u>  <u>zone</u>  <u>unusable</u> -- sum of of space that's been used in the past but now is not due to COW
                and not referenced anymore, the chunks have to be reclaimed and zones reset to  make  it  usable
                again

              • <u>Device</u> <u>zone</u> <u>size</u> -- the reported zone size of the host-managed device, same for all devices

              The root user will also see stats broken down by block group types:

                 Data,single: Size:1.15TiB, Used:1.13TiB (98.26%)
                    /dev/sdb        1.15TiB

                 Metadata,single: Size:12.00GiB, Used:6.45GiB (53.75%)
                    /dev/sdb       12.00GiB

                 System,single: Size:32.00MiB, Used:144.00KiB (0.44%)
                    /dev/sdb       32.00MiB

                 Unallocated:
                    /dev/sdb      669.99GiB

              <u>Data</u> is block group type, <u>single</u> is block group profile, <u>Size</u> is total size occupied by this type,
              <u>Used</u>  is  the actually used space, the percent is ratio of <u>Used/Size</u>. The <u>Unallocated</u> is remaining
              space.

              <b>Options</b>

              <b>-b|--raw</b>
                     raw numbers in bytes, without the <u>B</u> suffix

              <b>-h|--human-readable</b>
                     print human friendly numbers, base 1024, this is the default

              <b>-H</b>     print human friendly numbers, base 1000

              <b>--iec</b>  select the 1024 base for the following options, according to the IEC standard

              <b>--si</b>   select the 1000 base for the following options, according to the SI standard

              <b>-k|--kbytes</b>
                     show sizes in KiB, or kB with --si

              <b>-m|--mbytes</b>
                     show sizes in MiB, or MB with --si

              <b>-g|--gbytes</b>
                     show sizes in GiB, or GB with --si

              <b>-t|--tbytes</b>
                     show sizes in TiB, or TB with --si

              <b>-T</b>     show data in tabular format

              If conflicting options are passed, the last one takes precedence.

</pre><h4><b>EXAMPLES</b></h4><pre>
       <b>$</b> <b>btrfs</b> <b>filesystem</b> <b>defrag</b> <b>-v</b> <b>-r</b> <b>dir/</b>

       Recursively defragment files under <b>dir/</b>, print files as they are  processed.   The  file  names  will  be
       printed  in  batches,  similarly  the amount of data triggered by defragmentation will be proportional to
       last N printed files. The system dirty memory throttling will slow down the defragmentation but there can
       still be a lot of IO load and the system may stall for a moment.

       <b>$</b> <b>btrfs</b> <b>filesystem</b> <b>defrag</b> <b>-v</b> <b>-r</b> <b>-f</b> <b>dir/</b>

       Recursively defragment files under <b>dir/</b>, be  verbose  and  wait  until  all  blocks  are  flushed  before
       processing  next  file.  You  can  note  slower progress of the output and lower IO load (proportional to
       currently defragmented file).

       <b>$</b> <b>btrfs</b> <b>filesystem</b> <b>defrag</b> <b>-v</b> <b>-r</b> <b>-f</b> <b>-clzo</b> <b>dir/</b>

       Recursively defragment files under <b>dir/</b>, be verbose, wait until all blocks are  flushed  and  force  file
       compression.

       <b>$</b> <b>btrfs</b> <b>filesystem</b> <b>defrag</b> <b>-v</b> <b>-r</b> <b>-t</b> <b>64M</b> <b>dir/</b>

       Recursively defragment files under <b>dir/</b>, be verbose and try to merge extents to be about 64MiB. As stated
       above, the success rate depends on actual free space fragmentation and the final result is not guaranteed
       to meet the target even if run repeatedly.

       <b>$</b> <b>btrfs</b> <b>filesystem</b> <b>resize</b> <b>-1G</b> <b>/path</b>

       <b>$</b> <b>btrfs</b> <b>filesystem</b> <b>resize</b> <b>1:-1G</b> <b>/path</b>

       Shrink  size  of  the  filesystem's  device  id 1 by 1GiB. The first syntax expects a device with id 1 to
       exist, otherwise fails. The second is equivalent and more explicit. For a single-device  filesystem  it's
       typically not necessary to specify the devid though.

       <b>$</b> <b>btrfs</b> <b>filesystem</b> <b>resize</b> <b>max</b> <b>/path</b>

       <b>$</b> <b>btrfs</b> <b>filesystem</b> <b>resize</b> <b>1:max</b> <b>/path</b>

       Let's  assume  that devid 1 exists and the filesystem does not occupy the whole block device, e.g. it has
       been enlarged and we want to grow the filesystem. By simply using <u>max</u> as size we will achieve that.

       <b>NOTE:</b>
          There are two ways  to  minimize  the  filesystem  on  a  given  device.  The  <b>btrfs</b>  <b>inspect-internal</b>
          <b>min-dev-size</b> command, or iteratively shrink in steps.

</pre><h4><b>EXIT</b> <b>STATUS</b></h4><pre>
       <b>btrfs</b> <b>filesystem</b> returns a zero exit status if it succeeds. Non zero is returned in case of failure.

</pre><h4><b>AVAILABILITY</b></h4><pre>
       <b>btrfs</b> is part of btrfs-progs.  Please refer to the documentation at <u>https://btrfs.readthedocs.io</u>.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man8/btrfs-subvolume.8.html">btrfs-subvolume</a>(8)</u>, <u><a href="../man8/mkfs.btrfs.8.html">mkfs.btrfs</a>(8)</u>

6.14                                              Apr 17, 2025                               <u><a href="../man8/BTRFS-FILESYSTEM.8.html">BTRFS-FILESYSTEM</a></u>(8)
</pre>
 </div>
</div></section>
</div>
</body>
</html>