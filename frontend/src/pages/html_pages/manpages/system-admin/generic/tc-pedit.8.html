<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>pedit - generic packet editor action</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/iproute2">iproute2_6.14.0-1ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       pedit - generic packet editor action

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>tc</b> ... <b>action</b> <b>pedit</b> <b>[ex]</b> <b>munge</b> { <u>RAW_OP</u> | <u>LAYERED_OP</u> | <u>EXTENDED_LAYERED_OP</u> } [ <u>CONTROL</u> ]

       <u>RAW_OP</u> := <b>offset</b> <u>OFFSET</u> { <b>u8</b> | <b>u16</b> | <b>u32</b> } [ <u>AT_SPEC</u> ] <u>CMD_SPEC</u>

       <u>AT_SPEC</u> := <b>at</b> <u>AT</u> <b>offmask</b> <u>MASK</u> <b>shift</b> <u>SHIFT</u>

       <u>LAYERED_OP</u> := { <b>ip</b> <u>IPHDR_FIELD</u> | <b>ip</b> <u>BEYOND_IPHDR_FIELD</u> } <u>CMD_SPEC</u>

       <u>EXTENDED_LAYERED_OP</u>  :=  { <b>eth</b> <u>ETHHDR_FIELD</u> | <b>ip</b> <u>IPHDR_FIELD</u> | <b>ip</b> <u>EX_IPHDR_FIELD</u> | <b>ip6</b> <u>IP6HDR_FIELD</u> | <b>tcp</b>
               <u>TCPHDR_FIELD</u> | <b>udp</b> <u>UDPHDR_FIELD</u> } <u>CMD_SPEC</u>

       <u>ETHHDR_FIELD</u> := { <b>src</b> | <b>dst</b> | <b>type</b> }

       <u>IPHDR_FIELD</u> := { <b>src</b> | <b>dst</b> | <b>tos</b> | <b>dsfield</b> | <b>ihl</b> | <b>protocol</b> | <b>precedence</b> | <b>nofrag</b> | <b>firstfrag</b> | <b>ce</b> | <b>df</b> }

       <u>BEYOND_IPHDR_FIELD</u> := { <b>dport</b> | <b>sport</b> | <b>icmp_type</b> | <b>icmp_code</b> }

       <u>EX_IPHDR_FIELD</u> := { <b>ttl</b> }

       <u>IP6HDR_FIELD</u> := { <b>src</b> | <b>dst</b> | <b>traffic_class</b> | <b>flow_lbl</b> | <b>payload_len</b> | <b>nexthdr</b> | <b>hoplimit</b> }

       <u>TCPHDR_FIELD</u> := { <b>sport</b> | <b>dport</b> | <b>flags</b> }

       <u>UDPHDR_FIELD</u> := { <b>sport</b> | <b>dport</b> }

       <u>CMD_SPEC</u> := { <b>clear</b> | <b>invert</b> | <b>set</b> <u>VAL</u> | <b>add</b> <u>VAL</u> | <b>decrement</b> | <b>preserve</b> } [ <b>retain</b> <u>RVAL</u> ]

       <u>CONTROL</u> := { <b>reclassify</b> | <b>pipe</b> | <b>drop</b> | <b>shot</b> | <b>continue</b> | <b>pass</b> | <b>goto</b> <b>chain</b> <b>CHAIN_INDEX</b> }

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <b>pedit</b> action can be used to change arbitrary packet data. The location of data to change  can  either
       be  specified  by  giving  an offset and size as in <u>RAW_OP</u>, or for header values by naming the header and
       field to edit the size is then chosen automatically based on the header field size.

</pre><h4><b>OPTIONS</b></h4><pre>
       <b>ex</b>     Use extended pedit.  <u>EXTENDED_LAYERED_OP</u> and the add/decrement <u>CMD_SPEC</u> are allowed only  in  this
              mode.

       <b>offset</b> <u>OFFSET</u> { <b>u32</b> | <b>u16</b> | <b>u8</b> }
              Specify  the  offset  at  which  to  change  data.   <u>OFFSET</u>  is  a  signed  integer,  it's base is
              automatically chosen (e.g. hex if prefixed by <b>0x</b> or octal if prefixed by <b>0</b>).  The second  argument
              specifies the length of data to change, that is four bytes (<b>u32</b>), two bytes (<b>u16</b>) or a single byte
              (<b>u8</b>).

       <b>at</b> <u>AT</u> <b>offmask</b> <u>MASK</u> <b>shift</b> <u>SHIFT</u>
              This  is an optional part of <u>RAW_OP</u> which allows one to have a variable <u>OFFSET</u> depending on packet
              data at offset <u>AT</u>, which is binary ANDed with <u>MASK</u> and right-shifted by <u>SHIFT</u> before adding it  to
              <u>OFFSET</u>.

       <b>eth</b> <u>ETHHDR_FIELD</u>
              Change an ETH header field. The supported keywords for <u>ETHHDR_FIELD</u> are:

              <b>src</b>
              <b>dst</b>    Source or destination MAC address in the standard format: XX:XX:XX:XX:XX:XX

              <b>type</b>   Ether-type in numeric value

       <b>ip</b> <u>IPHDR_FIELD</u>
              Change an IPv4 header field. The supported keywords for <u>IPHDR_FIELD</u> are:

              <b>src</b>
              <b>dst</b>    Source or destination IP address, a four-byte value.

              <b>tos</b>
              <b>dsfield</b>
              <b>precedence</b>
                     Type Of Service field, an eight-bit value.

              <b>ihl</b>    Change the IP Header Length field, a four-bit value.

              <b>protocol</b>
                     Next-layer Protocol field, an eight-bit value.

              <b>nofrag</b>
              <b>firstfrag</b>
              <b>ce</b>
              <b>df</b>
              <b>mf</b>     Change  IP  header  flags. Note that the value to pass to the <b>set</b> command is not just a bit
                     value, but the full byte including the flags field.  Though only the relevant bits of  that
                     value are respected, the rest ignored.

       <b>ip</b> <u>BEYOND_IPHDR_FIELD</u>
              Supported  only for non-extended layered op. It is passed to the kernel as offsets relative to the
              beginning of the IP header and assumes the IP header is of minimum size (20 bytes). The  supported
              keywords for <u>BEYOND_IPHDR_FIELD</u> are:

              <b>dport</b>
              <b>sport</b>  Destination or source port numbers, a 16-bit value. Indeed, IPv4 headers don't contain this
                     information.  Instead,  this  will set an offset which suits at least TCP and UDP if the IP
                     header is of minimum size (20 bytes). If not, this will do unexpected things.

              <b>icmp_type</b>
              <b>icmp_code</b>
                     Again, this allows one to change data past the actual IP header itself. It assumes an  ICMP
                     header is present immediately following the (minimal sized) IP header.  If it is not or the
                     latter is bigger than the minimum of 20 bytes, this will do unexpected things. These fields
                     are eight-bit values.

       <b>ip</b> <u>EX_IPHDR_FIELD</u>
              Supported only when <u>ex</u> is used. The supported keywords for <u>EX_IPHDR_FIELD</u> are:

              <b>ttl</b>

       <b>ip6</b> <u>IP6HDR_FIELD</u>
              The supported keywords for <u>IP6HDR_FIELD</u> are:

              <b>src</b>
              <b>dst</b>
              <b>traffic_class</b>
              <b>flow_lbl</b>
              <b>payload_len</b>
              <b>nexthdr</b>
              <b>hoplimit</b>

       <b>tcp</b> <u>TCPHDR_FIELD</u>
              The supported keywords for <u>TCPHDR_FIELD</u> are:

              <b>sport</b>
              <b>dport</b>  Source or destination TCP port number, a 16-bit value.

              <b>flags</b>

       <b>udp</b> <u>UDPHDR_FIELD</u>
              The supported keywords for <u>UDPHDR_FIELD</u> are:

              <b>sport</b>
              <b>dport</b>  Source or destination TCP port number, a 16-bit value.

       <b>clear</b>  Clear the addressed data (i.e., set it to zero).

       <b>invert</b> Swap every bit in the addressed data.

       <b>set</b> <u>VAL</u>
              Set  the  addressed data to a specific value. The size of <u>VAL</u> is defined by either one of the <b>u32</b>,
              <b>u16</b> or <b>u8</b> keywords in <u>RAW_OP</u>, or the size of the addressed header field in <u>LAYERED_OP</u>.

       <b>add</b> <u>VAL</u>
              Add the addressed data by a specific value. The size  of  <u>VAL</u>  is  defined  by  the  size  of  the
              addressed  header  field  in  <u>EXTENDED_LAYERED_OP</u>.   This operation is supported only for extended
              layered op.

       <b>decrement</b>
              Decrease the addressed data by one.  This operation is supported only for <b>ip</b> <b>ttl</b> and <b>ip6</b> <b>hoplimit</b>.

       <b>preserve</b>
              Keep the addressed data as is.

       <b>retain</b> <u>RVAL</u>
              This optional extra part of <u>CMD_SPEC</u> allows one to exclude bits from being changed. Supported only
              for 32 bits fields or smaller.

       <u>CONTROL</u>
              The following keywords allow one to control how the tree of qdisc, classes, filters and actions is
              further traversed after this action.

              <b>reclassify</b>
                     Restart with the first filter in the current list.

              <b>pipe</b>   Continue with the next action attached to the same filter.

              <b>drop</b>
              <b>shot</b>   Drop the packet.

              <b>continue</b>
                     Continue classification with the next filter in line.

              <b>pass</b>   Finish classification process and return to calling qdisc for  further  packet  processing.
                     This is the default.

</pre><h4><b>EXAMPLES</b></h4><pre>
       Being  able  to  edit  packet  data,  one  could  do all kinds of things, such as e.g.  implementing port
       redirection. Certainly not the most useful application, but as an example it should do:

       First, qdiscs need to be set up to attach filters to. For the receive path, a simple <b>ingress</b>  qdisc  will
       do, for transmit path a classful qdisc (<b>HTB</b> in this case) is necessary:

              tc qdisc replace dev eth0 root handle 1: htb
              tc qdisc add dev eth0 ingress handle ffff:

       Finally,  a  filter with <b>pedit</b> action can be added for each direction. In this case, <b>u32</b> is used matching
       on the port number to redirect from, while <b>pedit</b> then does the actual rewriting:

              tc filter add dev eth0 parent 1: u32 \
                   match ip dport 23 0xffff \
                   action pedit pedit munge ip dport set 22
              tc filter add dev eth0 parent ffff: u32 \
                   match ip sport 22 0xffff \
                   action pedit pedit munge ip sport set 23
              tc filter add dev eth0 parent ffff: u32 \
                   match ip sport 22 0xffff \
                   action pedit ex munge ip dst set 192.168.1.199
              tc filter add dev eth0 parent ffff: u32 \
                   match ip sport 22 0xffff \
                   action pedit ex munge ip6 dst set fe80::dacb:8aff:fec7:320e
              tc filter add dev eth0 parent ffff: u32 \
                   match ip sport 22 0xffff \
                   action pedit ex munge eth dst set 11:22:33:44:55:66
              tc filter add dev eth0 parent ffff: u32 \
                   match ip dport 23 0xffff \
                   action pedit ex munge tcp dport set 22

       To rewrite just part of a field, use the <b>retain</b> directive. E.g. to overwrite the DSCP part of  a  dsfield
       with $DSCP, without touching ECN:

              tc filter add dev eth0 ingress flower ... \
                   action pedit ex munge ip dsfield set $((DSCP &lt;&lt; 2)) retain 0xfc

       And vice versa, to set ECN to e.g. 1 without impacting DSCP:

              tc filter add dev eth0 ingress flower ... \
                   action pedit ex munge ip dsfield set 1 retain 0x3

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man8/tc.8.html">tc</a></b>(8), <b><a href="../man8/tc-htb.8.html">tc-htb</a></b>(8), <b><a href="../man8/tc-u32.8.html">tc-u32</a></b>(8)

iproute2                                           12 Jan 2015             <u>Generic</u> <u>packet</u> <u>editor</u> <u>action</u> <u>in</u> <u><a href="../man8/tc.8.html">tc</a></u>(8)
</pre>
 </div>
</div></section>
</div>
</body>
</html>