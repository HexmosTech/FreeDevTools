<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sg_write_long - send SCSI WRITE LONG command</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/sg3-utils">sg3-utils_1.48-2ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       sg_write_long - send SCSI WRITE LONG command

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>sg_write_long</b>  [<u>--16</u>]  [<u>--cor_dis</u>]  [<u>--help</u>]  [<u>--in=IF</u>]  [<u>--lba=LBA</u>]  [<u>--pblock</u>]  [<u>--verbose</u>] [<u>--version</u>]
       [<u>--wr_uncor</u>] [<u>--xfer_len=BTL</u>] <u>DEVICE</u>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Send the SCSI WRITE LONG (10 or 16 byte) command to <u>DEVICE</u>. The buffer to be written  to  the  <u>DEVICE</u>  is
       filled  with  <b>0xff</b> bytes or read from the <u>IF</u> file. This buffer includes the logical data (e.g. 512 bytes)
       and the ECC bytes.

       This utility can be used to generate a MEDIUM ERROR at a specific logical  block  address.  This  can  be
       useful  for  testing  error  handling.  Prior to such a test, the <b>sg_dd</b> utility could be used to copy the
       original contents of the logical block address to some safe location. After the test  the  <b>sg_dd</b>  utility
       could  be  used  to  write back the original contents of the logical block address. An alternate strategy
       would be to read the "long" contents of the logical block address  with  <b>sg_read_long</b>  utility  prior  to
       testing and restore it with this utility after testing.

       <b>Take</b>  <b>care:</b> If recoverable errors are being injected (e.g. only one or a few bits changed so that the ECC
       is able to correct the data) then care should be taken  with  the  settings  in  the  "read  write  error
       recovery"  mode  page.   Specifically  if  the  ARRE  (for  reads)  and/or AWRE (for writes) are set then
       recovered errors will cause the lba to be reassigned (and the old location  to  be  added  to  the  grown
       defect  list  (PLIST)).  This  is  not  easily  reversed and uses (one of the finite number of) the spare
       sectors set aside for this purpose. If in doubt it is probably safest to clear the ARRE  and  AWRE  bits.
       These  bits  can  be  checked  and  modified  with the sdparm utility.  For example: "sdparm -c AWRE,ARRE
       /dev/sda" will clear the bits until the disk is power cycled.

       In SBC-4 revision 7 all uses of SCSI WRITE LONG (10 and 16 byte) commands were made obsolete  apart  from
       the  case  in  which  the  WR_UNCOR  bit  is set.  The SCSI READ LONG (10 and 16 byte) commands were made
       obsolete in the same revision.

</pre><h4><b>OPTIONS</b></h4><pre>
       Arguments to long options are mandatory for short options as well.

       <b>-S</b>, <b>--16</b>
              send a SCSI WRITE LONG (16) command to <u>DEVICE</u>. The default action (in the absence of this  option)
              is to send a SCSI WRITE LONG (10) command.

       <b>-c</b>, <b>--cor_dis</b>
              sets  the  correction disabled (i.e 'COR_DIS') bit. This inhibits various other mechanisms such as
              automatic block reallocation, error recovery and various informational exception conditions  being
              triggered.  This bit is relatively new in SBC-3 .

       <b>-h</b>, <b>--help</b>
              output the usage message then exit.

       <b>-i</b>, <b>--in</b>=<u>IF</u>
              read  data  (binary)  from  file named <u>IF</u> and use it for the SCSI WRITE LONG command. If <u>IF</u> is "-"
              then stdin is read. If this option is not given then 0xff bytes are used as fill.

       <b>-l</b>, <b>--lba</b>=<u>LBA</u>
              where <u>LBA</u> is the logical block address of the sector to overwrite.  Defaults to lba 0 which  is  a
              dangerous  block  to  overwrite on a disk that is in use. Assumed to be in decimal unless prefixed
              with '0x' or has a trailing 'h'. If <u>LBA</u> is larger than can fit in 32 bits  then  the  <u>--16</u>  option
              should be used.

       <b>-p</b>, <b>--pblock</b>
              sets  the  physical  block (i.e 'PBLOCK') bit. This instructs <u>DEVICE</u> to use the given data (unless
              <u>--wr_uncor</u> is also given) to write to the physical block specified by <u>LBA</u>. The default  action  is
              to write to the logical block corresponding to the given lba.  This bit is relatively new in SBC-3
              .

       <b>-v</b>, <b>--verbose</b>
              increase the degree of verbosity (debug messages).

       <b>-V</b>, <b>--version</b>
              output version string then exit.

       <b>-w</b>, <b>--wr_uncor</b>
              sets the "write uncorrected" (i.e 'WR_UNCOR') bit. This instructs the <u>DEVICE</u> to flag the given lba
              (or  the  physical  block  that  contains it if <u>--pblock</u> is also given) as having an unrecoverable
              error associated with it. Note: no data is transferred to <u>DEVICE</u>, other than the command (i.e. the
              cdb). In the absence of this option, the default action is to use the provided data or 0xff  bytes
              (<u>--xfer_len=BTL</u> in length) and write it to <u>DEVICE</u>.  This bit is relatively new in SBC-3 .

       <b>-x</b>, <b>--xfer_len</b>=<u>BTL</u>
              where  <u>BTL</u>  is the byte transfer length (default to 520). If the given value (or the default) does
              not match the "long" block size of the device, nothing is written to <u>DEVICE</u>  and  the  appropriate
              xfer_len value may be deduced from the error response which is printed (to stderr).

</pre><h4><b>NOTES</b></h4><pre>
       Various  numeric arguments (e.g. <u>LBA</u>) may include multiplicative suffixes or be given in hexadecimal. See
       the "NUMERIC ARGUMENTS" section in the <a href="../man8/sg3_utils.8.html">sg3_utils</a>(8) man page.

       The 10 byte SCSI WRITE LONG command limits the logical block address to a 32  bit  quantity.  For  larger
       LBAs use the <u>--16</u> option for the SCSI WRITE LONG (16) command.

</pre><h4><b>EXAMPLES</b></h4><pre>
       This  section  outlines  setting  up  a  block  with  corrupted  data, checking the error condition, then
       restoring useful contents to that sector.

       First, if the data in a sector is important, save it with the sg_read_long utility:

         sg_read_long --lba=0x1234 --out=0x1234_1.img -x <u>BTL</u> /dev/sda

       This utility may need to be executed several time in order to determine what the correct  value  for  <u>BTL</u>
       is.  Next use this utility to "corrupt" that sector. That might be done with:

         sg_write_long --lba=0x1234 -x <u>BTL</u> /dev/sda

       This  will  write  a sector (and ECC data) of 0xff bytes. Some disks may reject this (at least one of the
       author's does). Another approach is to copy the 0x1234_1.img file (to 0x1234_2.img in this  example)  and
       change some values with a hex editor. Then write the changed image with:

         sg_write_long --lba=0x1234 --in=0x1234_2.img -x <u>BTL</u> /dev/sda

       Yet another approach is to use the <u>--wr_uncor</u> option, if supported:

         sg_write_long --lba=0x1234 --wr_uncor /dev/sda

       Next we use the sg_dd utility to check that the sector is corrupted. Here is an example:

         sg_dd if=/dev/sda blk_sgio=1 skip=0x1234 of=. bs=512 count=1 verbose=4

       Notice  that  the  "blk_sgio=1"  option  is  given.  This is to make sure that the sector is read (and no
       others) and the error is fully reported.  The "blk_sgio=1" option causes the SG_IO ioctl to  be  used  by
       sg_dd rather than the block subsystem.

       Finally we should restore sector 0x1234 to a non-corrupted state. A sector full of zeros could be written
       with:

         sg_dd if=/dev/zero of=/dev/sda blk_sgio=1 seek=0x1234 bs=512 count=1

       This  will  result  in  a  sector  (block) with 512 bytes of 0x0 without a MEDIUM ERROR since the ECC and
       associated data will be regenerated and thus well formed. The 'blk_sgio=1' option is even more  important
       in  this  case  as  it  may  stop the block subsystem doing a read before write (since the read will most
       likely fail).  Another approach is to write back the original contents:

         sg_write_long --lba=0x1234 --in=0x1234_1.img -x <u>BTL</u> /dev/sda

</pre><h4><b>EXIT</b> <b>STATUS</b></h4><pre>
       The exit status of sg_write_long is 0 when it is successful. Otherwise see the <a href="../man8/sg3_utils.8.html">sg3_utils</a>(8) man page.

</pre><h4><b>AUTHORS</b></h4><pre>
       Written by Saeed Bishara. Further work by Douglas Gilbert.

</pre><h4><b>REPORTING</b> <b>BUGS</b></h4><pre>
       Report bugs to &lt;dgilbert at interlog dot com&gt;.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright Â© 2004-2016 Douglas Gilbert
       This software is distributed under the GPL version 2. There is NO warranty; not even for  MERCHANTABILITY
       or FITNESS FOR A PARTICULAR PURPOSE.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b>sg_read_long,</b> <b>sg_dd</b> <b>(both</b> <b>in</b> <b>sg3_utils),</b> <b>sdparm(sdparm)</b>

sg3_utils-1.42                                    January 2016                                  <u><a href="../man8/SG_WRITE_LONG.8.html">SG_WRITE_LONG</a></u>(8)
</pre>
 </div>
</div></section>
</div>
</body>
</html>