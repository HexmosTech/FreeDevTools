<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>getc_putc - program to test hard drive performance.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/bonnie++">bonnie++_2.00a+nmu2ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       getc_putc - program to test hard drive performance.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>getc_putc</b> <u>[-d</u> <u>dir]</u> <u>[-s</u> <u>size(KiB)]</u> <u>[-m</u> <u>machine-name]</u> <u>[-u</u> <u>uid-to-use:gid-to-use]</u> <u>[-g</u> <u>gid-to-use]</u>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This manual page documents briefly the <b>getc_putc</b>, program.

       This is a simple adjunct to the <b>bonnie++</b> benchmark.  It is used to test various ways of doing IO one byte
       at  a time, usually you don't need to do enough of this for it to be a performance issue for it to matter
       much which way you do it.  But sometimes it's necessary (for example whan parsing IO from a terminal  and
       then launching another process which will take over all IO, such as a simple shell).

       The real benefits of this are to help settle some arguements about the performance of such things, and to
       educate novices about how bad per-byte IO really is.

</pre><h4><b>OPTIONS</b></h4><pre>
       For  getc_putc  every  option is of the form of a hyphen followed by a letter and then the next parameter
       contains the value.

       <b>-d</b>     the directory to use for the tests.

       <b>-s</b>     the size of the file for byte IO performance measured in kilobytes.  NB You can specify  the  size
              in mega-bytes if you add 'm' to the end of the number.

              The default for this test is to test with a 512MiB file.  Of the file only 1/64 of it will be used
              for write() and read() system calls (anything else takes too long).

       <b>-m</b>     name of the machine - for display purposes only.

       <b>-u</b>     user-id to use.  When running as root specify the UID to use for the tests.  It is not recommended
              to  use  root, so if you really want to run as root then use <b>-u</b> <b>root.</b>  Also if you want to specify
              the group to run as then use the <b>user:group</b> format.  If you specify a user by name  but  no  group
              then  the primary group of that user will be chosen.  If you specify a user by number and no group
              then the group will be <b>nogroup.</b>

       <b>-g</b>     group-id to use.  Same as using <b>:group</b> for the <b>-u</b> parameter, just a different way  to  specify  it
              for compatibility with other programs.

       <b>-q</b>     quiet  mode.  If  specified then some of the extra informational messages will be suppressed. Also
              the csv data will be the only output on standard out and the plain text data will be  on  standard
              error. This means you can run <b>getc_putc</b> <b>-q</b> <b>&gt;&gt;</b> <b>file.csv</b> to record your csv data.

</pre><h4><b>OUTPUT</b></h4><pre>
       The  primary  output is plain-text in 80 columns which is designed to fit well when pasted into email and
       which will work well with Braille displays.

       The second type of output is CSV (Comma  Seperated  Values).   This  can  easily  be  imported  into  any
       spread-sheet or database program.

       For  every  test  the result is a speed in KiB/s.  I do not display the CPU time because it presumably is
       99% of the power of a single CPU (or something very close to that).

</pre><h4><b>AUTHOR</b></h4><pre>
       This  program,  it's  manual  page,  and   the   Debian   package   were   written   by   Russell   Coker
       &lt;<a href="mailto:russell@coker.com.au">russell@coker.com.au</a>&gt;.

       The  documentation, the Perl scripts, and all the code for testing the creation of thousands of files was
       written by Russell Coker, but the entire package is under joint copyright with Tim Bray.

</pre><h4><b>SIGNALS</b></h4><pre>
       Handles SIGINT and does a cleanup (which may take some time), a second SIGINT or a SIGQUIT will cause  it
       to immidiately die.

       SIGXCPU and SIGXFSZ act like SIGINT.

       Ignores SIGHUP.

</pre><h4><b>AVAILABILITY</b></h4><pre>
       The source is available from <a href="http://www.coker.com.au/bonnie">http://www.coker.com.au/bonnie</a>++ .

       See <a href="http://etbe.coker.com.au/category/benchmark">http://etbe.coker.com.au/category/benchmark</a> for further information.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b>bonnie++</b>(8), <b><a href="../man8/zcav.8.html">zcav</a></b>(8)

                                                                                                    <u><a href="../man8/getc_putc.8.html">getc_putc</a></u>(8)
</pre>
 </div>
</div></section>
</div>
</body>
</html>