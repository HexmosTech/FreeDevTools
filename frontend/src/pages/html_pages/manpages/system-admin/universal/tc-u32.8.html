<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>u32 - universal 32bit traffic control filter</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/iproute2">iproute2_6.14.0-1ubuntu3_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       u32 - universal 32bit traffic control filter

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>tc</b> <b>filter</b> ... [ <b>handle</b> <u>HANDLE</u> ] <b>u32</b> <u>OPTION_LIST</u> [ <b>offset</b> <u>OFFSET</u> ] [ <b>hashkey</b> <u>HASHKEY</u> ] [ <b>classid</b> <u>CLASSID</u> ]
               [ <b>divisor</b> <u>uint_value</u> ] [ <b>order</b> <u>u32_value</u> ] [ <b>ht</b> <u>HANDLE</u> ] [ <b>sample</b> <u>SELECTOR</u> [ <b>divisor</b> <u>uint_value</u> ]
               ] [ <b>link</b> <u>HANDLE</u> ] [ <b>indev</b> <u>ifname</u> ] [ <b>skip_hw</b> | <b>skip_sw</b> ] [ <b>help</b> ]

       <u>HANDLE</u> := { <u>u12_hex_htid</u><b>:</b>[<u>u8_hex_hash</u><b>:</b>[<u>u12_hex_nodeid</u>] | <b>0x</b><u>u32_hex_value</u> }

       <u>OPTION_LIST</u> := [ <u>OPTION_LIST</u> ] <u>OPTION</u>

       <u>HASHKEY</u> := [ <b>mask</b> <u>u32_hex_value</u> ] [ <b>at</b> <u>4*int_value</u> ]

       <u>CLASSID</u> := { <b>root</b> | <b>none</b> | [<u>u16_major</u>]<b>:</b><u>u16_minor</u> | <u>u32_hex_value</u> }

       <u>OFFSET</u> := [ <b>plus</b> <u>int_value</u> ] [ <b>at</b> <u>2*int_value</u> ] [ <b>mask</b> <u>u16_hex_value</u> ] [ <b>shift</b> <u>int_value</u> ] [ <b>eat</b> ]

       <u>OPTION</u> := { <b>match</b> <u>SELECTOR</u> | <b>action</b> <u>ACTION</u> }

       <u>SELECTOR</u>  := { <b>u32</b> <u>VAL_MASK_32</u> | <b>u16</b> <u>VAL_MASK_16</u> | <b>u8</b> <u>VAL_MASK_8</u> | <b>ip</b> <u>IP</u> | <b>ip6</b> <u>IP6</u> | { <b>tcp</b> | <b>udp</b> } <u>TCPUDP</u>
               | <b>icmp</b> <u>ICMP</u> | <b>mark</b> <u>VAL_MASK_32</u> | <b>ether</b> <u>ETHER</u> }

       <u>IP</u> := { { <b>src</b> | <b>dst</b> } { <b>default</b> | <b>any</b> | <b>all</b> | <u>ip_address</u> [ <b>/</b> { <u>prefixlen</u> | <u>netmask</u> } ] } <u>AT</u> | { <b>dsfield</b> |
               <b>ihl</b> | <b>protocol</b> | <b>precedence</b> | <b>icmp_type</b> | <b>icmp_code</b> } <u>VAL_MASK_8</u> | { <b>sport</b> | <b>dport</b> }  <u>VAL_MASK_16</u>
               | <b>nofrag</b> | <b>firstfrag</b> | <b>df</b> | <b>mf</b> }

       <u>IP6</u>  :=  { { <b>src</b> | <b>dst</b> } { <b>default</b> | <b>any</b> | <b>all</b> | <u>ip6_address</u> [/<u>prefixlen</u> ] } <u>AT</u> | <b>priority</b> <u>VAL_MASK_8</u> | {
               <b>protocol</b> | <b>icmp_type</b> | <b>icmp_code</b> } <u>VAL_MASK_8</u> |  <b>flowlabel</b>  <u>VAL_MASK_32</u>  |  {  <b>sport</b>  |  <b>dport</b>  }
               <u>VAL_MASK_16</u> }

       <u>TCPUDP</u> := { <b>src</b> | <b>dst</b> } <u>VAL_MASK_16</u>

       <u>ICMP</u> := { <b>type</b> <u>VAL_MASK_8</u> | <b>code</b> <u>VAL_MASK_8</u> }

       <u>ETHER</u> := { <b>src</b> | <b>dst</b> } <u>ether_address</u> <u>AT</u>

       <u>VAL_MASK_32</u> := <u>u32_value</u> <u>u32_hex_mask</u> [ <u>AT</u> ]

       <u>VAL_MASK_16</u> := <u>u16_value</u> <u>u16_hex_mask</u> [ <u>AT</u> ]

       <u>VAL_MASK_8</u> := <u>u8_value</u> <u>u8_hex_mask</u> [ <u>AT</u> ]

       <u>AT</u> := [ <b>at</b> [ <b>nexthdr+</b> ] <u>int_value</u> ]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  Universal/Ugly  32bit  filter allows one to match arbitrary bitfields in the packet. Due to breaking
       everything down to values, masks and offsets, It is equally  powerful  and  hard  to  use.  Luckily  many
       abstracting  directives  are  present which allow defining rules on a higher level and therefore free the
       user from having to fiddle with bits and masks in many cases.

       There are two general modes of invocation: The first mode creates a new filter  to  delegate  packets  to
       different  destinations.  Apart  from  the  obvious  ones,  namely classifying the packet by specifying a
       <u>CLASSID</u> or calling an <b>action</b>, one may <b>link</b>  one  filter  to  another  one  (or  even  a  list  of  them),
       effectively organizing filters into a tree-like hierarchy.

       Typically  filter  delegation  is  done  by  means  of  a  hash  table, which leads to the second mode of
       invocation: it merely serves to set up these hash tables. Filters can select a hash table and  provide  a
       key  selector  from  which  a  hash  is to be computed and used as key to lookup the table's bucket which
       contains filters for further processing. This is useful if a high number of filters is  in  use,  as  the
       overhead  of  performing  the  hash  operation  and  table  lookup becomes negligible in that case. Using
       hashtables with <b>u32</b> basically involves the following pattern:

       (1) Creating a new hash table, specifying it's size using the <b>divisor</b> parameter and ideally a  handle  by
           which  the  table  can be identified. If the latter is not given, the kernel chooses one on it's own,
           which has to be guessed later.

       (2) Creating filters which link to the created table in <u>(1)</u> using the <b>link</b>  parameter  and  defining  the
           packet data which the kernel will use to calculate the <b>hashkey</b>.

       (3) Adding  filters  to buckets in the hash table from <u>(1)</u>.  In order to avoid having to know how exactly
           the kernel creates the hash key, there is the <b>sample</b> parameter, which gives sample data to  hash  and
           thereby define the table bucket the filter should be added to.

       In  fact,  even if not explicitly requested <b>u32</b> creates a hash table for every <b>priority</b> a filter is being
       added with. The table's size is 1 though, so it is in fact merely a linked list.

</pre><h4><b>VALUES</b></h4><pre>
       Options and selectors require values to be specified in a specific format, which is often  non-intuitive.
       Therefore  the  terminals  in  <u>SYNOPSIS</u> have been given descriptive names to indicate the required format
       and/or maximum allowed numeric value: Prefixes <u>u32</u>, <u>u16</u>  and  <u>u8</u>  indicate  four,  two  and  single  byte
       unsigned  values.  E.g.   <u>u16</u>  indicates  a  two  byte-sized  value in range between 0 and 65535 (0xFFFF)
       inclusive. A prefix of <u>int</u> indicates a four byte signed value. A middle part of <b>_</b><u>hex</u><b>_</b> indicates that  the
       value is parsed in hexadecimal format. Otherwise, the value's base is automatically detected, i.e. values
       prefixed  with  <u>0x</u>  are  considered  hexadecimal,  a  leading <u>0</u> indicates octal format and decimal format
       otherwise. There are some values with special formatting as well: <u>ip_address</u> and <u>netmask</u> are  in  dotted-
       quad  formatting  as  usual  for  IPv4  addresses. An <u>ip6_address</u> is specified in common, colon-separated
       hexadecimal format. Finally, <u>prefixlen</u> is an unsigned, decimal integer value  in  range  from  0  to  the
       address width in bits (32 for IPv4 and 128 for IPv6).

       Sometimes  values  need  to  be  dividable by a certain number. In that case a name of the form <u>N*val</u> was
       chosen, indicating that <u>val</u> must be dividable by <u>N</u>.  Or the other way around: the resulting value must be
       a multiple of <u>N</u>.

</pre><h4><b>OPTIONS</b></h4><pre>
       <b>U32</b> recognizes the following options:

       <b>handle</b> <u>HANDLE</u>
              The handle is used to reference a filter and therefore must be unique. It consists of a hash table
              identifier <b>htid</b> and optional <b>hash</b> (which identifies the hash  table's  bucket)  and  <b>nodeid</b>.   All
              these  values are parsed as unsigned, hexadecimal numbers with length 12bits ( <b>htid</b> and <b>nodeid</b>) or
              8bits ( <b>hash</b>).  Alternatively one may specify a single, 32bit long hex number which  contains  the
              three fields bits in concatenated form. Other than the fields themselves, it has to be prefixed by
              <b>0x</b>.

       <b>offset</b> <u>OFFSET</u>
              Set  an  offset  which defines where matches of subsequent filters are applied to.  Therefore this
              option is useful only when combined with <b>link</b> or a combination of <b>ht</b> and <b>sample</b>.  The  offset  may
              be  given  explicitly by using the <b>plus</b> keyword, or extracted from the packet data with <b>at</b>.  It is
              possible to mangle the latter using <b>mask</b>  and/or  <b>shift</b>  keywords.  By  default,  this  offset  is
              recorded  but  not implicitly applied. It is used only to substitute the <b>nexthdr+</b> statement. Using
              the keyword <b>eat</b> though inverses this behaviour: the offset is applied always,  and  <b>nexthdr+</b>  will
              fall back to zero.

       <b>hashkey</b> <u>HASHKEY</u>
              Specify  what packet data to use to calculate a hash key for bucket lookup. The kernel adjusts the
              value according to the hash table's size. For this to work, the option <b>link</b> must be given.

       <b>classid</b> <u>CLASSID</u>
              Classify matching packets into the given <u>CLASSID</u>, which consists of either 16bit <b>major</b>  and  <b>minor</b>
              numbers or a single 32bit value combining both.

       <b>divisor</b> <u>u32_value</u>
              Specify  a  modulo  value.  Used when creating hash tables to define their size or for declaring a
              <b>sample</b> to calculate hash table keys from. Must be a power  of  two  with  exponent  not  exceeding
              eight.

       <b>order</b> <u>u32_value</u>
              A value to order filters by, ascending. Conflicts with <b>handle</b> which serves the same purpose.

       <b>sample</b> <u>SELECTOR</u>
              Used  together  with  <b>ht</b>  to  specify which bucket to add this filter to. This allows one to avoid
              having to know how exactly the kernel calculates hashes. The additional <b>divisor</b> defaults  to  256,
              so must be given for hash tables of different size.

       <b>link</b> <u>HANDLE</u>
              Delegate  matching  packets  to  filters in a hash table.  <u>HANDLE</u> is used to only specify the hash
              table, so only <b>htid</b> may be given, <b>hash</b> and <b>nodeid</b> have to be omitted. By default, bucket number  0
              will be used and can be overridden by the <b>hashkey</b> option.

       <b>indev</b> <u>ifname</u>
              Filter on the incoming interface of the packet. Obviously works only for forwarded traffic.

       <b>skip_sw</b>
              Do  not  process  filter  by  software.  If hardware has no offload support for this filter, or TC
              offload is not enabled for the interface, operation will fail.

       <b>skip_hw</b>
              Do not process filter by hardware.

       <b>help</b>   Print a brief help text about possible options.

</pre><h4><b>SELECTORS</b></h4><pre>
       Basically the only real selector is <b>u32</b> <b>.</b>  All others merely  provide  a  higher  level  syntax  and  are
       internally translated into <b>u32</b> <b>.</b>

       <b>u32</b> <u>VAL_MASK_32</u>
       <b>u16</b> <u>VAL_MASK_16</u>
       <b>u8</b> <u>VAL_MASK_8</u>
              Match packet data to a given value. The selector name defines the sample length to extract (32bits
              for <b>u32</b>, 16bits for <b>u16</b> and 8bits for <b>u8</b>).  Before comparing, the sample is binary AND'ed with the
              given  mask.  This  way  uninteresting  bits can be cleared before comparison. The position of the
              sample is defined by the offset specified in <u>AT</u>.

       <b>ip</b> <u>IP</u>
       <b>ip6</b> <u>IP6</u>
              Assume packet starts with an IPv4 ( <b>ip</b>) or IPv6 ( <b>ip6</b>) header.  <u>IP</u>/<u>IP6</u> then allows  one  to  match
              various header fields:

              <b>src</b> <u>ADDR</u>
              <b>dst</b> <u>ADDR</u>
                     Compare Source or Destination Address fields against the value of <u>ADDR</u>.  The reserved words
                     <b>default</b>,  <b>any</b>  and  <b>all</b>  effectively  match  any  address.  Otherwise  an IP address of the
                     particular protocol is expected, optionally suffixed by a  prefix  length  to  match  whole
                     subnets. In case of IPv4 a netmask may also be given.

              <b>dsfield</b> <u>VAL_MASK_8</u>
                     IPv4  only.  Match  the  packet  header's  DSCP/ECN  field.  Synonyms  to  this are <b>tos</b> and
                     <b>precedence</b>.

              <b>ihl</b> <u>VAL_MASK_8</u>
                     IPv4 only. Match the Internet Header Length field. Note that the value's unit is 32bits, so
                     to match a packet with 24byte header length <u>u8_value</u> has to be 6.

              <b>protocol</b> <u>VAL_MASK_8</u>
                     Match the Protocol (IPv4) or Next Header (IPv6) field value, e.g. 6 for TCP.

              <b>icmp_type</b> <u>VAL_MASK_8</u>
              <b>icmp_code</b> <u>VAL_MASK_8</u>
                     Assume a next-header protocol of icmp or ipv6-icmp and match Type  or  Code  field  values.
                     This  is  dangerous, as the code assumes minimal header size for IPv4 and lack of extension
                     headers for IPv6.

              <b>sport</b> <u>VAL_MASK_16</u>
              <b>dport</b> <u>VAL_MASK_16</u>
                     Match layer four source or destination ports. This is dangerous as well, as  it  assumes  a
                     suitable layer four protocol is present (which has Source and Destination Port fields right
                     at  the start of the header and 16bit in size).  Also minimal header size for IPv4 and lack
                     of IPv6 extension headers is assumed.

              <b>nofrag</b>
              <b>firstfrag</b>
              <b>df</b>
              <b>mf</b>     IPv4 only, check certain flags and fragment offset values. Match if the  packet  is  not  a
                     fragment (<b>nofrag</b>), the first fragment of a fragmented packet (<b>firstfrag</b>), if Don't Fragment
                     (<b>df</b>) or More Fragments (<b>mf</b>) bits are set.

              <b>priority</b> <u>VAL_MASK_8</u>
                     IPv6 only. Match the header's Traffic Class field, which has the same purpose and semantics
                     of IPv4's ToS field since RFC 3168: upper six bits are DSCP, the lower two ECN.

              <b>flowlabel</b> <u>VAL_MASK_32</u>
                     IPv6  only. Match the Flow Label field's value. Note that Flow Label itself is only 20bytes
                     long, which are the least significant ones here. The remaining upper 12bytes match  Version
                     and Traffic Class fields.

       <b>tcp</b> <u>TCPUDP</u>
       <b>udp</b> <u>TCPUDP</u>
              Match fields of next header of protocol TCP or UDP. The possible values for <u>TCPDUP</u> are:

              <b>src</b> <u>VAL_MASK_16</u>
                     Match on Source Port field value.

              <b>dst</b> <u>VALMASK_16</u>
                     Match on Destination Port field value.

       <b>icmp</b> <u>ICMP</u>
              Match fields of next header of protocol ICMP. The possible values for <u>ICMP</u> are:

              <b>type</b> <u>VAL_MASK_8</u>
                     Match on ICMP Type field.

              <b>code</b> <u>VAL_MASK_8</u>
                     Match on ICMP Code field.

       <b>mark</b> <u>VAL_MASK_32</u>
              Match on netfilter fwmark value.

       <b>ether</b> <u>ETHER</u>
              Match on ethernet header fields. Possible values for <u>ETHER</u> are:

              <b>src</b> <u>ether_address</u> <u>AT</u>
              <b>dst</b> <u>ether_address</u> <u>AT</u>
                     Match  on source or destination ethernet address. This is dangerous: It assumes an ethernet
                     header is present at the start of the packet. This will probably lead to unexpected  things
                     if used with layer three interfaces like e.g. tun or ppp.

</pre><h4><b>EXAMPLES</b></h4><pre>
              tc filter add dev eth0 parent 999:0 prio 99 protocol ip u32 \
                      match ip src 192.168.8.0/24 classid 1:1

       This  attaches  a  filter  to the qdisc identified by <b>999:0.</b>  It's priority is <b>99</b>, which affects in which
       order multiple filters attached to the same <b>parent</b> are consulted (the  lower  the  earlier).  The  filter
       handles  packets  of  <b>protocol</b>  type  <b>ip</b>,  and  <b>match</b>es  if  the IP header's source address is within the
       <b>192.168.8.0/24</b> subnet. Matching packets are classified into class <b>1.1</b>.  The effect of this command  might
       be surprising at first glance:

              filter parent 1: protocol ip pref 99 u32
              filter parent 1: protocol ip pref 99 u32 \
                      fh 800: ht divisor 1
              filter parent 1: protocol ip pref 99 u32 \
                      fh 800::800 order 2048 key ht 800 bkt 0 flowid 1:1 \
                      match c0a80800/ffffff00 at 12

       So  parent  <b>1:</b>  is  assigned  a  new  <b>u32</b>  filter,  which contains a hash table of size 1 (as the <b>divisor</b>
       indicates). The table ID is <b>800</b>.  The third line then shows the actual filter which was added  above:  it
       sits in table <b>800</b> and bucket <b>0</b>, classifies packets into class ID <b>1:1</b> and matches the upper three bytes of
       the four byte value at offset <b>12</b> to be <b>0xc0a808</b>, which is 192, 168 and 8.

       Now for something more complicated, namely creating a custom hash table:

              tc filter add dev eth0 prio 99 handle 1: u32 divisor 256

       This creates a table of size 256 with handle <b>1:</b> in priority <b>99</b>.  The effect is as follows:

              filter parent 1: protocol all pref 99 u32
              filter parent 1: protocol all pref 99 u32 fh 1: ht divisor 256
              filter parent 1: protocol all pref 99 u32 fh 800: ht divisor 1

       So  along  with  the  requested hash table (handle <b>1:</b>), the kernel has created his own table of size 1 to
       hold other filters of the same priority.

       The next step is to create a filter which links to the created hash table:

              tc filter add dev eth0 parent 1: prio 1 u32 \
                      link 1: hashkey mask 0x0000ff00 at 12 \
                      match ip src 192.168.0.0/16

       The filter is given a lower priority than the hash table  itself  so  <b>u32</b>  consults  it  before  manually
       traversing  the hash table. The options <b>link</b> and <b>hashkey</b> determine which table and bucket to redirect to.
       In this case the hash key should be constructed out of the second byte at offset 12, which corresponds to
       an IP packet's third byte of the source address field. Along with the <b>match</b> statement,  this  effectively
       maps all class C networks below 192.168.0.0/16 to different buckets of the hash table.

       Filters for certain subnets can be created like so:

              tc filter add dev eth0 parent 1: prio 99 u32 \
                      ht 1: sample u32 0x00000800 0x0000ff00 at 12 \
                      match ip src 192.168.8.0/24 classid 1:1

       The  bucket  is defined using the <b>sample</b> option: In this case, the second byte at offset 12 must be 0x08,
       exactly. In this case, the resulting bucket ID is obviously 8, but as soon as <b>sample</b> selects an amount of
       data which could exceed the <b>divisor</b>, one would have to know the kernel-internal algorithm to  deduce  the
       destination  bucket. This filter's <b>match</b> statement is redundant in this case, as the entropy for the hash
       key does not exceed the table size and therefore no collisions can occur.  Otherwise  it's  necessary  to
       prevent matching unwanted packets.

       Matching  upper  layer  fields  is  problematic  since  IPv4  header length is variable and IPv6 supports
       extension headers which affect upper layer header offset. To overcome this, there is the  possibility  to
       specify <b>nexthdr+</b> when giving an offset, and to make things easier there are the <b>tcp</b> and <b>udp</b> matches which
       use  <b>nexthdr+</b>  implicitly.  This  offset  has  to be calculated in beforehand though, and the only way to
       achieve that is by doing it in a separate filter which then links to the filter which wants  to  use  it.
       Here is an example of doing so:

              tc filter add dev eth0 parent 1:0 protocol ip handle 1: \
                      u32 divisor 1
              tc filter add dev eth0 parent 1:0 protocol ip \
                      u32 ht 1: \
                      match tcp src 22 FFFF \
                      classid 1:2
              tc filter add dev eth0 parent 1:0 protocol ip \
                      u32 ht 800: \
                      match ip protocol 6 FF \
                      match u16 0 1fff at 6 \
                      offset at 0 mask 0f00 shift 6 \
                      link 1:

       This is what is being done: In the first call, a single element sized hash table is created so there is a
       place  to hold the linked to filter and a known handle (<b>1:</b>) to reference to it. The second call then adds
       the actual filter, which pushes packets with TCP source port 22 into class <b>1:2</b>.  Using <b>ht</b>,  it  is  moved
       into the hash table created by the first call. The third call then does the actual magic: It matches IPv4
       packets  with  next layer protocol 6 (TCP), only if it's the first fragment (usually TCP sets DF bit, but
       if it doesn't and the packet is fragmented, only the first one contains the TCP header),  and  then  sets
       the offset based on the IP header's IHL field (right-shifting by 6 eliminates the offset of the field and
       at  the same time converts the value into byte unit). Finally, using <b>link</b>, the hash table from first call
       is referenced which holds the filter from second call.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man8/tc.8.html">tc</a></b>(8),
       <b>cls_u32.txt</b> at <b><a href="http://linux-tc-notes.sourceforge.net/">http://linux-tc-notes.sourceforge.net/</a></b>

iproute2                                           25 Sep 2015               <u>Universal</u> <u>32bit</u> <u>classifier</u> <u>in</u> <u><a href="../man8/tc.8.html">tc</a></u>(8)
</pre>
 </div>
</div></section>
</div>
</body>
</html>