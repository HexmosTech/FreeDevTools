<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>trace  -  Trace  a function and print its arguments or return value, optionally evaluating a filter. Uses</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/bpfcc-tools">bpfcc-tools_0.31.0+ds-7ubuntu2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       trace  -  Trace  a function and print its arguments or return value, optionally evaluating a filter. Uses
       Linux eBPF/bcc.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>trace</b> <b>[-h]</b> <b>[-b</b> <b>BUFFER_PAGES]</b> <b>[-p</b> <b>PID]</b> <b>[-L</b> <b>TID]</b> <b>[--uid</b> <b>UID]</b> <b>[-v]</b> <b>[-Z</b>  <b>STRING_SIZE]</b>  <b>[-S]</b>  <b>[-M</b>  <b>MAX_EVENTS]</b>
       <b>[-t]</b>
                [-u] [-T] [-C] [-c CGROUP_PATH] [-n NAME] [-f MSG_FILTER] [-B] [-s SYM_FILE_LIST] [-K] [-U] [-a]
                [-I header] [-A]
                probe [probe ...]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       trace  probes functions you specify and displays trace messages if a particular condition is met. You can
       control the message format to display function arguments and return values.

       Since this uses BPF, only the root user can use this tool.

</pre><h4><b>REQUIREMENTS</b></h4><pre>
       CONFIG_BPF and bcc.

</pre><h4><b>OPTIONS</b></h4><pre>
       -h     Print usage message.

       -p PID Trace only functions in the process PID.

       -L TID Trace only functions in the thread TID.

       --uid UID
              Trace only functions from user UID.

       -v     Display the generated BPF program, for debugging purposes.

       -z STRING_SIZE
              When collecting string arguments (of type char*), collect up  to  STRING_SIZE  characters.  Longer
              strings will be truncated.

       -s SYM_FILE_LIST
              When  collecting  stack  trace  in  build  id  format,  use  the  comma  separated list for symbol
              resolution.

       -S     If set, trace messages from trace's own process. By default, this is off to avoid  tracing  storms
              --  for  example,  if  you  trace the write system call, and consider that trace is writing to the
              standard output.

       -M MAX_EVENTS
              Print up to MAX_EVENTS trace messages and then exit.

       -t     Print times relative to the beginning of the trace (offsets), in seconds.

       -u     Print UNIX timestamps instead of offsets from trace beginning, requires -t.

       -T     Print the time column.

       -C     Print CPU id.

       -c CGROUP_PATH
              Trace only functions in processes under CGROUP_PATH hierarchy.

       -n NAME
              Only print process names containing this name.

       -f MSG_FILTER
              Only print message of event containing this string.

       -B     Treat argument of STRCMP helper as a binary value

       -K     Print the kernel stack for each event.

       -U     Print the user stack for each event.

       -a     Print virtual address in kernel and user stacks.

       -I header
              Additional header files to include in the BPF program. This is needed  if  your  filter  or  print
              expressions  use  types  or  data  structures  that are not available in the standard headers. For
              example: 'linux/mm.h'

       -A     Print aggregated amount of each trace. This should be used with -M/--max-events together.

       probe [probe ...]
              One or more probes that attach to functions, filter conditions, and print information.  See  PROBE
              SYNTAX below.

</pre><h4><b>PROBE</b> <b>SYNTAX</b></h4><pre>
       The general probe syntax is as follows:

       <b>[{p,r}]:[library]:function[+offset][(signature)]</b> <b>[(predicate)]</b> <b>["format</b> <b>string"[,</b> <b>arguments]]</b>

       <b>{t:category:event,u:library:probe}</b> <b>[(predicate)]</b> <b>["format</b> <b>string"[,</b> <b>arguments]]</b>

       <b>{[{p,r}],t,u}</b>
              Probe  type  - "p" for function entry, "r" for function return, "t" for kernel tracepoint, "u" for
              USDT probe. The default probe type is "p".

       <b>[library]</b>
              Library containing the probe.  Specify the full path to the  .so  or  executable  file  where  the
              function  to  probe  resides.  Alternatively,  you can specify just the lib name: for example, "c"
              refers to libc. If no library name is specified, the kernel is assumed. Also, you can  specify  an
              executable name (without a full path) if it is in the PATH.  For example, "bash".

       <b>category</b>
              The tracepoint category. For example, "sched" or "irq".

       <b>function</b>
              The function to probe.  <b>offset</b> The offset after the address of the function where the probe should
              injected.   For  example  "kfree_skb+56"  in decimal or hexadecimal "kfree_skb+0x38" format.  Only
              works with kprobes and uprobes. Zero if omitted.

       <b>signature</b>
              The optional signature of the function to probe. This can make it easier to access the  function's
              arguments,  instead  of  using the "arg1", "arg2" etc.  argument specifiers. For example, "(struct
              timespec *ts)" in the signature position lets you use "ts" in the filter or print expressions.

       <b>event</b>  The tracepoint event. For example, "block_rq_complete".

       <b>probe</b>  The USDT probe name. For example, "pthread_create".

       <b>[(predicate)]</b>
              The filter applied to the captured data. Only if the filter evaluates as true, the  trace  message
              will  be  printed.  The  filter can use any valid C expression that refers to the argument values:
              arg1, arg2, etc., or to the return value retval in a  return  probe.  If  necessary,  use  C  cast
              operators  to  coerce  the arguments to the desired type. For example, if arg1 is of type int, use
              the expression ((int)arg1 &lt; 0) to trace only invocations where arg1 is negative.  Note  that  only
              arg1-arg6  are  supported,  and only if the function is using the standard x86_64 convention where
              the first six arguments are in the RDI, RSI, RDX, RCX,  R8,  R9  registers.  If  no  predicate  is
              specified, all function invocations are traced.

              The predicate expression may also use the STRCMP pseudo-function to compare a predefined string to
              a  string  argument.  For example: STRCMP("test", arg1).  The order of arguments is important: the
              first argument MUST be a quoted literal string, and the second argument can be a  runtime  string,
              most typically an argument.

       <b>["format</b> <b>string"[,</b> <b>arguments]]</b>
              A  printf-style  format  string that will be used for the trace message. You can use the following
              format specifiers: %s, %d, %u, %lld, %llu, %hd, %hu, %c, %x, %llx -- with the  same  semantics  as
              printf's.  Make sure to pass the exact number of arguments as there are placeholders in the format
              string. The format specifier replacements may be any C expressions, and  may  refer  to  the  same
              special keywords as in the predicate (arg1, arg2, etc.).

              In  addition  to the above format specifiers, you can also use %K and %U when the expression is an
              address that potentially points to executable  code  (i.e.,  a  symbol).  trace  will  resolve  %K
              specifiers  to  a kernel symbol, such as vfs__read, and will resolve %U specifiers to a user-space
              symbol in that process, such as sprintf.

              In tracepoints, both the predicate and the arguments may refer to the tracepoint format structure,
              which is  stored  in  the  special  "args"  variable.  For  example,  the  block:block_rq_complete
              tracepoint  can print or filter by args-&gt;nr_sector. To discover the format of your tracepoint, use
              the tplist tool.

              In USDT probes, the arg1, ..., argN variables refer to the probe's arguments.  To determine  which
              arguments your probe has, use the tplist tool.

              The  predicate  expression  and  the  format  specifier replacements for printing may also use the
              following special keywords: $pid, $tgid to refer to the current process' pid and tgid; $uid,  $gid
              to refer to the current user's uid and gid; $cpu to refer to the current processor number.

</pre><h4><b>EXAMPLES</b></h4><pre>
       Trace all invocations of the open system call with the name of the file (from userspace) being opened:
              # <b>trace</b> <b>'::do_sys_open</b> <b>"%s",</b> <b>arg2@user'</b>

       Trace all invocations of the read system call where the number of bytes requested is greater than 20,000:
              # <b>trace</b> <b>'::sys_read</b> <b>(arg3</b> <b>&gt;</b> <b>20000)</b> <b>"read</b> <b>%d</b> <b>bytes",</b> <b>arg3'</b>

       Trace all malloc calls and print the size of the requested allocation:
              # <b>trace</b> <b>':c:malloc</b> <b>"size</b> <b>=</b> <b>%d",</b> <b>arg1'</b>

       Trace returns from the readline function in bash and print the return value as a string:
              # <b>trace</b> <b>'r:bash:readline</b> <b>"%s",</b> <b>retval'</b>

       Trace the block:block_rq_complete tracepoint and print the number of sectors completed:
              # <b>trace</b> <b>'t:block:block_rq_complete</b> <b>"%d</b> <b>sectors",</b> <b>args-&gt;nr_sector'</b>

       Trace the pthread_create USDT probe from the pthread library and print the address of the thread's start
       function:
              # <b>trace</b> <b>'u:pthread:pthread_create</b> <b>"start</b> <b>addr</b> <b>=</b> <b>%llx",</b> <b>arg3'</b>

       Trace the nanosleep system call and print the sleep duration in nanoseconds:
              # <b>trace</b> <b>'p::SyS_nanosleep(struct</b> <b>timespec</b> <b>*ts)</b> <b>sleep</b> <b>for</b> <b>%lld</b> <b>ns</b> <b>,</b> <b>ts-&gt;tv_nsec'</b>

       Trace the inet_pton system call using build id mechanism and print the stack
              # <b>trace</b> <b>-s</b> <b><a href="file:/lib/x86_64-linux-gnu/libc.so.6">/lib/x86_64-linux-gnu/libc.so.6</a>,<a href="file:/bin/ping">/bin/ping</a></b> <b>'p:c:inet_pton'</b> <b>-U</b>

</pre><h4><b>SOURCE</b></h4><pre>
       This is from bcc.

              https://github.com/iovisor/bcc

       Also  look  in  the bcc distribution for a companion _examples.txt file containing example usage, output,
       and commentary for this tool.

</pre><h4><b>OS</b></h4><pre>
       Linux

</pre><h4><b>STABILITY</b></h4><pre>
       Unstable - in development.

</pre><h4><b>AUTHOR</b></h4><pre>
       Sasha Goldshtein

USER COMMANDS                                      2016-02-18                                           <u><a href="../man8/trace.8.html">trace</a></u>(8)
</pre>
 </div>
</div></section>
</div>
</body>
</html>