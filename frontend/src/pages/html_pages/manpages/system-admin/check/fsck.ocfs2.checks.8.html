<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>fsck.ocfs2.checks   -   Consistency   checks  that  fsck.ocfs2(8)  performs  and  its  means  for  fixing</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/ocfs2-tools">ocfs2-tools_1.8.8-3build1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       fsck.ocfs2.checks   -   Consistency   checks  that  <b><a href="../man8/fsck.ocfs2.8.html">fsck.ocfs2</a>(8)</b>  performs  and  its  means  for  fixing
       inconsistencies.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b><a href="../man8/fsck.ocfs2.8.html">fsck.ocfs2</a>(8)</b> is used to check an OCFS2 file system.  It performs many consistency checks and will  offer
       to  fix  faults  that  it finds.  This man page lists the problems it may find and describes their fixes.
       The problems are indexed by the error number that <b><a href="../man8/fsck.ocfs2.8.html">fsck.ocfs2</a>(8)</b> emits when it describes the  problem  and
       asks if it should be fixed.

       The  prompts are constructed such that answering 'no' results in no changes to the file system.  This may
       result in errors later on that stop <b><a href="../man8/fsck.ocfs2.8.html">fsck.ocfs2</a>(8)</b> from proceeding.

</pre><h4><b>CHECKS</b></h4><pre>
   <b>EB_BLKNO</b>
       Extent blocks contain a record of the disk block where they are located.  An extent block was found at  a
       block that didn't match its recorded location.

       Answering yes will update the data structure in the extent block to reflect its real location on disk.

   <b>EB_GEN</b>
       Extent  blocks  are  created with a generation number to match the generation number of the volume at the
       time of creation.  An extent block was found which contains a generation number that doesn't match.

       Answering yes implies that the generation number is correct and that the extent block is from a  previous
       file  system.   The  extent  block  will  be  ignored and the file that contains it will lose the data it
       referenced.

   <b>EB_GEN_FIX</b>
       Extent blocks are created with a generation number to match the generation number of the  volume  at  the
       time of creation.  An extent block was found which contains a generation number that doesn't match.

       Answering  yes  implies  that  the generation number in the extent block is incorrect and that the extent
       block is valid.  The generation number in the block is updated to match  the  generation  number  in  the
       volume.

   <b>EXTENT_MARKED_UNWRITTEN</b>
       An  extent  record  has the UNWRITTEN flag set, but the filesystem feature set does not include unwritten
       extents.

       Answering yes clears the UNWRITTEN flag.  This is safe to do; as the feature is disabled anyway.

   <b>EXTENT_MARKED_REFCOUNTED</b>
       An extent record has the REFCOUNTED flag set, but neither the filesystem nor the file has the  REFCOUNTED
       flag set.

       Answering yes clears the REFCOUNTED flag.

   <b>EXTENT_BLKNO_UNALIGNED</b>
       The  block that marks the start of an extent should always fall on the start of a cluster.  An extent was
       found that starts part-way into a cluster.

       Answering yes moves the start of the extent back to the start of the addressed  cluster.   This  may  add
       data to the middle of the file that contains this extent.

   <b>EXTENT_CLUSTERS_OVERRUN</b>
       An extent was found which claims to contain clusters which are beyond the end of the volume.

       Answering yes clamps the extent to the end of the volume.  This may result in a reduced file size for the
       file  that  contains  the  extent,  but  it couldn't have addressed those final clusters anyway.  One can
       imagine this problem arising if there are problems shrinking a volume.

   <b>EXTENT_EB_INVALID</b>
       Deep extent trees are built by forming a tree out of extent blocks.  An extent tree references an invalid
       extent block.

       Answering yes stops the tree from referencing the invalid extent block.  This may truncate data from  the
       file which contains the tree.

   <b>EXTENT_LIST_DEPTH</b>
       Extent  lists contain a record of their depth in the tree.  An extent list was found whose recorded depth
       doesn't match the position they have in the tree.

       Answering yes updates the depth field in the list to match the tree on disk.

   <b>EXTENT_LIST_COUNT</b>
       The number of entries in an extent list is bounded by either the size of the inode or  the  size  of  the
       block  which  contains  it.  An extent list was found which claims to have more entries than would fit in
       its container.

       Answering yes updates the count field in the extent list to match the container.  Answering  no  to  this
       question may stop further fixes from being done because the count value can not be trusted.

   <b>EXTENT_LIST_FREE</b>
       The  number  of free entries in an extent list must be less than the total number of entries in the list.
       A list was found which claims to have more free entries than possible entries.

       Answering yes sets the number of free entries in the list equal to the total possible entries.

   <b>EXTENT_BLKNO_RANGE</b>
       An extent record was found which references a block which can  not  be  referenced  by  an  extent.   The
       referenced block is either very early in the volume, and thus reserved, or beyond the end of the volume.

       Answering  yes  removes  this extent record from the tree.  This may remove data from the file which owns
       the tree but any such data was inaccessible.

   <b>CHAIN_CPG</b>
       The bitmap inode indicates a different clusters per group  than  the  group  descriptor.  This  value  is
       typically  static  and  only  modified by tunefs during volume resize and that too only on volumes having
       only one cluster group.

       Answering yes updates the clusters per group on the bitmap inode to the corresponding value in the  group
       descriptor.

   <b>SUPERBLOCK_CLUSTERS</b>
       The  super block indicates a different total clusters value than the global bitmap. This is only possible
       due to a failed volume resize operation.

       Answering yes updates the total clusters in the super block to the value specified in the global bitmap.

   <b>FIXED_CHAIN_CLUSTERS</b>
       The global bitmap inode was repaired, resulting in a change to the total cluster count of the filesystem.

       Answering yes updates the total clusters in the super block to the value specified in the global bitmap.

   <b>GROUP_UNEXPECTED_DESC</b>
       The group descriptors that make up the global bitmap chain allocator reside at predictable  locations  on
       disk.   A group descriptor was found in the global bitmap allocator which isn't at one of these locations
       and so shouldn't be in the allocator.

       Answering yes removes this descriptor from the global bitmap allocator.

   <b>GROUP_EXPECTED_DESC</b>
       The group descriptors that make up the global bitmap chain allocator reside at predictable  locations  on
       disk.  A group descriptor at one of these locations was not linked into the global bitmap allocator.

       Answering yes will relink this group into the allocator.

   <b>GROUP_GEN</b>
       A  group  descriptor  was  found with a generation number that doesn't match the generation number of the
       volume.

       Answering yes sets the group descriptor's generation equal to the generation number in the volume.

   <b>GROUP_PARENT</b>
       Group descriptors contain a pointer to the allocator inode which contains the chain they  belong  to.   A
       group descriptor was found in an allocator inode that doesn't match the descriptor's parent pointer.

       Answering yes updates the group descriptor's parent pointer to match the inode it resides in.

   <b>GROUP_DUPLICATE</b>
       Group  descriptors  contain  a pointer to the allocator inode which contains the chain they belong to.  A
       group descriptor was found in two allocator inodes so it may be duplicated.

       Answering yes removes the group descriptor from current allocator inode.

   <b>GROUP_BLKNO</b>
       Group descriptors have a field which records their block location on disk.  A group descriptor was  found
       at a given location but is recorded as being located somewhere else.

       Answering  yes  updates  the  group descriptor's recorded location to match where it actually is found on
       disk.

   <b>GROUP_CHAIN</b>
       Group descriptors are found in a number of different singly-linked chains in an allocator inode.  A group
       descriptor records the chain number that it is linked in.  A group descriptor was found whose chain field
       doesn't match the chain it was found in.

       Answering yes sets the group descriptor's chain field to match the chain it is found in.

   <b>GROUP_FREE_BITS</b>
       A group descriptor records the number of bits in its bitmap that are free.  A group descriptor was  found
       which claims to have more free bits than are valid in its bitmap.

       Answering  yes  decreases  the number of recorded free bits so that it equals the total number of bits in
       the group descriptor's bitmap.

   <b>GROUP_CHAIN_LOOP</b>
       A chain may loop if the next field  of  the  group  descriptor  points  to  one  of  the  previous  group
       descriptors in the chain. This causes the ocfs2 code, both user space and kernel module to loop forever.

       Answering  yes  breaks  the loop at an optimum location so that all the existing group descriptors are in
       the chain. However, it cannot re-connect stray group descriptors and must rely on the rest  of  the  fsck
       code to fix it.

   <b>CHAIN_COUNT</b>
       The  chain list embedded in an inode is limited by the block size and the number of bytes consumed by the
       rest of the inode.  A chain list header was found which claimed that there are more entries in  the  list
       then could fit in the inode.

       Answering  yes  resets  the  header's cl_count member to the maximum size allowed by the block size after
       accounting for the space consumed by the inode.

   <b>CHAIN_NEXT_FREE</b>
       This is identical to CHAIN_COUNT except that it is testing and fixing the pointer to the next  free  list
       entry recorded in the cl_next_free_rec member instead of the total number of entries.

   <b>CHAIN_EMPTY</b>
       Chain  entries need to be packed such that there are no chains without descriptors found before the chain
       that is marked as free by the chain header.  A chain without descriptors  was  found  found  before  that
       chain that was marked free.

       Answering yes will remove the unused chain and shift the remaining chains forward in the list.

   <b>CHAIN_I_CLUSTERS</b>
       Chain  allocator  inodes  have  an  i_clusters  value  that represents the number of clusters used by the
       allocator.  An inode was found whose i_clusters value doesn't match the number  of  clusters  its  chains
       cover.

       Answering yes updates i_clusters in the inode to reflect what was actually found by walking the chain.

   <b>CHAIN_I_SIZE</b>
       Chain  allocator  inodes multiply the number of bytes per cluster by the their i_clusters value and store
       it in i_size.  An inode was found which didn't have the correct value in its i_size.

       Answering yes updates i_size to be the product of i_clusters and the cluster  size.   Nothing  else  uses
       this  value, and previous versions of tools didn't calculate it properly, so don't be too worried if this
       error appears.

   <b>CHAIN_GROUP_BITS</b>
       The inode that contains an embedded chain list has fields which record the total number of  bits  covered
       by the chain as well as the amount free.  These fields didn't match what was found in the chain.

       Answering yes updates the fields in the inode to reflect what was actually found by walking the chain.

   <b>CHAIN_HEAD_LINK_RANGE</b>
       The  header  that starts a chain tried to reference a group descriptor at a block number that couldn't be
       valid.

       Answering yes will clear the reference to this invalid block and truncate the chain that it started.

   <b>CHAIN_LINK_GEN</b>
       A reference was made to a group descriptor whose generation number doesn't match the  generation  of  the
       volume.

       Answering yes to this question implies that the group descriptor is invalid and the chain is truncated at
       the point that it referred to this invalid group descriptor.  Answering no to this question considers the
       group descriptor as valid and its generation may be fixed.

   <b>CHAIN_LINK_MAGIC</b>
       Chains are built by chain headers and group descriptors which are linked together by block references.  A
       reference  was  made to a group descriptor at a given block but a valid group descriptor signature wasn't
       found at that block.

       Answering yes clears the reference to this invalid block and truncates the chain  at  the  point  of  the
       reference.

   <b>CHAIN_LINK_RANGE</b>
       Chains are built by chain headers and group descriptors which are linked together by block references.  A
       reference  a  block  was  found which can't possibly be valid because it was either too small or extended
       beyond the volume.

       Answering yes truncates the chain in question by zeroing the invalid block reference.  This shortens  the
       chain  in  question  and  could  result  in  more  fixes  later if the part of the chain that couldn't be
       referenced was valid at some point.

   <b>CHAIN_BITS</b>
       A chain's header contains members which record the total number of bits in  the  chain  as  well  as  the
       number  of  bits  that  are  free.   After  walking  through a chain it was found that the number of bits
       recorded in its header don't match what was found by totalling up the group descriptors.

       Answering yes updates the c_total and c_free members of the header to reflect what was found in the group
       descriptors in the chain.

   <b>DISCONTIG_BG_DEPTH</b>
       A discontiguous block group has  an  extent  list  which  records  all  the  clusters  allocated  to  it.
       Discontiguous  block  groups  only  support extent lists with a tree depth of 0.  A block group claims to
       have a tree depth greater than 0.

       Answering yes will set the tree depth of the extent list to 0.

   <b>DISCONTIG_BG_COUNT</b>
       A discontiguous block group has an extent list which records all the clusters allocated to  it.  A  block
       group claims to have more records than can actually fit.

       Answering yes will set the record count to the maximum possible.

   <b>DISCONTIG_BG_REC_RANGE</b>
       Block  groups  set aside clusters to be used for metadata.  A discontiguous block group claims to contain
       clusters beyond the end of the volume.

       Answering yes will remove the block group.

   <b>DISCONTIG_BG_CORRUPT_LEAVES</b>
       A discontiguous block group has an extent list which records all the clusters allocated to it.   A  group
       has more than one extent claiming to have an impossible number of clusters.

       Answering yes will remove the block group.

   <b>DISCONTIG_BG_CLUSTERS</b>
       Extent  records  in  a  discontiguous  block group were found having more clusters allocated then a block
       group can have.

       Answering yes will remove the block group.

   <b>DISCONTIG_BG_LESS_CLUSTERS</b>
       Extent records in a discontiguous block group were found having less  clusters  allocated  then  a  block
       group can have.

       Answering yes will remove the block group.

   <b>DISCONTIG_BG_NEXT_FREE_REC</b>
       A  discontiguous  block  group has an extent list which records all the clusters allocated to it. A group
       was found with fewer filled in extents than it claims to have.  The filled in extents describe a complete
       and correct group.

       Answering yes will set the used extent count to the number of filled extents.

   <b>DISCONTIG_BG_LIST_CORRUPT</b>
       A discontiguous block group has an extent list which records all the clusters allocated to it.  The group
       claims to have more extents than is possible, and the existing extents contain errors.

       Answering yes will remove the block group.

   <b>DISCONTIG_BG_REC_CORRUPT</b>
       A discontiguous block group has a extent list which records all the clusters allocated to  it.   A  group
       was  found  with  one extent claiming too many clusters but the sum of the remaining extents are equal to
       the total clusters a group must have.

       Answering yes will remove the block group.

   <b>DISCONTIG_BG_LEAF_CLUSTERS</b>
       A discontiguous block group has a extent list which records all the clusters allocated to  it.   A  group
       was found with one extent claiming too many clusters, but the remaining extents are correct.

       Answering  yes  will  set  the  number of the clusters on the broken extent to the difference between the
       total clusters a group must have and the sum of the remaining extents.

   <b>INODE_ALLOC_REPAIR</b>
       The inode allocator did not accurately reflect the set of inodes that are free and in use in the volume.

       Answering yes will update the inode allocator bitmaps.  Each bit that doesn't  match  the  state  of  its
       inode will be inverted.

   <b>INODE_SUBALLOC</b>
       Each  inode records the node whose allocator is responsible for the inode.  An inode was found in a given
       node's allocator but the inode itself claimed to belong to a different node.

       Answering yes will correct the inode to point to the node's allocator that it belongs to.

   <b>LALLOC_SIZE</b>
       Each node has a local allocator contained in a block that is used to allocate  clusters  in  batches.   A
       node's local allocator claims to reflect more bytes than are possible for the volume's block size.

       Answering yes decreases the local allocator's size to reflect the volume's block size.

   <b>LALLOC_NZ_USED</b>
       A given node's local allocator isn't in use but it claims to have bits in use in its bitmap.

       Answering yes zeros this used field.

   <b>LALLOC_NZ_BM</b>
       A  given node's local allocator isn't in use but it has a field which records the bitmap as starting at a
       non-zero cluster offset.

       Answering yes zeros the bm_off field.

   <b>LALLOC_BM_OVERRUN</b>
       Each local allocator contains a reference to the first cluster that its bitmap addresses.  A given  local
       allocator was found which references a starting cluster that is beyond the end of the volume.

       Answering yes resets the given local allocator.  No allocated data will be lost.

   <b>LALLOC_BM_SIZE</b>
       The  given  local  allocator  claims  to  cover  more bits than are possible for the size in bytes of its
       bitmap.

       Answering yes decreases the number of bits the allocator covers to reflect  the  size  in  bytes  of  the
       bitmap and resets the allocator.  No allocated data will be lost.

   <b>LALLOC_BM_STRADDLE</b>
       The  given  local  allocator  claims  to  cover  a region of clusters which extents beyond the end of the
       volume.

       Answering yes resets the given local allocator.  No allocated data will be lost.

   <b>LALLOC_USED_OVERRUN</b>
       The given local allocator claims to have more bits in use than it has total bits in its bitmap.

       Answering yes decreases the number of bits used so that it equals the total number of available bits.

   <b>LALLOC_CLEAR</b>
       A local allocator inode was found to have problems.  This gives the operator a chance to just  reset  the
       local allocator inode.

       Answering  yes  clears  the  local allocator.  No information is lost but the global bitmap allocator may
       need to be updated to reflect clusters that were reserved for the local allocator but were free.

   <b>DEALLOC_COUNT</b>
       The given truncate log inode contains a count that is greater than the value that is possible  given  the
       size of the inode.

       Answering yes resets the count value to the possible maximum.

   <b>DEALLOC_USED</b>
       The  given  truncate  log  inode  claims  to have more records in use than it is possible to store in the
       inode.

       Answering yes resets the record of the number used to the maximum value possible.

   <b>TRUNCATE_REC_START_RANGE</b>
       A truncate record was found which claims to start at a cluster that is beyond the number of  clusters  in
       the volume.

       Answering  yes will clear the truncate record.  This may result in previously freed space being marked as
       allocated.  This will be fixed up later as the allocator is updated to match what is  used  by  the  file
       system.

   <b>TRUNCATE_REC_WRAP</b>
       Clusters  are recorded as 32bit values.  A truncate record was found which claims to have enough clusters
       to cause this value to wrap.  This could never be the case and is a sure sign of corruption.

       Answering yes will clear the truncate record.  This may result in previously freed space being marked  as
       allocated.   This  will  be  fixed up later as the allocator is updated to match what is used by the file
       system.

   <b>TRUNCATE_REC_RANGE</b>
       A truncate record was found which claims to reference a region of clusters which partially extends beyond
       the number of clusters in the volume.

       Answering yes will clear the truncate record.  This may result in previously freed space being marked  as
       allocated.   This  will  be  fixed up later as the allocator is updated to match what is used by the file
       system.

   <b>INODE_GEN</b>
       Inodes are created with a generation number to match the generation number of the volume at the  time  of
       creation.  An Inode was found which contains a generation number that doesn't match.

       Answering  yes  implies  that the generation number is correct and that the inode is from a previous file
       system.  The inode will be recorded as free.

   <b>INODE_GEN_FIX</b>
       Inodes are created with a generation number to match the generation number of the volume at the  time  of
       creation.  An inode was found which contains a generation number that doesn't match.

       Answering  yes  implies that the generation number in the inode is incorrect and that the inode is valid.
       The generation number in the inode is updated to match the generation number in the volume.

   <b>INODE_BLKNO</b>
       Inodes contain a field that must match the block that they reside in.  An inode was found at a block that
       doesn't match the field in the inode.

       Answering yes updates the field to match the inode's position on disk.

   <b>ROOT_NOTDIR</b>
       The super block contains a reference to the inode that contains the root directory.  This block was found
       to contain an inode that isn't a directory.

       Answering yes clears this inode.  The operator will be asked to recreate the root directory at a point in
       the near future.

   <b>INODE_NZ_DTIME</b>
       Inodes contain a field describing the time at which they were deleted.  This can not be set for an  inode
       that is still in use.  An inode was found which is in use but which contains a non-zero dtime.

       Answering yes implies that the inode is still valid and resets its dtime to zero.

   <b>LINK_FAST_DATA</b>
       The  target  name  for  a  symbolic link is stored either as file contents for that inode or in the inode
       structure itself on disk.  Only small destination names are stored in the inode structure.  The  i_blocks
       field  of  the  inode indicates that the name is stored in the inode when it is zero.  An inode was found
       that has both i_blocks set to zero and file contents.

       Answering yes clears the inode and so deletes the link.

   <b>LINK_NULLTERM</b>
       The targets of links on disk must be null  terminated.   A  link  was  found  whose  target  wasn't  null
       terminated.

       Answering yes clears the inode and so deletes the link.

   <b>LINK_SIZE</b>
       The  size of a link on disk must match the length of its target string.  A link was found whose size does
       not.

       Answering yes updates the link's size to reflect the length of its target string.

   <b>LINK_BLOCKS</b>
       Links can not be sparse.  There must be exactly as many blocks allocated as are needed to cover its size.
       A link was found which doesn't have enough blocks allocated to cover its size.

       Answering yes clears the link's inode thus deleting the link.

   <b>DIR_ZERO</b>
       Directories must at least contain a block that has the "." and ".." entries.  A directory was found which
       doesn't contain any blocks.

       Answering yes to this question clears the directory's inode thus deleting the directory.

   <b>INODE_SIZE</b>
       Certain inodes record the size of the data they reference in an i_size field.  This can be the number  of
       bytes  in  a  file,  directory, or symlink target which are stored in data mapped by extents of clusters.
       This error occurs when the extent lists are walked and the amount of data found does not  match  what  is
       stored in i_size.

       Answering  yes  to this question updates the inode's i_size to match the amount of data referenced by the
       extent lists.  It is vitally important that i_size matches the extent  lists  and  so  answering  yes  is
       strongly encouraged.

   <b>INODE_SPARSE_SIZE</b>
       Certain  inodes record the size of the data they reference in an i_size field.  This can be the number of
       bytes in a file, directory, or symlink target which are stored in data mapped  by  extents  of  clusters.
       This error occurs when a sparse inode was found that had data allocated past its i_size.

       Answering  yes to this question will update the inode's i_size to cover all of its allocated storage.  It
       is vitally important that i_size matches the extent lists and so answering yes is strongly encouraged.

   <b>INODE_INLINE_SIZE</b>
       Inodes can only fit a certain amount of inline data.  This inode has its data inline but claims an i_size
       larger than will actually fit.

       Answering yes to this question updates the inode's i_size to the maximum available inline space.

   <b>INODE_CLUSTERS</b>
       Inodes contain a record of how many clusters are allocated to them.  An inode was  found  whose  recorded
       number of clusters doesn't match the number of blocks that were found associated with the inode.

       Answering  yes resets the inode's number of clusters to reflect the number of blocks that were associated
       with the file.

   <b>INODE_SPARSE_CLUSTERS</b>
       Inodes contain a record of how many clusters are allocated to them.  An  sparse  inode  was  found  whose
       recorded number of clusters doesn't match the number of blocks that were found associated with the inode.

       Answering  yes resets the inode's number of clusters to reflect the number of blocks that were associated
       with the file.

   <b>INODE_INLINE_CLUSTERS</b>
       Inlined inode should not have allocated clusters.  An inode who has inline data flag set was  found  with
       clusters allocated.

       Answering yes resets the inode's number of clusters to zero.

   <b>LALLOC_REPAIR</b>
       An  active local allocator did not accurately reflect the set of clusters that are free and in use in its
       region.

       Answering yes will update the local allocator bitmap.  Each bit that doesn't match the use of its cluster
       will be inverted.

   <b>LALLOC_USED</b>
       A local allocator records the number of bits that are used in its bitmap.  An allocator was  found  whose
       used value doesn't reflect the number of bits that are set in its bitmap.

       Answering yes sets the used value to match the number of bits set in the allocator's bitmap.

   <b>CLUSTER_ALLOC_BIT</b>
       A specific cluster's use didn't match the setting of its bit in the cluster allocator.

       Answering  yes  will  invert the bit in the allocator to match the use of the cluster -- either allocated
       and in use or free.

   <b>REFCOUNT_FLAG_INVALID</b>
       Refcount file can only exist in a volume with refcount supported, Fsck has found that a file  in  a  non-
       refcount volume has refcount flag set.

       Answering yes remove this flag from the file.

   <b>REFCOUNT_LOC_INVALID</b>
       Refcount loc can only be valid if the file has refcount flag set. Fsck has found that a file has refcount
       loc while it doesn't have refcount flag set.

       Answering yes reset refcount loc to zero for the file.

   <b>RB_BLKNO</b>
       refcount  blocks  contain a record of the disk block where they are located.  An refcount block was found
       at a block that didn't match its recorded location.

       Answering yes will update the data structure in the refcount block to reflect its real location on disk.

   <b>RB_GEN</b>
       Refcount blocks are created with a generation number to match the generation number of the volume at  the
       time of creation.  An refcount block was found which contains a generation number that doesn't match.

       Answering  yes  implies  that  the  generation  number  is  correct and that the refcount block is from a
       previous file system.  The refcount block will be removed and  the  file  that  uses  it  will  lose  the
       refcounted information, but it may be regenerated later.

   <b>RB_GEN_FIX</b>
       Refcount  blocks are created with a generation number to match the generation number of the volume at the
       time of creation.  An refcount block was found which contains a generation number that doesn't match.

       Answering yes implies that the generation number in the refcount block is incorrect and that the refcount
       block is valid.  The generation number in the block is updated to match  the  generation  number  in  the
       volume.

   <b>RB_PARENT</b>
       refcount  blocks  contain a record of the parent this disk block belongs to.  An refcount block was found
       storing a wrong parent location.

       Answering yes will update the data structure in the refcount block to reflect its parent's real  location
       on disk.

   <b>REFCOUNT_LIST_COUNT</b>
       The  number  of  entries  in  a  refcount list is bounded by the size of the block which contains it.  An
       refcount list was found which claims to have more entries than would fit in its container.

       Answering yes updates the count field in the refcount list to match the container. Answering no  to  this
       question may stop further fixes from being done because the count value can not be trusted.

   <b>REFCOUNT_LIST_USED</b>
       The  number of free entries in a refcount list must be less than the total number of entries in the list.
       A list was found which claims to have more free entries than possible entries.

       Answering yes sets the number of free entries in the list equal to the total possible entries.

   <b>REFCOUNT_CLUSTER_RANGE</b>
       A refcount record was found which references a cluster which can not be referenced by  a  refcount.   The
       referenced  cluster  is  either  very  early  in  the volume, and thus reserved, or beyond the end of the
       volume.

       Answering yes removes this refcount record from the tree.

   <b>REFCOUNT_CLUSTER_COLLISION</b>
       A refcount record was found which references a cluster which has a  collision  with  the  previous  valid
       refcount record.

       Answering yes removes this refcount record from the tree.

   <b>REFCOUNT_LIST_EMPTY</b>
       A  refcount  list  was  found  which  has  no refcount record in it. It is normally caused by a corrupted
       refcount record.

       Answering yes removes this refcount block from the tree. It will be  re-generated  in  refcounted  extent
       records handler if all the other information is sane.

   <b>REFCOUNT_BLOCK_INVALID</b>
       Refcount  block  stores  the  refcount  record for physical clusters of a file.  It is found referring an
       invalid refcount block.

       Answering yes remove this refcount block.

   <b>REFCOUNT_CLUSTERS</b>
       Refcount tree contains a record of how many clusters are allocated to  them.   A  tree  was  found  whose
       recorded number of clusters doesn't match the number of blocks that were found associated with it.

       Answering  yes  resets the number of clusters to reflect the real number of clusters that were associated
       with the tree.

   <b>REFCOUNT_ROOT_BLOCK_INVALID</b>
       Root refcount block is the root of the refcount record for a file.  It  is  found  referring  an  invalid
       refcount block.

       Answering yes remove this refcount block and clear refcount flag from this file.

   <b>REFCOUNT_REC_REDUNDANT</b>
       Refcount  record  is  used  to store the refcount for physical clusters. Some refcount record is found to
       have no physical clusters corresponding to it.

       Answering yes remove the refcount record.

   <b>REFCOUNT_COUNT_INVALID</b>
       Refcount record is used to store the refcount for physical clusters. A  record  record  is  found  whichs
       claims the wrong refcount for some physical clusters.

       Answering yes update the corresponding refcount record.

   <b>REFCOUNT_COUNT</b>
       Refcount  tree  contains  a  record  of  how  many  files referring to this tree.  A tree was found whose
       recorded number of files doesn't match the real files referring to the tree.

       Answering yes resets the number of files to reflect the real number of files that  were  associated  with
       the tree.

   <b>DUP_CLUSTERS_SYSFILE_CLONE</b>
       A  system  file inode claims clusters that are also claimed by another inode.  ocfs2 does not allow this.
       System files may be cloned but may not be deleted.  Allocation system files may not be cloned or deleted.

       Answering yes will copy the data of this inode to newly allocated extents.  This will break the claim  on
       the overcommitted clusters.

   <b>DUP_CLUSTERS_CLONE</b>
       An inode claims clusters that are also claimed by another inode.  ocfs2 does not allow this.

       Answering  yes will copy the data of this inode to newly allocated extents.  This will break the claim on
       the overcommitted clusters.

   <b>DUP_CLUSTERS_DELETE</b>
       An inode claims clusters that are also claimed by another inode.  ocfs2 does not allow this.

       Answering yes will remove this inode, thus breaking its claim on the overcommitted clusters.

   <b>DUP_CLUSTERS_ADD_REFCOUNT</b>
       An inode claims clusters that are also claimed by another inode.  ocfs2 does not allow this.

       Answering yes will try to add a refcount record for all  these  inodes,  so  that  they  will  share  the
       cluster.

   <b>DIRENT_DOTTY_DUP</b>
       There  can  be  only  one instance of both the "." and ".." entries in a directory. A directory entry was
       found which duplicated one of these entries.

       Answering yes will remove the duplicate directory entry.

   <b>DIRENT_NOT_DOTTY</b>
       The first and second directory entries in a directory must be "." and ".."  respectively.  One  of  these
       directory entries was found to not match these rules.

       Answering  yes  will  force  the  directory entry to be either "." or "..".  This might consume otherwise
       valid entries and cause some files to appear in lost+found.

   <b>DIRENT_DOT_INODE</b>
       The inode field of the "." directory entry must refer to the directory  inode  that  contains  the  given
       directory block.  A "." entry was found which doesn't do so.

       Answering yes sets the directory entry's inode reference to the parent directory that contains the entry.

   <b>DIRENT_DOT_EXCESS</b>
       A "." directory entry was found whose lengths exceeds the amount required for the single dot in the name.

       Answering yes creates another empty directory entry in this excess space.

   <b>DIRENT_ZERO</b>
       A directory entry was found with a zero length name.

       Answering yes clears the directory entry so its space can be reused.

   <b>DIRENT_NAME_CHARS</b>
       Directory entries can not contain either the NULL character (ASCII 0) or the forward slash (ASCII 47).  A
       directory entry was found which contains either.

       Answering yes will change each instance of these forbidden characters into a period (ASCII 46).

   <b>DIRENT_INODE_RANGE</b>
       Each  directory  entry  contains a inode field which the entry's name corresponds to.  An entry was found
       which referenced an inode number that is invalid for the current volume.

       Answering yes clears this entry so its space can be reused.  If the entry once  corresponded  to  a  real
       inode and was corrupted this inode may appear in lost+found.

   <b>DIRENT_INODE_FREE</b>
       Each  directory  entry  contains a inode field which the entry's name corresponds to.  An entry was found
       which referenced an inode number that isn't in use.

       Answering yes clears this directory entry.

   <b>DIRENT_TYPE</b>
       Each directory entry contains a field which describes the type of file that  the  entry  refers  to.   An
       entry was found whose type doesn't match the inode it is referring to.

       Answering yes resets the entry's type to match the target inode.

   <b>DIR_PARENT_DUP</b>
       Each  directory  can  only be pointed to by one directory entry in a parent directory.  A directory entry
       was found which was the second entry to point to a given directory inode.

       Answering yes clears this entry which was the second to refer to a given directory.   This  reflects  the
       policy that hard links to directories are not allowed.

   <b>DIRENT_DUPLICATE</b>
       File names within a directory must be unique.  A file name occurred in more than one directory entry in a
       given directory.

       Answering  yes  renames  the  duplicate  entry  to a name that doesn't collide with recent entries and is
       unlikely to collide with future entries in the directory.

   <b>DIRENT_LENGTH</b>
       There are very few directory entry lengths that are valid.  The lengths must be greater than the  minimum
       required  to  record  a single character directory, be rounded to 12 bytes, be within the amount of space
       remaining in a directory block, and be properly rounded for the size of the name of the directory  entry.
       An entry was found which didn't meet these criteria.

       Answering  yes  will try to repair the directory entry.  This runs a very good chance of invalidating all
       the entries in the directory block.  Orphaned inodes may appear in lost+found.

   <b>DIR_TRAILER_INODE</b>
       A directory block trailer is a  fake  directory  entry  at  the  end  of  the  block.   The  trailer  has
       compatibility fields for when it is viewed as a directory entry.  The inode field must be zero.

       Answering yes will set the inode field to zero.

   <b>DIR_TRAILER_NAME_LEN</b>
       A  directory  block  trailer  is  a  fake  directory  entry  at  the  end  of the block.  The trailer has
       compatibility fields for when it is viewed as a directory entry.  The name length field must be zero.

       Answering yes will set the name length field to zero.

   <b>DIR_TRAILER_REC_LEN</b>
       A directory block trailer is a  fake  directory  entry  at  the  end  of  the  block.   The  trailer  has
       compatibility  fields  for when it is viewed as a directory entry.  The record length field must be equal
       to the size of the trailer.

       Answering yes will set the record length field to the size of the trailer.

   <b>DIR_TRAILER_BLKNO</b>
       A directory block trailer is a fake directory entry at the end of the block.  The self-referential  block
       number is incorrect.

       Answering yes will set the block number to the correct block on disk.

   <b>DIR_TRAILER_PARENT_INODE</b>
       A  directory  block  trailer  is a fake directory entry at the end of the block.  It has a pointer to the
       directory inode it belongs to.  This pointer is incorrect.

       Answering yes will set the parent inode pointer to the inode referencing this directory block.

   <b>ROOT_DIR_MISSING</b>
       The super block contains a reference to the inode that serves as  the  root  directory.   This  reference
       points to an inode that isn't in use.

       Answering  yes  will  create  a  new  inode and update the super block to refer to this inode as the root
       directory.

   <b>LOSTFOUND_MISSING</b>
       The super block contains a reference to  the  inode  that  serves  as  the  lost+found  directory.   This
       reference points to an inode that isn't in use.

       Answering yes will create a new lost+found directory in the root directory.

   <b>DIR_NOT_CONNECTED</b>
       Every  directory  in  the  file  system should be reachable by a directory entry in its parent directory.
       This is verified by walking every directory in the system.  A directory inode was found during this  walk
       which doesn't have a parent directory entry.

       Answering  yes  moves this directory entry into the lost+found directory and gives it a name based on its
       inode number.

   <b>DIR_DOTDOT</b>
       A directory inode's ".." directory entry must refer to the parent directory.  A directory was found whose
       ".." doesn't refer to its parent.

       Answering yes will read the directory block for the given directory and update its ".." entry to  reflect
       its parent.

   <b>INODE_NOT_CONNECTED</b>
       Most  all  inodes in the system should be referenced by a directory entry. An inode was found which isn't
       referred to by any directory entry.

       Answering yes moves this inode into the lost+found directory and gives it  a  name  based  on  its  inode
       number.

   <b>INODE_COUNT</b>
       Each  inode  records the number of directory entries that refer to it.  An inode was found whose recorded
       count doesn't match the number of entries that refer to it.

       Answering yes sets the inode's count to match the number of referring directory entries.

   <b>INODE_ORPHANED</b>
       While files are being deleted they are placed in an internal directory.  If  the  machine  crashes  while
       this is taking place the files will be left in this directory.  Fsck has found an inode in this directory
       and would like to finish the job of truncating and removing it.

       Answering yes removes the file data associated with the inode and frees the inode.

   <b>RECOVER_BACKUP_SUPERBLOCK</b>
       When  <u>fsck.ocfs2</u> successfully uses the specified backup superblock, it provides the user with this option
       to overwrite the existing superblock with that backup.

       Answering yes will refresh the superblock from the backup. Answering no will only disable the copying  of
       the backup superblock and will not effect the remaining <u>fsck.ocfs2</u> processing.

   <b>ORPHAN_DIR_MISSING</b>
       While  files  are  being  deleted they are placed in an internal directory, named orphan directory. If an
       orphan directory does not exist, an OCFS2 volume cannot be  mounted  successfully.  Fsck  has  found  the
       orphan directory is missing and would like to create it for future use.

       Answering yes creates the orphan directory in the system directory.

   <b>JOURNAL_FILE_INVALID</b>
       OCFS2  uses JDB for journalling and some journal files exist in the system directory. Fsck has found some
       journal files that are invalid.

       Answering yes to this question will regenerate the invalid journal files.

   <b>JOURNAL_UNKNOWN_FEATURE</b>
       Fsck has found some journal files with unknown features.  Other journals  on  the  filesystem  have  only
       known  features,  so  this  is  likely a corruption.  If you think your filesystem may be newer than this
       version of fsck.ocfs2, say N here and grab the latest version of fsck.ocfs2.

       Answering yes resets the journal features to match other journals.

   <b>JOURNAL_MISSING_FEATURE</b>
       Fsck has found some journal files have features that are not set on all journal files.  All  journals  on
       filesystem should have the same set of features.

       Answering yes will set all journals to the union of set features.

   <b>JOURNAL_TOO_SMALL</b>
       Fsck has found some journal files are too small.

       Answering yes extends these journals.

   <b>RECOVER_CLUSTER_INFO</b>
       The  currently  active  cluster  stack is different than the one the filesystem is configured for.  Thus,
       fsck.ocfs2 cannot determine whether the filesystem is mounted on an another node or not. The  recommended
       solution is to exit and run fsck.ocfs2 on this device from a node that has the appropriate active cluster
       stack. However, you can proceed with the fsck if you are sure that the volume is not in use on any node.

       Answering  yes  reconfigures  the  filesystem  to  use  the  current  cluster stack.  DANGER: YOU MUST BE
       ABSOLUTELY SURE THAT NO OTHER NODE IS USING  THIS  FILESYSTEM  BEFORE  CONTINUING.   OTHERWISE,  YOU  CAN
       CORRUPT THE FILESYSTEM AND LOSE DATA.

   <b>INLINE_DATA_FLAG_INVALID</b>
       Inline  file can only exist in a volume with inline supported, Fsck has found that a file in a non-inline
       volume has inline flag set.

       Answering yes remove this flag from the file.

   <b>INLINE_DATA_COUNT_INVALID</b>
       For an inline file, there is a limit for id2.id_data.id_count. Fsck  has  found  that  this  value  isn't
       right.

       Answering yes change this value to the right number.

   <b>XATTR_BLOCK_INVALID</b>
       Extended  attributes  are  stored  off  an  extended attribute block referenced by the inode.  This inode
       references an invalid extended attribute block.

       Answering yes will remove this block.

   <b>XATTR_COUNT_INVALID</b>
       The count of extended attributes in an inode, block, or bucket does not match the number of entries found
       by fsck.

       Answering yes will change this to the correct count.

   <b>XATTR_ENTRY_INVALID</b>
       An extended attribute entry points to already used space.

       Answering yes will remove this entry.

   <b>XATTR_NAME_OFFSET_INVALID</b>
       The name_offset field of an extended attribute entry is  not  correct.   Without  a  correct  name_offset
       field, the entry cannot be used.

       Answering yes will remove this entry.

   <b>XATTR_VALUE_INVALID</b>
       The value region of an extended attribute points to already used space.

       Answering yes will remove this entry.

   <b>XATTR_LOCATION_INVALID</b>
       The  xe_local  field  and xe_value_size field of an extended attribute entry does not match. So the entry
       cannot be used.

       Answering yes will remove this entry.

   <b>XATTR_HASH_INVALID</b>
       Extended attributes use a hash of their name  for  lookup  purposes.   The  name_hash  of  this  extended
       attribute entry is not correct.

       Answering yes will change this to the correct hash.

   <b>XATTR_FREE_START_INVALID</b>
       Extended  attributes  use free_start to indicate the offset of the free space in inode, block, or bucket.
       The free_start field of this object is not correct.

       Answering yes will change this to the correct offset.

   <b>XATTR_VALUE_LEN_INVALID</b>
       Extended attributes use name_value_len to store the total length of all entry's name and value in  inode,
       block or bucket.  the name_value_len filed of this object is not correct.

       Answering yes will change this to the correct value.

   <b>XATTR_BUCKET_COUNT_INVALID</b>
       The count of extended attributes bucket pointed by one extent record does not match the number of buckets
       found by fsck.

       Answering yes will change this to the correct count.

   <b>QMAGIC_INVALID</b>
       The magic number in the header of quota file does not match the proper number.

       Answering yes will make fsck use values in the quota file header anyway.

   <b>QTREE_BLK_INVALID</b>
       Block with references to other blocks with quota data is corrupted.

       Answering yes will make fsck use references in the block.

   <b>DQBLK_INVALID</b>
       The structure with quota limits was found in a corrupted block.

       Answering yes will use the values of limits for the user / group.

   <b>DUP_DQBLK_INVALID</b>
       The  structure  with  quota limits was found in a corrupted block and fsck has already found quota limits
       for this user / group.

       Answering yes will use new values of limits for the user / group.

   <b>DUP_DQBLK_VALID</b>
       The structure with quota limits was found in a correct block but fsck has already found quota limits  for
       this user / group.

       Answering yes will use new values of limits for the user / group.

   <b>IV_DX_TREE</b>
       A directory index was found on an inode but that feature is not enabled on the file system.

       Answering yes will truncate the invalid index.

   <b>DX_LOOKUP_FAILED</b>
       A  directory entry is missing an entry in the directory index. The missing index entry will cause lookups
       on this name to fail.

       Answering yes will rebuild the directory index, restoring the missing entry.

   <b>NO_HOLES</b>
       A metadata structure encountered a hole where it should not. Examples of such structures are directories,
       refcount trees, dx_trees etc.

       Answering yes will remove the hole by updating the offset to the expected value.

   <b>EXTENT_OVERLAP</b>
       The extents of the file overlap, which means there could be two or more possible data  for  a  particular
       offset for the file.

       Answering yes will serialize the extents.

   <b>DX_TREE_CORRUPT</b>
       The index tree of the directory is corrupt.

       Answering yes will rebuild the directory index, in pass 2.

   <b>DX_TREE_MISSING</b>
       The index of this directory is missing.

       Answering yes will rebuild the directory index.

   <b>BAD_CRC32</b>
       The metadata block has a bad CRC32, which means either the block or the crc32 field is corrupted.

       Answering yes will recalculate the CRC32.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man8/debugfs.ocfs2.8.html">debugfs.ocfs2</a>(8)</b>  <b><a href="../man8/fsck.ocfs2.8.html">fsck.ocfs2</a>(8)</b>  <b><a href="../man8/mkfs.ocfs2.8.html">mkfs.ocfs2</a>(8)</b>  <b><a href="../man8/mount.ocfs2.8.html">mount.ocfs2</a>(8)</b>  <b><a href="../man8/mounted.ocfs2.8.html">mounted.ocfs2</a>(8)</b>  <b><a href="../man8/o2cluster.8.html">o2cluster</a>(8)</b> <b><a href="../man8/o2image.8.html">o2image</a>(8)</b>
       <b><a href="../man1/o2info.1.html">o2info</a>(1)</b> <b><a href="../man8/tunefs.ocfs2.8.html">tunefs.ocfs2</a>(8)</b>

</pre><h4><b>AUTHORS</b></h4><pre>
       Oracle Corporation.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright © 2004, 2012 Oracle. All rights reserved.

Version 1.8.8                                     January 2012                              <u><a href="../man8/fsck.ocfs2.checks.8.html">fsck.ocfs2.checks</a></u>(8)
</pre>
 </div>
</div></section>
</div>
</body>
</html>