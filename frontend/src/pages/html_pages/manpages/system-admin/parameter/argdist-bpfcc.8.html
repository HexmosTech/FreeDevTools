<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>argdist - Trace a function and display a histogram or frequency count of its parameter values. Uses Linux</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/bpfcc-tools">bpfcc-tools_0.31.0+ds-7ubuntu2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       argdist - Trace a function and display a histogram or frequency count of its parameter values. Uses Linux
       eBPF/bcc.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>argdist</b>  <b>[-h]</b>  <b>[-p</b>  <b>PID]</b>  <b>[-z</b>  <b>STRING_SIZE]</b>  <b>[-i</b>  <b>INTERVAL]</b>  <b>[-d</b>  <b>DURATION]</b>  <b>[-n</b> <b>COUNT]</b> <b>[-v]</b> <b>[-T</b> <b>TOP]</b> <b>[-H</b>
       <b>specifier]</b> <b>[-C</b> <b>specifier]</b> <b>[-I</b> <b>header]</b> <b>[-t</b> <b>TID]</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       argdist attaches to function entry and exit points, collects specified parameter values, and stores  them
       in  a  histogram or a frequency collection that counts the number of times a parameter value occurred. It
       can also filter parameter values and instrument multiple entry points at once.

       Since this uses BPF, only the root user can use this tool.

</pre><h4><b>REQUIREMENTS</b></h4><pre>
       CONFIG_BPF and bcc.

</pre><h4><b>OPTIONS</b></h4><pre>
       -h     Print usage message.

       -p PID Trace only functions in the process PID.

       -t TID Trace only functions in the thread TID.

       -z STRING_SIZE
              When collecting string arguments (of type char*), collect up  to  STRING_SIZE  characters.  Longer
              strings will be truncated.

       -i INTERVAL
              Print the collected data every INTERVAL seconds. The default is 1 second.

       -d DURATION
              Total duration of trace in seconds.

       -n NUMBER
              Print the collected data COUNT times and then exit.

       -v     Display the generated BPF program, for debugging purposes.

       -T TOP When collecting frequency counts, display only the top TOP entries.

       -H specifiers, -C specifiers
              One  or more probe specifications that instruct argdist which functions to probe, which parameters
              to collect, how to aggregate them, and whether to perform  any  filtering.  See  SPECIFIER  SYNTAX
              below.

       -I header
              One  or  more  header  files  that  should be included in the BPF program. This enables the use of
              structure definitions, enumerations, and constants that are available in these headers. You should
              provide  the  same  path  you  would  include  in  the  BPF  program,  e.g.  'linux/blkdev.h'   or
              'linux/time.h'. Note: in many cases, argdist will deduce the necessary header files automatically.

</pre><h4><b>SPECIFIER</b> <b>SYNTAX</b></h4><pre>
       The general specifier syntax is as follows:

       <b>{p,r,t,u}:{[library],category}:function(signature):type[,type...]:expr[,expr...][:filter]][#label]</b>

       <b>{p,r,t,u}</b>
              Probe  type  - "p" for function entry, "r" for function return, "t" for kernel tracepoint, "u" for
              USDT probe; -H for histogram collection, -C for frequency count.  Indicates  where  to  place  the
              probe and whether the probe should collect frequency count information, or aggregate the collected
              values  into  a  histogram. Counting probes will collect the number of times every parameter value
              was observed, whereas histogram probes will collect the parameter values into a  histogram.   Only
              integral types can be used with histogram probes; there is no such limitation for counting probes.

       <b>[library]</b>
              Library  containing  the  probe.   Specify  the  full path to the .so or executable file where the
              function to probe resides. Alternatively, you can specify just the  lib  name:  for  example,  "c"
              refers to libc. If no library name is specified, the kernel is assumed.

       <b>category</b>
              The category of the kernel tracepoint. For example: net, sched, block.

       <b>function(signature)</b>
              The  function  to probe, and its signature.  The function name must match exactly for the probe to
              be placed. The signature, on the other hand, is only required if you  plan  to  collect  parameter
              values  based on that signature. For example, if you only want to collect the first parameter, you
              don't have to specify the rest  of  the  parameters  in  the  signature.   When  capturing  kernel
              tracepoints,  this  should  be  the name of the event, e.g.  net_dev_start_xmit. The signature for
              kernel tracepoints should be empty. When capturing USDT probes, this should be  the  name  of  the
              probe, e.g. reloc_complete.  The signature for USDT probes should be empty.

       <b>[type[,type...]]</b>
              The type(s) of the expression(s) to capture.  This is the type of the keys in the histogram or raw
              event collection that are collected by the probes.

       <b>[expr[,expr...]]</b>
              The  expression(s)  to  capture.   These  are the values that are assigned to the histogram or raw
              event collection.  You may use the parameters directly, or valid C expressions  that  involve  the
              parameters, such as "size % 10".  Tracepoints may access a special structure called "args" that is
              formatted  according  to  the tracepoint format (which you can obtain using tplist).  For example,
              the block:block_rq_complete tracepoint can access args-&gt;nr_sector.  USDT  probes  may  access  the
              arguments defined by the tracing program in the special arg1, arg2, ... variables. To obtain their
              types,  use  the  tplist tool.  Return probes can use the argument values received by the function
              when it was entered, through the $entry(paramname)  special  variable.   Return  probes  can  also
              access the function's return value in $retval, and the function's execution time in nanoseconds in
              $latency.  Note  that  adding  the  $latency or $entry(paramname) variables to the expression will
              introduce an additional probe at  the  function's  entry  to  collect  this  data,  and  therefore
              introduce additional overhead.

       <b>[filter]</b>
              The  filter  applied  to  the  captured  data.  Only parameter values that pass the filter will be
              collected. This is any valid C expression that refers to the parameter values, such as "fd == 1 &amp;&amp;
              length &gt; 16".  The $entry, $retval, and $latency variables can be used here  as  well,  in  return
              probes.   The  filter  expression  may also use the STRCMP pseudo-function to compare a predefined
              string to a string argument. For example: STRCMP("test.txt", file).  The  order  of  arguments  is
              important:  the  first  argument MUST be a quoted literal string, and the second argument can be a
              runtime string.

       <b>[label]</b>
              The label that will be displayed when printing the probed values. By default, this  is  the  probe
              specifier.

</pre><h4><b>EXAMPLES</b></h4><pre>
       Print a histogram of allocation sizes passed to kmalloc:
              # <b>argdist</b> <b>-H</b> <b>'p::__kmalloc(u64</b> <b>size):u64:size'</b>

       Print a count of how many times process 1005 called malloc with an allocation size of 16 bytes:
              # <b>argdist</b> <b>-p</b> <b>1005</b> <b>-C</b> <b>'p:c:malloc(size_t</b> <b>size):size_t:size:size==16'</b>

       Snoop on all strings returned by gets():
              # <b>argdist</b> <b>-C</b> <b>'r:c:gets():char*:$retval'</b>

       Print a histogram of read sizes that were longer than 1ms:
              #  <b>argdist</b>  <b>-H</b> <b>'r::__vfs_read(void</b> <b>*file,</b> <b>void</b> <b>*buf,</b> <b>size_t</b> <b>count):size_t:$entry(count):$latency</b> <b>&gt;</b>
              <b>1000000'</b>

       Print frequency counts of how many times writes were issued to a particular file descriptor number, in
       process 1005:
              # <b>argdist</b> <b>-p</b> <b>1005</b> <b>-C</b> <b>'p:c:write(int</b> <b>fd):int:fd'</b>

       Print a histogram of error codes returned by read() in process 1005:
              # <b>argdist</b> <b>-p</b> <b>1005</b> <b>-H</b> <b>'r:c:read()'</b>

       Print a histogram of buffer sizes passed to write() across all processes, where the file descriptor was 1
       (STDOUT):
              # <b>argdist</b> <b>-H</b> <b>'p:c:write(int</b> <b>fd,</b> <b>const</b> <b>void</b> <b>*buf,</b> <b>size_t</b> <b>count):size_t:count:fd==1'</b>

       Count fork() calls in libc across all processes, grouped by pid:
              # <b>argdist</b> <b>-C</b> <b>'p:c:fork():int:$PID;fork</b> <b>per</b> <b>process'</b>

       Print histogram of number of sectors in completing block I/O requests:
              # <b>argdist</b> <b>-H</b> <b>'t:block:block_rq_complete():u32:nr_sector'</b>

       Aggregate interrupts by interrupt request (IRQ):
              # <b>argdist</b> <b>-C</b> <b>'t:irq:irq_handler_entry():int:irq'</b>

       Print the functions used as thread entry points and how common they are:
              # <b>argdist</b> <b>-C</b> <b>'u:pthread:pthread_start():u64:arg2'</b> <b>-p</b> <b>1337</b>

       Print histograms of sleep() and nanosleep() parameter values:
              #   <b>argdist</b>   <b>-H</b>   <b>'p:c:sleep(u32</b>   <b>seconds):u32:seconds'</b>   <b>-H</b>   <b>'p:c:nanosleep(struct</b>    <b>timespec</b>
              <b>*req):long:req-&gt;tv_nsec'</b>

       Spy on writes to STDOUT performed by process 2780, up to a string size of 120 characters:
              # <b>argdist</b> <b>-p</b> <b>2780</b> <b>-z</b> <b>120</b> <b>-C</b> <b>'p:c:write(int</b> <b>fd,</b> <b>char*</b> <b>buf,</b> <b>size_t</b> <b>len):char*:buf:fd==1'</b>

       Group files being read from and the read sizes from __vfs_read:
              #      <b>argdist</b>      <b>-C</b>     <b>'p::__vfs_read(struct</b>     <b>file</b>     <b>*file,</b>     <b>void</b>     <b>*buf,</b>     <b>size_t</b>
              <b>count):char*,size_t:file-&gt;f_path.dentry-&gt;d_iname,count:file-&gt;f_path.dentry-&gt;d_iname[0]!=0'</b>

</pre><h4><b>SOURCE</b></h4><pre>
       This is from bcc.

              https://github.com/iovisor/bcc

       Also look in the bcc distribution for a companion _examples.txt file containing  example  usage,  output,
       and commentary for this tool.

</pre><h4><b>OS</b></h4><pre>
       Linux

</pre><h4><b>STABILITY</b></h4><pre>
       Unstable - in development.

</pre><h4><b>AUTHOR</b></h4><pre>
       Sasha Goldshtein

USER COMMANDS                                      2016-02-11                                         <u><a href="../man8/argdist.8.html">argdist</a></u>(8)
</pre>
 </div>
</div></section>
</div>
</body>
</html>