<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>wakeuptime - Summarize sleep to wakeup time by waker kernel stack. Uses Linux eBPF/bcc.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/bpfcc-tools">bpfcc-tools_0.31.0+ds-7ubuntu2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       wakeuptime - Summarize sleep to wakeup time by waker kernel stack. Uses Linux eBPF/bcc.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>wakeuptime</b> <b>[-h]</b> <b>[-u]</b> <b>[-p</b> <b>PID]</b> <b>[-v]</b> <b>[-f]</b> <b>[--stack-storage-size</b> <b>STACK_STORAGE_SIZE]</b> <b>[-m</b> <b>MIN_BLOCK_TIME]</b> <b>[-M</b>
       <b>MAX_BLOCK_TIME]</b> <b>[duration]</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This program shows the kernel stack traces for threads that woke up other blocked threads, along with the
       process  names  of  the  waker  and target, along with a sum of the time that the target was blocked: the
       "blocked time".  It works by tracing when threads block and when they were then woken up,  and  measuring
       the  time  delta.  This  time measurement will be very similar to off-CPU time, however, off-CPU time may
       include a little extra time spent waiting on a run queue to  be  scheduled.  The  stack  traces,  process
       names, and time spent blocked is summarized in the kernel using an eBPF map for efficiency.

       The  output summary will help you identify reasons why threads were blocking by showing who woke them up,
       along with the time they were blocked. This spans all types of blocking activity: disk I/O, network  I/O,
       locks, page faults, involuntary context switches, etc.

       This  can  be  used  in  conjunction  with offcputime, which shows the stack trace of the blocked thread.
       wakeuptime shows the stack trace of the waker thread.

       See <a href="http://www.brendangregg.com/FlameGraphs/offcpuflamegraphs.html">http://www.brendangregg.com/FlameGraphs/offcpuflamegraphs.html</a>

       This tool only works on Linux 4.6+. It uses the new `BPF_STACK_TRACE` table  APIs  to  generate  the  in-
       kernel stack traces.

</pre><h4><b>REQUIREMENTS</b></h4><pre>
       CONFIG_BPF and bcc.

</pre><h4><b>OPTIONS</b></h4><pre>
       -h     Print usage message.

       -f     Print output in folded stack format.

       -u     Only trace user threads (not kernel threads).

       -v     Show raw addresses (for non-folded format).

       -p PID Trace this process ID only (filtered in-kernel).

       --stack-storage-size STACK_STORAGE_SIZE
              Change the number of unique stack traces that can be stored and displayed.

       duration
              Duration to trace, in seconds.

       -m MIN_BLOCK_TIME
              The amount of time in microseconds over which we store traces (default 1)

       -M MAX_BLOCK_TIME
              The amount of time in microseconds under which we store traces (default U64_MAX)

</pre><h4><b>EXAMPLES</b></h4><pre>
       Trace all thread blocking events, and summarize (in-kernel) by kernel stack trace and total blocked time:
              # <b>wakeuptime</b>

       Trace user-mode target threads only:
              # <b>wakeuptime</b> <b>-u</b>

       Trace for 5 seconds only:
              # <b>wakeuptime</b> <b>5</b>

       Trace for 5 seconds, and emit output in folded stack format (suitable for flame graphs):
              # <b>wakeuptime</b> <b>-f</b> <b>5</b>

       Trace PID 185 only:
              # <b>wakeuptime</b> <b>-p</b> <b>185</b>

</pre><h4><b>OVERHEAD</b></h4><pre>
       This  summarizes  unique  stack  traces  in-kernel  for efficiency, allowing it to trace a higher rate of
       events than methods that post-process in user space. The stack trace and time data is only copied to user
       space once, when the output is printed. While these techniques greatly lower overhead,  scheduler  events
       are  still  a high frequency event, as they can exceed 1 million events per second, and so caution should
       still be used. Test before production use.

       If the overhead is still a problem, take a look at the min block option.  If your aim is  to  chase  down
       longer  blocking events, then this could be increased to filter shorter blocking events, further lowering
       overhead.

</pre><h4><b>SOURCE</b></h4><pre>
       This is from bcc.

              https://github.com/iovisor/bcc

       Also look in the bcc distribution for a companion _examples.txt file containing  example  usage,  output,
       and commentary for this tool.

</pre><h4><b>OS</b></h4><pre>
       Linux

</pre><h4><b>STABILITY</b></h4><pre>
       Unstable - in development.

</pre><h4><b>AUTHOR</b></h4><pre>
       Brendan Gregg

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man8/offcputime.8.html">offcputime</a>(8), <a href="../man8/stackcount.8.html">stackcount</a>(8)

USER COMMANDS                                      2016-01-27                                      <u><a href="../man8/wakeuptime.8.html">wakeuptime</a></u>(8)
</pre>
 </div>
</div></section>
</div>
</body>
</html>