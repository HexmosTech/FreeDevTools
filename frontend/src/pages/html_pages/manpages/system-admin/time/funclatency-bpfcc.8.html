<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>funclatency - Time functions and print latency as a histogram.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/bpfcc-tools">bpfcc-tools_0.31.0+ds-7ubuntu2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       funclatency - Time functions and print latency as a histogram.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>funclatency</b> <b>[-h]</b> <b>[-p</b> <b>PID]</b> <b>[-i</b> <b>INTERVAL]</b> <b>[-d</b> <b>DURATION]</b> <b>[-T]</b> <b>[-u]</b> <b>[-m]</b> <b>[-F]</b> <b>[-r]</b> <b>[-v]</b> <b>pattern</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This tool traces function calls and times their duration (latency), and shows the latency distribution as
       a  histogram.  The time is measured from when the function is called to when it returns, and is inclusive
       of both on-CPU time and time spent blocked.

       This tool uses in-kernel eBPF maps for storing timestamps and the histogram, for efficiency.

       Currently nested or recursive functions are not supported properly, and timestamps will  be  overwritten,
       creating dubious output. Try to match single functions, or groups of functions that run at the same stack
       layer, and don't ultimately call each other.

       WARNING:  This  uses  dynamic tracing of (what can be many) functions, an activity that has had issues on
       some kernel versions (risk of panics or freezes). Test, and know what you are doing, before use.

       Since this uses BPF, only the root user can use this tool.

</pre><h4><b>REQUIREMENTS</b></h4><pre>
       CONFIG_BPF and bcc.

</pre><h4><b>OPTIONS</b></h4><pre>
       pattern Function name or search pattern. Supports "*" wildcards. See EXAMPLES.  You can also use  -r  for
       regular expressions.

       -h     Print usage message.

       -p PID Trace this process ID only.

       -i INTERVAL
              Print output every interval seconds.

       -d DURATION
              Total duration of trace, in seconds.

       -l LEVEL
              Set the level of nested or recursive functions.

       -T     Include timestamps on output.

       -u     Output histogram in microseconds.

       -m     Output histogram in milliseconds.

       -F     Print a separate histogram per function matched.

       -r     Use regular expressions for the search pattern.

       -v     Print the BPF program (for debugging purposes).

</pre><h4><b>EXAMPLES</b></h4><pre>
       Time the do_sys_open() kernel function, and print the distribution as a histogram:
              # <b>funclatency</b> <b>do_sys_open</b>

       Time the read() function in libc across all processes on the system:
              # <b>funclatency</b> <b>c:read</b>

       Time vfs_read(), and print the histogram in units of microseconds:
              # <b>funclatency</b> <b>-u</b> <b>vfs_read</b>

       Time do_nanosleep(), and print the histogram in units of milliseconds:
              # <b>funclatency</b> <b>-m</b> <b>do_nanosleep</b>

       Time libc open(), and print output every 2 seconds, for duration 10 seconds:
              # <b>funclatency</b> <b>-i</b> <b>2</b> <b>-d</b> <b>10</b> <b>c:read</b>

       Time vfs_read(), and print output every 5 seconds, with timestamps:
              # <b>funclatency</b> <b>-mTi</b> <b>5</b> <b>vfs_read</b>

       Time vfs_read() for process ID 181 only:
              # <b>funclatency</b> <b>-p</b> <b>181</b> <b>vfs_read</b>

       Time both vfs_fstat() and vfs_fstatat() calls, by use of a wildcard:
              # <b>funclatency</b> <b>'vfs_fstat*'</b>

       Time both vfs_fstat* calls, and print a separate histogram for each:
              # <b>funclatency</b> <b>-F</b> <b>'vfs_fstat*'</b>

</pre><h4><b>FIELDS</b></h4><pre>
       necs   Nanosecond range

       usecs  Microsecond range

       msecs  Millisecond range

       count  How many calls fell into this range

       distribution
              An ASCII bar chart to visualize the distribution (count column)

</pre><h4><b>OVERHEAD</b></h4><pre>
       This traces kernel functions and maintains in-kernel timestamps and a histogram, which are asynchronously
       copied  to user-space. While this method is very efficient, the rate of kernel functions can also be very
       high (&gt;1M/sec), at which point the overhead is expected to be measurable. Measure in a  test  environment
       and  understand  overheads before use. You can also use funccount to measure the rate of kernel functions
       over a short duration, to set some expectations before use.

</pre><h4><b>SOURCE</b></h4><pre>
       This is from bcc.

              https://github.com/iovisor/bcc

       Also look in the bcc distribution for a companion _examples.txt file containing  example  usage,  output,
       and commentary for this tool.

</pre><h4><b>OS</b></h4><pre>
       Linux

</pre><h4><b>STABILITY</b></h4><pre>
       Unstable - in development.

</pre><h4><b>AUTHOR</b></h4><pre>
       Brendan Gregg, Sasha Goldshtein

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man8/funccount.8.html">funccount</a>(8)

USER COMMANDS                                      2015-08-18                                     <u><a href="../man8/funclatency.8.html">funclatency</a></u>(8)
</pre>
 </div>
</div></section>
</div>
</body>
</html>