<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>adjtimex - display or set the kernel time variables</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/adjtimex">adjtimex_1.29-12_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       adjtimex - display or set the kernel time variables

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>adjtimex</b> [<u>option</u> ...]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This program gives you raw access to the kernel time variables.  Anyone may print out the time variables,
       but only the superuser may change them.

       Your computer has two clocks – the "hardware clock" that runs all the time, and the system clock that
       runs only while the computer is on.  Normally, "hwclock --hctosys" should be run at startup to initialize
       the system clock.  The system clock has much better precision (approximately 1 usec), but the hardware
       clock probably has better long-term stability.  There are three basic strategies for managing these
       clocks.

       For a machine connected to the Internet, or equipped with a precision oscillator or radio clock, the best
       way is to regulate the system clock with <b><a href="../man8/ntpd.8.html">ntpd</a></b>(8).  The kernel will automatically update the hardware
       clock every eleven minutes.

       In addition, <b><a href="../man8/hwclock.8.html">hwclock</a></b>(8) can be used to approximately correct for a constant drift in the hardware clock.
       In this case, "hwclock --adjust" is run occasionally.  <b>hwclock</b> notes how long it has been since the last
       adjustment, and nudges the hardware clock forward or back by the appropriate amount.  The user needs to
       set the time with "hwclock --set" several times over the course of a few days so <b>hwclock</b> can estimate the
       drift rate.  During that time, <b>ntpd</b> should not be running, or else <b>hwclock</b> will conclude the hardware
       clock does not drift at all.  After you have run "hwclock --set" for the last time, it's okay to start
       <b>ntpd</b>.  Then, "hwclock --systohc" should be run when the machine is shut down.  (To see why, suppose the
       machine runs for a week with <b>ntpd</b>, is shut down for a day, is restarted, and "hwclock --adjust" is run by
       a startup script.  It should only correct for one day's worth of drift.  However, it has no way of
       knowing that <b>ntpd</b> has been adjusting the hardware clock, so it bases its adjustment on the last time
       <b>hwclock</b> was run.)

       For a standalone or intermittently connected machine, where it's not possible to run <b>ntpd</b>, you may use
       <b>adjtimex</b> instead to correct the system clock for systematic drift.

       There are several ways to estimate the drift rate.  If your computer can be connected to the net, you
       might run <b>ntpd</b> for at least several hours and run "adjtimex --print" to learn what values of tick and
       freq it settled on.  Alternately, you could estimate values using as a reference the CMOS clock (see the
       <b>--compare</b> and <b>--adjust</b> switches), another host (see <b>--host</b> and <b>--review</b>), or some other source of time
       (see <b>--watch</b> and <b>--review</b>).  You could then add a line to <u>rc.local</u> invoking <b>adjtimex</b>, or configure
       <u>/etc/init.d/adjtimex</u> or <u>/etc/default/adjtimex</u>, to set those parameters each time you reboot.

</pre><h4><b>OPTIONS</b></h4><pre>
       Options may be introduced by either <b>-</b> or <b>--</b>, and unique abbreviations may be used.

       Here is a summary of the options, grouped by type.  Explanations follow.

       <b>Get/Set</b> <b>Kernel</b> <b>Time</b> <b>Parameters</b>
              -p  --print  -t  --tick  <u>val</u>  -f  <u>newfreq</u>  --frequency  <u>newfreq</u>  -o <u>val</u> --offset <u>val</u> -s <u>adjustment</u>
              --singleshot <u>adjustment</u> -S <u>status</u> --status  <u>status</u>  -m  <u>val</u>  -R  --reset  --maxerror  <u>val</u>  -e  <u>val</u>
              --esterror <u>val</u> -T <u>val</u> --timeconstant <u>val</u> -a[<u>count</u>] --adjust[=<u>count</u>]

       <b>Estimate</b> <b>Systematic</b> <b>Drifts</b>
              -c[<u>count</u>]  --compare[=<u>count</u>]  -i  <u>tim</u>  --interval  <u>tim</u>  -l  <u>file</u>  --log=<u>file</u>  -h <u>timeserver</u> --host
              <u>timeserver</u> -w  --watch  -r[<u>file</u>]  --review[=<u>file</u>]  --review[=<u>file</u>]  -u  --utc  -d  --directisa  -n
              --nointerrupt

       <b>Informative</b> <b>Output</b>
              --help -v --version -V --verbose

       <b>-p</b>, <b>--print</b>
              Print the current values of the kernel time variables.  NOTE: The time is "raw", and may be off by
              up  to  one  timer  tick  (10  msec).  "status" gives the value of the <b>time_status</b> variable in the
              kernel.  For Linux 1.0 and 1.2 kernels, the value is as follows:
                    0   clock is synchronized (so the kernel should
                        periodically set the CMOS clock to match the
                        system clock)
                    1   inserting a leap second at midnight
                    2   deleting a leap second at midnight
                    3   leap second in progress
                    4   leap second has occurred
                    5   clock not externally synchronized (so the
                        kernel should leave the CMOS clock alone)
              For Linux kernels 2.0 through 2.6, the value is a sum of these:
                    1   PLL updates enabled
                    2   PPS freq discipline enabled
                    4   PPS time discipline enabled
                    8   frequency-lock mode enabled
                   16   inserting leap second
                   32   deleting leap second
                   64   clock unsynchronized
                  128   holding frequency
                  256   PPS signal present
                  512   PPS signal jitter exceeded
                 1024   PPS signal wander exceeded
                 2048   PPS signal calibration error
                 4096   clock hardware fault
               * The following status value are appended since 2.6.26 (July 2008):
                 8192   resolution (0 = us, 8192 = ns)
                16384   mode (0 = PLL, 16384 = FLL)
                32768   clock source (0 = A, 32768 = B)

       <b>-t</b> <u>val</u>, <b>--tick</b> <u>val</u>
              Set the number of microseconds that should be added to  the  system  time  for  each  kernel  tick
              interrupt.   For  a kernel with USER_HZ=100, there are supposed to be 100 ticks per second, so <u>val</u>
              should be close to 10000.  Increasing <u>val</u> by 1 speeds up the system clock by  about  100  ppm,  or
              8.64 sec/day.  <u>tick</u> must be in the range 900000/USER_HZ to 1100000/USER_HZ.  If <u>val</u> is rejected by
              the  kernel,  <b>adjtimex</b>  will  determine the acceptable range through trial and error and print it.
              (After completing the search, it will restore the original value.)

       <b>-f</b> <u>newfreq</u>, <b>--frequency</b> <u>newfreq</u>
              Set the system clock frequency offset to <u>newfreq</u>.  <u>newfreq</u> can be negative or positive, and  gives
              a  much  finer adjustment than the <b>--tick</b> switch.  When USER_HZ=100, the value is scaled such that
              <u>newfreq</u> = 65536 speeds up the system clock by about 1 ppm, or 0.0864 sec/day.  Thus, all of  these
              are about the same:
                   <b>--tick</b>  <b>9995</b> <b>--frequency</b>  <b>32768000</b>
                   <b>--tick</b> <b>10000</b> <b>--frequency</b>         <b>0</b>
                   <b>--tick</b> <b>10001</b> <b>--frequency</b>  <b>-6553600</b>
                   <b>--tick</b> <b>10002</b> <b>--frequency</b> <b>-13107200</b>
                   <b>--tick</b> <b>10005</b> <b>--frequency</b> <b>-32768000</b>
              To  see  the  acceptable range for <u>newfreq</u>, use --print and look at "tolerance", or try an invalid
              value (e.g., --tick 0).

       <b>-s</b> <u>adj</u>, <b>--singleshot</b> <u>adj</u>
              Slew the system clock by <u>adj</u> usec or nsec (using whichever unit the clock is presently denominated
              in).  (Its rate is changed temporarily by about 1 part in 2000.)

       <b>-o</b> <u>adj</u>, <b>--offset</b> <u>adj</u>
              Add a time offset of <u>adj</u> usec or nsec (using whichever unit the  clock  is  presently  denominated
              in).  The kernel code adjusts the time gradually by <u>adj</u>, notes how long it has been since the last
              time offset, and then adjusts the frequency offset to correct for the apparent drift.  <u>adj</u> must be
              in the range -512000 to 512000.

       <b>-S</b> <u>status</u>, <b>--status</b> <u>status</u>
              Set  kernel  system  clock status register to value <u>status</u>.  Look here above at the <b>--print</b> switch
              section for the meaning of <u>status</u>, depending on your kernel.

       <b>-R</b>, <b>--reset</b>
              Reset clock status  after  setting  a  clock  parameter.   For  early  Linux  kernels,  using  the
              <a href="../man2/adjtimex.2.html">adjtimex</a>(2)  system call to set any time parameter the kernel think the clock is synchronized with
              an external time source, so it sets the kernel variable time_status to TIME_OK.  Thereafter, at 11
              minute intervals, it will adjust the CMOS clock to match.  We prevent this "eleven minute mode" by
              setting the clock, because that has the side effect of resetting time_status to TIME_BAD.  We  try
              not  to actually change the clock setting.  Kernel versions 2.0.40 and later apparently don't need
              this.  If your kernel does require it, use this option with: <b>-t</b> <b>-T</b> <b>-t</b> <b>-e</b> <b>-m</b> <b>-f</b> <b>-s</b> <b>-o</b> <b>-c</b> <b>-r</b>.

       <b>-m</b> <u>val</u>, <b>--maxerror</b> <u>val</u>
              Set maximum error (usec).

       <b>-e</b> <u>val</u>, <b>--esterror</b> <u>val</u>
              Set estimated error (usec).  The maximum and estimated error are not used by the kernel.  They are
              merely made available to user processes via the <b><a href="../man2/adjtimex.2.html">adjtimex</a></b>(2) system call.

       <b>-T</b> <u>val</u>, <b>--timeconstant</b> <u>val</u>
              Set phase locked loop (PLL) time constant.  <u>val</u> determines the bandwidth  or  "stiffness"  of  the
              PLL.   The effective PLL time constant will be a multiple of (2^<u>val</u>).  For room-temperature quartz
              oscillators, David Mills recommends the value 2, which corresponds to a PLL time constant of about
              900 sec and a maximum update interval of  about  64  sec.   The  maximum  update  interval  scales
              directly  with  the  time constant, so that at the maximum time constant of 6, the update interval
              can be as large as 1024 sec.

              Values of <u>val</u> between zero and 2 give quick convergence; values between 2 and 6  can  be  used  to
              reduce network load, but at a modest cost in accuracy.

       <b>-c</b>[<u>count</u>], <b>--compare</b>[<b>=</b><u>count</u>]
              Periodically  compare  the  system  clock  with  the CMOS clock.  After the first two calls, print
              values for tick and frequency offset that would bring the system clock into approximate  agreement
              with  the  CMOS clock.  CMOS clock readings are adjusted for systematic drift using the correction
              in <u>/etc/adjtime</u> — see <b><a href="../man8/hwclock.8.html">hwclock</a></b>(8).  The interval between comparisons is 10 seconds, unless  changed
              by  the  <b>--interval</b> switch.  The optional argument is the number of comparisons.  (If the argument
              is supplied, the "<b>=</b>" is required.)  If the CMOS clock and the system clock differ by more than six
              minutes, <b>adjtimex</b> will try shifting the time from the CMOS clock by some multiple of one hour,  up
              to  plus or minus 13 hours in all.  This should allow correct operation, including logging, if the
              --utc switch was used when the CMOS clock is set to local time (or vice-versa), or if summer  time
              has started or stopped since the CMOS clock was last set.

       <b>-a</b>[<u>count</u><b>],</b> <b>--adjust[=</b><u>count</u><b>]</b>
              By  itself,  same  as  <b>--compare</b>, except the recommended values are actually installed after every
              third comparison.  With <b>--review</b>, the tick and frequency are set to the  least-squares  estimates.
              (In the latter case, any <u>count</u> value is ignored.)

       <b>--force-adjust</b>
              Override the sanity check that prevents changing the clock rate by more than 500 ppm.

       <b>-i</b> <u>tim</u>, <b>--interval</b> <u>tim</u>
              Set the interval in seconds between clock comparisons for the <b>--compare</b> and <b>--adjust</b> options.

       <b>-u</b>, <b>--utc</b>
              The CMOS clock is set to UTC (universal time) rather than local time.

       <b>-d</b>, <b>--directisa</b>
              To  read  the  CMOS  clock accurately, <b>adjtimex</b> usually accesses the clock via the /dev/rtc device
              driver of the kernel, and makes use of its CMOS update-ended interrupt to detect the beginning  of
              seconds.   It  will  also  try  /dev/rtc0  (for  udev), /dev/misc/rtc (for the obsolete devfs) and
              possibly others.  When the /dev/rtc driver is absent, or when  the  interrupt  is  not  available,
              <b>adjtimex</b>  can sometimes automatically fallback to a direct access method.  This method detects the
              start of seconds by polling the update-in-progress (UIP) flag of the CMOS clock.   You  can  force
              this direct access to the CMOS chip with the <b>--directisa</b> switch.

              Note  that  the  /dev/rtc interrupt method is more accurate, less sensible to perturbations due to
              system load, cleaner, cheaper, and is generally better than  the  direct  access  method.   It  is
              advisable  to  not  use  the  <b>--directisa</b>  switch,  unless  the CMOS chip or the motherboard don't
              properly provide the necessary interrupt.

       <b>-n</b>, <b>--nointerrupt</b>
              Force immediate use of busywait access method, without first waiting for the interrupt timeout.

       <b>-l</b>[<u>file</u>], <b>--log</b>[<b>=</b><u>file</u>]
              Save the current values of the system and CMOS clocks, and optionally a reference  time,  to  <u>file</u>
              (default  <u>/var/log/clocks.log</u>).   The  reference  time is taken from a network timeserver (see the
              <b>--host</b> switch) or supplied by the user (see the <b>--watch</b> switch).

       <b>-h</b> <u>timeserver</u>, <b>--host</b> <u>timeserver</u>
              Use <b>ntpdate</b> to query the given timeserver for the current time.  This will fail if  <u>timeserver</u>  is
              not  running a Network Time Protocol (NTP) server, or if that server is not synchronized.  Implies
              <b>--log</b>.

       <b>-w</b>, <b>--watch</b>
              Ask for a keypress when the user knows the time, then ask what that time was, and its  approximate
              accuracy.  Implies <b>--log</b>.

       <b>-r</b>[<u>file</u>], <b>--review</b>[<b>=</b><u>file</u>]
              Review  the  clock  log <u>file</u> (default <u>/var/log/clocks.log</u>) and estimate, if possible, the rates of
              the CMOS and system clocks.   Calculate  least-squares  rates  using  all  suitable  log  entries.
              Suggest corrections to adjust for systematic drift.  With <b>--adjust</b>, the frequency and tick are set
              to the suggested values.  (The CMOS clock correction is not changed.)

       <b>-V</b>, <b>--verbose</b>
              Increase verbosity.

       <b>--help</b> Print the program options.

       <b>-v</b>, <b>--version</b>
              Print the program version.

</pre><h4><b>EXAMPLES</b></h4><pre>
       If your system clock gained 8 seconds in 24 hours, you could set the tick to 9999, and then it would lose
       0.64  seconds a day (that is, 1 tick unit = 8.64 seconds per day).  To correct the rest of the error, you
       could set the frequency offset to (2^16)*0.64/.0864 = 485452.  Thus, putting the  following  in  rc.local
       would approximately correct the system clock:

            adjtimex  --tick 9999  --freq 485452

</pre><h4><b>NOTES</b></h4><pre>
       <b>adjtimex</b>  adjusts  only the system clock — the one that runs while the computer is powered up.  To set or
       regulate the CMOS clock, see <b><a href="../man8/hwclock.8.html">hwclock</a></b>(8).

</pre><h4><b>AUTHORS</b></h4><pre>
       Steven S. Dick &lt;ssd at nevets.oau.org&gt;, Jim Van Zandt &lt;jrv at comcast.net&gt;.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1L/date.1L.html">date</a></b>(1L), <b><a href="../man2/gettimeofday.2.html">gettimeofday</a></b>(2), <b><a href="../man2/settimeofday.2.html">settimeofday</a></b>(2), <b><a href="../man8/hwclock.8.html">hwclock</a></b>(8), <b><a href="../man8/ntpdate.8.html">ntpdate</a></b>(8), <b><a href="../man8/ntpd.8.html">ntpd</a></b>(8).
       Files in the directory <u>/usr/src/linux/include/linux</u>:
       <u>timex.h</u>, <u>sched.h</u>
       in the directory <u>/usr/src/linux/kernel</u>:
       <u>time.c</u>, <u>sched.c</u>.

                                                 March 11, 2009                                      <u><a href="../man8/ADJTIMEX.8.html">ADJTIMEX</a></u>(8)
</pre>
 </div>
</div></section>
</div>
</body>
</html>