<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>lat_mem_rd - memory read latency benchmark</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/lmbench">lmbench_3.0-a9+debian.1-9_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       lat_mem_rd - memory read latency benchmark

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>lat_mem_rd</b>  [  <u>-P</u> <u>&lt;parallelism&gt;</u> ] [ <u>-W</u> <u>&lt;warmups&gt;</u> ] [ <u>-N</u> <u>&lt;repetitions&gt;</u> ] <u>size_in_megabytes</u> <u>stride</u> [ <u>stride</u>
       <u>stride...</u>  ]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>lat_mem_rd</b> measures memory read latency for varying memory sizes and strides.  The results  are  reported
       in nanoseconds per load and have been verified accurate to within a few nanoseconds on an SGI Indy.

       The entire memory hierarchy is measured, including onboard cache latency and size, external cache latency
       and size, main memory latency, and TLB miss latency.

       Only data accesses are measured; the instruction cache is not measured.

       The  benchmark runs as two nested loops.  The outer loop is the stride size.  The inner loop is the array
       size.  For each array size, the benchmark creates a ring of pointers  that  point  backward  one  stride.
       Traversing the array is done by

            <b>p</b> <b>=</b> <b>(char</b> <b>**)*p;</b>

       in  a  for loop (the over head of the for loop is not significant; the loop is an unrolled loop 100 loads
       long).

       The size of the array varies from 512 bytes to (typically) eight megabytes.  For  the  small  sizes,  the
       cache  will  have an effect, and the loads will be much faster.  This becomes much more apparent when the
       data is plotted.

       Since this benchmark uses fixed-stride offsets in the pointer chain,  it  may  be  vulnerable  to  smart,
       stride-sensitive  cache  prefetching  policies.   Older  machines  were  typically  able  to prefetch for
       sequential access patterns, and some were able to prefetch for strided forward access patterns, but  only
       a  few  could prefetch for backward strided patterns.  These capabilities are becoming more widespread in
       newer processors.

</pre><h4><b>OUTPUT</b></h4><pre>
       Output format is intended as input to <b>xgraph</b> or some similar program (we use a perl script that  produces
       pic  input).  There is a set of data produced for each stride.  The data set title is the stride size and
       the data points are the array size in megabytes (floating point value) and  the  load  latency  over  all
       points in that array.

</pre><h4><b>INTERPRETING</b> <b>THE</b> <b>OUTPUT</b></h4><pre>
       The output is best examined in a graph where you typically get a graph that has four plateaus.  The graph
       should  plotted in log base 2 of the array size on the X axis and the latency on the Y axis.  Each stride
       is then plotted as a curve.  The plateaus that appear correspond  to  the  onboard  cache  (if  present),
       external cache (if present), main memory latency, and TLB miss latency.

       As  a  rough  guide,  you  may  be able to extract the latencies of the various parts as follows, but you
       should really look at the graphs, since these rules of thumb do not always work (some systems do not have
       onboard cache, for example).

       onboard cache   Try stride of 128 and array size of .00098.

       external cache  Try stride of 128 and array size of .125.

       main memory     Try stride of 128 and array size of 8.

       TLB miss        Try the largest stride and the largest array.

</pre><h4><b>BUGS</b></h4><pre>
       This program is dependent on the correct operation of <b><a href="../man8/mhz.8.html">mhz</a></b>(8).  If you are getting numbers that seem  off,
       check that <b><a href="../man8/mhz.8.html">mhz</a></b>(8) is giving you a clock rate that you believe.

</pre><h4><b>ACKNOWLEDGEMENT</b></h4><pre>
       Funding for the development of this tool was provided by Sun Microsystems Computer Corporation.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man8/lmbench.8.html">lmbench</a>(8), <a href="../man8/tlb.8.html">tlb</a>(8), <a href="../man8/cache.8.html">cache</a>(8), <a href="../man8/line.8.html">line</a>(8).

</pre><h4><b>AUTHOR</b></h4><pre>
       Carl Staelin and Larry McVoy

       Comments, suggestions, and bug reports are always welcome.

(c)1994 Larry McVoy                                  $Date$                                        <u><a href="../man8/LAT_MEM_RD.8.html">LAT_MEM_RD</a></u>(8)
</pre>
 </div>
</div></section>
</div>
</body>
</html>