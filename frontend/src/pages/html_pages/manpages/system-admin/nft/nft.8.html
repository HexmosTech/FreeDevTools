<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>nft - Administration tool of the nftables framework for packet filtering and classification</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/nftables">nftables_1.1.3-1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       nft - Administration tool of the nftables framework for packet filtering and classification

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>nft</b> [ <b>-nNscaeSupyjtT</b> ] [ <b>-I</b> <u>directory</u> ] [ <b>-f</b> <u>filename</u> | <b>-i</b> | <u>cmd</u> ...]
       <b>nft</b> <b>-h</b>
       <b>nft</b> <b>-v</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       nft is the command line tool used to set up, maintain and inspect packet filtering and classification
       rules in the Linux kernel, in the nftables framework. The Linux kernel subsystem is known as nf_tables,
       and ‘nf’ stands for Netfilter.

</pre><h4><b>OPTIONS</b></h4><pre>
       The command accepts several different options which are documented here in groups for better
       understanding of their meaning. You can get information about options by running <b>nft</b> <b>--help</b>.

       <b>General</b> <b>options:</b>

       <b>-h</b>, <b>--help</b>
           Show help message and all options.

       <b>-v</b>, <b>--version</b>
           Show version.

       <b>-V</b>
           Show long version information, including compile-time configuration.

       <b>Ruleset</b> <b>input</b> <b>handling</b> <b>options</b> <b>that</b> <b>specify</b> <b>to</b> <b>how</b> <b>to</b> <b>load</b> <b>rulesets:</b>

       <b>-f</b>, <b>--file</b> <u>filename</u>
           Read input from <u>filename</u>. If <u>filename</u> is -, read from stdin. The directory path to this file is
           inserted at the beginning the list of directories to be searched for included files (see
           <b>-I/--includepath</b>).

       <b>-D</b>, <b>--define</b> <u>name=value</u>
           Define a variable. You can only combine this option with <u>-f</u>.

       <b>-i</b>, <b>--interactive</b>
           Read input from an interactive readline CLI. You can use quit to exit, or use the EOF marker,
           normally this is CTRL-D.

       <b>-I</b>, <b>--includepath</b> <b>directory</b>
           Add the directory <u>directory</u> to the list of directories to be searched for included files. This option
           may be specified multiple times.

       <b>-c</b>, <b>--check</b>
           Check commands validity without actually applying the changes.

       <b>-o</b>, <b>--optimize</b>
           Optimize your ruleset. You can combine this option with <u>-c</u> to inspect the proposed optimizations.

       <b>Ruleset</b> <b>list</b> <b>output</b> <b>formatting</b> <b>that</b> <b>modify</b> <b>the</b> <b>output</b> <b>of</b> <b>the</b> <b>list</b> <b>ruleset</b> <b>command:</b>

       <b>-a</b>, <b>--handle</b>
           Show object handles in output.

       <b>-s</b>, <b>--stateless</b>
           Omit stateful information of rules and stateful objects.

       <b>-t</b>, <b>--terse</b>
           Omit contents of sets from output.

       <b>-S</b>, <b>--service</b>
           Translate ports to service names as defined by /etc/services.

       <b>-N</b>, <b>--reversedns</b>
           Translate IP address to names via reverse DNS lookup. This may slow down your listing since it
           generates network traffic.

       <b>-u</b>, <b>--guid</b>
           Translate numeric UID/GID to names as defined by <a href="file:/etc/passwd">/etc/passwd</a> and /etc/group.

       <b>-n</b>, <b>--numeric</b>
           Print fully numerical output.

       <b>-y</b>, <b>--numeric-priority</b>
           Display base chain priority numerically.

       <b>-p</b>, <b>--numeric-protocol</b>
           Display layer 4 protocol numerically.

       <b>-T</b>, <b>--numeric-time</b>
           Show time, day and hour values in numeric format.

       <b>Command</b> <b>output</b> <b>formatting:</b>

       <b>-e</b>, <b>--echo</b>
           When inserting items into the ruleset using <b>add</b>, <b>insert</b> or <b>replace</b> commands, print notifications just
           like <b>nft</b> <b>monitor</b>.

       <b>-j</b>, <b>--json</b>
           Format output in JSON. See <a href="../man5/libnftables-json.5.html">libnftables-json</a>(5) for a schema description.

       <b>-d</b>, <b>--debug</b> <u>level</u>
           Enable debugging output. The debug level can be any of <b>scanner</b>, <b>parser</b>, <b>eval</b>, <b>netlink</b>, <b>mnl</b>,
           <b>proto-ctx</b>, <b>segtree</b>, <b>all</b>. You can combine more than one by separating by the <u>,</u> symbol, for example <u>-d</u>
           <u>eval,mnl</u>.

</pre><h4><b>INPUT</b> <b>FILE</b> <b>FORMATS</b></h4><pre>
   <b>LEXICAL</b> <b>CONVENTIONS</b>
       Input is parsed line-wise. When the last character of a line, just before the newline character, is a
       non-quoted backslash (\), the next line is treated as a continuation. Multiple commands on the same line
       can be separated using a semicolon (;).

       A hash sign (#) begins a comment. All following characters on the same line are ignored.

       Identifiers begin with an alphabetic character (a-z,A-Z), followed by zero or more alphanumeric
       characters (a-z,A-Z,0-9) and the characters slash (/), backslash (\), underscore (_) and dot (.).
       Identifiers using different characters or clashing with a keyword need to be enclosed in double quotes
       (").

   <b>INCLUDE</b> <b>FILES</b>
           <b>include</b> <u>filename</u>

       Other files can be included by using the <b>include</b> statement. The directories to be searched for include
       files can be specified using the <b>-I</b>/<b>--includepath</b> option. You can override this behaviour either by
       prepending ‘./’ to your path to force inclusion of files located in the current working directory (i.e.
       relative path) or / for file location expressed as an absolute path.

       If <b>-I</b>/<b>--includepath</b> is not specified, then nft relies on the default directory that is specified at
       compile time. You can retrieve this default directory via the <b>-h</b>/<b>--help</b> option.

       Include statements support the usual shell wildcard symbols (<b>,?,[]).</b> <b>Having</b> <b>no</b> <b>matches</b> <b>for</b> <b>an</b> <b>include</b>
       <b>statement</b> <b>is</b> <b>not</b> <b>an</b> <b>error,</b> <b>if</b> <b>wildcard</b> <b>symbols</b> <b>are</b> <b>used</b> <b>in</b> <b>the</b> <b>include</b> <b>statement.</b> <b>This</b> <b>allows</b> <b>having</b>
       <b>potentially</b> <b>empty</b> <b>include</b> <b>directories</b> <b>for</b> <b>statements</b> <b>like</b> <b>include</b> <b>"/etc/firewall/rules/"</b>. The wildcard
       matches are loaded in alphabetical order. Files beginning with dot (.) are not matched by include
       statements.

   <b>SYMBOLIC</b> <b>VARIABLES</b>
           <b>define</b> <u>variable</u> <b>=</b> <u>expr</u>
           <b>undefine</b> <u>variable</u>
           <b>redefine</b> <u>variable</u> <b>=</b> <u>expr</u>
           <b>$variable</b>

       Symbolic variables can be defined using the <b>define</b> statement. Variable references are expressions and can
       be used to initialize other variables. The scope of a definition is the current block and all blocks
       contained within. Symbolic variables can be undefined using the <b>undefine</b> statement, and modified using
       the <b>redefine</b> statement.

       <b>Using</b> <b>symbolic</b> <b>variables</b>.

           define int_if1 = eth0
           define int_if2 = eth1
           define int_ifs = { $int_if1, $int_if2 }
           redefine int_if2 = wlan0
           undefine int_if2

           filter input iif $int_ifs accept

</pre><h4><b>ADDRESS</b> <b>FAMILIES</b></h4><pre>
       Address families determine the type of packets which are processed. For each address family, the kernel
       contains so called hooks at specific stages of the packet processing paths, which invoke nftables if
       rules for these hooks exist.

       <b>ip</b>       IPv4 address family.

       <b>ip6</b>      IPv6 address family.

       <b>inet</b>     Internet (IPv4/IPv6) address family.

       <b>arp</b>      ARP address family, handling IPv4 ARP
                packets.

       <b>bridge</b>   Bridge address family, handling
                packets which traverse a bridge
                device.

       <b>netdev</b>   Netdev address family, handling
                packets on ingress and egress.

       All nftables objects exist in address family specific namespaces, therefore all identifiers include an
       address family. If an identifier is specified without an address family, the <b>ip</b> family is used by
       default.

   <b>IPV4/IPV6/INET</b> <b>ADDRESS</b> <b>FAMILIES</b>
       The IPv4/IPv6/Inet address families handle IPv4, IPv6 or both types of packets. They contain five hooks
       at different packet processing stages in the network stack.

       <b>Table</b> <b>1.</b> <b>IPv4/IPv6/Inet</b> <b>address</b> <b>family</b> <b>hooks</b>
       ┌─────────────┬───────────────────────────────────────┐
       │ <b>Hook</b>        │ <b>Description</b>                           │
       ├─────────────┼───────────────────────────────────────┤
       │             │                                       │
       │ prerouting  │ All packets entering the system are   │
       │             │ processed by the prerouting hook. It  │
       │             │ is invoked before the routing process │
       │             │ and is used for early filtering or    │
       │             │ changing packet attributes that       │
       │             │ affect routing.                       │
       ├─────────────┼───────────────────────────────────────┤
       │             │                                       │
       │ input       │ Packets delivered to the local system │
       │             │ are processed by the input hook.      │
       ├─────────────┼───────────────────────────────────────┤
       │             │                                       │
       │ forward     │ Packets forwarded to a different host │
       │             │ are processed by the forward hook.    │
       ├─────────────┼───────────────────────────────────────┤
       │             │                                       │
       │ output      │ Packets sent by local processes are   │
       │             │ processed by the output hook.         │
       ├─────────────┼───────────────────────────────────────┤
       │             │                                       │
       │ postrouting │ All packets leaving the system are    │
       │             │ processed by the postrouting hook.    │
       ├─────────────┼───────────────────────────────────────┤
       │             │                                       │
       │ ingress     │ All packets entering the system are   │
       │             │ processed by this hook. It is invoked │
       │             │ before layer 3 protocol handlers,     │
       │             │ hence before the prerouting hook, and │
       │             │ it can be used for filtering and      │
       │             │ policing. Ingress is only available   │
       │             │ for Inet family (since Linux kernel   │
       │             │ 5.10).                                │
       └─────────────┴───────────────────────────────────────┘

   <b>ARP</b> <b>ADDRESS</b> <b>FAMILY</b>
       The ARP address family handles ARP packets received and sent by the system. It is commonly used to mangle
       ARP packets for clustering.

       <b>Table</b> <b>2.</b> <b>ARP</b> <b>address</b> <b>family</b> <b>hooks</b>
       ┌────────┬───────────────────────────────────────┐
       │ <b>Hook</b>   │ <b>Description</b>                           │
       ├────────┼───────────────────────────────────────┤
       │        │                                       │
       │ input  │ Packets delivered to the local system │
       │        │ are processed by the input hook.      │
       ├────────┼───────────────────────────────────────┤
       │        │                                       │
       │ output │ Packets send by the local system are  │
       │        │ processed by the output hook.         │
       └────────┴───────────────────────────────────────┘

   <b>BRIDGE</b> <b>ADDRESS</b> <b>FAMILY</b>
       The bridge address family handles Ethernet packets traversing bridge devices.

       The list of supported hooks is identical to IPv4/IPv6/Inet address families above.

   <b>NETDEV</b> <b>ADDRESS</b> <b>FAMILY</b>
       The Netdev address family handles packets from the device ingress and egress path. This family allows you
       to filter packets of any ethertype such as ARP, VLAN 802.1q, VLAN 802.1ad (Q-in-Q) as well as IPv4 and
       IPv6 packets.

       <b>Table</b> <b>3.</b> <b>Netdev</b> <b>address</b> <b>family</b> <b>hooks</b>
       ┌─────────┬───────────────────────────────────────┐
       │ <b>Hook</b>    │ <b>Description</b>                           │
       ├─────────┼───────────────────────────────────────┤
       │         │                                       │
       │ ingress │ All packets entering the system are   │
       │         │ processed by this hook. It is invoked │
       │         │ after the network taps (ie. <b>tcpdump</b>), │
       │         │ right after <b>tc</b> ingress and before     │
       │         │ layer 3 protocol handlers, it can be  │
       │         │ used for early filtering and          │
       │         │ policing.                             │
       ├─────────┼───────────────────────────────────────┤
       │         │                                       │
       │ egress  │ All packets leaving the system are    │
       │         │ processed by this hook. It is invoked │
       │         │ after layer 3 protocol handlers and   │
       │         │ before <b>tc</b> egress. It can be used for  │
       │         │ late filtering and policing.          │
       └─────────┴───────────────────────────────────────┘

       Tunneled packets (such as <b>vxlan</b>) are processed by netdev family hooks both in decapsulated and
       encapsulated (tunneled) form. So a packet can be filtered on the overlay network as well as on the
       underlying network.

       Note that the order of netfilter and <b>tc</b> is mirrored on ingress versus egress. This ensures symmetry for
       NAT and other packet mangling.

       Ingress packets which are redirected out some other interface are only processed by netfilter on egress
       if they have passed through netfilter ingress processing before. Thus, ingress packets which are
       redirected by <b>tc</b> are not subjected to netfilter. But they are if they are redirected by <b>netfilter</b> on
       ingress. Conceptually, tc and netfilter can be thought of as layers, with netfilter layered above tc: If
       the packet hasn’t been passed up from the tc layer to the netfilter layer, it’s not subjected to
       netfilter on egress.

</pre><h4><b>RULESET</b></h4><pre>
           {<b>list</b> | <b>flush</b>} <b>ruleset</b> [<u>family</u>]

       The <b>ruleset</b> keyword is used to identify the whole set of tables, chains, etc. currently in place in
       kernel. The following <b>ruleset</b> commands exist:

       <b>list</b>    Print the ruleset in human-readable
               format.

       <b>flush</b>   Clear the whole ruleset. Note that,
               unlike iptables, this will remove all
               tables and whatever they contain,
               effectively leading to an empty
               ruleset - no packet filtering will
               happen anymore, so the kernel accepts
               any valid packet it receives.

       It is possible to limit <b>list</b> and <b>flush</b> to a specific address family only. For a list of valid family
       names, see the section called “ADDRESS FAMILIES” above.

       By design, <b>list</b> <b>ruleset</b> command output may be used as input to <b>nft</b> <b>-f</b>. Effectively, this is the
       nft-equivalent of <b>iptables-save</b> and <b>iptables-restore</b>.

</pre><h4><b>TABLES</b></h4><pre>
           {<b>add</b> | <b>create</b>} <b>table</b> [<u>family</u>] <u>table</u> [<b>{</b> [<b>comment</b> <u>comment</u> <b>;</b>] [<b>flags</b> <u>flags</u> <b>;</b>] <b>}</b>]
           {<b>delete</b> | <b>destroy</b> | <b>list</b> | <b>flush</b>} <b>table</b> [<u>family</u>] <u>table</u>
           <b>list</b> <b>tables</b> [<u>family</u>]
           <b>delete</b> <b>table</b> [<u>family</u>] <b>handle</b> <u>handle</u>
           <b>destroy</b> <b>table</b> [<u>family</u>] <b>handle</b> <u>handle</u>

       Tables are containers for chains, sets and stateful objects. They are identified by their address family
       and their name. The address family must be one of <b>ip</b>, <b>ip6</b>, <b>inet</b>, <b>arp</b>, <b>bridge</b>, <b>netdev</b>. The <b>inet</b> address
       family is a dummy family which is used to create hybrid IPv4/IPv6 tables. The <b>meta</b> <b>expression</b> <b>nfproto</b>
       keyword can be used to test which family (ipv4 or ipv6) context the packet is being processed in. When no
       address family is specified, <b>ip</b> is used by default. The only difference between add and create is that
       the former will not return an error if the specified table already exists while <b>create</b> will return an
       error.

       <b>Table</b> <b>4.</b> <b>Table</b> <b>flags</b>
       ┌─────────┬───────────────────────────────────────┐
       │ <b>Flag</b>    │ <b>Description</b>                           │
       ├─────────┼───────────────────────────────────────┤
       │         │                                       │
       │ dormant │ table is not evaluated any more (base │
       │         │ chains are unregistered).             │
       ├─────────┼───────────────────────────────────────┤
       │         │                                       │
       │ owner   │ table is owned by the creating        │
       │         │ process.                              │
       ├─────────┼───────────────────────────────────────┤
       │         │                                       │
       │ persist │ table shall outlive the owning        │
       │         │ process.                              │
       └─────────┴───────────────────────────────────────┘

       Creating a table with flag <b>owner</b> excludes other processes from manipulating it or its contents. By
       default, it will be removed when the process exits. Setting flag <b>persist</b> will prevent this and the
       resulting orphaned table will accept a new owner, e.g. a restarting daemon maintaining the table.

       <b>Add,</b> <b>change,</b> <b>delete</b> <b>a</b> <b>table</b>.

           # start nft in interactive mode
           nft --interactive

           # create a new table.
           create table inet mytable

           # add a new base chain: get input packets
           add chain inet mytable myin { type filter hook input priority filter; }

           # add a single counter to the chain
           add rule inet mytable myin counter

           # disable the table temporarily -- rules are not evaluated anymore
           add table inet mytable { flags dormant; }

           # make table active again:
           add table inet mytable

       <b>add</b>       Add a new table for the given family
                 with the given name.

       <b>delete</b>    Delete the specified table.

       <b>destroy</b>   Delete the specified table, it does
                 not fail if it does not exist.

       <b>list</b>      List all chains and rules of the
                 specified table.

       <b>flush</b>     Flush all chains and rules of the
                 specified table.

</pre><h4><b>CHAINS</b></h4><pre>
           {<b>add</b> | <b>create</b>} <b>chain</b> [<u>family</u>] <u>table</u> <u>chain</u> [<b>{</b> <b>type</b> <u>type</u> <b>hook</b> <u>hook</u> [<b>device</b> <u>device</u>] <b>priority</b> <u>priority</u> <b>;</b> [<b>policy</b> <u>policy</u> <b>;</b>] [<b>comment</b> <u>comment</u> <b>;</b>] <b>}</b>]
           {<b>delete</b> | <b>destroy</b> | <b>list</b> | <b>flush</b>} <b>chain</b> [<u>family</u>] <u>table</u> <u>chain</u>
           <b>list</b> <b>chains</b> [<u>family</u>]
           <b>delete</b> <b>chain</b> [<u>family</u>] <u>table</u> <b>handle</b> <u>handle</u>
           <b>destroy</b> <b>chain</b> [<u>family</u>] <u>table</u> <b>handle</b> <u>handle</u>
           <b>rename</b> <b>chain</b> [<u>family</u>] <u>table</u> <u>chain</u> <u>newname</u>

       Chains are containers for rules. They exist in two kinds, base chains and regular chains. A base chain is
       an entry point for packets from the networking stack, a regular chain may be used as jump target and is
       used for better rule organization.

       <b>add</b>       Add a new chain in the specified
                 table. When a hook and priority value
                 are specified, the chain is created
                 as a base chain and hooked up to the
                 networking stack.

       <b>create</b>    Similar to the <b>add</b> command, but
                 returns an error if the chain already
                 exists.

       <b>delete</b>    Delete the specified chain. The chain
                 must not contain any rules or be used
                 as jump target.

       <b>destroy</b>   Delete the specified chain, it does
                 not fail if it does not exist. The
                 chain must not contain any rules or
                 be used as jump target.

       <b>rename</b>    Rename the specified chain.

       <b>list</b>      List all rules of the specified
                 chain.

       <b>flush</b>     Flush all rules of the specified
                 chain.

       For base chains, <b>type</b>, <b>hook</b> and <b>priority</b> parameters are mandatory.

       <b>Table</b> <b>5.</b> <b>Supported</b> <b>chain</b> <b>types</b>
       ┌────────┬───────────────┬─────────────────────┬────────────────────────┐
       │ <b>Type</b>   │ <b>Families</b>      │ <b>Hooks</b>               │ <b>Description</b>            │
       ├────────┼───────────────┼─────────────────────┼────────────────────────┤
       │        │               │                     │                        │
       │ filter │ all           │ all                 │ Standard chain type to │
       │        │               │                     │ use in doubt.          │
       ├────────┼───────────────┼─────────────────────┼────────────────────────┤
       │        │               │                     │                        │
       │ nat    │ ip, ip6, inet │ prerouting, input,  │ Chains of this type    │
       │        │               │ output, postrouting │ perform Native Address │
       │        │               │                     │ Translation based on   │
       │        │               │                     │ conntrack entries.     │
       │        │               │                     │ Only the first packet  │
       │        │               │                     │ of a connection        │
       │        │               │                     │ actually traverses     │
       │        │               │                     │ this chain - its rules │
       │        │               │                     │ usually define details │
       │        │               │                     │ of the created         │
       │        │               │                     │ conntrack entry (NAT   │
       │        │               │                     │ statements for         │
       │        │               │                     │ instance).             │
       ├────────┼───────────────┼─────────────────────┼────────────────────────┤
       │        │               │                     │                        │
       │ route  │ ip, ip6, inet │ output              │ If a packet has        │
       │        │               │                     │ traversed a chain of   │
       │        │               │                     │ this type and is about │
       │        │               │                     │ to be accepted, a new  │
       │        │               │                     │ route lookup is        │
       │        │               │                     │ performed if relevant  │
       │        │               │                     │ parts of the IP header │
       │        │               │                     │ have changed. This     │
       │        │               │                     │ allows one to e.g.     │
       │        │               │                     │ implement policy       │
       │        │               │                     │ routing selectors in   │
       │        │               │                     │ nftables.              │
       └────────┴───────────────┴─────────────────────┴────────────────────────┘

       Apart from the special cases illustrated above (e.g. <b>nat</b> type not supporting <b>forward</b> hook or <b>route</b> type
       only supporting <b>output</b> hook), there are three further quirks worth noticing:

       •   The netdev family supports merely two combinations, namely <b>filter</b> type with <b>ingress</b> hook and <b>filter</b>
           type with <b>egress</b> hook. Base chains in this family also require the <b>device</b> parameter to be present
           since they exist per interface only.

       •   The arp family supports only the <b>input</b> and <b>output</b> hooks, both in chains of type <b>filter</b>.

       •   The inet family also supports the <b>ingress</b> hook (since Linux kernel 5.10), to filter IPv4 and IPv6
           packet at the same location as the netdev <b>ingress</b> hook. This inet hook allows you to share sets and
           maps between the usual <b>prerouting</b>, <b>input</b>, <b>forward</b>, <b>output</b>, <b>postrouting</b> and this <b>ingress</b> hook.

       The <b>device</b> parameter accepts a network interface name as a string, and is required when adding a base
       chain that filters traffic on the ingress or egress hooks. Any ingress or egress chains will only filter
       traffic from the interface specified in the <b>device</b> parameter.

       The <b>priority</b> parameter accepts a signed integer value or a standard priority name which specifies the
       order in which chains with the same <b>hook</b> value are traversed. The ordering is ascending, i.e. lower
       priority values have precedence over higher ones.

       With <b>nat</b> type chains, there’s a lower excluding limit of -200 for <b>priority</b> values, because conntrack
       hooks at this priority and NAT requires it.

       Standard priority values can be replaced with easily memorizable names. Not all names make sense in every
       family with every hook (see the compatibility matrices below) but their numerical value can still be used
       for prioritizing chains.

       These names and values are defined and made available based on what priorities are used by xtables when
       registering their default chains.

       Most of the families use the same values, but bridge uses different ones from the others. See the
       following tables that describe the values and compatibility.

       <b>Table</b> <b>6.</b> <b>Standard</b> <b>priority</b> <b>names,</b> <b>family</b> <b>and</b> <b>hook</b> <b>compatibility</b> <b>matrix</b>
       ┌──────────┬───────┬─────────────────────┬─────────────┐
       │ <b>Name</b>     │ <b>Value</b> │ <b>Families</b>            │ <b>Hooks</b>       │
       ├──────────┼───────┼─────────────────────┼─────────────┤
       │          │       │                     │             │
       │ raw      │ -300  │ ip, ip6, inet       │ all         │
       ├──────────┼───────┼─────────────────────┼─────────────┤
       │          │       │                     │             │
       │ mangle   │ -150  │ ip, ip6, inet       │ all         │
       ├──────────┼───────┼─────────────────────┼─────────────┤
       │          │       │                     │             │
       │ dstnat   │ -100  │ ip, ip6, inet       │ prerouting  │
       ├──────────┼───────┼─────────────────────┼─────────────┤
       │          │       │                     │             │
       │ filter   │ 0     │ ip, ip6, inet, arp, │ all         │
       │          │       │ netdev              │             │
       ├──────────┼───────┼─────────────────────┼─────────────┤
       │          │       │                     │             │
       │ security │ 50    │ ip, ip6, inet       │ all         │
       ├──────────┼───────┼─────────────────────┼─────────────┤
       │          │       │                     │             │
       │ srcnat   │ 100   │ ip, ip6, inet       │ postrouting │
       └──────────┴───────┴─────────────────────┴─────────────┘

       <b>Table</b> <b>7.</b> <b>Standard</b> <b>priority</b> <b>names</b> <b>and</b> <b>hook</b> <b>compatibility</b> <b>for</b> <b>the</b> <b>bridge</b> <b>family</b>
       ┌────────┬───────┬─────────────┐
       │        │       │             │
       │ Name   │ Value │ Hooks       │
       ├────────┼───────┼─────────────┤
       │        │       │             │
       │ dstnat │ -300  │ prerouting  │
       ├────────┼───────┼─────────────┤
       │        │       │             │
       │ filter │ -200  │ all         │
       ├────────┼───────┼─────────────┤
       │        │       │             │
       │ out    │ 100   │ output      │
       ├────────┼───────┼─────────────┤
       │        │       │             │
       │ srcnat │ 300   │ postrouting │
       └────────┴───────┴─────────────┘

       Basic arithmetic expressions (addition and subtraction) can also be achieved with these standard names to
       ease relative prioritizing, e.g. <b>mangle</b> <b>-</b> <b>5</b> stands for <b>-155</b>. Values will also be printed like this until
       the value is not further than 10 from the standard value.

       Base chains also allow one to set the chain’s <b>policy</b>, i.e. what happens to packets not explicitly
       accepted or refused in contained rules. Supported policy values are <b>accept</b> (which is the default) or
       <b>drop</b>.

</pre><h4><b>RULES</b></h4><pre>
           {<b>add</b> | <b>insert</b>} <b>rule</b> [<u>family</u>] <u>table</u> <u>chain</u> [<b>handle</b> <u>handle</u> | <b>index</b> <u>index</u>] <u>statement</u> ... [<b>comment</b> <u>comment</u>]
           <b>replace</b> <b>rule</b> [<u>family</u>] <u>table</u> <u>chain</u> <b>handle</b> <u>handle</u> <u>statement</u> ... [<b>comment</b> <u>comment</u>]
           {<b>delete</b> | <b>reset</b>} <b>rule</b> [<u>family</u>] <u>table</u> <u>chain</u> <b>handle</b> <u>handle</u>
           <b>destroy</b> <b>rule</b> [<u>family</u>] <u>table</u> <u>chain</u> <b>handle</b> <u>handle</u>
           <b>reset</b> <b>rules</b> [<u>family</u>] [<u>table</u> [<u>chain</u>]]

       Rules are added to chains in the given table. If the family is not specified, the ip family is used.
       Rules are constructed from two kinds of components according to a set of grammatical rules: expressions
       and statements.

       The add and insert commands support an optional location specifier, which is either a <u>handle</u> or the <u>index</u>
       (starting at zero) of an existing rule. Internally, rule locations are always identified by <u>handle</u> and
       the translation from <u>index</u> happens in userspace. This has two potential implications in case a concurrent
       ruleset change happens after the translation was done: The effective rule index might change if a rule
       was inserted or deleted before the referred one. If the referred rule was deleted, the command is
       rejected by the kernel just as if an invalid <u>handle</u> was given.

       A <u>comment</u> is a single word or a double-quoted (") multi-word string which can be used to make notes
       regarding the actual rule. <b>Note:</b> If you use bash for adding rules, you have to escape the quotation
       marks, e.g. \"enable ssh for servers\".

       <b>add</b>       Add a new rule described by the list
                 of statements. The rule is appended
                 to the given chain unless a location
                 is specified, in which case the rule
                 is inserted after the specified rule.

       <b>insert</b>    Same as <b>add</b> except the rule is
                 inserted at the beginning of the
                 chain or before the specified rule.

       <b>replace</b>   Similar to <b>add</b>, but the rule replaces
                 the specified rule.

       <b>delete</b>    Delete the specified rule.

       <b>destroy</b>   Delete the specified rule, it does
                 not fail if it does not exist.

       <b>reset</b>     Reset rule-contained state, e.g.
                 counter and quota statement values.

       <b>add</b> <b>a</b> <b>rule</b> <b>to</b> <b>ip</b> <b>table</b> <b>output</b> <b>chain</b>.

           nft add rule filter output ip daddr 192.168.0.0/24 accept # 'ip filter' is assumed
           # same command, slightly more verbose
           nft add rule ip filter output ip daddr 192.168.0.0/24 accept

       <b>delete</b> <b>rule</b> <b>from</b> <b>inet</b> <b>table</b>.

           # nft -a list ruleset
           table inet filter {
                   chain input {
                           type filter hook input priority filter; policy accept;
                           ct state established,related accept # handle 4
                           ip saddr 10.1.1.1 tcp dport ssh accept # handle 5
                     ...
           # delete the rule with handle 5
           nft delete rule inet filter input handle 5

</pre><h4><b>SETS</b></h4><pre>
       nftables offers two kinds of set concepts. Anonymous sets are sets that have no specific name. The set
       members are enclosed in curly braces, with commas to separate elements when creating the rule the set is
       used in. Once that rule is removed, the set is removed as well. They cannot be updated, i.e. once an
       anonymous set is declared it cannot be changed anymore except by removing/altering the rule that uses the
       anonymous set.

       <b>Using</b> <b>anonymous</b> <b>sets</b> <b>to</b> <b>accept</b> <b>particular</b> <b>subnets</b> <b>and</b> <b>ports</b>.

           nft add rule filter input ip saddr { 10.0.0.0/8, 192.168.0.0/16 } tcp dport { 22, 443 } accept

       Named sets are sets that need to be defined first before they can be referenced in rules. Unlike
       anonymous sets, elements can be added to or removed from a named set at any time. Sets are referenced
       from rules using an @ prefixed to the sets name.

       <b>Using</b> <b>named</b> <b>sets</b> <b>to</b> <b>accept</b> <b>addresses</b> <b>and</b> <b>ports</b>.

           nft add rule filter input ip saddr @allowed_hosts tcp dport @allowed_ports accept

       The sets allowed_hosts and allowed_ports need to be created first. The next section describes nft set
       syntax in more detail.

           <b>add</b> <b>set</b> [<u>family</u>] <u>table</u> <u>set</u> <b>{</b> <b>type</b> <u>type</u> | <b>typeof</b> <u>expression</u> <b>;</b> [<b>flags</b> <u>flags</u> <b>;</b>] [<b>timeout</b> <u>timeout</u> <b>;</b>] [<b>gc-interval</b> <u>gc-interval</u> <b>;</b>] [<b>elements</b> <b>=</b> <b>{</b> <u>element</u>[<b>,</b> ...] <b>}</b> <b>;</b>] [<b>size</b> <u>size</u> <b>;</b>] [<b>comment</b> <u>comment</u> <b>;</b><u>]</u> <u>[</u><b>policy</b> <u>'policy</u> <b>;</b>] [<b>auto-merge</b> <b>;</b>] <b>}</b>
           {<b>delete</b> | <b>destroy</b> | <b>list</b> | <b>flush</b> | <b>reset</b> } <b>set</b> [<u>family</u>] <u>table</u> <u>set</u>
           <b>list</b> <b>sets</b> [<u>family</u>] [<u>table</u>]
           <b>delete</b> <b>set</b> [<u>family</u>] <u>table</u> <b>handle</b> <u>handle</u>
           {<b>add</b> | <b>delete</b> | <b>destroy</b> } <b>element</b> [<u>family</u>] <u>table</u> <u>set</u> <b>{</b> <u>element</u>[<b>,</b> ...] <b>}</b>

       Sets are element containers of a user-defined data type, they are uniquely identified by a user-defined
       name and attached to tables. Their behaviour can be tuned with the flags that can be specified at set
       creation time.

       <b>add</b>       Add a new set in the specified table.
                 See the Set specification table below
                 for more information about how to
                 specify properties of a set.

       <b>delete</b>    Delete the specified set.

       <b>destroy</b>   Delete the specified set, it does not
                 fail if it does not exist.

       <b>list</b>      Display the elements in the specified
                 set.

       <b>flush</b>     Remove all elements from the
                 specified set.

       <b>reset</b>     Reset state in all contained
                 elements, e.g. counter and quota
                 statement values.

       <b>Table</b> <b>8.</b> <b>Set</b> <b>specifications</b>
       ┌─────────────┬──────────────────────────────┬─────────────────────────────┐
       │ <b>Keyword</b>     │ <b>Description</b>                  │ <b>Type</b>                        │
       ├─────────────┼──────────────────────────────┼─────────────────────────────┤
       │             │                              │                             │
       │ type        │ data type of set elements    │ string: ipv4_addr,          │
       │             │                              │ ipv6_addr, ether_addr,      │
       │             │                              │ inet_proto, inet_service,   │
       │             │                              │ mark                        │
       ├─────────────┼──────────────────────────────┼─────────────────────────────┤
       │             │                              │                             │
       │ typeof      │ data type of set element     │ expression to derive the    │
       │             │                              │ data type from              │
       ├─────────────┼──────────────────────────────┼─────────────────────────────┤
       │             │                              │                             │
       │ flags       │ set flags                    │ string: constant, dynamic,  │
       │             │                              │ interval, timeout. Used to  │
       │             │                              │ describe the sets           │
       │             │                              │ properties.                 │
       ├─────────────┼──────────────────────────────┼─────────────────────────────┤
       │             │                              │                             │
       │ timeout     │ time an element stays in the │ string, decimal followed by │
       │             │ set, mandatory if set is     │ unit. Units are: d, h, m, s │
       │             │ added to from the packet     │                             │
       │             │ path (ruleset)               │                             │
       ├─────────────┼──────────────────────────────┼─────────────────────────────┤
       │             │                              │                             │
       │ gc-interval │ garbage collection interval, │ string, decimal followed by │
       │             │ only available when timeout  │ unit. Units are: d, h, m, s │
       │             │ or flag timeout are active   │                             │
       ├─────────────┼──────────────────────────────┼─────────────────────────────┤
       │             │                              │                             │
       │ elements    │ elements contained by the    │ set data type               │
       │             │ set                          │                             │
       ├─────────────┼──────────────────────────────┼─────────────────────────────┤
       │             │                              │                             │
       │ size        │ maximum number of elements   │ unsigned integer (64 bit)   │
       │             │ in the set, mandatory if set │                             │
       │             │ is added to from the packet  │                             │
       │             │ path (ruleset)               │                             │
       ├─────────────┼──────────────────────────────┼─────────────────────────────┤
       │             │                              │                             │
       │ policy      │ set policy                   │ string: performance         │
       │             │                              │ [default], memory           │
       ├─────────────┼──────────────────────────────┼─────────────────────────────┤
       │             │                              │                             │
       │ auto-merge  │ automatic merge of           │                             │
       │             │ adjacent/overlapping set     │                             │
       │             │ elements (only for interval  │                             │
       │             │ sets)                        │                             │
       └─────────────┴──────────────────────────────┴─────────────────────────────┘

</pre><h4><b>MAPS</b></h4><pre>
           <b>add</b> <b>map</b> [<u>family</u>] <u>table</u> <u>map</u> <b>{</b> <b>type</b> <u>type</u> | <b>typeof</b> <u>expression</u> [<b>flags</b> <u>flags</u> <b>;</b>] [<b>elements</b> <b>=</b> <b>{</b> <u>element</u>[<b>,</b> ...] <b>}</b> <b>;</b>] [<b>size</b> <u>size</u> <b>;</b>] [<b>comment</b> <u>comment</u> <b>;</b><u>]</u> <u>[</u><b>policy</b> <u>'policy</u> <b>;</b>] <b>}</b>
           {<b>delete</b> | <b>destroy</b> | <b>list</b> | <b>flush</b> | <b>reset</b> } <b>map</b> [<u>family</u>] <u>table</u> <u>map</u>
           <b>list</b> <b>maps</b> [<u>family</u>] [<u>table</u>]

       Maps store data based on some specific key used as input. They are uniquely identified by a user-defined
       name and attached to tables.

       <b>add</b>       Add a new map in the specified table.

       <b>delete</b>    Delete the specified map.

       <b>destroy</b>   Delete the specified map, it does not
                 fail if it does not exist.

       <b>list</b>      Display the elements in the specified
                 map.

       <b>flush</b>     Remove all elements from the
                 specified map.

       <b>reset</b>     Reset state in all contained
                 elements, e.g. counter and quota
                 statement values.

       <b>Table</b> <b>9.</b> <b>Map</b> <b>specifications</b>
       ┌──────────┬────────────────────────────┬────────────────────────────┐
       │ <b>Keyword</b>  │ <b>Description</b>                │ <b>Type</b>                       │
       ├──────────┼────────────────────────────┼────────────────────────────┤
       │          │                            │                            │
       │ type     │ data type of map elements  │ string: ipv4_addr,         │
       │          │                            │ ipv6_addr, ether_addr,     │
       │          │                            │ inet_proto, inet_service,  │
       │          │                            │ mark, counter, quota.      │
       │          │                            │ Counter and quota can’t be │
       │          │                            │ used as keys               │
       ├──────────┼────────────────────────────┼────────────────────────────┤
       │          │                            │                            │
       │ typeof   │ data type of set element   │ expression to derive the   │
       │          │                            │ data type from             │
       ├──────────┼────────────────────────────┼────────────────────────────┤
       │          │                            │                            │
       │ flags    │ map flags                  │ string, same as set flags  │
       ├──────────┼────────────────────────────┼────────────────────────────┤
       │          │                            │                            │
       │ elements │ elements contained by the  │ map data type              │
       │          │ map                        │                            │
       ├──────────┼────────────────────────────┼────────────────────────────┤
       │          │                            │                            │
       │ size     │ maximum number of elements │ unsigned integer (64 bit)  │
       │          │ in the map                 │                            │
       ├──────────┼────────────────────────────┼────────────────────────────┤
       │          │                            │                            │
       │ policy   │ map policy                 │ string: performance        │
       │          │                            │ [default], memory          │
       └──────────┴────────────────────────────┴────────────────────────────┘

       Users can specifiy the properties/features that the set/map must support. This allows the kernel to pick
       an optimal internal representation. If a required flag is missing, the ruleset might still work, as
       nftables will auto-enable features if it can infer this from the ruleset. This may not work for all
       cases, however, so it is recommended to specify all required features in the set/map definition manually.

       <b>Table</b> <b>10.</b> <b>Set</b> <b>and</b> <b>Map</b> <b>flags</b>
       ┌──────────┬──────────────────────────────────────┐
       │ <b>Flag</b>     │ <b>Description</b>                          │
       ├──────────┼──────────────────────────────────────┤
       │          │                                      │
       │ constant │ Set contents will never change after │
       │          │ creation                             │
       ├──────────┼──────────────────────────────────────┤
       │          │                                      │
       │ dynamic  │ Set must support updates from the    │
       │          │ packet path with the <b>add</b>, <b>update</b> or  │
       │          │ <b>delete</b> keywords.                     │
       ├──────────┼──────────────────────────────────────┤
       │          │                                      │
       │ interval │ Set must be able to store intervals  │
       │          │ (ranges)                             │
       ├──────────┼──────────────────────────────────────┤
       │          │                                      │
       │ timeout  │ Set must support element timeouts    │
       │          │ (auto-removal of elements once they  │
       │          │ expire).                             │
       └──────────┴──────────────────────────────────────┘

</pre><h4><b>ELEMENTS</b></h4><pre>
           {<b>add</b> | <b>create</b> | <b>delete</b> | <b>destroy</b> | <b>get</b> | <b>reset</b> } <b>element</b> [<u>family</u>] <u>table</u> <u>set</u> <b>{</b> <u>ELEMENT</u>[<b>,</b> ...] <b>}</b>

           <u>ELEMENT</u> := <u>key_expression</u> <u>OPTIONS</u> [<b>:</b> <u>value_expression</u>]
           <u>OPTIONS</u> := [<b>timeout</b> <u>TIMESPEC</u>] [<b>expires</b> <u>TIMESPEC</u>] [<b>comment</b> <u>string</u>]
           <u>TIMESPEC</u> := [<u>num</u><b>d</b>][<u>num</u><b>h</b>][<u>num</u><b>m</b>][<u>num</u>[<b>s</b>]]

       Element-related commands allow one to change contents of named sets and maps. <u>key_expression</u> is typically
       a value matching the set type. <u>value_expression</u> is not allowed in sets but mandatory when adding to maps,
       where it matches the data part in its type definition. When deleting from maps, it may be specified but
       is optional as <u>key_expression</u> uniquely identifies the element.

       <b>create</b> command is similar to <b>add</b> with the exception that none of the listed elements may already exist.

       <b>get</b> command is useful to check if an element is contained in a set which may be non-trivial in very large
       and/or interval sets. In the latter case, the containing interval is returned instead of just the element
       itself.

       <b>reset</b> command resets state attached to the given element(s), e.g. counter and quota statement values.

       <b>Table</b> <b>11.</b> <b>Element</b> <b>options</b>
       ┌─────────┬───────────────────────────────────────┐
       │ <b>Option</b>  │ <b>Description</b>                           │
       ├─────────┼───────────────────────────────────────┤
       │         │                                       │
       │ timeout │ timeout value for sets/maps with flag │
       │         │ <b>timeout</b>                               │
       ├─────────┼───────────────────────────────────────┤
       │         │                                       │
       │ expires │ the time until given element expires, │
       │         │ useful for ruleset replication only   │
       ├─────────┼───────────────────────────────────────┤
       │         │                                       │
       │ comment │ per element comment field             │
       └─────────┴───────────────────────────────────────┘

</pre><h4><b>FLOWTABLES</b></h4><pre>
           {<b>add</b> | <b>create</b>} <b>flowtable</b> [<u>family</u>] <u>table</u> <u>flowtable</u> <b>{</b> <b>hook</b> <u>hook</u> <b>priority</b> <u>priority</u> <b>;</b> <b>devices</b> <b>=</b> <b>{</b> <u>device</u>[<b>,</b> ...] <b>}</b> <b>;</b> <b>}</b>
           <b>list</b> <b>flowtables</b> [<u>family</u>] [<u>table</u>]
           {<b>delete</b> | <b>destroy</b> | <b>list</b>} <b>flowtable</b> [<u>family</u>] <u>table</u> <u>flowtable</u>
           <b>delete</b> <b>flowtable</b> [<u>family</u>] <u>table</u> <b>handle</b> <u>handle</u>

       Flowtables allow you to accelerate packet forwarding in software. Flowtables entries are represented
       through a tuple that is composed of the input interface, source and destination address, source and
       destination port; and layer 3/4 protocols. Each entry also caches the destination interface and the
       gateway address - to update the destination link-layer address - to forward packets. The ttl and hoplimit
       fields are also decremented. Hence, flowtables provides an alternative path that allow packets to bypass
       the classic forwarding path. Flowtables reside in the ingress <b>hook</b> that is located before the prerouting
       <b>hook</b>. You can select which flows you want to offload through the flow expression from the forward chain.
       Flowtables are identified by their address family and their name. The address family must be one of ip,
       ip6, or inet. The inet address family is a dummy family which is used to create hybrid IPv4/IPv6 tables.
       When no address family is specified, ip is used by default.

       The <b>priority</b> can be a signed integer or <b>filter</b> which stands for 0. Addition and subtraction can be used
       to set relative priority, e.g. filter + 5 equals to 5.

       <b>add</b>       Add a new flowtable for the given
                 family with the given name.

       <b>delete</b>    Delete the specified flowtable.

       <b>destroy</b>   Delete the specified flowtable, it
                 does not fail if it does not exist.

       <b>list</b>      List all flowtables.

</pre><h4><b>STATEFUL</b> <b>OBJECTS</b></h4><pre>
           {<b>add</b> | <b>delete</b> | <b>destroy</b> | <b>list</b> | <b>reset</b>} <b>counter</b> [<u>family</u>] <u>table</u> <u>object</u>
           {<b>add</b> | <b>delete</b> | <b>destroy</b> | <b>list</b> | <b>reset</b>} <b>quota</b> [<u>family</u>] <u>table</u> <u>object</u>
           {<b>add</b> | <b>delete</b> | <b>destroy</b> | <b>list</b>} <b>limit</b> [<u>family</u>] <u>table</u> <u>object</u>
           <b>delete</b> <u>counter</u> [<u>family</u>] <u>table</u> <b>handle</b> <u>handle</u>
           <b>delete</b> <u>quota</u> [<u>family</u>] <u>table</u> <b>handle</b> <u>handle</u>
           <b>delete</b> <u>limit</u> [<u>family</u>] <u>table</u> <b>handle</b> <u>handle</u>
           <b>destroy</b> <u>counter</u> [<u>family</u>] <u>table</u> <b>handle</b> <u>handle</u>
           <b>destroy</b> <u>quota</u> [<u>family</u>] <u>table</u> <b>handle</b> <u>handle</u>
           <b>destroy</b> <u>limit</u> [<u>family</u>] <u>table</u> <b>handle</b> <u>handle</u>
           <b>list</b> { <b>counters</b> | <b>limits</b> | <b>quotas</b> } [<u>family</u>] [<u>table</u>]
           <b>reset</b> { <b>counters</b> | <b>quotas</b> } [<u>family</u>] [<u>table</u>]

       Stateful objects are attached to tables and are identified by a unique name. They group stateful
       information from rules, to reference them in rules the keywords "type name" are used e.g. "counter name".

       <b>add</b>       Add a new stateful object in the
                 specified table.

       <b>delete</b>    Delete the specified object.

       <b>destroy</b>   Delete the specified object, it does
                 not fail if it does not exist.

       <b>list</b>      Display stateful information the
                 object holds.

       <b>reset</b>     List-and-reset stateful object.

   <b>CT</b> <b>HELPER</b>
           <b>add</b> <b>ct</b> <b>helper</b> [<u>family</u>] <u>table</u> <u>name</u> <b>{</b> <b>type</b> <u>type</u> <b>protocol</b> <u>protocol</u> <b>;</b> [<b>l3proto</b> <u>family</u> <b>;</b>] <b>}</b>
           <b>delete</b> <b>ct</b> <b>helper</b> [<u>family</u>] <u>table</u> <u>name</u>
           <b>list</b> <b>ct</b> <b>helpers</b>

       Ct helper is used to define connection tracking helpers that can then be used in combination with the <b>ct</b>
       <b>helper</b> <b>set</b> statement. <u>type</u> and <u>protocol</u> are mandatory, l3proto is derived from the table family by
       default, i.e. in the inet table the kernel will try to load both the ipv4 and ipv6 helper backends, if
       they are supported by the kernel.

       <b>Table</b> <b>12.</b> <b>conntrack</b> <b>helper</b> <b>specifications</b>
       ┌──────────┬─────────────────────────────┬────────────────────────────┐
       │ <b>Keyword</b>  │ <b>Description</b>                 │ <b>Type</b>                       │
       ├──────────┼─────────────────────────────┼────────────────────────────┤
       │          │                             │                            │
       │ type     │ name of helper type         │ quoted string (e.g. "ftp") │
       ├──────────┼─────────────────────────────┼────────────────────────────┤
       │          │                             │                            │
       │ protocol │ layer 4 protocol of the     │ string (e.g. ip)           │
       │          │ helper                      │                            │
       ├──────────┼─────────────────────────────┼────────────────────────────┤
       │          │                             │                            │
       │ l3proto  │ layer 3 protocol of the     │ address family (e.g. ip)   │
       │          │ helper                      │                            │
       ├──────────┼─────────────────────────────┼────────────────────────────┤
       │          │                             │                            │
       │ comment  │ per ct helper comment field │ string                     │
       └──────────┴─────────────────────────────┴────────────────────────────┘

       <b>defining</b> <b>and</b> <b>assigning</b> <b>ftp</b> <b>helper</b>.

           Unlike iptables, helper assignment needs to be performed after the conntrack
           lookup has completed, for example with the default 0 hook priority.

           table inet myhelpers {
             ct helper ftp-standard {
                type "ftp" protocol tcp
             }
             chain prerouting {
                 type filter hook prerouting priority filter;
                 tcp dport 21 ct helper set "ftp-standard"
             }
           }

   <b>CT</b> <b>TIMEOUT</b>
           <b>add</b> <b>ct</b> <b>timeout</b>  [<u>family</u>] <u>table</u> <u>name</u> <b>{</b> <b>protocol</b> <u>protocol</u> <b>;</b> <b>policy</b> <b>=</b> <b>{</b> <u>state</u><b>:</b> <u>value</u> [<b>,</b> ...] <b>}</b> <b>;</b> [<b>l3proto</b> <u>family</u> <b>;</b>] <b>}</b>
           <b>delete</b> <b>ct</b> <b>timeout</b> [<u>family</u>] <u>table</u> <u>name</u>
           <b>list</b> <b>ct</b> <b>timeouts</b>

       Ct timeout is used to update connection tracking timeout values.Timeout policies are assigned with the <b>ct</b>
       <b>timeout</b> <b>set</b> statement. <u>protocol</u> and <u>policy</u> are mandatory, l3proto is derived from the table family by
       default.

       <b>Table</b> <b>13.</b> <b>conntrack</b> <b>timeout</b> <b>specifications</b>
       ┌──────────┬──────────────────────────────┬─────────────────────────────┐
       │ <b>Keyword</b>  │ <b>Description</b>                  │ <b>Type</b>                        │
       ├──────────┼──────────────────────────────┼─────────────────────────────┤
       │          │                              │                             │
       │ protocol │ layer 4 protocol of the      │ string (e.g. ip)            │
       │          │ timeout object               │                             │
       ├──────────┼──────────────────────────────┼─────────────────────────────┤
       │          │                              │                             │
       │ state    │ connection state name        │ string (e.g. "established") │
       ├──────────┼──────────────────────────────┼─────────────────────────────┤
       │          │                              │                             │
       │ value    │ timeout value for connection │ unsigned integer            │
       │          │ state                        │                             │
       ├──────────┼──────────────────────────────┼─────────────────────────────┤
       │          │                              │                             │
       │ l3proto  │ layer 3 protocol of the      │ address family (e.g. ip)    │
       │          │ timeout object               │                             │
       ├──────────┼──────────────────────────────┼─────────────────────────────┤
       │          │                              │                             │
       │ comment  │ per ct timeout comment field │ string                      │
       └──────────┴──────────────────────────────┴─────────────────────────────┘

       tcp connection state names that can have a specific timeout value are:

       <u>close</u>, <u>close_wait</u>, <u>established</u>, <u>fin_wait</u>, <u>last_ack</u>, <u>retrans</u>, <u>syn_recv</u>, <u>syn_sent</u>, <u>time_wait</u> and <u>unack</u>.

       You can use <u>sysctl</u> <u>-a</u> <u>|grep</u> <u>net.netfilter.nf_conntrack_tcp_timeout</u><b>_</b> to view and change the system-wide
       defaults. <u>ct</u> <u>timeout</u> allows for flow-specific settings, without changing the global timeouts.

       For example, tcp port 53 could have much lower settings than other traffic.

       udp state names that can have a specific timeout value are <u>replied</u> and <u>unreplied</u>.

       <b>defining</b> <b>and</b> <b>assigning</b> <b>ct</b> <b>timeout</b> <b>policy</b>.

           table ip filter {
                   ct timeout customtimeout {
                           protocol tcp;
                           l3proto ip
                           policy = { established: 2m, close: 20s }
                   }

                   chain output {
                           type filter hook output priority filter; policy accept;
                           ct timeout set "customtimeout"
                   }
           }

       <b>testing</b> <b>the</b> <b>updated</b> <b>timeout</b> <b>policy</b>.

           % conntrack -E

           It should display:

           [UPDATE] tcp      6 120 ESTABLISHED src=172.16.19.128 dst=172.16.19.1
           sport=22 dport=41360 [UNREPLIED] src=172.16.19.1 dst=172.16.19.128
           sport=41360 dport=22

   <b>CT</b> <b>EXPECTATION</b>
           <b>add</b> <b>ct</b> <b>expectation</b>  [<u>family</u>] <u>table</u> <u>name</u> <b>{</b> <b>protocol</b> <u>protocol</u> <b>;</b> <b>dport</b> <u>dport</u> <b>;</b> <b>timeout</b> <u>timeout</u> <b>;</b> <b>size</b> <u>size</u> <b>;</b> [<b>l3proto</b> <u>family</u> <b>;</b>] <b>}</b>
           <b>delete</b> <b>ct</b> <b>expectation</b>  [<u>family</u>] <u>table</u> <u>name</u>
           <b>list</b> <b>ct</b> <b>expectations</b>

       Ct expectation is used to create connection expectations. Expectations are assigned with the <b>ct</b>
       <b>expectation</b> <b>set</b> statement. <u>protocol</u>, <u>dport</u>, <u>timeout</u> and <u>size</u> are mandatory, l3proto is derived from the
       table family by default.

       <b>Table</b> <b>14.</b> <b>conntrack</b> <b>expectation</b> <b>specifications</b>
       ┌──────────┬──────────────────────────────┬──────────────────────────┐
       │ <b>Keyword</b>  │ <b>Description</b>                  │ <b>Type</b>                     │
       ├──────────┼──────────────────────────────┼──────────────────────────┤
       │          │                              │                          │
       │ protocol │ layer 4 protocol of the      │ string (e.g. ip)         │
       │          │ expectation object           │                          │
       ├──────────┼──────────────────────────────┼──────────────────────────┤
       │          │                              │                          │
       │ dport    │ destination port of expected │ unsigned integer         │
       │          │ connection                   │                          │
       ├──────────┼──────────────────────────────┼──────────────────────────┤
       │          │                              │                          │
       │ timeout  │ timeout value for            │ unsigned integer         │
       │          │ expectation                  │                          │
       ├──────────┼──────────────────────────────┼──────────────────────────┤
       │          │                              │                          │
       │ size     │ size value for expectation   │ unsigned integer         │
       ├──────────┼──────────────────────────────┼──────────────────────────┤
       │          │                              │                          │
       │ l3proto  │ layer 3 protocol of the      │ address family (e.g. ip) │
       │          │ expectation object           │                          │
       ├──────────┼──────────────────────────────┼──────────────────────────┤
       │          │                              │                          │
       │ comment  │ per ct expectation comment   │ string                   │
       │          │ field                        │                          │
       └──────────┴──────────────────────────────┴──────────────────────────┘

       <b>defining</b> <b>and</b> <b>assigning</b> <b>ct</b> <b>expectation</b> <b>policy</b>.

           table ip filter {
                   ct expectation expect {
                           protocol udp
                           dport 9876
                           timeout 2m
                           size 8
                           l3proto ip
                   }

                   chain input {
                           type filter hook input priority filter; policy accept;
                           ct expectation set "expect"
                   }
           }

   <b>COUNTER</b>
           <b>add</b> <b>counter</b> [<u>family</u>] <u>table</u> <u>name</u> [<b>{</b> [ <b>packets</b> <u>packets</u> <b>bytes</b> <u>bytes</u> <u>;</u> ] [ <b>comment</b> <u>comment</u> <u>;</u> <b>}</b>]
           <b>delete</b> <b>counter</b> [<u>family</u>] <u>table</u> <u>name</u>
           <b>list</b> <b>counters</b>

       <b>Table</b> <b>15.</b> <b>Counter</b> <b>specifications</b>
       ┌─────────┬───────────────────────────┬───────────────────────────┐
       │ <b>Keyword</b> │ <b>Description</b>               │ <b>Type</b>                      │
       ├─────────┼───────────────────────────┼───────────────────────────┤
       │         │                           │                           │
       │ packets │ initial count of packets  │ unsigned integer (64 bit) │
       ├─────────┼───────────────────────────┼───────────────────────────┤
       │         │                           │                           │
       │ bytes   │ initial count of bytes    │ unsigned integer (64 bit) │
       ├─────────┼───────────────────────────┼───────────────────────────┤
       │         │                           │                           │
       │ comment │ per counter comment field │ string                    │
       └─────────┴───────────────────────────┴───────────────────────────┘

       <b>Using</b> <b>named</b> <b>counters</b>.

           nft add counter filter http
           nft add rule filter input tcp dport 80 counter name \"http\"

       <b>Using</b> <b>named</b> <b>counters</b> <b>with</b> <b>maps</b>.

           nft add counter filter http
           nft add counter filter https
           nft add rule filter input counter name tcp dport map { 80 : \"http\", 443 : \"https\" }

   <b>QUOTA</b>
           <b>add</b> <b>quota</b> [<u>family</u>] <u>table</u> <u>name</u> <b>{</b> [<b>over</b>|<b>until</b>] <u>bytes</u> <u>BYTE_UNIT</u> [ <b>used</b> <u>bytes</u> <u>BYTE_UNIT</u> ] <u>;</u> [ <b>comment</b> <u>comment</u> <u>;</u> ] <b>}</b>
           BYTE_UNIT := bytes | kbytes | mbytes
           <b>delete</b> <b>quota</b> [<u>family</u>] <u>table</u> <u>name</u>
           <b>list</b> <b>quotas</b>

       <b>Table</b> <b>16.</b> <b>Quota</b> <b>specifications</b>
       ┌─────────┬─────────────────────────────┬──────────────────────────────┐
       │ <b>Keyword</b> │ <b>Description</b>                 │ <b>Type</b>                         │
       ├─────────┼─────────────────────────────┼──────────────────────────────┤
       │         │                             │                              │
       │ quota   │ quota limit, used as the    │ Two arguments, unsigned      │
       │         │ quota name                  │ integer (64 bit) and string: │
       │         │                             │ bytes, kbytes, mbytes.       │
       │         │                             │ "over" and "until" go before │
       │         │                             │ these arguments              │
       ├─────────┼─────────────────────────────┼──────────────────────────────┤
       │         │                             │                              │
       │ used    │ initial value of used quota │ Two arguments, unsigned      │
       │         │                             │ integer (64 bit) and string: │
       │         │                             │ bytes, kbytes, mbytes        │
       ├─────────┼─────────────────────────────┼──────────────────────────────┤
       │         │                             │                              │
       │ comment │ per quota comment field     │ string                       │
       └─────────┴─────────────────────────────┴──────────────────────────────┘

       <b>Using</b> <b>named</b> <b>quotas</b>.

           nft add quota filter user123 { over 20 mbytes }
           nft add rule filter input ip saddr 192.168.10.123 quota name \"user123\"

       <b>Using</b> <b>named</b> <b>quotas</b> <b>with</b> <b>maps</b>.

           nft add quota filter user123 { over 20 mbytes }
           nft add quota filter user124 { over 20 mbytes }
           nft add rule filter input quota name ip saddr map { 192.168.10.123 : \"user123\", 192.168.10.124 : \"user124\" }

</pre><h4><b>EXPRESSIONS</b></h4><pre>
       Expressions represent values, either constants like network addresses, port numbers, etc., or data
       gathered from the packet during ruleset evaluation. Expressions can be combined using binary, logical,
       relational and other types of expressions to form complex or relational (match) expressions. They are
       also used as arguments to certain types of operations, like NAT, packet marking etc.

       Each expression has a data type, which determines the size, parsing and representation of symbolic values
       and type compatibility with other expressions.

   <b>DESCRIBE</b> <b>COMMAND</b>
           <b>describe</b> <u>expression</u> | <u>data</u> <u>type</u>

       The <b>describe</b> command shows information about the type of an expression and its data type. A data type may
       also be given, in which nft will display more information about the type.

       <b>The</b> <b>describe</b> <b>command</b>.

           $ nft describe tcp flags
           payload expression, datatype tcp_flag (TCP flag) (basetype bitmask, integer), 8 bits

           predefined symbolic constants:
           fin                           0x01
           syn                           0x02
           rst                           0x04
           psh                           0x08
           ack                           0x10
           urg                           0x20
           ecn                           0x40
           cwr                           0x80

</pre><h4><b>DATA</b> <b>TYPES</b></h4><pre>
       Data types determine the size, parsing and representation of symbolic values and type compatibility of
       expressions. A number of global data types exist, in addition some expression types define further data
       types specific to the expression type. Most data types have a fixed size, some however may have a dynamic
       size, f.i. the string type. Some types also have predefined symbolic constants. Those can be listed using
       the nft <b>describe</b> command:

           $ nft describe ct_state
           datatype ct_state (conntrack state) (basetype bitmask, integer), 32 bits

           pre-defined symbolic constants (in hexadecimal):
           invalid                         0x00000001
           new ...

       Types may be derived from lower order types, f.i. the IPv4 address type is derived from the integer type,
       meaning an IPv4 address can also be specified as an integer value.

       In certain contexts (set and map definitions), it is necessary to explicitly specify a data type. Each
       type has a name which is used for this.

   <b>INTEGER</b> <b>TYPE</b>
       ┌─────────┬─────────┬──────────┬───────────┐
       │ <b>Name</b>    │ <b>Keyword</b> │ <b>Size</b>     │ <b>Base</b> <b>type</b> │
       ├─────────┼─────────┼──────────┼───────────┤
       │         │         │          │           │
       │ Integer │ integer │ variable │ -         │
       └─────────┴─────────┴──────────┴───────────┘

       The integer type is used for numeric values. It may be specified as a decimal, hexadecimal or octal
       number. The integer type does not have a fixed size, its size is determined by the expression for which
       it is used.

   <b>BITMASK</b> <b>TYPE</b>
       ┌─────────┬─────────┬──────────┬───────────┐
       │ <b>Name</b>    │ <b>Keyword</b> │ <b>Size</b>     │ <b>Base</b> <b>type</b> │
       ├─────────┼─────────┼──────────┼───────────┤
       │         │         │          │           │
       │ Bitmask │ bitmask │ variable │ integer   │
       └─────────┴─────────┴──────────┴───────────┘

       The bitmask type (<b>bitmask</b>) is used for bitmasks.

   <b>STRING</b> <b>TYPE</b>
       ┌────────┬─────────┬──────────┬───────────┐
       │ <b>Name</b>   │ <b>Keyword</b> │ <b>Size</b>     │ <b>Base</b> <b>type</b> │
       ├────────┼─────────┼──────────┼───────────┤
       │        │         │          │           │
       │ String │ string  │ variable │ -         │
       └────────┴─────────┴──────────┴───────────┘

       The string type is used for character strings. A string begins with an alphabetic character (a-zA-Z)
       followed by zero or more alphanumeric characters or the characters /, -, _ and .. In addition, anything
       enclosed in double quotes (") is recognized as a string.

       <b>String</b> <b>specification</b>.

           # Interface name
           filter input iifname eth0

           # Weird interface name
           filter input iifname "(eth0)"

   <b>LINK</b> <b>LAYER</b> <b>ADDRESS</b> <b>TYPE</b>
       ┌────────────────────┬─────────┬──────────┬───────────┐
       │ <b>Name</b>               │ <b>Keyword</b> │ <b>Size</b>     │ <b>Base</b> <b>type</b> │
       ├────────────────────┼─────────┼──────────┼───────────┤
       │                    │         │          │           │
       │ Link layer address │ lladdr  │ variable │ integer   │
       └────────────────────┴─────────┴──────────┴───────────┘

       The link layer address type is used for link layer addresses. Link layer addresses are specified as a
       variable amount of groups of two hexadecimal digits separated using colons (:).

       <b>Link</b> <b>layer</b> <b>address</b> <b>specification</b>.

           # Ethernet destination MAC address
           filter input ether daddr 20:c9:d0:43:12:d9

   <b>IPV4</b> <b>ADDRESS</b> <b>TYPE</b>
       ┌──────────────┬───────────┬────────┬───────────┐
       │ <b>Name</b>         │ <b>Keyword</b>   │ <b>Size</b>   │ <b>Base</b> <b>type</b> │
       ├──────────────┼───────────┼────────┼───────────┤
       │              │           │        │           │
       │ IPV4 address │ ipv4_addr │ 32 bit │ integer   │
       └──────────────┴───────────┴────────┴───────────┘

       The IPv4 address type is used for IPv4 addresses. Addresses are specified in either dotted decimal,
       dotted hexadecimal, dotted octal, decimal, hexadecimal, octal notation or as a host name. A host name
       will be resolved using the standard system resolver.

       <b>IPv4</b> <b>address</b> <b>specification</b>.

           # dotted decimal notation
           filter output ip daddr 127.0.0.1

           # host name
           filter output ip daddr localhost

   <b>IPV6</b> <b>ADDRESS</b> <b>TYPE</b>
       ┌──────────────┬───────────┬─────────┬───────────┐
       │ <b>Name</b>         │ <b>Keyword</b>   │ <b>Size</b>    │ <b>Base</b> <b>type</b> │
       ├──────────────┼───────────┼─────────┼───────────┤
       │              │           │         │           │
       │ IPv6 address │ ipv6_addr │ 128 bit │ integer   │
       └──────────────┴───────────┴─────────┴───────────┘

       The IPv6 address type is used for IPv6 addresses. Addresses are specified as a host name or as
       hexadecimal halfwords separated by colons. Addresses might be enclosed in square brackets ("[]") to
       differentiate them from port numbers.

       <b>IPv6</b> <b>address</b> <b>specification</b>.

           # abbreviated loopback address
           filter output ip6 daddr ::1

       <b>IPv6</b> <b>address</b> <b>specification</b> <b>with</b> <b>bracket</b> <b>notation</b>.

           # without [] the port number (22) would be parsed as part of the
           # ipv6 address
           ip6 nat prerouting tcp dport 2222 dnat to [1ce::d0]:22

   <b>BOOLEAN</b> <b>TYPE</b>
       ┌─────────┬─────────┬───────┬───────────┐
       │ <b>Name</b>    │ <b>Keyword</b> │ <b>Size</b>  │ <b>Base</b> <b>type</b> │
       ├─────────┼─────────┼───────┼───────────┤
       │         │         │       │           │
       │ Boolean │ boolean │ 1 bit │ integer   │
       └─────────┴─────────┴───────┴───────────┘

       The boolean type is a syntactical helper type in userspace. Its use is in the right-hand side of a
       (typically implicit) relational expression to change the expression on the left-hand side into a boolean
       check (usually for existence).

       <b>Table</b> <b>17.</b> <b>The</b> <b>following</b> <b>keywords</b> <b>will</b> <b>automatically</b> <b>resolve</b> <b>into</b> <b>a</b> <b>boolean</b> <b>type</b> <b>with</b> <b>given</b> <b>value</b>
       ┌─────────┬───────┐
       │ <b>Keyword</b> │ <b>Value</b> │
       ├─────────┼───────┤
       │         │       │
       │ exists  │ 1     │
       ├─────────┼───────┤
       │         │       │
       │ missing │ 0     │
       └─────────┴───────┘

       <b>Table</b> <b>18.</b> <b>expressions</b> <b>support</b> <b>a</b> <b>boolean</b> <b>comparison</b>
       ┌────────────┬────────────────────────────────────┐
       │ <b>Expression</b> │ <b>Behaviour</b>                          │
       ├────────────┼────────────────────────────────────┤
       │            │                                    │
       │ fib        │ Check route existence.             │
       ├────────────┼────────────────────────────────────┤
       │            │                                    │
       │ exthdr     │ Check IPv6 extension header        │
       │            │ existence.                         │
       ├────────────┼────────────────────────────────────┤
       │            │                                    │
       │ tcp option │ Check TCP option header existence. │
       └────────────┴────────────────────────────────────┘

       <b>Boolean</b> <b>specification</b>.

           # match if route exists
           filter input fib daddr . iif oif exists

           # match only non-fragmented packets in IPv6 traffic
           filter input exthdr frag missing

           # match if TCP timestamp option is present
           filter input tcp option timestamp exists

   <b>ICMP</b> <b>TYPE</b> <b>TYPE</b>
       ┌───────────┬───────────┬───────┬───────────┐
       │ <b>Name</b>      │ <b>Keyword</b>   │ <b>Size</b>  │ <b>Base</b> <b>type</b> │
       ├───────────┼───────────┼───────┼───────────┤
       │           │           │       │           │
       │ ICMP Type │ icmp_type │ 8 bit │ integer   │
       └───────────┴───────────┴───────┴───────────┘

       The ICMP Type type is used to conveniently specify the ICMP header’s type field.

       <b>Table</b> <b>19.</b> <b>Keywords</b> <b>may</b> <b>be</b> <b>used</b> <b>when</b> <b>specifying</b> <b>the</b> <b>ICMP</b> <b>type</b>
       ┌─────────────────────────┬───────┐
       │ <b>Keyword</b>                 │ <b>Value</b> │
       ├─────────────────────────┼───────┤
       │                         │       │
       │ echo-reply              │ 0     │
       ├─────────────────────────┼───────┤
       │                         │       │
       │ destination-unreachable │ 3     │
       ├─────────────────────────┼───────┤
       │                         │       │
       │ source-quench           │ 4     │
       ├─────────────────────────┼───────┤
       │                         │       │
       │ redirect                │ 5     │
       ├─────────────────────────┼───────┤
       │                         │       │
       │ echo-request            │ 8     │
       ├─────────────────────────┼───────┤
       │                         │       │
       │ router-advertisement    │ 9     │
       ├─────────────────────────┼───────┤
       │                         │       │
       │ router-solicitation     │ 10    │
       ├─────────────────────────┼───────┤
       │                         │       │
       │ time-exceeded           │ 11    │
       ├─────────────────────────┼───────┤
       │                         │       │
       │ parameter-problem       │ 12    │
       ├─────────────────────────┼───────┤
       │                         │       │
       │ timestamp-request       │ 13    │
       ├─────────────────────────┼───────┤
       │                         │       │
       │ timestamp-reply         │ 14    │
       ├─────────────────────────┼───────┤
       │                         │       │
       │ info-request            │ 15    │
       ├─────────────────────────┼───────┤
       │                         │       │
       │ info-reply              │ 16    │
       ├─────────────────────────┼───────┤
       │                         │       │
       │ address-mask-request    │ 17    │
       ├─────────────────────────┼───────┤
       │                         │       │
       │ address-mask-reply      │ 18    │
       └─────────────────────────┴───────┘

       <b>ICMP</b> <b>Type</b> <b>specification</b>.

           # match ping packets
           filter output icmp type { echo-request, echo-reply }

   <b>ICMP</b> <b>CODE</b> <b>TYPE</b>
       ┌───────────┬───────────┬───────┬───────────┐
       │ <b>Name</b>      │ <b>Keyword</b>   │ <b>Size</b>  │ <b>Base</b> <b>type</b> │
       ├───────────┼───────────┼───────┼───────────┤
       │           │           │       │           │
       │ ICMP Code │ icmp_code │ 8 bit │ integer   │
       └───────────┴───────────┴───────┴───────────┘

       The ICMP Code type is used to conveniently specify the ICMP header’s code field.

   <b>ICMPV6</b> <b>TYPE</b> <b>TYPE</b>
       ┌─────────────┬─────────────┬───────┬───────────┐
       │ <b>Name</b>        │ <b>Keyword</b>     │ <b>Size</b>  │ <b>Base</b> <b>type</b> │
       ├─────────────┼─────────────┼───────┼───────────┤
       │             │             │       │           │
       │ ICMPv6 Type │ icmpv6_type │ 8 bit │ integer   │
       └─────────────┴─────────────┴───────┴───────────┘

       The ICMPv6 Type type is used to conveniently specify the ICMPv6 header’s type field.

       <b>Table</b> <b>20.</b> <b>keywords</b> <b>may</b> <b>be</b> <b>used</b> <b>when</b> <b>specifying</b> <b>the</b> <b>ICMPv6</b> <b>type:</b>
       ┌─────────────────────────┬───────┐
       │ <b>Keyword</b>                 │ <b>Value</b> │
       ├─────────────────────────┼───────┤
       │                         │       │
       │ destination-unreachable │ 1     │
       ├─────────────────────────┼───────┤
       │                         │       │
       │ packet-too-big          │ 2     │
       ├─────────────────────────┼───────┤
       │                         │       │
       │ time-exceeded           │ 3     │
       ├─────────────────────────┼───────┤
       │                         │       │
       │ parameter-problem       │ 4     │
       ├─────────────────────────┼───────┤
       │                         │       │
       │ echo-request            │ 128   │
       ├─────────────────────────┼───────┤
       │                         │       │
       │ echo-reply              │ 129   │
       ├─────────────────────────┼───────┤
       │                         │       │
       │ mld-listener-query      │ 130   │
       ├─────────────────────────┼───────┤
       │                         │       │
       │ mld-listener-report     │ 131   │
       ├─────────────────────────┼───────┤
       │                         │       │
       │ mld-listener-done       │ 132   │
       ├─────────────────────────┼───────┤
       │                         │       │
       │ mld-listener-reduction  │ 132   │
       ├─────────────────────────┼───────┤
       │                         │       │
       │ nd-router-solicit       │ 133   │
       ├─────────────────────────┼───────┤
       │                         │       │
       │ nd-router-advert        │ 134   │
       ├─────────────────────────┼───────┤
       │                         │       │
       │ nd-neighbor-solicit     │ 135   │
       ├─────────────────────────┼───────┤
       │                         │       │
       │ nd-neighbor-advert      │ 136   │
       ├─────────────────────────┼───────┤
       │                         │       │
       │ nd-redirect             │ 137   │
       ├─────────────────────────┼───────┤
       │                         │       │
       │ router-renumbering      │ 138   │
       ├─────────────────────────┼───────┤
       │                         │       │
       │ ind-neighbor-solicit    │ 141   │
       ├─────────────────────────┼───────┤
       │                         │       │
       │ ind-neighbor-advert     │ 142   │
       ├─────────────────────────┼───────┤
       │                         │       │
       │ mld2-listener-report    │ 143   │
       └─────────────────────────┴───────┘

       <b>ICMPv6</b> <b>Type</b> <b>specification</b>.

           # match ICMPv6 ping packets
           filter output icmpv6 type { echo-request, echo-reply }

   <b>ICMPV6</b> <b>CODE</b> <b>TYPE</b>
       ┌─────────────┬─────────────┬───────┬───────────┐
       │ <b>Name</b>        │ <b>Keyword</b>     │ <b>Size</b>  │ <b>Base</b> <b>type</b> │
       ├─────────────┼─────────────┼───────┼───────────┤
       │             │             │       │           │
       │ ICMPv6 Code │ icmpv6_code │ 8 bit │ integer   │
       └─────────────┴─────────────┴───────┴───────────┘

       The ICMPv6 Code type is used to conveniently specify the ICMPv6 header’s code field.

   <b>CONNTRACK</b> <b>TYPES</b>
       <b>Table</b> <b>21.</b> <b>overview</b> <b>of</b> <b>types</b> <b>used</b> <b>in</b> <b>ct</b> <b>expression</b> <b>and</b> <b>statement</b>
       ┌──────────────────────┬───────────┬─────────┬───────────┐
       │ <b>Name</b>                 │ <b>Keyword</b>   │ <b>Size</b>    │ <b>Base</b> <b>type</b> │
       ├──────────────────────┼───────────┼─────────┼───────────┤
       │                      │           │         │           │
       │ conntrack state      │ ct_state  │ 4 byte  │ bitmask   │
       ├──────────────────────┼───────────┼─────────┼───────────┤
       │                      │           │         │           │
       │ conntrack direction  │ ct_dir    │ 8 bit   │ integer   │
       ├──────────────────────┼───────────┼─────────┼───────────┤
       │                      │           │         │           │
       │ conntrack status     │ ct_status │ 4 byte  │ bitmask   │
       ├──────────────────────┼───────────┼─────────┼───────────┤
       │                      │           │         │           │
       │ conntrack event bits │ ct_event  │ 4 byte  │ bitmask   │
       ├──────────────────────┼───────────┼─────────┼───────────┤
       │                      │           │         │           │
       │ conntrack label      │ ct_label  │ 128 bit │ bitmask   │
       └──────────────────────┴───────────┴─────────┴───────────┘

       For each of the types above, keywords are available for convenience:

       <b>Table</b> <b>22.</b> <b>conntrack</b> <b>state</b> <b>(ct_state)</b>
       ┌─────────────┬───────┐
       │ <b>Keyword</b>     │ <b>Value</b> │
       ├─────────────┼───────┤
       │             │       │
       │ invalid     │ 1     │
       ├─────────────┼───────┤
       │             │       │
       │ established │ 2     │
       ├─────────────┼───────┤
       │             │       │
       │ related     │ 4     │
       ├─────────────┼───────┤
       │             │       │
       │ new         │ 8     │
       ├─────────────┼───────┤
       │             │       │
       │ untracked   │ 64    │
       └─────────────┴───────┘

       <b>Table</b> <b>23.</b> <b>conntrack</b> <b>direction</b> <b>(ct_dir)</b>
       ┌──────────┬───────┐
       │ <b>Keyword</b>  │ <b>Value</b> │
       ├──────────┼───────┤
       │          │       │
       │ original │ 0     │
       ├──────────┼───────┤
       │          │       │
       │ reply    │ 1     │
       └──────────┴───────┘

       <b>Table</b> <b>24.</b> <b>conntrack</b> <b>status</b> <b>(ct_status)</b>
       ┌────────────┬───────┐
       │ <b>Keyword</b>    │ <b>Value</b> │
       ├────────────┼───────┤
       │            │       │
       │ expected   │ 1     │
       ├────────────┼───────┤
       │            │       │
       │ seen-reply │ 2     │
       ├────────────┼───────┤
       │            │       │
       │ assured    │ 4     │
       ├────────────┼───────┤
       │            │       │
       │ confirmed  │ 8     │
       ├────────────┼───────┤
       │            │       │
       │ snat       │ 16    │
       ├────────────┼───────┤
       │            │       │
       │ dnat       │ 32    │
       ├────────────┼───────┤
       │            │       │
       │ dying      │ 512   │
       └────────────┴───────┘

       <b>Table</b> <b>25.</b> <b>conntrack</b> <b>event</b> <b>bits</b> <b>(ct_event)</b>
       ┌───────────┬───────┐
       │ <b>Keyword</b>   │ <b>Value</b> │
       ├───────────┼───────┤
       │           │       │
       │ new       │ 1     │
       ├───────────┼───────┤
       │           │       │
       │ related   │ 2     │
       ├───────────┼───────┤
       │           │       │
       │ destroy   │ 4     │
       ├───────────┼───────┤
       │           │       │
       │ reply     │ 8     │
       ├───────────┼───────┤
       │           │       │
       │ assured   │ 16    │
       ├───────────┼───────┤
       │           │       │
       │ protoinfo │ 32    │
       ├───────────┼───────┤
       │           │       │
       │ helper    │ 64    │
       ├───────────┼───────┤
       │           │       │
       │ mark      │ 128   │
       ├───────────┼───────┤
       │           │       │
       │ seqadj    │ 256   │
       ├───────────┼───────┤
       │           │       │
       │ secmark   │ 512   │
       ├───────────┼───────┤
       │           │       │
       │ label     │ 1024  │
       └───────────┴───────┘

       Possible keywords for conntrack label type (ct_label) are read at runtime from /etc/connlabel.conf.

   <b>DCCP</b> <b>PKTTYPE</b> <b>TYPE</b>
       ┌──────────────────┬──────────────┬───────┬───────────┐
       │ <b>Name</b>             │ <b>Keyword</b>      │ <b>Size</b>  │ <b>Base</b> <b>type</b> │
       ├──────────────────┼──────────────┼───────┼───────────┤
       │                  │              │       │           │
       │ DCCP packet type │ dccp_pkttype │ 4 bit │ integer   │
       └──────────────────┴──────────────┴───────┴───────────┘

       The DCCP packet type abstracts the different legal values of the respective four bit field in the DCCP
       header, as stated by RFC4340. Note that possible values 10-15 are considered reserved and therefore not
       allowed to be used. In iptables' <b>dccp</b> match, these values are aliased <u>INVALID</u>. With nftables, one may
       simply match on the numeric value range, i.e. <b>10-15</b>.

       <b>Table</b> <b>26.</b> <b>keywords</b> <b>may</b> <b>be</b> <b>used</b> <b>when</b> <b>specifying</b> <b>the</b> <b>DCCP</b> <b>packet</b> <b>type</b>
       ┌──────────┬───────┐
       │ <b>Keyword</b>  │ <b>Value</b> │
       ├──────────┼───────┤
       │          │       │
       │ request  │ 0     │
       ├──────────┼───────┤
       │          │       │
       │ response │ 1     │
       ├──────────┼───────┤
       │          │       │
       │ data     │ 2     │
       ├──────────┼───────┤
       │          │       │
       │ ack      │ 3     │
       ├──────────┼───────┤
       │          │       │
       │ dataack  │ 4     │
       ├──────────┼───────┤
       │          │       │
       │ closereq │ 5     │
       ├──────────┼───────┤
       │          │       │
       │ close    │ 6     │
       ├──────────┼───────┤
       │          │       │
       │ reset    │ 7     │
       ├──────────┼───────┤
       │          │       │
       │ sync     │ 8     │
       ├──────────┼───────┤
       │          │       │
       │ syncack  │ 9     │
       └──────────┴───────┘

</pre><h4><b>PRIMARY</b> <b>EXPRESSIONS</b></h4><pre>
       The lowest order expression is a primary expression, representing either a constant or a single datum
       from a packet’s payload, meta data or a stateful module.

   <b>META</b> <b>EXPRESSIONS</b>
           <b>meta</b> {<b>length</b> | <b>nfproto</b> | <b>l4proto</b> | <b>protocol</b> | <b>priority</b>}
           [<b>meta</b>] {<b>mark</b> | <b>iif</b> | <b>iifname</b> | <b>iiftype</b> | <b>oif</b> | <b>oifname</b> | <b>oiftype</b> | <b>skuid</b> | <b>skgid</b> | <b>nftrace</b> | <b>rtclassid</b> | <b>ibrname</b> | <b>obrname</b> | <b>pkttype</b> | <b>cpu</b> | <b>iifgroup</b> | <b>oifgroup</b> | <b>cgroup</b> | <b>random</b> | <b>ipsec</b> | <b>iifkind</b> | <b>oifkind</b> | <b>time</b> | <b>hour</b> | <b>day</b> }

       A meta expression refers to meta data associated with a packet.

       There are two types of meta expressions: unqualified and qualified meta expressions. Qualified meta
       expressions require the meta keyword before the meta key, unqualified meta expressions can be specified
       by using the meta key directly or as qualified meta expressions. Meta l4proto is useful to match a
       particular transport protocol that is part of either an IPv4 or IPv6 packet. It will also skip any IPv6
       extension headers present in an IPv6 packet.

       meta iif, oif, iifname and oifname are used to match the interface a packet arrived on or is about to be
       sent out on.

       iif and oif are used to match on the interface index, whereas iifname and oifname are used to match on
       the interface name. This is not the same — assuming the rule

           filter input meta iif "foo"

       Then this rule can only be added if the interface "foo" exists. Also, the rule will continue to match
       even if the interface "foo" is renamed to "bar".

       This is because internally the interface index is used. In case of dynamically created interfaces, such
       as tun/tap or dialup interfaces (ppp for example), it might be better to use iifname or oifname instead.

       In these cases, the name is used so the interface doesn’t have to exist to add such a rule, it will stop
       matching if the interface gets renamed and it will match again in case interface gets deleted and later a
       new interface with the same name is created.

       Like with iptables, wildcard matching on interface name prefixes is available for <b>iifname</b> and <b>oifname</b>
       matches by appending an asterisk (*) character. Note however that unlike iptables, nftables does not
       accept interface names consisting of the wildcard character only - users are supposed to just skip those
       always matching expressions. In order to match on literal asterisk character, one may escape it using
       backslash (\).

       <b>Table</b> <b>27.</b> <b>Meta</b> <b>expression</b> <b>types</b>
       ┌───────────┬──────────────────────────────┬────────────────────────────┐
       │ <b>Keyword</b>   │ <b>Description</b>                  │ <b>Type</b>                       │
       ├───────────┼──────────────────────────────┼────────────────────────────┤
       │           │                              │                            │
       │ length    │ Length of the packet in      │ integer (32-bit)           │
       │           │ bytes                        │                            │
       ├───────────┼──────────────────────────────┼────────────────────────────┤
       │           │                              │                            │
       │ nfproto   │ real hook protocol family,   │ integer (32 bit)           │
       │           │ useful only in inet table    │                            │
       ├───────────┼──────────────────────────────┼────────────────────────────┤
       │           │                              │                            │
       │ l4proto   │ layer 4 protocol, skips ipv6 │ integer (8 bit)            │
       │           │ extension headers            │                            │
       ├───────────┼──────────────────────────────┼────────────────────────────┤
       │           │                              │                            │
       │ protocol  │ EtherType protocol value     │ ether_type                 │
       ├───────────┼──────────────────────────────┼────────────────────────────┤
       │           │                              │                            │
       │ priority  │ TC packet priority           │ tc_handle                  │
       ├───────────┼──────────────────────────────┼────────────────────────────┤
       │           │                              │                            │
       │ mark      │ Packet mark                  │ mark                       │
       ├───────────┼──────────────────────────────┼────────────────────────────┤
       │           │                              │                            │
       │ iif       │ Input interface index        │ iface_index                │
       ├───────────┼──────────────────────────────┼────────────────────────────┤
       │           │                              │                            │
       │ iifname   │ Input interface name         │ ifname                     │
       ├───────────┼──────────────────────────────┼────────────────────────────┤
       │           │                              │                            │
       │ iiftype   │ Input interface type         │ iface_type                 │
       ├───────────┼──────────────────────────────┼────────────────────────────┤
       │           │                              │                            │
       │ oif       │ Output interface index       │ iface_index                │
       ├───────────┼──────────────────────────────┼────────────────────────────┤
       │           │                              │                            │
       │ oifname   │ Output interface name        │ ifname                     │
       ├───────────┼──────────────────────────────┼────────────────────────────┤
       │           │                              │                            │
       │ oiftype   │ Output interface hardware    │ iface_type                 │
       │           │ type                         │                            │
       ├───────────┼──────────────────────────────┼────────────────────────────┤
       │           │                              │                            │
       │ sdif      │ Slave device input interface │ iface_index                │
       │           │ index                        │                            │
       ├───────────┼──────────────────────────────┼────────────────────────────┤
       │           │                              │                            │
       │ sdifname  │ Slave device interface name  │ ifname                     │
       ├───────────┼──────────────────────────────┼────────────────────────────┤
       │           │                              │                            │
       │ skuid     │ UID associated with          │ uid                        │
       │           │ originating socket           │                            │
       ├───────────┼──────────────────────────────┼────────────────────────────┤
       │           │                              │                            │
       │ skgid     │ GID associated with          │ gid                        │
       │           │ originating socket           │                            │
       ├───────────┼──────────────────────────────┼────────────────────────────┤
       │           │                              │                            │
       │ rtclassid │ Routing realm                │ realm                      │
       ├───────────┼──────────────────────────────┼────────────────────────────┤
       │           │                              │                            │
       │ ibrname   │ Input bridge interface name  │ ifname                     │
       ├───────────┼──────────────────────────────┼────────────────────────────┤
       │           │                              │                            │
       │ obrname   │ Output bridge interface name │ ifname                     │
       ├───────────┼──────────────────────────────┼────────────────────────────┤
       │           │                              │                            │
       │ pkttype   │ packet type                  │ pkt_type                   │
       ├───────────┼──────────────────────────────┼────────────────────────────┤
       │           │                              │                            │
       │ cpu       │ cpu number processing the    │ integer (32 bit)           │
       │           │ packet                       │                            │
       ├───────────┼──────────────────────────────┼────────────────────────────┤
       │           │                              │                            │
       │ iifgroup  │ incoming device group        │ devgroup                   │
       ├───────────┼──────────────────────────────┼────────────────────────────┤
       │           │                              │                            │
       │ oifgroup  │ outgoing device group        │ devgroup                   │
       ├───────────┼──────────────────────────────┼────────────────────────────┤
       │           │                              │                            │
       │ cgroup    │ control group id             │ integer (32 bit)           │
       ├───────────┼──────────────────────────────┼────────────────────────────┤
       │           │                              │                            │
       │ random    │ pseudo-random number         │ integer (32 bit)           │
       ├───────────┼──────────────────────────────┼────────────────────────────┤
       │           │                              │                            │
       │ ipsec     │ true if packet was ipsec     │ boolean (1 bit)            │
       │           │ encrypted                    │                            │
       ├───────────┼──────────────────────────────┼────────────────────────────┤
       │           │                              │                            │
       │ iifkind   │ Input interface kind         │                            │
       ├───────────┼──────────────────────────────┼────────────────────────────┤
       │           │                              │                            │
       │ oifkind   │ Output interface kind        │                            │
       ├───────────┼──────────────────────────────┼────────────────────────────┤
       │           │                              │                            │
       │ time      │ Absolute time of packet      │ Integer (32 bit) or string │
       │           │ reception                    │                            │
       ├───────────┼──────────────────────────────┼────────────────────────────┤
       │           │                              │                            │
       │ day       │ Day of week                  │ Integer (8 bit) or string  │
       ├───────────┼──────────────────────────────┼────────────────────────────┤
       │           │                              │                            │
       │ hour      │ Hour of day                  │ String                     │
       └───────────┴──────────────────────────────┴────────────────────────────┘

       <b>Table</b> <b>28.</b> <b>Meta</b> <b>expression</b> <b>specific</b> <b>types</b>
       ┌───────────────┬───────────────────────────────────────┐
       │ <b>Type</b>          │ <b>Description</b>                           │
       ├───────────────┼───────────────────────────────────────┤
       │               │                                       │
       │ iface_index   │ Interface index (32 bit number). Can  │
       │               │ be specified numerically or as name   │
       │               │ of an existing interface.             │
       ├───────────────┼───────────────────────────────────────┤
       │               │                                       │
       │ ifname        │ Interface name (16 byte string). Does │
       │               │ not have to exist.                    │
       ├───────────────┼───────────────────────────────────────┤
       │               │                                       │
       │ iface_type    │ Interface type (16 bit number).       │
       ├───────────────┼───────────────────────────────────────┤
       │               │                                       │
       │ uid           │ User ID (32 bit number). Can be       │
       │               │ specified numerically or as user      │
       │               │ name.                                 │
       ├───────────────┼───────────────────────────────────────┤
       │               │                                       │
       │ gid           │ Group ID (32 bit number). Can be      │
       │               │ specified numerically or as group     │
       │               │ name.                                 │
       ├───────────────┼───────────────────────────────────────┤
       │               │                                       │
       │ realm         │ Routing Realm (32 bit number). Can be │
       │               │ specified numerically or as symbolic  │
       │               │ name defined in                       │
       │               │ /etc/iproute2/rt_realms.              │
       ├───────────────┼───────────────────────────────────────┤
       │               │                                       │
       │ devgroup_type │ Device group (32 bit number). Can be  │
       │               │ specified numerically or as symbolic  │
       │               │ name defined in /etc/iproute2/group.  │
       ├───────────────┼───────────────────────────────────────┤
       │               │                                       │
       │ pkt_type      │ Packet type: <b>host</b> (addressed to local │
       │               │ host), <b>broadcast</b> (to all), <b>multicast</b>  │
       │               │ (to group), <b>other</b> (addressed to       │
       │               │ another host).                        │
       ├───────────────┼───────────────────────────────────────┤
       │               │                                       │
       │ ifkind        │ Interface kind (16 byte string). See  │
       │               │ TYPES in <a href="../man8/ip-link.8.html">ip-link</a>(8) for a list.       │
       ├───────────────┼───────────────────────────────────────┤
       │               │                                       │
       │ time          │ Either an integer or a date in ISO    │
       │               │ format. For example: "2019-06-06      │
       │               │ 17:00". Hour and seconds are optional │
       │               │ and can be omitted if desired. If     │
       │               │ omitted, midnight will be assumed.    │
       │               │ The following three would be          │
       │               │ equivalent: "2019-06-06", "2019-06-06 │
       │               │ 00:00" and "2019-06-06 00:00:00". Use │
       │               │ a range expression such as            │
       │               │ "2019-06-06 10:00"-"2019-06-10 14:00" │
       │               │ for matching a time range. When an    │
       │               │ integer is given, it is assumed to be │
       │               │ a UNIX timestamp.                     │
       ├───────────────┼───────────────────────────────────────┤
       │               │                                       │
       │ day           │ Either a day of week ("Monday",       │
       │               │ "Tuesday", etc.), or an integer       │
       │               │ between 0 and 6. Strings are matched  │
       │               │ case-insensitively, and a full match  │
       │               │ is not expected (e.g. "Mon" would     │
       │               │ match "Monday"). When an integer is   │
       │               │ given, 0 is Sunday and 6 is Saturday. │
       │               │ Use a range expression such as        │
       │               │ "Monday"-"Wednesday" for matching a   │
       │               │ week day range.                       │
       ├───────────────┼───────────────────────────────────────┤
       │               │                                       │
       │ hour          │ A string representing an hour in      │
       │               │ 24-hour format. Seconds can           │
       │               │ optionally be specified. For example, │
       │               │ 17:00 and 17:00:00 would be           │
       │               │ equivalent. Use a range expression    │
       │               │ such as "17:00"-"19:00" for matching  │
       │               │ a time range.                         │
       └───────────────┴───────────────────────────────────────┘

       <b>Using</b> <b>meta</b> <b>expressions</b>.

           # qualified meta expression
           filter output meta oif eth0
           filter forward meta iifkind { "tun", "veth" }

           # unqualified meta expression
           filter output oif eth0

           # incoming packet was subject to ipsec processing
           raw prerouting meta ipsec exists accept

           # match incoming packet from 03:00 to 14:00 local time
           raw prerouting meta hour "03:00"-"14:00" counter accept

   <b>SOCKET</b> <b>EXPRESSION</b>
           <b>socket</b> {<b>transparent</b> | <b>mark</b> | <b>wildcard</b>}
           <b>socket</b> <b>cgroupv2</b> <b>level</b> <u>NUM</u>

       Socket expression can be used to search for an existing open TCP/UDP socket and its attributes that can
       be associated with a packet. It looks for an established or non-zero bound listening socket (possibly
       with a non-local address). You can also use it to match on the socket cgroupv2 at a given ancestor level,
       e.g. if the socket belongs to cgroupv2 <u>a/b</u>, ancestor level 1 checks for a matching on cgroup <u>a</u> and
       ancestor level 2 checks for a matching on cgroup <u>b</u>.

       <b>Table</b> <b>29.</b> <b>Available</b> <b>socket</b> <b>attributes</b>
       ┌─────────────┬──────────────────────────────┬─────────────────┐
       │ <b>Name</b>        │ <b>Description</b>                  │ <b>Type</b>            │
       ├─────────────┼──────────────────────────────┼─────────────────┤
       │             │                              │                 │
       │ transparent │ Value of the IP_TRANSPARENT  │ boolean (1 bit) │
       │             │ socket option in the found   │                 │
       │             │ socket. It can be 0 or 1.    │                 │
       ├─────────────┼──────────────────────────────┼─────────────────┤
       │             │                              │                 │
       │ mark        │ Value of the socket mark     │ mark            │
       │             │ (SOL_SOCKET, SO_MARK).       │                 │
       ├─────────────┼──────────────────────────────┼─────────────────┤
       │             │                              │                 │
       │ wildcard    │ Indicates whether the socket │ boolean (1 bit) │
       │             │ is wildcard-bound (e.g.      │                 │
       │             │ 0.0.0.0 or ::0).             │                 │
       ├─────────────┼──────────────────────────────┼─────────────────┤
       │             │                              │                 │
       │ cgroupv2    │ cgroup version 2 for this    │ cgroupv2        │
       │             │ socket (path from            │                 │
       │             │ <a href="file:/sys/fs/cgroup">/sys/fs/cgroup</a>)              │                 │
       └─────────────┴──────────────────────────────┴─────────────────┘

       <b>Using</b> <b>socket</b> <b>expression</b>.

           # Mark packets that correspond to a transparent socket. "socket wildcard 0"
           # means that zero-bound listener sockets are NOT matched (which is usually
           # exactly what you want).
           table inet x {
               chain y {
                   type filter hook prerouting priority mangle; policy accept;
                   socket transparent 1 socket wildcard 0 mark set 0x00000001 accept
               }
           }

           # Trace packets that corresponds to a socket with a mark value of 15
           table inet x {
               chain y {
                   type filter hook prerouting priority mangle; policy accept;
                   socket mark 0x0000000f nftrace set 1
               }
           }

           # Set packet mark to socket mark
           table inet x {
               chain y {
                   type filter hook prerouting priority mangle; policy accept;
                   tcp dport 8080 mark set socket mark
               }
           }

           # Count packets for cgroupv2 "user.slice" at level 1
           table inet x {
               chain y {
                   type filter hook input priority filter; policy accept;
                   socket cgroupv2 level 1 "user.slice" counter
               }
           }

   <b>OSF</b> <b>EXPRESSION</b>
           <b>osf</b> [<b>ttl</b> {<b>loose</b> | <b>skip</b>}] {<b>name</b> | <b>version</b>}

       The osf expression does passive operating system fingerprinting. This expression compares some data
       (Window Size, MSS, options and their order, DF, and others) from packets with the SYN bit set.

       <b>Table</b> <b>30.</b> <b>Available</b> <b>osf</b> <b>attributes</b>
       ┌─────────┬──────────────────────────────┬────────┐
       │ <b>Name</b>    │ <b>Description</b>                  │ <b>Type</b>   │
       ├─────────┼──────────────────────────────┼────────┤
       │         │                              │        │
       │ ttl     │ Do TTL checks on the packet  │ string │
       │         │ to determine the operating   │        │
       │         │ system.                      │        │
       ├─────────┼──────────────────────────────┼────────┤
       │         │                              │        │
       │ version │ Do OS version checks on the  │        │
       │         │ packet.                      │        │
       ├─────────┼──────────────────────────────┼────────┤
       │         │                              │        │
       │ name    │ Name of the OS signature to  │ string │
       │         │ match. All signatures can be │        │
       │         │ found at pf.os file. Use     │        │
       │         │ "unknown" for OS signatures  │        │
       │         │ that the expression could    │        │
       │         │ not detect.                  │        │
       └─────────┴──────────────────────────────┴────────┘

       <b>Available</b> <b>ttl</b> <b>values</b>.

           If no TTL attribute is passed, make a true IP header and fingerprint TTL true comparison. This generally works for LANs.

           * loose: Check if the IP header's TTL is less than the fingerprint one. Works for globally-routable addresses.
           * skip: Do not compare the TTL at all.

       <b>Using</b> <b>osf</b> <b>expression</b>.

           # Accept packets that match the "Linux" OS genre signature without comparing TTL.
           table inet x {
               chain y {
                   type filter hook input priority filter; policy accept;
                   osf ttl skip name "Linux"
               }
           }

   <b>FIB</b> <b>EXPRESSIONS</b>
           <b>fib</b> <u>FIB_TUPLE</u> <u>FIB_RESULT</u>
           <u>FIB_TUPLE</u> := { <b>saddr</b> | <b>daddr</b>} [ <b>.</b> { <b>iif</b> | <b>oif</b> } <b>.</b> <b>mark</b> ]
           <u>FIB_RESULT</u>  := { <b>oif</b> | <b>oifname</b> | <b>type</b> }

       A fib expression queries the fib (forwarding information base) to obtain information such as the output
       interface index.

       The first arguments to the <b>fib</b> expression are the input keys to be passed to the fib lookup function. One
       of <b>saddr</b> or <b>daddr</b> is mandatory, they are also mutually exclusive.

       <b>mark</b>, <b>iif</b> and <b>oif</b> keywords are optional modifiers to influence the search result, see the <b>FIB_TUPLE</b>
       keyword table below for a description. The <b>iif</b> and <b>oif</b> tuple keywords are also mutually exclusive.

       The last argument to the <b>fib</b> expression is the desired result type.

       <b>oif</b> asks to obtain the interface index that would be used to send packets to the packets source (<b>saddr</b>
       key) or destination (<b>daddr</b> key). If no routing entry is found, the returned interface index is 0.

       <b>oifname</b> is like <b>oif</b>, but it fills the interface name instead. This is useful to check dynamic interfaces
       such as ppp devices. If no entry is found, an empty interface name is returned.

       <b>type</b> returns the address type such as unicast or multicast. A complete list of supported address types
       can be shown with <b>nft</b> <b>describe</b> <b>fib_addrtype</b>.

       <b>Table</b> <b>31.</b> <b>FIB_TUPLE</b> <b>keywords</b>
       ┌───────┬───────────────────────────────────────┐
       │ <b>flag</b>  │ <b>Description</b>                           │
       ├───────┼───────────────────────────────────────┤
       │       │                                       │
       │ daddr │ Perform a normal route lookup: search │
       │       │ fib for route to the <b>destination</b>      │
       │       │ <b>address</b> of the packet.                │
       ├───────┼───────────────────────────────────────┤
       │       │                                       │
       │ saddr │ Perform a reverse route lookup:       │
       │       │ search the fib for route to the       │
       │       │ <b>source</b> <b>address</b> of the packet.         │
       ├───────┼───────────────────────────────────────┤
       │       │                                       │
       │ mark  │ consider the packet mark (nfmark)     │
       │       │ when querying the fib.                │
       ├───────┼───────────────────────────────────────┤
       │       │                                       │
       │ iif   │ if fib lookups provides a route then  │
       │       │ check its output interface is         │
       │       │ identical to the packets <b>input</b>        │
       │       │ interface.                            │
       ├───────┼───────────────────────────────────────┤
       │       │                                       │
       │ oif   │ if fib lookups provides a route then  │
       │       │ check its output interface is         │
       │       │ identical to the packets <b>output</b>       │
       │       │ interface. This flag can only be used │
       │       │ with the <b>type</b> result.                 │
       └───────┴───────────────────────────────────────┘

       <b>Table</b> <b>32.</b> <b>FIB_RESULT</b> <b>keywords</b>
       ┌─────────┬────────────────────────┬─────────────────────────────┐
       │ <b>Keyword</b> │ <b>Description</b>            │ <b>Result</b> <b>Type</b>                 │
       ├─────────┼────────────────────────┼─────────────────────────────┤
       │         │                        │                             │
       │ oif     │ Output interface index │ iface_index                 │
       ├─────────┼────────────────────────┼─────────────────────────────┤
       │         │                        │                             │
       │ oifname │ Output interface name  │ ifname                      │
       ├─────────┼────────────────────────┼─────────────────────────────┤
       │         │                        │                             │
       │ type    │ Address type           │ fib_addrtype (see <b>nft</b>       │
       │         │                        │ <b>describe</b> <b>fib_addrtype</b> for a │
       │         │                        │ list)                       │
       └─────────┴────────────────────────┴─────────────────────────────┘

       The <b>oif</b> and <b>oifname</b> result is only valid in the <b>prerouting</b>, <b>input</b> and <b>forward</b> hooks. The <b>type</b> can be
       queried from any one of <b>prerouting</b>, <b>input</b>, <b>forward</b> <b>output</b> and <b>postrouting</b>.

       For <b>type</b>, the presence of the <b>iif</b> keyword in the <u>FIB_TUPLE</u> modifiers restrict the available hooks to
       those where the packet is associated with an incoming interface, i.e. <b>prerouting</b>, <b>input</b> and <b>forward</b>.
       Likewise, the <b>oif</b> keyword in the <u>FIB_TUPLE</u> modifier list will limit the available hooks to <b>forward</b>,
       <b>output</b> and <b>postrouting</b>.

       <b>Using</b> <b>fib</b> <b>expressions</b>.

           # drop packets without a reverse path
           filter prerouting fib saddr . iif oif missing drop

           In this example, 'saddr . iif' looks up a route to the *source address* of the packet and restricts matching
           results to the interface that the packet arrived on, then stores the output interface index from the obtained
           fib route result.

           If no route was found for the source address/input interface combination, the output interface index is zero.
           Hence, this rule will drop all packets that do not have a strict reverse path (hypothetical reply packet
           would be sent via the interface the tested packet arrived on).

           If only 'saddr oif' is used as the input key, then this rule would only drop packets where the fib cannot
           find a route. In most setups this will never drop packets because the default route is returned.

           # drop packets if the destination ip address is not configured on the incoming interface
           filter prerouting fib daddr . iif type != { local, broadcast, multicast } drop

           This queries the fib based on the current packets' destination address and the incoming interface.

           If the packet is sent to a unicast address that is configured on a different interface, then the packet
           will be dropped as such an address would be classified as 'unicast' type.
           Without the 'iif' modifier, any address configured on the local machine is 'local', and unicast addresses
           not configured on any interface would return the type 'unicast'.

           # perform lookup in a specific 'blackhole' table (0xdead, needs ip appropriate ip rule)
           filter prerouting meta mark set 0xdead fib daddr . mark type vmap { blackhole : drop, prohibit : jump prohibited, unreachable : drop }

   <b>ROUTING</b> <b>EXPRESSIONS</b>
           <b>rt</b> [<b>ip</b> | <b>ip6</b>] {<b>classid</b> | <b>nexthop</b> | <b>mtu</b> | <b>ipsec</b>}

       A routing expression refers to routing data associated with a packet.

       <b>Table</b> <b>33.</b> <b>Routing</b> <b>expression</b> <b>types</b>
       ┌─────────┬─────────────────────────────┬─────────────────────┐
       │ <b>Keyword</b> │ <b>Description</b>                 │ <b>Type</b>                │
       ├─────────┼─────────────────────────────┼─────────────────────┤
       │         │                             │                     │
       │ classid │ Routing realm               │ realm               │
       ├─────────┼─────────────────────────────┼─────────────────────┤
       │         │                             │                     │
       │ nexthop │ Routing nexthop             │ ipv4_addr/ipv6_addr │
       ├─────────┼─────────────────────────────┼─────────────────────┤
       │         │                             │                     │
       │ mtu     │ TCP maximum segment size of │ integer (16 bit)    │
       │         │ route                       │                     │
       ├─────────┼─────────────────────────────┼─────────────────────┤
       │         │                             │                     │
       │ ipsec   │ route via ipsec tunnel or   │ boolean             │
       │         │ transport                   │                     │
       └─────────┴─────────────────────────────┴─────────────────────┘

       <b>Table</b> <b>34.</b> <b>Routing</b> <b>expression</b> <b>specific</b> <b>types</b>
       ┌───────┬───────────────────────────────────────┐
       │ <b>Type</b>  │ <b>Description</b>                           │
       ├───────┼───────────────────────────────────────┤
       │       │                                       │
       │ realm │ Routing Realm (32 bit number). Can be │
       │       │ specified numerically or as symbolic  │
       │       │ name defined in                       │
       │       │ /etc/iproute2/rt_realms.              │
       └───────┴───────────────────────────────────────┘

       <b>Using</b> <b>routing</b> <b>expressions</b>.

           # IP family independent rt expression
           filter output rt classid 10

           # IP family dependent rt expressions
           ip filter output rt nexthop 192.168.0.1
           ip6 filter output rt nexthop fd00::1
           inet filter output rt ip nexthop 192.168.0.1
           inet filter output rt ip6 nexthop fd00::1

           # outgoing packet will be encapsulated/encrypted by ipsec
           filter output rt ipsec exists

   <b>IPSEC</b> <b>EXPRESSIONS</b>
           <b>ipsec</b> {<b>in</b> | <b>out</b>} [ <b>spnum</b> <u>NUM</u> ]  {<b>reqid</b> | <b>spi</b>}
           <b>ipsec</b> {<b>in</b> | <b>out</b>} [ <b>spnum</b> <u>NUM</u> ]  {<b>ip</b> | <b>ip6</b>} {<b>saddr</b> | <b>daddr</b>}

       An ipsec expression refers to ipsec data associated with a packet.

       The <u>in</u> or <u>out</u> keyword needs to be used to specify if the expression should examine inbound or outbound
       policies. The <u>in</u> keyword can be used in the prerouting, input and forward hooks. The <u>out</u> keyword applies
       to forward, output and postrouting hooks. The optional keyword spnum can be used to match a specific
       state in a chain, it defaults to 0.

       <b>Table</b> <b>35.</b> <b>Ipsec</b> <b>expression</b> <b>types</b>
       ┌─────────┬──────────────────────────────┬─────────────────────┐
       │ <b>Keyword</b> │ <b>Description</b>                  │ <b>Type</b>                │
       ├─────────┼──────────────────────────────┼─────────────────────┤
       │         │                              │                     │
       │ reqid   │ Request ID                   │ integer (32 bit)    │
       ├─────────┼──────────────────────────────┼─────────────────────┤
       │         │                              │                     │
       │ spi     │ Security Parameter Index     │ integer (32 bit)    │
       ├─────────┼──────────────────────────────┼─────────────────────┤
       │         │                              │                     │
       │ saddr   │ Source address of the tunnel │ ipv4_addr/ipv6_addr │
       ├─────────┼──────────────────────────────┼─────────────────────┤
       │         │                              │                     │
       │ daddr   │ Destination address of the   │ ipv4_addr/ipv6_addr │
       │         │ tunnel                       │                     │
       └─────────┴──────────────────────────────┴─────────────────────┘

       <b>Note:</b> When using xfrm_interface, this expression is not useable in output hook as the plain packet does
       not traverse it with IPsec info attached - use a chain in postrouting hook instead.

   <b>NUMGEN</b> <b>EXPRESSION</b>
           <b>numgen</b> {<b>inc</b> | <b>random</b>} <b>mod</b> <u>NUM</u> [ <b>offset</b> <u>NUM</u> ]

       Create a number generator. The <b>inc</b> or <b>random</b> keywords control its operation mode: In <b>inc</b> mode, the last
       returned value is simply incremented. In <b>random</b> mode, a new random number is returned. The value after
       <b>mod</b> keyword specifies an upper boundary (read: modulus) which is not reached by returned numbers. The
       optional <b>offset</b> allows one to increment the returned value by a fixed offset.

       A typical use-case for <b>numgen</b> is load-balancing:

       <b>Using</b> <b>numgen</b> <b>expression</b>.

           # round-robin between 192.168.10.100 and 192.168.20.200:
           add rule nat prerouting dnat to numgen inc mod 2 map \
                   { 0 : 192.168.10.100, 1 : 192.168.20.200 }

           # probability-based with odd bias using intervals:
           add rule nat prerouting dnat to numgen random mod 10 map \
                   { 0-2 : 192.168.10.100, 3-9 : 192.168.20.200 }

   <b>HASH</b> <b>EXPRESSIONS</b>
           <b>jhash</b> {<b>ip</b> <b>saddr</b> | <b>ip6</b> <b>daddr</b> | <b>tcp</b> <b>dport</b> | <b>udp</b> <b>sport</b> | <b>ether</b> <b>saddr</b>} [<b>.</b> ...] <b>mod</b> <u>NUM</u> [ <b>seed</b> <u>NUM</u> ] [ <b>offset</b> <u>NUM</u> ]
           <b>symhash</b> <b>mod</b> <u>NUM</u> [ <b>offset</b> <u>NUM</u> ]

       Use a hashing function to generate a number. The functions available are <b>jhash</b>, known as Jenkins Hash,
       and <b>symhash</b>, for Symmetric Hash. The <b>jhash</b> requires an expression to determine the parameters of the
       packet header to apply the hashing, concatenations are possible as well. The value after <b>mod</b> keyword
       specifies an upper boundary (read: modulus) which is not reached by returned numbers. The optional <b>seed</b>
       is used to specify an init value used as seed in the hashing function. The optional <b>offset</b> allows one to
       increment the returned value by a fixed offset.

       A typical use-case for <b>jhash</b> and <b>symhash</b> is load-balancing:

       <b>Using</b> <b>hash</b> <b>expressions</b>.

           # load balance based on source ip between 2 ip addresses:
           add rule nat prerouting dnat to jhash ip saddr mod 2 map \
                   { 0 : 192.168.10.100, 1 : 192.168.20.200 }

           # symmetric load balancing between 2 ip addresses:
           add rule nat prerouting dnat to symhash mod 2 map \
                   { 0 : 192.168.10.100, 1 : 192.168.20.200 }

</pre><h4><b>PAYLOAD</b> <b>EXPRESSIONS</b></h4><pre>
       Payload expressions refer to data from the packet’s payload.

   <b>ETHERNET</b> <b>HEADER</b> <b>EXPRESSION</b>
           <b>ether</b> {<b>daddr</b> | <b>saddr</b> | <b>type</b>}

       <b>Table</b> <b>36.</b> <b>Ethernet</b> <b>header</b> <b>expression</b> <b>types</b>
       ┌─────────┬─────────────────────────┬────────────┐
       │ <b>Keyword</b> │ <b>Description</b>             │ <b>Type</b>       │
       ├─────────┼─────────────────────────┼────────────┤
       │         │                         │            │
       │ daddr   │ Destination MAC address │ ether_addr │
       ├─────────┼─────────────────────────┼────────────┤
       │         │                         │            │
       │ saddr   │ Source MAC address      │ ether_addr │
       ├─────────┼─────────────────────────┼────────────┤
       │         │                         │            │
       │ type    │ EtherType               │ ether_type │
       └─────────┴─────────────────────────┴────────────┘

   <b>VLAN</b> <b>HEADER</b> <b>EXPRESSION</b>
           <b>vlan</b> {<b>id</b> | <b>dei</b> | <b>pcp</b> | <b>type</b>}

       The vlan expression is used to match on the vlan header fields. This expression will not work in the <b>ip</b>,
       <b>ip6</b> and <b>inet</b> families, unless the vlan interface is configured with the <b>reorder_hdr</b> <b>off</b> setting. The
       default is <b>reorder_hdr</b> <b>on</b> which will automatically remove the vlan tag from the packet. See <a href="../man8/ip-link.8.html">ip-link</a>(8)
       for more information. For these families its easier to match the vlan interface name instead, using the
       <b>meta</b> <b>iif</b> or <b>meta</b> <b>iifname</b> expression.

       <b>Table</b> <b>37.</b> <b>VLAN</b> <b>header</b> <b>expression</b>
       ┌─────────┬─────────────────────────┬──────────────────┐
       │ <b>Keyword</b> │ <b>Description</b>             │ <b>Type</b>             │
       ├─────────┼─────────────────────────┼──────────────────┤
       │         │                         │                  │
       │ id      │ VLAN ID (VID)           │ integer (12 bit) │
       ├─────────┼─────────────────────────┼──────────────────┤
       │         │                         │                  │
       │ dei     │ Drop Eligible Indicator │ integer (1 bit)  │
       ├─────────┼─────────────────────────┼──────────────────┤
       │         │                         │                  │
       │ pcp     │ Priority code point     │ integer (3 bit)  │
       ├─────────┼─────────────────────────┼──────────────────┤
       │         │                         │                  │
       │ type    │ EtherType               │ ether_type       │
       └─────────┴─────────────────────────┴──────────────────┘

   <b>ARP</b> <b>HEADER</b> <b>EXPRESSION</b>
           <b>arp</b> {<b>htype</b> | <b>ptype</b> | <b>hlen</b> | <b>plen</b> | <b>operation</b> | <b>saddr</b> { <b>ip</b> | <b>ether</b> } | <b>daddr</b> { <b>ip</b> | <b>ether</b> }

       <b>Table</b> <b>38.</b> <b>ARP</b> <b>header</b> <b>expression</b>
       ┌─────────────┬─────────────────────────┬──────────────────┐
       │ <b>Keyword</b>     │ <b>Description</b>             │ <b>Type</b>             │
       ├─────────────┼─────────────────────────┼──────────────────┤
       │             │                         │                  │
       │ htype       │ ARP hardware type       │ integer (16 bit) │
       ├─────────────┼─────────────────────────┼──────────────────┤
       │             │                         │                  │
       │ ptype       │ EtherType               │ ether_type       │
       ├─────────────┼─────────────────────────┼──────────────────┤
       │             │                         │                  │
       │ hlen        │ Hardware address len    │ integer (8 bit)  │
       ├─────────────┼─────────────────────────┼──────────────────┤
       │             │                         │                  │
       │ plen        │ Protocol address len    │ integer (8 bit)  │
       ├─────────────┼─────────────────────────┼──────────────────┤
       │             │                         │                  │
       │ operation   │ Operation               │ arp_op           │
       ├─────────────┼─────────────────────────┼──────────────────┤
       │             │                         │                  │
       │ saddr ether │ Ethernet sender address │ ether_addr       │
       ├─────────────┼─────────────────────────┼──────────────────┤
       │             │                         │                  │
       │ daddr ether │ Ethernet target address │ ether_addr       │
       ├─────────────┼─────────────────────────┼──────────────────┤
       │             │                         │                  │
       │ saddr ip    │ IPv4 sender address     │ ipv4_addr        │
       ├─────────────┼─────────────────────────┼──────────────────┤
       │             │                         │                  │
       │ daddr ip    │ IPv4 target address     │ ipv4_addr        │
       └─────────────┴─────────────────────────┴──────────────────┘

   <b>IPV4</b> <b>HEADER</b> <b>EXPRESSION</b>
           <b>ip</b> {<b>version</b> | <b>hdrlength</b> | <b>dscp</b> | <b>ecn</b> | <b>length</b> | <b>id</b> | <b>frag-off</b> | <b>ttl</b> | <b>protocol</b> | <b>checksum</b> | <b>saddr</b> | <b>daddr</b> }

       <b>Table</b> <b>39.</b> <b>IPv4</b> <b>header</b> <b>expression</b>
       ┌───────────┬──────────────────────────────┬───────────────────────┐
       │ <b>Keyword</b>   │ <b>Description</b>                  │ <b>Type</b>                  │
       ├───────────┼──────────────────────────────┼───────────────────────┤
       │           │                              │                       │
       │ version   │ IP header version (4)        │ integer (4 bit)       │
       ├───────────┼──────────────────────────────┼───────────────────────┤
       │           │                              │                       │
       │ hdrlength │ IP header length including   │ integer (4 bit) FIXME │
       │           │ options                      │ scaling               │
       ├───────────┼──────────────────────────────┼───────────────────────┤
       │           │                              │                       │
       │ dscp      │ Differentiated Services Code │ dscp                  │
       │           │ Point                        │                       │
       ├───────────┼──────────────────────────────┼───────────────────────┤
       │           │                              │                       │
       │ ecn       │ Explicit Congestion          │ ecn                   │
       │           │ Notification                 │                       │
       ├───────────┼──────────────────────────────┼───────────────────────┤
       │           │                              │                       │
       │ length    │ Total packet length          │ integer (16 bit)      │
       ├───────────┼──────────────────────────────┼───────────────────────┤
       │           │                              │                       │
       │ id        │ IP ID                        │ integer (16 bit)      │
       ├───────────┼──────────────────────────────┼───────────────────────┤
       │           │                              │                       │
       │ frag-off  │ Fragment offset              │ integer (16 bit)      │
       ├───────────┼──────────────────────────────┼───────────────────────┤
       │           │                              │                       │
       │ ttl       │ Time to live                 │ integer (8 bit)       │
       ├───────────┼──────────────────────────────┼───────────────────────┤
       │           │                              │                       │
       │ protocol  │ Upper layer protocol         │ inet_proto            │
       ├───────────┼──────────────────────────────┼───────────────────────┤
       │           │                              │                       │
       │ checksum  │ IP header checksum           │ integer (16 bit)      │
       ├───────────┼──────────────────────────────┼───────────────────────┤
       │           │                              │                       │
       │ saddr     │ Source address               │ ipv4_addr             │
       ├───────────┼──────────────────────────────┼───────────────────────┤
       │           │                              │                       │
       │ daddr     │ Destination address          │ ipv4_addr             │
       └───────────┴──────────────────────────────┴───────────────────────┘

       Careful with matching on <b>ip</b> <b>length</b>: If GRO/GSO is enabled, then the Linux kernel might aggregate several
       packets into one big packet that is larger than MTU. Moreover, if GRO/GSO maximum size is larger than
       65535 (see man <a href="../man8/ip-link.8.html">ip-link</a>(8), specifically gro_ipv6_max_size and gso_ipv6_max_size), then <b>ip</b> <b>length</b> might be
       0 for such jumbo packets. <b>meta</b> <b>length</b> allows you to match on the packet length including the IP header
       size. If you want to perform heuristics on the <b>ip</b> <b>length</b> field, then disable GRO/GSO.

   <b>ICMP</b> <b>HEADER</b> <b>EXPRESSION</b>
           <b>icmp</b> {<b>type</b> | <b>code</b> | <b>checksum</b> | <b>id</b> | <b>sequence</b> | <b>gateway</b> | <b>mtu</b>}

       This expression refers to ICMP header fields. When using it in <b>inet</b>, <b>bridge</b> or <b>netdev</b> families, it will
       cause an implicit dependency on IPv4 to be created. To match on unusual cases like ICMP over IPv6, one
       has to add an explicit <b>meta</b> <b>protocol</b> <b>ip6</b> match to the rule.

       <b>Table</b> <b>40.</b> <b>ICMP</b> <b>header</b> <b>expression</b>
       ┌──────────┬─────────────────────────────┬──────────────────┐
       │ <b>Keyword</b>  │ <b>Description</b>                 │ <b>Type</b>             │
       ├──────────┼─────────────────────────────┼──────────────────┤
       │          │                             │                  │
       │ type     │ ICMP type field             │ icmp_type        │
       ├──────────┼─────────────────────────────┼──────────────────┤
       │          │                             │                  │
       │ code     │ ICMP code field             │ integer (8 bit)  │
       ├──────────┼─────────────────────────────┼──────────────────┤
       │          │                             │                  │
       │ checksum │ ICMP checksum field         │ integer (16 bit) │
       ├──────────┼─────────────────────────────┼──────────────────┤
       │          │                             │                  │
       │ id       │ ID of echo request/response │ integer (16 bit) │
       ├──────────┼─────────────────────────────┼──────────────────┤
       │          │                             │                  │
       │ sequence │ sequence number of echo     │ integer (16 bit) │
       │          │ request/response            │                  │
       ├──────────┼─────────────────────────────┼──────────────────┤
       │          │                             │                  │
       │ gateway  │ gateway of redirects        │ integer (32 bit) │
       ├──────────┼─────────────────────────────┼──────────────────┤
       │          │                             │                  │
       │ mtu      │ MTU of path MTU discovery   │ integer (16 bit) │
       └──────────┴─────────────────────────────┴──────────────────┘

   <b>IGMP</b> <b>HEADER</b> <b>EXPRESSION</b>
           <b>igmp</b> {<b>type</b> | <b>mrt</b> | <b>checksum</b> | <b>group</b>}

       This expression refers to IGMP header fields. When using it in <b>inet</b>, <b>bridge</b> or <b>netdev</b> families, it will
       cause an implicit dependency on IPv4 to be created. To match on unusual cases like IGMP over IPv6, one
       has to add an explicit <b>meta</b> <b>protocol</b> <b>ip6</b> match to the rule.

       <b>Table</b> <b>41.</b> <b>IGMP</b> <b>header</b> <b>expression</b>
       ┌──────────┬────────────────────────────┬──────────────────┐
       │ <b>Keyword</b>  │ <b>Description</b>                │ <b>Type</b>             │
       ├──────────┼────────────────────────────┼──────────────────┤
       │          │                            │                  │
       │ type     │ IGMP type field            │ igmp_type        │
       ├──────────┼────────────────────────────┼──────────────────┤
       │          │                            │                  │
       │ mrt      │ IGMP maximum response time │ integer (8 bit)  │
       │          │ field                      │                  │
       ├──────────┼────────────────────────────┼──────────────────┤
       │          │                            │                  │
       │ checksum │ IGMP checksum field        │ integer (16 bit) │
       ├──────────┼────────────────────────────┼──────────────────┤
       │          │                            │                  │
       │ group    │ Group address              │ integer (32 bit) │
       └──────────┴────────────────────────────┴──────────────────┘

   <b>IPV6</b> <b>HEADER</b> <b>EXPRESSION</b>
           <b>ip6</b> {<b>version</b> | <b>dscp</b> | <b>ecn</b> | <b>flowlabel</b> | <b>length</b> | <b>nexthdr</b> | <b>hoplimit</b> | <b>saddr</b> | <b>daddr</b>}

       This expression refers to the ipv6 header fields. Caution when using <b>ip6</b> <b>nexthdr</b>, the value only refers
       to the next header, i.e. <b>ip6</b> <b>nexthdr</b> <b>tcp</b> will only match if the ipv6 packet does not contain any
       extension headers. Packets that are fragmented or e.g. contain a routing extension headers will not be
       matched. Please use <b>meta</b> <b>l4proto</b> if you wish to match the real transport header and ignore any additional
       extension headers instead.

       <b>Table</b> <b>42.</b> <b>IPv6</b> <b>header</b> <b>expression</b>
       ┌───────────┬──────────────────────────────┬──────────────────┐
       │ <b>Keyword</b>   │ <b>Description</b>                  │ <b>Type</b>             │
       ├───────────┼──────────────────────────────┼──────────────────┤
       │           │                              │                  │
       │ version   │ IP header version (6)        │ integer (4 bit)  │
       ├───────────┼──────────────────────────────┼──────────────────┤
       │           │                              │                  │
       │ dscp      │ Differentiated Services Code │ dscp             │
       │           │ Point                        │                  │
       ├───────────┼──────────────────────────────┼──────────────────┤
       │           │                              │                  │
       │ ecn       │ Explicit Congestion          │ ecn              │
       │           │ Notification                 │                  │
       ├───────────┼──────────────────────────────┼──────────────────┤
       │           │                              │                  │
       │ flowlabel │ Flow label                   │ integer (20 bit) │
       ├───────────┼──────────────────────────────┼──────────────────┤
       │           │                              │                  │
       │ length    │ Payload length               │ integer (16 bit) │
       ├───────────┼──────────────────────────────┼──────────────────┤
       │           │                              │                  │
       │ nexthdr   │ Nexthdr protocol             │ inet_proto       │
       ├───────────┼──────────────────────────────┼──────────────────┤
       │           │                              │                  │
       │ hoplimit  │ Hop limit                    │ integer (8 bit)  │
       ├───────────┼──────────────────────────────┼──────────────────┤
       │           │                              │                  │
       │ saddr     │ Source address               │ ipv6_addr        │
       ├───────────┼──────────────────────────────┼──────────────────┤
       │           │                              │                  │
       │ daddr     │ Destination address          │ ipv6_addr        │
       └───────────┴──────────────────────────────┴──────────────────┘

       Careful with matching on <b>ip6</b> <b>length</b>: If GRO/GSO is enabled, then the Linux kernel might aggregate several
       packets into one big packet that is larger than MTU. Moreover, if GRO/GSO maximum size is larger than
       65535 (see man <a href="../man8/ip-link.8.html">ip-link</a>(8), specifically gro_ipv6_max_size and gso_ipv6_max_size), then <b>ip6</b> <b>length</b> might
       be 0 for such jumbo packets. <b>meta</b> <b>length</b> allows you to match on the packet length including the IP header
       size. If you want to perform heuristics on the <b>ip6</b> <b>length</b> field, then disable GRO/GSO.

       <b>Using</b> <b>ip6</b> <b>header</b> <b>expressions</b>.

           # matching if first extension header indicates a fragment
           ip6 nexthdr ipv6-frag

   <b>ICMPV6</b> <b>HEADER</b> <b>EXPRESSION</b>
           <b>icmpv6</b> {<b>type</b> | <b>code</b> | <b>checksum</b> | <b>parameter-problem</b> | <b>packet-too-big</b> | <b>id</b> | <b>sequence</b> | <b>max-delay</b> | <b>taddr</b> | <b>daddr</b>}

       This expression refers to ICMPv6 header fields. When using it in <b>inet</b>, <b>bridge</b> or <b>netdev</b> families, it will
       cause an implicit dependency on IPv6 to be created. To match on unusual cases like ICMPv6 over IPv4, one
       has to add an explicit <b>meta</b> <b>protocol</b> <b>ip</b> match to the rule.

       <b>Table</b> <b>43.</b> <b>ICMPv6</b> <b>header</b> <b>expression</b>
       ┌───────────────────┬─────────────────────────────┬──────────────────┐
       │ <b>Keyword</b>           │ <b>Description</b>                 │ <b>Type</b>             │
       ├───────────────────┼─────────────────────────────┼──────────────────┤
       │                   │                             │                  │
       │ type              │ ICMPv6 type field           │ icmpv6_type      │
       ├───────────────────┼─────────────────────────────┼──────────────────┤
       │                   │                             │                  │
       │ code              │ ICMPv6 code field           │ integer (8 bit)  │
       ├───────────────────┼─────────────────────────────┼──────────────────┤
       │                   │                             │                  │
       │ checksum          │ ICMPv6 checksum field       │ integer (16 bit) │
       ├───────────────────┼─────────────────────────────┼──────────────────┤
       │                   │                             │                  │
       │ parameter-problem │ pointer to problem          │ integer (32 bit) │
       ├───────────────────┼─────────────────────────────┼──────────────────┤
       │                   │                             │                  │
       │ packet-too-big    │ oversized MTU               │ integer (32 bit) │
       ├───────────────────┼─────────────────────────────┼──────────────────┤
       │                   │                             │                  │
       │ id                │ ID of echo request/response │ integer (16 bit) │
       ├───────────────────┼─────────────────────────────┼──────────────────┤
       │                   │                             │                  │
       │ sequence          │ sequence number of echo     │ integer (16 bit) │
       │                   │ request/response            │                  │
       ├───────────────────┼─────────────────────────────┼──────────────────┤
       │                   │                             │                  │
       │ max-delay         │ maximum response delay of   │ integer (16 bit) │
       │                   │ MLD queries                 │                  │
       ├───────────────────┼─────────────────────────────┼──────────────────┤
       │                   │                             │                  │
       │ taddr             │ target address of neighbor  │ ipv6_addr        │
       │                   │ solicit/advert, redirect or │                  │
       │                   │ MLD                         │                  │
       ├───────────────────┼─────────────────────────────┼──────────────────┤
       │                   │                             │                  │
       │ daddr             │ destination address of      │ ipv6_addr        │
       │                   │ redirect                    │                  │
       └───────────────────┴─────────────────────────────┴──────────────────┘

   <b>TCP</b> <b>HEADER</b> <b>EXPRESSION</b>
           <b>tcp</b> {<b>sport</b> | <b>dport</b> | <b>sequence</b> | <b>ackseq</b> | <b>doff</b> | <b>reserved</b> | <b>flags</b> | <b>window</b> | <b>checksum</b> | <b>urgptr</b>}

       <b>Table</b> <b>44.</b> <b>TCP</b> <b>header</b> <b>expression</b>
       ┌──────────┬────────────────────────┬───────────────────────┐
       │ <b>Keyword</b>  │ <b>Description</b>            │ <b>Type</b>                  │
       ├──────────┼────────────────────────┼───────────────────────┤
       │          │                        │                       │
       │ sport    │ Source port            │ inet_service          │
       ├──────────┼────────────────────────┼───────────────────────┤
       │          │                        │                       │
       │ dport    │ Destination port       │ inet_service          │
       ├──────────┼────────────────────────┼───────────────────────┤
       │          │                        │                       │
       │ sequence │ Sequence number        │ integer (32 bit)      │
       ├──────────┼────────────────────────┼───────────────────────┤
       │          │                        │                       │
       │ ackseq   │ Acknowledgement number │ integer (32 bit)      │
       ├──────────┼────────────────────────┼───────────────────────┤
       │          │                        │                       │
       │ doff     │ Data offset            │ integer (4 bit) FIXME │
       │          │                        │ scaling               │
       ├──────────┼────────────────────────┼───────────────────────┤
       │          │                        │                       │
       │ reserved │ Reserved area          │ integer (4 bit)       │
       ├──────────┼────────────────────────┼───────────────────────┤
       │          │                        │                       │
       │ flags    │ TCP flags              │ tcp_flag              │
       ├──────────┼────────────────────────┼───────────────────────┤
       │          │                        │                       │
       │ window   │ Window                 │ integer (16 bit)      │
       ├──────────┼────────────────────────┼───────────────────────┤
       │          │                        │                       │
       │ checksum │ Checksum               │ integer (16 bit)      │
       ├──────────┼────────────────────────┼───────────────────────┤
       │          │                        │                       │
       │ urgptr   │ Urgent pointer         │ integer (16 bit)      │
       └──────────┴────────────────────────┴───────────────────────┘

   <b>UDP</b> <b>HEADER</b> <b>EXPRESSION</b>
           <b>udp</b> {<b>sport</b> | <b>dport</b> | <b>length</b> | <b>checksum</b>}

       <b>Table</b> <b>45.</b> <b>UDP</b> <b>header</b> <b>expression</b>
       ┌──────────┬─────────────────────┬──────────────────┐
       │ <b>Keyword</b>  │ <b>Description</b>         │ <b>Type</b>             │
       ├──────────┼─────────────────────┼──────────────────┤
       │          │                     │                  │
       │ sport    │ Source port         │ inet_service     │
       ├──────────┼─────────────────────┼──────────────────┤
       │          │                     │                  │
       │ dport    │ Destination port    │ inet_service     │
       ├──────────┼─────────────────────┼──────────────────┤
       │          │                     │                  │
       │ length   │ Total packet length │ integer (16 bit) │
       ├──────────┼─────────────────────┼──────────────────┤
       │          │                     │                  │
       │ checksum │ Checksum            │ integer (16 bit) │
       └──────────┴─────────────────────┴──────────────────┘

   <b>UDP-LITE</b> <b>HEADER</b> <b>EXPRESSION</b>
           <b>udplite</b> {<b>sport</b> | <b>dport</b> | <b>checksum</b>}

       <b>Table</b> <b>46.</b> <b>UDP-Lite</b> <b>header</b> <b>expression</b>
       ┌──────────┬──────────────────┬──────────────────┐
       │ <b>Keyword</b>  │ <b>Description</b>      │ <b>Type</b>             │
       ├──────────┼──────────────────┼──────────────────┤
       │          │                  │                  │
       │ sport    │ Source port      │ inet_service     │
       ├──────────┼──────────────────┼──────────────────┤
       │          │                  │                  │
       │ dport    │ Destination port │ inet_service     │
       ├──────────┼──────────────────┼──────────────────┤
       │          │                  │                  │
       │ checksum │ Checksum         │ integer (16 bit) │
       └──────────┴──────────────────┴──────────────────┘

   <b>SCTP</b> <b>HEADER</b> <b>EXPRESSION</b>
           <b>sctp</b> {<b>sport</b> | <b>dport</b> | <b>vtag</b> | <b>checksum</b>}
           <b>sctp</b> <b>chunk</b> <u>CHUNK</u> [ <u>FIELD</u> ]

           <u>CHUNK</u> := <b>data</b> | <b>init</b> | <b>init-ack</b> | <b>sack</b> | <b>heartbeat</b> |
                      <b>heartbeat-ack</b> | <b>abort</b> | <b>shutdown</b> | <b>shutdown-ack</b> | <b>error</b> |
                      <b>cookie-echo</b> | <b>cookie-ack</b> | <b>ecne</b> | <b>cwr</b> | <b>shutdown-complete</b>
                      | <b>asconf-ack</b> | <b>forward-tsn</b> | <b>asconf</b>

           <u>FIELD</u> := <u>COMMON_FIELD</u> | <u>DATA_FIELD</u> | <u>INIT_FIELD</u> | <u>INIT_ACK_FIELD</u> |
                      <u>SACK_FIELD</u> | <u>SHUTDOWN_FIELD</u> | <u>ECNE_FIELD</u> | <u>CWR_FIELD</u> |
                      <u>ASCONF_ACK_FIELD</u> | <u>FORWARD_TSN_FIELD</u> | <u>ASCONF_FIELD</u>

           <u>COMMON_FIELD</u> := <b>type</b> | <b>flags</b> | <b>length</b>
           <u>DATA_FIELD</u> := <b>tsn</b> | <b>stream</b> | <b>ssn</b> | <b>ppid</b>
           <u>INIT_FIELD</u> := <b>init-tag</b> | <b>a-rwnd</b> | <b>num-outbound-streams</b> |
                           <b>num-inbound-streams</b> | <b>initial-tsn</b>
           <u>INIT_ACK_FIELD</u> := <u>INIT_FIELD</u>
           <u>SACK_FIELD</u> := <b>cum-tsn-ack</b> | <b>a-rwnd</b> | <b>num-gap-ack-blocks</b> |
                           <b>num-dup-tsns</b>
           <u>SHUTDOWN_FIELD</u> := <b>cum-tsn-ack</b>
           <u>ECNE_FIELD</u> := <b>lowest-tsn</b>
           <u>CWR_FIELD</u> := <b>lowest-tsn</b>
           <u>ASCONF_ACK_FIELD</u> := <b>seqno</b>
           <u>FORWARD_TSN_FIELD</u> := <b>new-cum-tsn</b>
           <u>ASCONF_FIELD</u> := <b>seqno</b>

       <b>Table</b> <b>47.</b> <b>SCTP</b> <b>header</b> <b>expression</b>
       ┌──────────┬────────────────────────┬────────────────────────┐
       │ <b>Keyword</b>  │ <b>Description</b>            │ <b>Type</b>                   │
       ├──────────┼────────────────────────┼────────────────────────┤
       │          │                        │                        │
       │ sport    │ Source port            │ inet_service           │
       ├──────────┼────────────────────────┼────────────────────────┤
       │          │                        │                        │
       │ dport    │ Destination port       │ inet_service           │
       ├──────────┼────────────────────────┼────────────────────────┤
       │          │                        │                        │
       │ vtag     │ Verification Tag       │ integer (32 bit)       │
       ├──────────┼────────────────────────┼────────────────────────┤
       │          │                        │                        │
       │ checksum │ Checksum               │ integer (32 bit)       │
       ├──────────┼────────────────────────┼────────────────────────┤
       │          │                        │                        │
       │ chunk    │ Search chunk in packet │ without <u>FIELD</u>, boolean │
       │          │                        │ indicating existence   │
       └──────────┴────────────────────────┴────────────────────────┘

       <b>Table</b> <b>48.</b> <b>SCTP</b> <b>chunk</b> <b>fields</b>
       ┌──────────────────────┬───────────────┬──────────────────────┬────────────────────────┐
       │ <b>Name</b>                 │ <b>Width</b> <b>in</b> <b>bits</b> │ <b>Chunk</b>                │ <b>Notes</b>                  │
       ├──────────────────────┼───────────────┼──────────────────────┼────────────────────────┤
       │                      │               │                      │                        │
       │ type                 │ 8             │ all                  │ not useful, defined by │
       │                      │               │                      │ chunk type             │
       ├──────────────────────┼───────────────┼──────────────────────┼────────────────────────┤
       │                      │               │                      │                        │
       │ flags                │ 8             │ all                  │ semantics defined on   │
       │                      │               │                      │ per-chunk basis        │
       ├──────────────────────┼───────────────┼──────────────────────┼────────────────────────┤
       │                      │               │                      │                        │
       │ length               │ 16            │ all                  │ length of this chunk   │
       │                      │               │                      │ in bytes excluding     │
       │                      │               │                      │ padding                │
       ├──────────────────────┼───────────────┼──────────────────────┼────────────────────────┤
       │                      │               │                      │                        │
       │ tsn                  │ 32            │ data                 │ transmission sequence  │
       │                      │               │                      │ number                 │
       ├──────────────────────┼───────────────┼──────────────────────┼────────────────────────┤
       │                      │               │                      │                        │
       │ stream               │ 16            │ data                 │ stream identifier      │
       ├──────────────────────┼───────────────┼──────────────────────┼────────────────────────┤
       │                      │               │                      │                        │
       │ ssn                  │ 16            │ data                 │ stream sequence number │
       ├──────────────────────┼───────────────┼──────────────────────┼────────────────────────┤
       │                      │               │                      │                        │
       │ ppid                 │ 32            │ data                 │ payload protocol       │
       │                      │               │                      │ identifier             │
       ├──────────────────────┼───────────────┼──────────────────────┼────────────────────────┤
       │                      │               │                      │                        │
       │ init-tag             │ 32            │ init, init-ack       │ initiate tag           │
       ├──────────────────────┼───────────────┼──────────────────────┼────────────────────────┤
       │                      │               │                      │                        │
       │ a-rwnd               │ 32            │ init, init-ack, sack │ advertised receiver    │
       │                      │               │                      │ window credit          │
       ├──────────────────────┼───────────────┼──────────────────────┼────────────────────────┤
       │                      │               │                      │                        │
       │ num-outbound-streams │ 16            │ init, init-ack       │ number of outbound     │
       │                      │               │                      │ streams                │
       ├──────────────────────┼───────────────┼──────────────────────┼────────────────────────┤
       │                      │               │                      │                        │
       │ num-inbound-streams  │ 16            │ init, init-ack       │ number of inbound      │
       │                      │               │                      │ streams                │
       ├──────────────────────┼───────────────┼──────────────────────┼────────────────────────┤
       │                      │               │                      │                        │
       │ initial-tsn          │ 32            │ init, init-ack       │ initial transmit       │
       │                      │               │                      │ sequence number        │
       ├──────────────────────┼───────────────┼──────────────────────┼────────────────────────┤
       │                      │               │                      │                        │
       │ cum-tsn-ack          │ 32            │ sack, shutdown       │ cumulative             │
       │                      │               │                      │ transmission sequence  │
       │                      │               │                      │ number acknowledged    │
       ├──────────────────────┼───────────────┼──────────────────────┼────────────────────────┤
       │                      │               │                      │                        │
       │ num-gap-ack-blocks   │ 16            │ sack                 │ number of Gap Ack      │
       │                      │               │                      │ Blocks included        │
       ├──────────────────────┼───────────────┼──────────────────────┼────────────────────────┤
       │                      │               │                      │                        │
       │ num-dup-tsns         │ 16            │ sack                 │ number of duplicate    │
       │                      │               │                      │ transmission sequence  │
       │                      │               │                      │ numbers received       │
       ├──────────────────────┼───────────────┼──────────────────────┼────────────────────────┤
       │                      │               │                      │                        │
       │ lowest-tsn           │ 32            │ ecne, cwr            │ lowest transmission    │
       │                      │               │                      │ sequence number        │
       ├──────────────────────┼───────────────┼──────────────────────┼────────────────────────┤
       │                      │               │                      │                        │
       │ seqno                │ 32            │ asconf-ack, asconf   │ sequence number        │
       ├──────────────────────┼───────────────┼──────────────────────┼────────────────────────┤
       │                      │               │                      │                        │
       │ new-cum-tsn          │ 32            │ forward-tsn          │ new cumulative         │
       │                      │               │                      │ transmission sequence  │
       │                      │               │                      │ number                 │
       └──────────────────────┴───────────────┴──────────────────────┴────────────────────────┘

   <b>DCCP</b> <b>HEADER</b> <b>EXPRESSION</b>
           <b>dccp</b> {<b>sport</b> | <b>dport</b> | <b>type</b>}

       <b>Table</b> <b>49.</b> <b>DCCP</b> <b>header</b> <b>expression</b>
       ┌─────────┬──────────────────┬──────────────┐
       │ <b>Keyword</b> │ <b>Description</b>      │ <b>Type</b>         │
       ├─────────┼──────────────────┼──────────────┤
       │         │                  │              │
       │ sport   │ Source port      │ inet_service │
       ├─────────┼──────────────────┼──────────────┤
       │         │                  │              │
       │ dport   │ Destination port │ inet_service │
       ├─────────┼──────────────────┼──────────────┤
       │         │                  │              │
       │ type    │ Packet type      │ dccp_pkttype │
       └─────────┴──────────────────┴──────────────┘

   <b>AUTHENTICATION</b> <b>HEADER</b> <b>EXPRESSION</b>
           <b>ah</b> {<b>nexthdr</b> | <b>hdrlength</b> | <b>reserved</b> | <b>spi</b> | <b>sequence</b>}

       <b>Table</b> <b>50.</b> <b>AH</b> <b>header</b> <b>expression</b>
       ┌───────────┬──────────────────────────┬──────────────────┐
       │ <b>Keyword</b>   │ <b>Description</b>              │ <b>Type</b>             │
       ├───────────┼──────────────────────────┼──────────────────┤
       │           │                          │                  │
       │ nexthdr   │ Next header protocol     │ inet_proto       │
       ├───────────┼──────────────────────────┼──────────────────┤
       │           │                          │                  │
       │ hdrlength │ AH Header length         │ integer (8 bit)  │
       ├───────────┼──────────────────────────┼──────────────────┤
       │           │                          │                  │
       │ reserved  │ Reserved area            │ integer (16 bit) │
       ├───────────┼──────────────────────────┼──────────────────┤
       │           │                          │                  │
       │ spi       │ Security Parameter Index │ integer (32 bit) │
       ├───────────┼──────────────────────────┼──────────────────┤
       │           │                          │                  │
       │ sequence  │ Sequence number          │ integer (32 bit) │
       └───────────┴──────────────────────────┴──────────────────┘

   <b>ENCRYPTED</b> <b>SECURITY</b> <b>PAYLOAD</b> <b>HEADER</b> <b>EXPRESSION</b>
           <b>esp</b> {<b>spi</b> | <b>sequence</b>}

       <b>Table</b> <b>51.</b> <b>ESP</b> <b>header</b> <b>expression</b>
       ┌──────────┬──────────────────────────┬──────────────────┐
       │ <b>Keyword</b>  │ <b>Description</b>              │ <b>Type</b>             │
       ├──────────┼──────────────────────────┼──────────────────┤
       │          │                          │                  │
       │ spi      │ Security Parameter Index │ integer (32 bit) │
       ├──────────┼──────────────────────────┼──────────────────┤
       │          │                          │                  │
       │ sequence │ Sequence number          │ integer (32 bit) │
       └──────────┴──────────────────────────┴──────────────────┘

   <b>IPCOMP</b> <b>HEADER</b> <b>EXPRESSION</b>
       <b>comp</b> {<b>nexthdr</b> | <b>flags</b> | <b>cpi</b>}

       <b>Table</b> <b>52.</b> <b>IPComp</b> <b>header</b> <b>expression</b>
       ┌─────────┬─────────────────────────────┬──────────────────┐
       │ <b>Keyword</b> │ <b>Description</b>                 │ <b>Type</b>             │
       ├─────────┼─────────────────────────────┼──────────────────┤
       │         │                             │                  │
       │ nexthdr │ Next header protocol        │ inet_proto       │
       ├─────────┼─────────────────────────────┼──────────────────┤
       │         │                             │                  │
       │ flags   │ Flags                       │ bitmask          │
       ├─────────┼─────────────────────────────┼──────────────────┤
       │         │                             │                  │
       │ cpi     │ compression Parameter Index │ integer (16 bit) │
       └─────────┴─────────────────────────────┴──────────────────┘

   <b>GRE</b> <b>HEADER</b> <b>EXPRESSION</b>
           <b>gre</b> {<b>flags</b> | <b>version</b> | <b>protocol</b>}
           <b>gre</b> <b>ip</b> {<b>version</b> | <b>hdrlength</b> | <b>dscp</b> | <b>ecn</b> | <b>length</b> | <b>id</b> | <b>frag-off</b> | <b>ttl</b> | <b>protocol</b> | <b>checksum</b> | <b>saddr</b> | <b>daddr</b> }
           <b>gre</b> <b>ip6</b> {<b>version</b> | <b>dscp</b> | <b>ecn</b> | <b>flowlabel</b> | <b>length</b> | <b>nexthdr</b> | <b>hoplimit</b> | <b>saddr</b> | <b>daddr</b>}

       The gre expression is used to match on the gre header fields. This expression also allows to match on the
       IPv4 or IPv6 packet within the gre header.

       <b>Table</b> <b>53.</b> <b>GRE</b> <b>header</b> <b>expression</b>
       ┌──────────┬──────────────────────────────┬──────────────────┐
       │ <b>Keyword</b>  │ <b>Description</b>                  │ <b>Type</b>             │
       ├──────────┼──────────────────────────────┼──────────────────┤
       │          │                              │                  │
       │ flags    │ checksum, routing, key,      │ integer (5 bit)  │
       │          │ sequence and strict source   │                  │
       │          │ route flags                  │                  │
       ├──────────┼──────────────────────────────┼──────────────────┤
       │          │                              │                  │
       │ version  │ gre version field, 0 for GRE │ integer (3 bit)  │
       │          │ and 1 for PPTP               │                  │
       ├──────────┼──────────────────────────────┼──────────────────┤
       │          │                              │                  │
       │ protocol │ EtherType of encapsulated    │ integer (16 bit) │
       │          │ packet                       │                  │
       └──────────┴──────────────────────────────┴──────────────────┘

       <b>Matching</b> <b>inner</b> <b>IPv4</b> <b>destination</b> <b>address</b> <b>encapsulated</b> <b>in</b> <b>gre</b>.

           netdev filter ingress gre ip daddr 9.9.9.9 counter

   <b>GENEVE</b> <b>HEADER</b> <b>EXPRESSION</b>
           <b>geneve</b> {<b>vni</b> | <b>flags</b>}
           <b>geneve</b> <b>ether</b> {<b>daddr</b> | <b>saddr</b> | <b>type</b>}
           <b>geneve</b> <b>vlan</b> {<b>id</b> | <b>dei</b> | <b>pcp</b> | <b>type</b>}
           <b>geneve</b> <b>ip</b> {<b>version</b> | <b>hdrlength</b> | <b>dscp</b> | <b>ecn</b> | <b>length</b> | <b>id</b> | <b>frag-off</b> | <b>ttl</b> | <b>protocol</b> | <b>checksum</b> | <b>saddr</b> | <b>daddr</b> }
           <b>geneve</b> <b>ip6</b> {<b>version</b> | <b>dscp</b> | <b>ecn</b> | <b>flowlabel</b> | <b>length</b> | <b>nexthdr</b> | <b>hoplimit</b> | <b>saddr</b> | <b>daddr</b>}
           <b>geneve</b> <b>tcp</b> {<b>sport</b> | <b>dport</b> | <b>sequence</b> | <b>ackseq</b> | <b>doff</b> | <b>reserved</b> | <b>flags</b> | <b>window</b> | <b>checksum</b> | <b>urgptr</b>}
           <b>geneve</b> <b>udp</b> {<b>sport</b> | <b>dport</b> | <b>length</b> | <b>checksum</b>}

       The geneve expression is used to match on the geneve header fields. The geneve header encapsulates a
       ethernet frame within a <b>udp</b> packet. This expression requires that you restrict the matching to <b>udp</b>
       packets (usually at port 6081 according to IANA-assigned ports).

       <b>Table</b> <b>54.</b> <b>GENEVE</b> <b>header</b> <b>expression</b>
       ┌──────────┬───────────────────────────┬──────────────────┐
       │ <b>Keyword</b>  │ <b>Description</b>               │ <b>Type</b>             │
       ├──────────┼───────────────────────────┼──────────────────┤
       │          │                           │                  │
       │ protocol │ EtherType of encapsulated │ integer (16 bit) │
       │          │ packet                    │                  │
       ├──────────┼───────────────────────────┼──────────────────┤
       │          │                           │                  │
       │ vni      │ Virtual Network ID (VNI)  │ integer (24 bit) │
       └──────────┴───────────────────────────┴──────────────────┘

       <b>Matching</b> <b>inner</b> <b>TCP</b> <b>destination</b> <b>port</b> <b>encapsulated</b> <b>in</b> <b>geneve</b>.

           netdev filter ingress udp dport 4789 geneve tcp dport 80 counter

   <b>GRETAP</b> <b>HEADER</b> <b>EXPRESSION</b>
           <b>gretap</b> {<b>vni</b> | <b>flags</b>}
           <b>gretap</b> <b>ether</b> {<b>daddr</b> | <b>saddr</b> | <b>type</b>}
           <b>gretap</b> <b>vlan</b> {<b>id</b> | <b>dei</b> | <b>pcp</b> | <b>type</b>}
           <b>gretap</b> <b>ip</b> {<b>version</b> | <b>hdrlength</b> | <b>dscp</b> | <b>ecn</b> | <b>length</b> | <b>id</b> | <b>frag-off</b> | <b>ttl</b> | <b>protocol</b> | <b>checksum</b> | <b>saddr</b> | <b>daddr</b> }
           <b>gretap</b> <b>ip6</b> {<b>version</b> | <b>dscp</b> | <b>ecn</b> | <b>flowlabel</b> | <b>length</b> | <b>nexthdr</b> | <b>hoplimit</b> | <b>saddr</b> | <b>daddr</b>}
           <b>gretap</b> <b>tcp</b> {<b>sport</b> | <b>dport</b> | <b>sequence</b> | <b>ackseq</b> | <b>doff</b> | <b>reserved</b> | <b>flags</b> | <b>window</b> | <b>checksum</b> | <b>urgptr</b>}
           <b>gretap</b> <b>udp</b> {<b>sport</b> | <b>dport</b> | <b>length</b> | <b>checksum</b>}

       The gretap expression is used to match on the encapsulated ethernet frame within the gre header. Use the
       <b>gre</b> expression to match on the <b>gre</b> header fields.

       <b>Matching</b> <b>inner</b> <b>TCP</b> <b>destination</b> <b>port</b> <b>encapsulated</b> <b>in</b> <b>gretap</b>.

           netdev filter ingress gretap tcp dport 80 counter

   <b>VXLAN</b> <b>HEADER</b> <b>EXPRESSION</b>
           <b>vxlan</b> {<b>vni</b> | <b>flags</b>}
           <b>vxlan</b> <b>ether</b> {<b>daddr</b> | <b>saddr</b> | <b>type</b>}
           <b>vxlan</b> <b>vlan</b> {<b>id</b> | <b>dei</b> | <b>pcp</b> | <b>type</b>}
           <b>vxlan</b> <b>ip</b> {<b>version</b> | <b>hdrlength</b> | <b>dscp</b> | <b>ecn</b> | <b>length</b> | <b>id</b> | <b>frag-off</b> | <b>ttl</b> | <b>protocol</b> | <b>checksum</b> | <b>saddr</b> | <b>daddr</b> }
           <b>vxlan</b> <b>ip6</b> {<b>version</b> | <b>dscp</b> | <b>ecn</b> | <b>flowlabel</b> | <b>length</b> | <b>nexthdr</b> | <b>hoplimit</b> | <b>saddr</b> | <b>daddr</b>}
           <b>vxlan</b> <b>tcp</b> {<b>sport</b> | <b>dport</b> | <b>sequence</b> | <b>ackseq</b> | <b>doff</b> | <b>reserved</b> | <b>flags</b> | <b>window</b> | <b>checksum</b> | <b>urgptr</b>}
           <b>vxlan</b> <b>udp</b> {<b>sport</b> | <b>dport</b> | <b>length</b> | <b>checksum</b>}

       The vxlan expression is used to match on the vxlan header fields. The vxlan header encapsulates a
       ethernet frame within a <b>udp</b> packet. This expression requires that you restrict the matching to <b>udp</b>
       packets (usually at port 4789 according to IANA-assigned ports).

       <b>Table</b> <b>55.</b> <b>VXLAN</b> <b>header</b> <b>expression</b>
       ┌─────────┬──────────────────────────┬──────────────────┐
       │ <b>Keyword</b> │ <b>Description</b>              │ <b>Type</b>             │
       ├─────────┼──────────────────────────┼──────────────────┤
       │         │                          │                  │
       │ flags   │ vxlan flags              │ integer (8 bit)  │
       ├─────────┼──────────────────────────┼──────────────────┤
       │         │                          │                  │
       │ vni     │ Virtual Network ID (VNI) │ integer (24 bit) │
       └─────────┴──────────────────────────┴──────────────────┘

       <b>Matching</b> <b>inner</b> <b>TCP</b> <b>destination</b> <b>port</b> <b>encapsulated</b> <b>in</b> <b>vxlan</b>.

           netdev filter ingress udp dport 4789 vxlan tcp dport 80 counter

   <b>RAW</b> <b>PAYLOAD</b> <b>EXPRESSION</b>
           <b>@</b><u>base</u><b>,</b><u>offset</u><b>,</b><u>length</u>

       The raw payload expression instructs to load <u>length</u> bits starting at <u>offset</u> bits. Bit 0 refers to the
       very first bit — in the C programming language, this corresponds to the topmost bit, i.e. 0x80 in case of
       an octet. They are useful to match headers that do not have a human-readable template expression yet.
       Note that nft will not add dependencies for Raw payload expressions. If you e.g. want to match protocol
       fields of a transport header with protocol number 5, you need to manually exclude packets that have a
       different transport header, for instance by using <b>meta</b> <b>l4proto</b> <b>5</b> before the raw expression.

       <b>Table</b> <b>56.</b> <b>Supported</b> <b>payload</b> <b>protocol</b> <b>bases</b>
       ┌──────┬──────────────────────────────────────┐
       │ <b>Base</b> │ <b>Description</b>                          │
       ├──────┼──────────────────────────────────────┤
       │      │                                      │
       │ ll   │ Link layer, for example the Ethernet │
       │      │ header                               │
       ├──────┼──────────────────────────────────────┤
       │      │                                      │
       │ nh   │ Network header, for example IPv4 or  │
       │      │ IPv6                                 │
       ├──────┼──────────────────────────────────────┤
       │      │                                      │
       │ th   │ Transport Header, for example TCP    │
       ├──────┼──────────────────────────────────────┤
       │      │                                      │
       │ ih   │ Inner Header / Payload, i.e. after   │
       │      │ the L4 transport level header        │
       └──────┴──────────────────────────────────────┘

       <b>Matching</b> <b>destination</b> <b>port</b> <b>of</b> <b>both</b> <b>UDP</b> <b>and</b> <b>TCP</b>.

           inet filter input meta l4proto {tcp, udp} @th,16,16 { 53, 80 }

       The above can also be written as

           inet filter input meta l4proto {tcp, udp} th dport { 53, 80 }

       it is more convenient, but like the raw expression notation no dependencies are created or checked. It is
       the users responsibility to restrict matching to those header types that have a notion of ports.
       Otherwise, rules using raw expressions will errnously match unrelated packets, e.g. mis-interpreting ESP
       packets SPI field as a port.

       <b>Rewrite</b> <b>arp</b> <b>packet</b> <b>target</b> <b>hardware</b> <b>address</b> <b>if</b> <b>target</b> <b>protocol</b> <b>address</b> <b>matches</b> <b>a</b> <b>given</b> <b>address</b>.

           input meta iifname enp2s0 arp ptype 0x0800 arp htype 1 arp hlen 6 arp plen 4 @nh,192,32 0xc0a88f10 @nh,144,48 set 0x112233445566 accept

   <b>EXTENSION</b> <b>HEADER</b> <b>EXPRESSIONS</b>
       Extension header expressions refer to data from variable-sized protocol headers, such as IPv6 extension
       headers, TCP options and IPv4 options.

       nftables currently supports matching (finding) a given ipv6 extension header, TCP option or IPv4 option.

           <b>hbh</b> {<b>nexthdr</b> | <b>hdrlength</b>}
           <b>frag</b> {<b>nexthdr</b> | <b>frag-off</b> | <b>more-fragments</b> | <b>id</b>}
           <b>rt</b> {<b>nexthdr</b> | <b>hdrlength</b> | <b>type</b> | <b>seg-left</b>}
           <b>dst</b> {<b>nexthdr</b> | <b>hdrlength</b>}
           <b>mh</b> {<b>nexthdr</b> | <b>hdrlength</b> | <b>checksum</b> | <b>type</b>}
           <b>srh</b> {<b>flags</b> | <b>tag</b> | <b>sid</b> | <b>seg-left</b>}
           <b>tcp</b> <b>option</b> {<b>eol</b> | <b>nop</b> | <b>maxseg</b> | <b>window</b> | <b>sack-perm</b> | <b>sack</b> | <b>sack0</b> | <b>sack1</b> | <b>sack2</b> | <b>sack3</b> | <b>timestamp</b> | <b>mptcp</b> } <u>tcp_option_field</u>
           <b>ip</b> <b>option</b> { lsrr | ra | rr | ssrr } <u>ip_option_field</u>

       The following syntaxes are valid only in a relational expression with boolean type on right-hand side for
       checking header existence only:

           <b>exthdr</b> {<b>hbh</b> | <b>frag</b> | <b>rt</b> | <b>dst</b> | <b>mh</b>}
           <b>tcp</b> <b>option</b> {<b>eol</b> | <b>nop</b> | <b>maxseg</b> | <b>window</b> | <b>sack-perm</b> | <b>sack</b> | <b>sack0</b> | <b>sack1</b> | <b>sack2</b> | <b>sack3</b> | <b>timestamp</b> | <b>mptcp</b> }
           <b>ip</b> <b>option</b> { lsrr | ra | rr | ssrr }
           <b>dccp</b> <b>option</b> <u>dccp_option_type</u>

       <b>Table</b> <b>57.</b> <b>IPv6</b> <b>extension</b> <b>headers</b>
       ┌─────────┬────────────────────────┐
       │ <b>Keyword</b> │ <b>Description</b>            │
       ├─────────┼────────────────────────┤
       │         │                        │
       │ hbh     │ Hop by Hop             │
       ├─────────┼────────────────────────┤
       │         │                        │
       │ rt      │ Routing Header         │
       ├─────────┼────────────────────────┤
       │         │                        │
       │ frag    │ Fragmentation header   │
       ├─────────┼────────────────────────┤
       │         │                        │
       │ dst     │ dst options            │
       ├─────────┼────────────────────────┤
       │         │                        │
       │ mh      │ Mobility Header        │
       ├─────────┼────────────────────────┤
       │         │                        │
       │ srh     │ Segment Routing Header │
       └─────────┴────────────────────────┘

       <b>Table</b> <b>58.</b> <b>TCP</b> <b>Options</b>
       ┌───────────┬───────────────────────────┬──────────────────────┐
       │ <b>Keyword</b>   │ <b>Description</b>               │ <b>TCP</b> <b>option</b> <b>fields</b>    │
       ├───────────┼───────────────────────────┼──────────────────────┤
       │           │                           │                      │
       │ eol       │ End if option list        │ -                    │
       ├───────────┼───────────────────────────┼──────────────────────┤
       │           │                           │                      │
       │ nop       │ 1 Byte TCP Nop padding    │ -                    │
       │           │ option                    │                      │
       ├───────────┼───────────────────────────┼──────────────────────┤
       │           │                           │                      │
       │ maxseg    │ TCP Maximum Segment Size  │ length, size         │
       ├───────────┼───────────────────────────┼──────────────────────┤
       │           │                           │                      │
       │ window    │ TCP Window Scaling        │ length, count        │
       ├───────────┼───────────────────────────┼──────────────────────┤
       │           │                           │                      │
       │ sack-perm │ TCP SACK permitted        │ length               │
       ├───────────┼───────────────────────────┼──────────────────────┤
       │           │                           │                      │
       │ sack      │ TCP Selective             │ length, left, right  │
       │           │ Acknowledgement (alias of │                      │
       │           │ block 0)                  │                      │
       ├───────────┼───────────────────────────┼──────────────────────┤
       │           │                           │                      │
       │ sack0     │ TCP Selective             │ length, left, right  │
       │           │ Acknowledgement (block 0) │                      │
       ├───────────┼───────────────────────────┼──────────────────────┤
       │           │                           │                      │
       │ sack1     │ TCP Selective             │ length, left, right  │
       │           │ Acknowledgement (block 1) │                      │
       ├───────────┼───────────────────────────┼──────────────────────┤
       │           │                           │                      │
       │ sack2     │ TCP Selective             │ length, left, right  │
       │           │ Acknowledgement (block 2) │                      │
       ├───────────┼───────────────────────────┼──────────────────────┤
       │           │                           │                      │
       │ sack3     │ TCP Selective             │ length, left, right  │
       │           │ Acknowledgement (block 3) │                      │
       ├───────────┼───────────────────────────┼──────────────────────┤
       │           │                           │                      │
       │ timestamp │ TCP Timestamps            │ length, tsval, tsecr │
       ├───────────┼───────────────────────────┼──────────────────────┤
       │           │                           │                      │
       │ mptcp     │ Multipath TCP             │ subtype              │
       └───────────┴───────────────────────────┴──────────────────────┘

       Data types can be queried with <u>nft</u> <u>describe</u> <u>tcp</u> <u>option</u> <b>keyword</b> <u>[</u> <b>fieldname</b> <u>]</u>.

       TCP option matching also supports raw expression syntax to access arbitrary options:

           <b>tcp</b> <b>option</b>

           <b>tcp</b> <b>option</b> <b>@</b><u>number</u><b>,</b><u>offset</u><b>,</b><u>length</u>

       <b>Table</b> <b>59.</b> <b>IP</b> <b>Options</b>
       ┌─────────┬─────────────────────┬───────────────────┐
       │ <b>Keyword</b> │ <b>Description</b>         │ <b>IP</b> <b>option</b> <b>fields</b>  │
       ├─────────┼─────────────────────┼───────────────────┤
       │         │                     │                   │
       │ lsrr    │ Loose Source Route  │ length, ptr, addr │
       ├─────────┼─────────────────────┼───────────────────┤
       │         │                     │                   │
       │ ra      │ Router Alert        │ length, value     │
       ├─────────┼─────────────────────┼───────────────────┤
       │         │                     │                   │
       │ rr      │ Record Route        │ length, ptr, addr │
       ├─────────┼─────────────────────┼───────────────────┤
       │         │                     │                   │
       │ ssrr    │ Strict Source Route │ length, ptr, addr │
       └─────────┴─────────────────────┴───────────────────┘

       <b>finding</b> <b>TCP</b> <b>options</b>.

           filter input tcp option sack-perm exists counter

       <b>matching</b> <b>TCP</b> <b>options</b>.

           filter input tcp option maxseg size lt 536

       <b>matching</b> <b>IPv6</b> <b>exthdr</b>.

           ip6 filter input frag more-fragments 1 counter

       <b>finding</b> <b>IP</b> <b>option</b>.

           filter input ip option lsrr exists counter

       <b>finding</b> <b>DCCP</b> <b>option</b>.

           filter input dccp option 40 exists counter

   <b>CONNTRACK</b> <b>EXPRESSIONS</b>
       Conntrack expressions refer to meta data of the connection tracking entry associated with a packet.

       There are three types of conntrack expressions. Some conntrack expressions require the flow direction
       before the conntrack key, others must be used directly because they are direction agnostic. The <b>packets</b>,
       <b>bytes</b> and <b>avgpkt</b> keywords can be used with or without a direction. If the direction is omitted, the sum
       of the original and the reply direction is returned. The same is true for the <b>zone</b>, if a direction is
       given, the zone is only matched if the zone id is tied to the given direction.

           <b>ct</b> {<b>state</b> | <b>direction</b> | <b>status</b> | <b>mark</b> | <b>expiration</b> | <b>helper</b> | <b>label</b> | <b>count</b> | <b>id</b>}
           <b>ct</b> [<b>original</b> | <b>reply</b>] {<b>l3proto</b> | <b>protocol</b> | <b>bytes</b> | <b>packets</b> | <b>avgpkt</b> | <b>zone</b>}
           <b>ct</b> {<b>original</b> | <b>reply</b>} {<b>proto-src</b> | <b>proto-dst</b>}
           <b>ct</b> {<b>original</b> | <b>reply</b>} {<b>ip</b> | <b>ip6</b>} {<b>saddr</b> | <b>daddr</b>}

       The conntrack-specific types in this table are described in the sub-section CONNTRACK TYPES above.

       <b>Table</b> <b>60.</b> <b>Conntrack</b> <b>expressions</b>
       ┌────────────┬──────────────────────────────┬─────────────────────┐
       │ <b>Keyword</b>    │ <b>Description</b>                  │ <b>Type</b>                │
       ├────────────┼──────────────────────────────┼─────────────────────┤
       │            │                              │                     │
       │ state      │ State of the connection      │ ct_state            │
       ├────────────┼──────────────────────────────┼─────────────────────┤
       │            │                              │                     │
       │ direction  │ Direction of the packet      │ ct_dir              │
       │            │ relative to the connection   │                     │
       ├────────────┼──────────────────────────────┼─────────────────────┤
       │            │                              │                     │
       │ status     │ Status of the connection     │ ct_status           │
       ├────────────┼──────────────────────────────┼─────────────────────┤
       │            │                              │                     │
       │ mark       │ Connection mark              │ mark                │
       ├────────────┼──────────────────────────────┼─────────────────────┤
       │            │                              │                     │
       │ expiration │ Connection expiration time   │ time                │
       ├────────────┼──────────────────────────────┼─────────────────────┤
       │            │                              │                     │
       │ helper     │ Helper associated with the   │ string              │
       │            │ connection                   │                     │
       ├────────────┼──────────────────────────────┼─────────────────────┤
       │            │                              │                     │
       │ label      │ Connection tracking label    │ ct_label            │
       │            │ bit or symbolic name defined │                     │
       │            │ in connlabel.conf in the     │                     │
       │            │ nftables include path        │                     │
       ├────────────┼──────────────────────────────┼─────────────────────┤
       │            │                              │                     │
       │ l3proto    │ Layer 3 protocol of the      │ nf_proto            │
       │            │ connection                   │                     │
       ├────────────┼──────────────────────────────┼─────────────────────┤
       │            │                              │                     │
       │ saddr      │ Source address of the        │ ipv4_addr/ipv6_addr │
       │            │ connection for the given     │                     │
       │            │ direction                    │                     │
       ├────────────┼──────────────────────────────┼─────────────────────┤
       │            │                              │                     │
       │ daddr      │ Destination address of the   │ ipv4_addr/ipv6_addr │
       │            │ connection for the given     │                     │
       │            │ direction                    │                     │
       ├────────────┼──────────────────────────────┼─────────────────────┤
       │            │                              │                     │
       │ protocol   │ Layer 4 protocol of the      │ inet_proto          │
       │            │ connection for the given     │                     │
       │            │ direction                    │                     │
       ├────────────┼──────────────────────────────┼─────────────────────┤
       │            │                              │                     │
       │ proto-src  │ Layer 4 protocol source for  │ integer (16 bit)    │
       │            │ the given direction          │                     │
       ├────────────┼──────────────────────────────┼─────────────────────┤
       │            │                              │                     │
       │ proto-dst  │ Layer 4 protocol destination │ integer (16 bit)    │
       │            │ for the given direction      │                     │
       ├────────────┼──────────────────────────────┼─────────────────────┤
       │            │                              │                     │
       │ packets    │ packet count seen in the     │ integer (64 bit)    │
       │            │ given direction or sum of    │                     │
       │            │ original and reply           │                     │
       ├────────────┼──────────────────────────────┼─────────────────────┤
       │            │                              │                     │
       │ bytes      │ byte count seen, see         │ integer (64 bit)    │
       │            │ description for <b>packets</b>      │                     │
       │            │ keyword                      │                     │
       ├────────────┼──────────────────────────────┼─────────────────────┤
       │            │                              │                     │
       │ avgpkt     │ average bytes per packet,    │ integer (64 bit)    │
       │            │ see description for <b>packets</b>  │                     │
       │            │ keyword                      │                     │
       ├────────────┼──────────────────────────────┼─────────────────────┤
       │            │                              │                     │
       │ zone       │ conntrack zone               │ integer (16 bit)    │
       ├────────────┼──────────────────────────────┼─────────────────────┤
       │            │                              │                     │
       │ count      │ number of current            │ integer (32 bit)    │
       │            │ connections                  │                     │
       ├────────────┼──────────────────────────────┼─────────────────────┤
       │            │                              │                     │
       │ id         │ Connection id                │ ct_id               │
       └────────────┴──────────────────────────────┴─────────────────────┘

       <b>restrict</b> <b>the</b> <b>number</b> <b>of</b> <b>parallel</b> <b>connections</b> <b>to</b> <b>a</b> <b>server</b>.

           nft add set filter ssh_flood '{ type ipv4_addr; flags dynamic; }'
           nft add rule filter input tcp dport 22 add @ssh_flood '{ ip saddr ct count over 2 }' reject

</pre><h4><b>STATEMENTS</b></h4><pre>
       Statements represent actions to be performed. They can alter control flow (return, jump to a different
       chain, accept or drop the packet) or can perform actions, such as logging, rejecting a packet, etc.

       Statements exist in two kinds. Terminal statements unconditionally terminate evaluation of the current
       rule, non-terminal statements either only conditionally or never terminate evaluation of the current
       rule, in other words, they are passive from the ruleset evaluation perspective. There can be an arbitrary
       amount of non-terminal statements in a rule, but only a single terminal statement as the final statement.

   <b>VERDICT</b> <b>STATEMENT</b>
       The verdict statement alters control flow in the ruleset and issues policy decisions for packets.

           {<b>accept</b> | <b>drop</b> | <b>queue</b> | <b>continue</b> | <b>return</b>}
           {<b>jump</b> | <b>goto</b>} <u>chain</u>

       <b>accept</b> and <b>drop</b> are absolute verdicts — they terminate ruleset evaluation immediately.

       <b>accept</b>       Terminate ruleset evaluation and
                    accept the packet. The packet can
                    still be dropped later by another
                    hook, for instance accept in the
                    forward hook still allows one to drop
                    the packet later in the postrouting
                    hook, or another forward base chain
                    that has a higher priority number and
                    is evaluated afterwards in the
                    processing pipeline.

       <b>drop</b>         Terminate ruleset evaluation and drop
                    the packet. The drop occurs
                    instantly, no further chains or hooks
                    are evaluated. It is not possible to
                    accept the packet in a later chain
                    again, as those are not evaluated
                    anymore for the packet.

       <b>queue</b>        Terminate ruleset evaluation and
                    queue the packet to userspace.
                    Userspace must provide a drop or
                    accept verdict. In case of accept,
                    processing resumes with the next base
                    chain hook, not the rule following
                    the queue verdict.

       <b>continue</b>     Continue ruleset evaluation with the
                    next rule. This is the default
                    behaviour in case a rule issues no
                    verdict.

       <b>return</b>       Return from the current chain and
                    continue evaluation at the next rule
                    in the last chain. If issued in a
                    base chain, it is equivalent to the
                    base chain policy.

       <b>jump</b> <u>chain</u>   Continue evaluation at the first rule
                    in <u>chain</u>. The current position in the
                    ruleset is pushed to a call stack and
                    evaluation will continue there when
                    the new chain is entirely evaluated
                    or a <b>return</b> verdict is issued. In
                    case an absolute verdict is issued by
                    a rule in the chain, ruleset
                    evaluation terminates immediately and
                    the specific action is taken.

       <b>goto</b> <u>chain</u>   Similar to <b>jump</b>, but the current
                    position is not pushed to the call
                    stack, meaning that after the new
                    chain evaluation will continue at the
                    last chain instead of the one
                    containing the goto statement.

       <b>Using</b> <b>verdict</b> <b>statements</b>.

           # process packets from eth0 and the internal network in from_lan
           # chain, drop all packets from eth0 with different source addresses.

           filter input iif eth0 ip saddr 192.168.0.0/24 jump from_lan
           filter input iif eth0 drop

   <b>PAYLOAD</b> <b>STATEMENT</b>
           <u>payload_expression</u> <b>set</b> <u>value</u>

       The payload statement alters packet content. It can be used for example to set ip DSCP (diffserv) header
       field or ipv6 flow labels.

       <b>route</b> <b>some</b> <b>packets</b> <b>instead</b> <b>of</b> <b>bridging</b>.

           # redirect tcp:http from 192.160.0.0/16 to local machine for routing instead of bridging
           # assumes 00:11:22:33:44:55 is local MAC address.
           bridge input meta iif eth0 ip saddr 192.168.0.0/16 tcp dport 80 meta pkttype set host ether daddr set 00:11:22:33:44:55

       <b>Set</b> <b>IPv4</b> <b>DSCP</b> <b>header</b> <b>field</b>.

           ip forward ip dscp set 42

   <b>EXTENSION</b> <b>HEADER</b> <b>STATEMENT</b>
           <u>extension_header_expression</u> <b>set</b> <u>value</u>

       The extension header statement alters packet content in variable-sized headers. This can currently be
       used to alter the TCP Maximum segment size of packets, similar to the TCPMSS target in iptables.

       <b>change</b> <b>tcp</b> <b>mss</b>.

           tcp flags syn tcp option maxseg size set 1360
           # set a size based on route information:
           tcp flags syn tcp option maxseg size set rt mtu

       You can also remove tcp options via reset keyword.

       <b>remove</b> <b>tcp</b> <b>option</b>.

           tcp flags syn reset tcp option sack-perm

   <b>LOG</b> <b>STATEMENT</b>
           <b>log</b> [<b>prefix</b> <u>quoted_string</u>] [<b>level</b> <u>syslog-level</u>] [<b>flags</b> <u>log-flags</u>]
           <b>log</b> <b>group</b> <u>nflog_group</u> [<b>prefix</b> <u>quoted_string</u>] [<b>queue-threshold</b> <u>value</u>] [<b>snaplen</b> <u>size</u>]
           <b>log</b> <b>level</b> <b>audit</b>

       The log statement enables logging of matching packets. When this statement is used from a rule, the Linux
       kernel will print some information on all matching packets, such as header fields, via the kernel log
       (where it can be read with <a href="../man1/dmesg.1.html">dmesg</a>(1) or read in the syslog).

       In the second form of invocation (if <u>nflog_group</u> is specified), the Linux kernel will pass the packet to
       nfnetlink_log which will send the log through a netlink socket to the specified group. One userspace
       process may subscribe to the group to receive the logs, see <a href="../man8/man.8.html">man</a>(8) ulogd for the Netfilter userspace log
       daemon and libnetfilter_log documentation for details in case you would like to develop a custom program
       to digest your logs.

       In the third form of invocation (if level audit is specified), the Linux kernel writes a message into the
       audit buffer suitably formatted for reading with auditd. Therefore no further formatting options (such as
       prefix or flags) are allowed in this mode.

       This is a non-terminating statement, so the rule evaluation continues after the packet is logged.

       <b>Table</b> <b>61.</b> <b>log</b> <b>statement</b> <b>options</b>
       ┌─────────────────┬──────────────────────────────┬──────────────────────────────┐
       │ <b>Keyword</b>         │ <b>Description</b>                  │ <b>Type</b>                         │
       ├─────────────────┼──────────────────────────────┼──────────────────────────────┤
       │                 │                              │                              │
       │ prefix          │ Log message prefix           │ quoted string                │
       ├─────────────────┼──────────────────────────────┼──────────────────────────────┤
       │                 │                              │                              │
       │ level           │ Syslog level of logging      │ string: emerg, alert, crit,  │
       │                 │                              │ err, warn [default], notice, │
       │                 │                              │ info, debug, audit           │
       ├─────────────────┼──────────────────────────────┼──────────────────────────────┤
       │                 │                              │                              │
       │ group           │ NFLOG group to send messages │ unsigned integer (16 bit)    │
       │                 │ to                           │                              │
       ├─────────────────┼──────────────────────────────┼──────────────────────────────┤
       │                 │                              │                              │
       │ snaplen         │ Length of packet payload to  │ unsigned integer (32 bit)    │
       │                 │ include in netlink message   │                              │
       ├─────────────────┼──────────────────────────────┼──────────────────────────────┤
       │                 │                              │                              │
       │ queue-threshold │ Number of packets to queue   │ unsigned integer (32 bit)    │
       │                 │ inside the kernel before     │                              │
       │                 │ sending them to userspace    │                              │
       └─────────────────┴──────────────────────────────┴──────────────────────────────┘

       <b>Table</b> <b>62.</b> <b>log-flags</b>
       ┌──────────────┬─────────────────────────────────────┐
       │ <b>Flag</b>         │ <b>Description</b>                         │
       ├──────────────┼─────────────────────────────────────┤
       │              │                                     │
       │ tcp sequence │ Log TCP sequence numbers.           │
       ├──────────────┼─────────────────────────────────────┤
       │              │                                     │
       │ tcp options  │ Log options from the TCP packet     │
       │              │ header.                             │
       ├──────────────┼─────────────────────────────────────┤
       │              │                                     │
       │ ip options   │ Log options from the IP/IPv6 packet │
       │              │ header.                             │
       ├──────────────┼─────────────────────────────────────┤
       │              │                                     │
       │ skuid        │ Log the userid of the process which │
       │              │ generated the packet.               │
       ├──────────────┼─────────────────────────────────────┤
       │              │                                     │
       │ ether        │ Decode MAC addresses and protocol.  │
       ├──────────────┼─────────────────────────────────────┤
       │              │                                     │
       │ all          │ Enable all log flags listed above.  │
       └──────────────┴─────────────────────────────────────┘

       <b>Using</b> <b>log</b> <b>statement</b>.

           # log the UID which generated the packet and ip options
           ip filter output log flags skuid flags ip options

           # log the tcp sequence numbers and tcp options from the TCP packet
           ip filter output log flags tcp sequence,options

           # enable all supported log flags
           ip6 filter output log flags all

   <b>REJECT</b> <b>STATEMENT</b>
           <b>reject</b> [ <b>with</b> <u>REJECT_WITH</u> ]

           <u>REJECT_WITH</u> := <b>icmp</b> <u>icmp_reject_code</u> |
                            <b>icmpv6</b> <u>icmpv6_reject_code</u> |
                            <b>icmpx</b> <u>icmpx_reject_code</u> |
                            <b>tcp</b> <b>reset</b>

       A reject statement is used to send back an error packet in response to the matched packet otherwise it is
       equivalent to drop so it is a terminating statement, ending rule traversal. This statement is only valid
       in base chains using the <b>prerouting</b>, <b>input</b>, <b>forward</b> or <b>output</b> hooks, and user-defined chains which are
       only called from those chains.

       <b>Table</b> <b>63.</b> <b>Keywords</b> <b>may</b> <b>be</b> <b>used</b> <b>to</b> <b>reject</b> <b>when</b> <b>specifying</b> <b>the</b> <b>ICMP</b> <b>code</b>
       ┌──────────────────┬───────┐
       │ <b>Keyword</b>          │ <b>Value</b> │
       ├──────────────────┼───────┤
       │                  │       │
       │ net-unreachable  │ 0     │
       ├──────────────────┼───────┤
       │                  │       │
       │ host-unreachable │ 1     │
       ├──────────────────┼───────┤
       │                  │       │
       │ prot-unreachable │ 2     │
       ├──────────────────┼───────┤
       │                  │       │
       │ port-unreachable │ 3     │
       ├──────────────────┼───────┤
       │                  │       │
       │ frag-needed      │ 4     │
       ├──────────────────┼───────┤
       │                  │       │
       │ net-prohibited   │ 9     │
       ├──────────────────┼───────┤
       │                  │       │
       │ host-prohibited  │ 10    │
       ├──────────────────┼───────┤
       │                  │       │
       │ admin-prohibited │ 13    │
       └──────────────────┴───────┘

       <b>Table</b> <b>64.</b> <b>keywords</b> <b>may</b> <b>be</b> <b>used</b> <b>to</b> <b>reject</b> <b>when</b> <b>specifying</b> <b>the</b> <b>ICMPv6</b> <b>code</b>
       ┌──────────────────┬───────┐
       │ <b>Keyword</b>          │ <b>Value</b> │
       ├──────────────────┼───────┤
       │                  │       │
       │ no-route         │ 0     │
       ├──────────────────┼───────┤
       │                  │       │
       │ admin-prohibited │ 1     │
       ├──────────────────┼───────┤
       │                  │       │
       │ addr-unreachable │ 3     │
       ├──────────────────┼───────┤
       │                  │       │
       │ port-unreachable │ 4     │
       ├──────────────────┼───────┤
       │                  │       │
       │ policy-fail      │ 5     │
       ├──────────────────┼───────┤
       │                  │       │
       │ reject-route     │ 6     │
       └──────────────────┴───────┘

       The ICMPvX Code type abstraction is a set of values which overlap between ICMP and ICMPv6 Code types to
       be used from the inet family.

       <b>Table</b> <b>65.</b> <b>keywords</b> <b>may</b> <b>be</b> <b>used</b> <b>when</b> <b>specifying</b> <b>the</b> <b>ICMPvX</b> <b>code</b>
       ┌──────────────────┬───────┐
       │ <b>Keyword</b>          │ <b>Value</b> │
       ├──────────────────┼───────┤
       │                  │       │
       │ no-route         │ 0     │
       ├──────────────────┼───────┤
       │                  │       │
       │ port-unreachable │ 1     │
       ├──────────────────┼───────┤
       │                  │       │
       │ host-unreachable │ 2     │
       ├──────────────────┼───────┤
       │                  │       │
       │ admin-prohibited │ 3     │
       └──────────────────┴───────┘

       The common default ICMP code to reject is <b>port-unreachable</b>.

       Note that in bridge family, reject statement is only allowed in base chains which hook into input or
       prerouting.

   <b>COUNTER</b> <b>STATEMENT</b>
       A counter statement sets the hit count of packets along with the number of bytes.

           <b>counter</b> <b>packets</b> <u>number</u> <b>bytes</b> <u>number</u>
           <b>counter</b> { <b>packets</b> <u>number</u> | <b>bytes</b> <u>number</u> }

   <b>CONNTRACK</b> <b>STATEMENT</b>
       The conntrack statement can be used to set the conntrack mark and conntrack labels.

           <b>ct</b> {<b>mark</b> | <b>event</b> | <b>label</b> | <b>zone</b>} <b>set</b> <u>value</u>

       The ct statement sets meta data associated with a connection. The zone id has to be assigned before a
       conntrack lookup takes place, i.e. this has to be done in prerouting and possibly output (if locally
       generated packets need to be placed in a distinct zone), with a hook priority of <b>raw</b> (-300).

       Unlike iptables, where the helper assignment happens in the raw table, the helper needs to be assigned
       after a conntrack entry has been found, i.e. it will not work when used with hook priorities equal or
       before -200.

       <b>Table</b> <b>66.</b> <b>Conntrack</b> <b>statement</b> <b>types</b>
       ┌─────────┬─────────────────────────────┬───────────────────────────┐
       │ <b>Keyword</b> │ <b>Description</b>                 │ <b>Value</b>                     │
       ├─────────┼─────────────────────────────┼───────────────────────────┤
       │         │                             │                           │
       │ event   │ conntrack event bits        │ bitmask, integer (32 bit) │
       ├─────────┼─────────────────────────────┼───────────────────────────┤
       │         │                             │                           │
       │ helper  │ name of ct helper object to │ quoted string             │
       │         │ assign to the connection    │                           │
       ├─────────┼─────────────────────────────┼───────────────────────────┤
       │         │                             │                           │
       │ mark    │ Connection tracking mark    │ mark                      │
       ├─────────┼─────────────────────────────┼───────────────────────────┤
       │         │                             │                           │
       │ label   │ Connection tracking label   │ label                     │
       ├─────────┼─────────────────────────────┼───────────────────────────┤
       │         │                             │                           │
       │ zone    │ conntrack zone              │ integer (16 bit)          │
       └─────────┴─────────────────────────────┴───────────────────────────┘

       <b>save</b> <b>packet</b> <b>nfmark</b> <b>in</b> <b>conntrack</b>.

           ct mark set meta mark

       <b>set</b> <b>zone</b> <b>mapped</b> <b>via</b> <b>interface</b>.

           table inet raw {
             chain prerouting {
                 type filter hook prerouting priority raw;
                 ct zone set iif map { "eth1" : 1, "veth1" : 2 }
             }
             chain output {
                 type filter hook output priority raw;
                 ct zone set oif map { "eth1" : 1, "veth1" : 2 }
             }
           }

       <b>restrict</b> <b>events</b> <b>reported</b> <b>by</b> <b>ctnetlink</b>.

           ct event set new,related,destroy

   <b>NOTRACK</b> <b>STATEMENT</b>
       The notrack statement allows one to disable connection tracking for certain packets.

           <b>notrack</b>

       Note that for this statement to be effective, it has to be applied to packets before a conntrack lookup
       happens. Therefore, it needs to sit in a chain with either prerouting or output hook and a hook priority
       of -300 (<b>raw</b>) or less.

       See SYNPROXY STATEMENT for an example usage.

   <b>META</b> <b>STATEMENT</b>
       A meta statement sets the value of a meta expression. The existing meta fields are: priority, mark,
       pkttype, nftrace.

           <b>meta</b> {<b>mark</b> | <b>priority</b> | <b>pkttype</b> | <b>nftrace</b> | <b>broute</b>} <b>set</b> <u>value</u>

       A meta statement sets meta data associated with a packet.

       <b>Table</b> <b>67.</b> <b>Meta</b> <b>statement</b> <b>types</b>
       ┌──────────┬────────────────────────────┬───────────┐
       │ <b>Keyword</b>  │ <b>Description</b>                │ <b>Value</b>     │
       ├──────────┼────────────────────────────┼───────────┤
       │          │                            │           │
       │ priority │ TC packet priority         │ tc_handle │
       ├──────────┼────────────────────────────┼───────────┤
       │          │                            │           │
       │ mark     │ Packet mark                │ mark      │
       ├──────────┼────────────────────────────┼───────────┤
       │          │                            │           │
       │ pkttype  │ packet type                │ pkt_type  │
       ├──────────┼────────────────────────────┼───────────┤
       │          │                            │           │
       │ nftrace  │ ruleset packet tracing     │ 0, 1      │
       │          │ on/off. Use <b>monitor</b> <b>trace</b>  │           │
       │          │ command to watch traces    │           │
       ├──────────┼────────────────────────────┼───────────┤
       │          │                            │           │
       │ broute   │ broute on/off. packets are │ 0, 1      │
       │          │ routed instead of being    │           │
       │          │ bridged                    │           │
       └──────────┴────────────────────────────┴───────────┘

   <b>LIMIT</b> <b>STATEMENT</b>
           <b>limit</b> <b>rate</b> [<b>over</b>] <u>packet_number</u> <b>/</b> <u>TIME_UNIT</u> [<b>burst</b> <u>packet_number</u> <b>packets</b>]
           <b>limit</b> <b>rate</b> [<b>over</b>] <u>byte_number</u> <u>BYTE_UNIT</u> <b>/</b> <u>TIME_UNIT</u> [<b>burst</b> <u>byte_number</u> <u>BYTE_UNIT</u>]

           <u>TIME_UNIT</u> := <b>second</b> | <b>minute</b> | <b>hour</b> | <b>day</b>
           <u>BYTE_UNIT</u> := <b>bytes</b> | <b>kbytes</b> | <b>mbytes</b>

       A limit statement matches at a limited rate using a token bucket filter. A rule using this statement will
       match until this limit is reached. It can be used in combination with the log statement to give limited
       logging. The optional <b>over</b> keyword makes it match over the specified rate.

       The <b>burst</b> value influences the bucket size, i.e. jitter tolerance. With packet-based <b>limit</b>, the bucket
       holds exactly <b>burst</b> packets, by default five. If you specify packet <b>burst</b>, it must be a non-zero value.
       With byte-based <b>limit</b>, the bucket’s minimum size is the given rate’s byte value and the <b>burst</b> value adds
       to that, by default zero bytes.

       <b>Table</b> <b>68.</b> <b>limit</b> <b>statement</b> <b>values</b>
       ┌───────────────┬───────────────────┬───────────────────────────┐
       │ <b>Value</b>         │ <b>Description</b>       │ <b>Type</b>                      │
       ├───────────────┼───────────────────┼───────────────────────────┤
       │               │                   │                           │
       │ packet_number │ Number of packets │ unsigned integer (32 bit) │
       ├───────────────┼───────────────────┼───────────────────────────┤
       │               │                   │                           │
       │ byte_number   │ Number of bytes   │ unsigned integer (32 bit) │
       └───────────────┴───────────────────┴───────────────────────────┘

   <b>NAT</b> <b>STATEMENTS</b>
           <b>snat</b> [[<b>ip</b> | <b>ip6</b>] [ <b>prefix</b> ] <b>to</b>] <u>ADDR_SPEC</u> [<b>:</b><u>PORT_SPEC</u>] [<u>FLAGS</u>]
           <b>dnat</b> [[<b>ip</b> | <b>ip6</b>] [ <b>prefix</b> ] <b>to</b>] <u>ADDR_SPEC</u> [<b>:</b><u>PORT_SPEC</u>] [<u>FLAGS</u>]
           <b>masquerade</b> [<b>to</b> <b>:</b><u>PORT_SPEC</u>] [<u>FLAGS</u>]
           <b>redirect</b> [<b>to</b> <b>:</b><u>PORT_SPEC</u>] [<u>FLAGS</u>]

           <u>ADDR_SPEC</u> := <u>address</u> | <u>address</u> <b>-</b> <u>address</u>
           <u>PORT_SPEC</u> := <u>port</u> | <u>port</u> <b>-</b> <u>port</u>

           <u>FLAGS</u>  := <u>FLAG</u> [<b>,</b> <u>FLAGS</u>]
           <u>FLAG</u>  := <b>persistent</b> | <b>random</b> | <b>fully-random</b>

       The nat statements are only valid from nat chain types.

       The <b>snat</b> and <b>masquerade</b> statements specify that the source address of the packet should be modified.
       While <b>snat</b> is only valid in the postrouting and input chains, <b>masquerade</b> makes sense only in postrouting.
       The dnat and redirect statements are only valid in the prerouting and output chains, they specify that
       the destination address of the packet should be modified. You can use non-base chains which are called
       from base chains of nat chain type too. All future packets in this connection will also be mangled, and
       rules should cease being examined.

       The <b>masquerade</b> statement is a special form of snat which always uses the outgoing interface’s IP address
       to translate to. It is particularly useful on gateways with dynamic (public) IP addresses.

       The <b>redirect</b> statement is a special form of dnat which always translates the destination address to the
       local host’s one. It comes in handy if one only wants to alter the destination port of incoming traffic
       on different interfaces.

       When used in the inet family (available with kernel 5.2), the dnat and snat statements require the use of
       the ip and ip6 keyword in case an address is provided, see the examples below.

       Before kernel 4.18 nat statements require both prerouting and postrouting base chains to be present since
       otherwise packets on the return path won’t be seen by netfilter and therefore no reverse translation will
       take place.

       The optional <b>prefix</b> keyword allows to map to map <b>n</b> source addresses to <b>n</b> destination addresses. See
       <u>Advanced</u> <u>NAT</u> <u>examples</u> below.

       <b>Table</b> <b>69.</b> <b>NAT</b> <b>statement</b> <b>values</b>
       ┌────────────┬──────────────────────────────┬──────────────────────────────┐
       │ <b>Expression</b> │ <b>Description</b>                  │ <b>Type</b>                         │
       ├────────────┼──────────────────────────────┼──────────────────────────────┤
       │            │                              │                              │
       │ address    │ Specifies that the           │ ipv4_addr, ipv6_addr, e.g.   │
       │            │ source/destination address   │ abcd::1234, or you can use a │
       │            │ of the packet should be      │ mapping, e.g. meta mark map  │
       │            │ modified. You may specify a  │ { 10 : 192.168.1.2, 20 :     │
       │            │ mapping to relate a list of  │ 192.168.1.3 }                │
       │            │ tuples composed of arbitrary │                              │
       │            │ expression key with address  │                              │
       │            │ value.                       │                              │
       ├────────────┼──────────────────────────────┼──────────────────────────────┤
       │            │                              │                              │
       │ port       │ Specifies that the           │ port number (16 bit)         │
       │            │ source/destination port of   │                              │
       │            │ the packet should be         │                              │
       │            │ modified.                    │                              │
       └────────────┴──────────────────────────────┴──────────────────────────────┘

       <b>Table</b> <b>70.</b> <b>NAT</b> <b>statement</b> <b>flags</b>
       ┌──────────────┬──────────────────────────────────────┐
       │ <b>Flag</b>         │ <b>Description</b>                          │
       ├──────────────┼──────────────────────────────────────┤
       │              │                                      │
       │ persistent   │ Gives a client the same              │
       │              │ source-/destination-address for each │
       │              │ connection.                          │
       ├──────────────┼──────────────────────────────────────┤
       │              │                                      │
       │ random       │ In kernel 5.0 and newer this is the  │
       │              │ same as fully-random. In earlier     │
       │              │ kernels the port mapping will be     │
       │              │ randomized using a seeded MD5 hash   │
       │              │ mix using source and destination     │
       │              │ address and destination port.        │
       ├──────────────┼──────────────────────────────────────┤
       │              │                                      │
       │ fully-random │ If used then port mapping is         │
       │              │ generated based on a 32-bit          │
       │              │ pseudo-random algorithm.             │
       └──────────────┴──────────────────────────────────────┘

       <b>Using</b> <b>NAT</b> <b>statements</b>.

           # create a suitable table/chain setup for all further examples
           add table nat
           add chain nat prerouting { type nat hook prerouting priority dstnat; }
           add chain nat postrouting { type nat hook postrouting priority srcnat; }

           # translate source addresses of all packets leaving via eth0 to address 1.2.3.4
           add rule nat postrouting oif eth0 snat to 1.2.3.4

           # redirect all traffic entering via eth0 to destination address 192.168.1.120
           add rule nat prerouting iif eth0 dnat to 192.168.1.120

           # translate source addresses of all packets leaving via eth0 to whatever
           # locally generated packets would use as source to reach the same destination
           add rule nat postrouting oif eth0 masquerade

           # redirect incoming TCP traffic for port 22 to port 2222
           add rule nat prerouting tcp dport 22 redirect to :2222

           # inet family:
           # handle ip dnat:
           add rule inet nat prerouting dnat ip to 10.0.2.99
           # handle ip6 dnat:
           add rule inet nat prerouting dnat ip6 to fe80::dead
           # this masquerades both ipv4 and ipv6:
           add rule inet nat postrouting meta oif ppp0 masquerade

       <b>Advanced</b> <b>NAT</b> <b>examples</b>.

           # map prefixes in one network to that of another, e.g. 10.141.11.4 is mangled to 192.168.2.4,
           # 10.141.11.5 is mangled to 192.168.2.5 and so on.
           add rule nat postrouting snat ip prefix to ip saddr map { 10.141.11.0/24 : 192.168.2.0/24 }

           # map a source address, source port combination to a pool of destination addresses and ports:
           add rule nat postrouting dnat to ip saddr . tcp dport map { 192.168.1.2 . 80 : 10.141.10.2-10.141.10.5 . 8888-8999 }

           # The above example generates the following NAT expression:
           #
           # [ nat dnat ip addr_min reg 1 addr_max reg 10 proto_min reg 9 proto_max reg 11 ]
           #
           # which expects to obtain the following tuple:
           # IP address (min), source port (min), IP address (max), source port (max)
           # to be obtained from the map. The given addresses and ports are inclusive.

           # This also works with named maps and in combination with both concatenations and ranges:
           table ip nat {
                   map ipportmap {
                           typeof ip saddr : interval ip daddr . tcp dport
                           flags interval
                           elements = { 192.168.1.2 : 10.141.10.1-10.141.10.3 . 8888-8999, 192.168.2.0/24 : 10.141.11.5-10.141.11.20 . 8888-8999 }
                   }

                   chain prerouting {
                           type nat hook prerouting priority dstnat; policy accept;
                           ip protocol tcp dnat ip to ip saddr map @ipportmap
                   }
           }

           @ipportmap maps network prefixes to a range of hosts and ports.
           The new destination is taken from the range provided by the map element.
           Same for the destination port.

           Note the use of the "interval" keyword in the typeof description.
           This is required so nftables knows that it has to ask for twice the
           amount of storage for each key-value pair in the map.

           ": ipv4_addr . inet_service" would allow associating one address and one port
           with each key.  But for this case, for each key, two addresses and two ports
           (The minimum and maximum values for both) have to be stored.

   <b>TPROXY</b> <b>STATEMENT</b>
       Tproxy redirects the packet to a local socket without changing the packet header in any way. If any of
       the arguments is missing the data of the incoming packet is used as parameter. Tproxy matching requires
       another rule that ensures the presence of transport protocol header is specified.

           <b>tproxy</b> <b>to</b> <u>address</u><b>:</b><u>port</u>
           <b>tproxy</b> <b>to</b> {<u>address</u> | <b>:</b><u>port</u>}

       This syntax can be used in <b>ip/ip6</b> tables where network layer protocol is obvious. Either IP address or
       port can be specified, but at least one of them is necessary.

           <b>tproxy</b> {<b>ip</b> | <b>ip6</b>} <b>to</b> <u>address</u>[<b>:</b><u>port</u>]
           <b>tproxy</b> <b>to</b> <b>:</b><u>port</u>

       This syntax can be used in <b>inet</b> tables. The <b>ip/ip6</b> parameter defines the family the rule will match. The
       <b>address</b> parameter must be of this family. When only <b>port</b> is defined, the address family should not be
       specified. In this case the rule will match for both families.

       <b>Table</b> <b>71.</b> <b>tproxy</b> <b>attributes</b>
       ┌─────────┬──────────────────────────────────────┐
       │ <b>Name</b>    │ <b>Description</b>                          │
       ├─────────┼──────────────────────────────────────┤
       │         │                                      │
       │ address │ IP address the listening socket with │
       │         │ IP_TRANSPARENT option is bound to.   │
       ├─────────┼──────────────────────────────────────┤
       │         │                                      │
       │ port    │ Port the listening socket with       │
       │         │ IP_TRANSPARENT option is bound to.   │
       └─────────┴──────────────────────────────────────┘

       <b>Example</b> <b>ruleset</b> <b>for</b> <b>tproxy</b> <b>statement</b>.

           table ip x {
               chain y {
                   type filter hook prerouting priority mangle; policy accept;
                   tcp dport ntp tproxy to 1.1.1.1 accept
                   udp dport ssh tproxy to :2222 accept
               }
           }
           table ip6 x {
               chain y {
                  type filter hook prerouting priority mangle; policy accept;
                  tcp dport ntp tproxy to [dead::beef] accept
                  udp dport ssh tproxy to :2222 accept
               }
           }
           table inet x {
               chain y {
                   type filter hook prerouting priority mangle; policy accept;
                   tcp dport 321 tproxy to :22 accept
                   tcp dport 99 tproxy ip to 1.1.1.1:999 accept
                   udp dport 155 tproxy ip6 to [dead::beef]:smux accept
               }
           }

       Note that the tproxy statement is non-terminal to allow post-processing of packets. This allows packets
       to be logged for debugging as well as updating the mark to ensure that packets are delivered locally
       through policy routing rules.

       <b>Example</b> <b>ruleset</b> <b>for</b> <b>tproxy</b> <b>statement</b> <b>with</b> <b>logging</b> <b>and</b> <b>meta</b> <b>mark</b>.

           table inet x {
               chain y {
                   type filter hook prerouting priority mangle; policy accept;
                   udp dport 9999 goto {
                       tproxy to :1234 log prefix "packet tproxied: " meta mark set 1 accept
                       log prefix "no socket on port 1234 or not transparent?: " drop
                   }
               }
           }

       As packet headers are unchanged, packets might be forwarded instead of delivered locally. As mentioned
       above, this can be avoided by adding policy routing rules and the packet mark.

       <b>Example</b> <b>policy</b> <b>routing</b> <b>rules</b> <b>for</b> <b>local</b> <b>redirection</b>.

           ip rule add fwmark 1 lookup 100
           ip route add local 0.0.0.0/0 dev lo table 100

       This is a change in behavior compared to the legacy iptables TPROXY target which is terminal. To
       terminate the packet processing after the tproxy statement, remember to issue a verdict as in the example
       above.

   <b>SYNPROXY</b> <b>STATEMENT</b>
       This statement will process TCP three-way-handshake parallel in netfilter context to protect either local
       or backend system. This statement requires connection tracking because sequence numbers need to be
       translated.

           <b>synproxy</b> [<b>mss</b> <u>mss_value</u>] [<b>wscale</b> <u>wscale_value</u>] [<u>SYNPROXY_FLAGS</u>]

       <b>Table</b> <b>72.</b> <b>synproxy</b> <b>statement</b> <b>attributes</b>
       ┌────────┬───────────────────────────────────────┐
       │ <b>Name</b>   │ <b>Description</b>                           │
       ├────────┼───────────────────────────────────────┤
       │        │                                       │
       │ mss    │ Maximum segment size announced to     │
       │        │ clients. This must match the backend. │
       ├────────┼───────────────────────────────────────┤
       │        │                                       │
       │ wscale │ Window scale announced to clients.    │
       │        │ This must match the backend.          │
       └────────┴───────────────────────────────────────┘

       <b>Table</b> <b>73.</b> <b>synproxy</b> <b>statement</b> <b>flags</b>
       ┌───────────┬───────────────────────────────────────┐
       │ <b>Flag</b>      │ <b>Description</b>                           │
       ├───────────┼───────────────────────────────────────┤
       │           │                                       │
       │ sack-perm │ Pass client selective acknowledgement │
       │           │ option to backend (will be disabled   │
       │           │ if not present).                      │
       ├───────────┼───────────────────────────────────────┤
       │           │                                       │
       │ timestamp │ Pass client timestamp option to       │
       │           │ backend (will be disabled if not      │
       │           │ present, also needed for selective    │
       │           │ acknowledgement and window scaling).  │
       └───────────┴───────────────────────────────────────┘

       <b>Example</b> <b>ruleset</b> <b>for</b> <b>synproxy</b> <b>statement</b>.

           Determine tcp options used by backend, from an external system

                         tcpdump -pni eth0 -c 1 'tcp[tcpflags] == (tcp-syn|tcp-ack)'
                             port 80 &amp;
                         telnet 192.0.2.42 80
                         18:57:24.693307 IP 192.0.2.42.80 &gt; 192.0.2.43.48757:
                             Flags [S.], seq 360414582, ack 788841994, win 14480,
                             options [mss 1460,sackOK,
                             TS val 1409056151 ecr 9690221,
                             nop,wscale 9],
                             length 0

           Switch tcp_loose mode off, so conntrack will mark out-of-flow packets as state INVALID.

                         echo 0 &gt; <a href="file:/proc/sys/net/netfilter/nf_conntrack_tcp_loose">/proc/sys/net/netfilter/nf_conntrack_tcp_loose</a>

           Make SYN packets untracked.

                   table ip x {
                           chain y {
                                   type filter hook prerouting priority raw; policy accept;
                                   tcp flags syn notrack
                           }
                   }

           Catch UNTRACKED (SYN  packets) and INVALID (3WHS ACK packets) states and send
           them to SYNPROXY. This rule will respond to SYN packets with SYN+ACK
           syncookies, create ESTABLISHED for valid client response (3WHS ACK packets) and
           drop incorrect cookies. Flags combinations not expected during  3WHS will not
           match and continue (e.g. SYN+FIN, SYN+ACK). Finally, drop invalid packets, this
           will be out-of-flow packets that were not matched by SYNPROXY.

               table ip x {
                       chain z {
                               type filter hook input priority filter; policy accept;
                               ct state invalid, untracked synproxy mss 1460 wscale 9 timestamp sack-perm
                               ct state invalid drop
                       }
               }

   <b>FLOW</b> <b>STATEMENT</b>
       A flow statement allows us to select what flows you want to accelerate forwarding through layer 3 network
       stack bypass. You have to specify the flowtable name where you want to offload this flow.

       <b>flow</b> <b>add</b> <b>@</b><u>flowtable</u>

   <b>QUEUE</b> <b>STATEMENT</b>
       This statement passes the packet to userspace using the nfnetlink_queue handler. The packet is put into
       the queue identified by its 16-bit queue number. Userspace can inspect and modify the packet if desired.
       Userspace must then drop or re-inject the packet into the kernel. See libnetfilter_queue documentation
       for details.

           <b>queue</b> [<b>flags</b> <u>QUEUE_FLAGS</u>] [<b>to</b> <u>queue_number</u>]
           <b>queue</b> [<b>flags</b> <u>QUEUE_FLAGS</u>] [<b>to</b> <u>queue_number_from</u> - <u>queue_number_to</u>]
           <b>queue</b> [<b>flags</b> <u>QUEUE_FLAGS</u>] [<b>to</b> <u>QUEUE_EXPRESSION</u> ]

           <u>QUEUE_FLAGS</u> := <u>QUEUE_FLAG</u> [<b>,</b> <u>QUEUE_FLAGS</u>]
           <u>QUEUE_FLAG</u>  := <b>bypass</b> | <b>fanout</b>
           <u>QUEUE_EXPRESSION</u> := <b>numgen</b> | <b>hash</b> | <b>symhash</b> | <b>MAP</b> <b>STATEMENT</b>

       QUEUE_EXPRESSION can be used to compute a queue number at run-time with the hash or numgen expressions.
       It also allows one to use the map statement to assign fixed queue numbers based on external inputs such
       as the source ip address or interface names.

       <b>Table</b> <b>74.</b> <b>queue</b> <b>statement</b> <b>values</b>
       ┌───────────────────┬────────────────────────────┬───────────────────────────┐
       │ <b>Value</b>             │ <b>Description</b>                │ <b>Type</b>                      │
       ├───────────────────┼────────────────────────────┼───────────────────────────┤
       │                   │                            │                           │
       │ queue_number      │ Sets queue number, default │ unsigned integer (16 bit) │
       │                   │ is 0.                      │                           │
       ├───────────────────┼────────────────────────────┼───────────────────────────┤
       │                   │                            │                           │
       │ queue_number_from │ Sets initial queue in the  │ unsigned integer (16 bit) │
       │                   │ range, if fanout is used.  │                           │
       ├───────────────────┼────────────────────────────┼───────────────────────────┤
       │                   │                            │                           │
       │ queue_number_to   │ Sets closing queue in the  │ unsigned integer (16 bit) │
       │                   │ range, if fanout is used.  │                           │
       └───────────────────┴────────────────────────────┴───────────────────────────┘

       <b>Table</b> <b>75.</b> <b>queue</b> <b>statement</b> <b>flags</b>
       ┌────────┬──────────────────────────────────────┐
       │ <b>Flag</b>   │ <b>Description</b>                          │
       ├────────┼──────────────────────────────────────┤
       │        │                                      │
       │ bypass │ Let packets go through if userspace  │
       │        │ application cannot back off. Before  │
       │        │ using this flag, read                │
       │        │ libnetfilter_queue documentation for │
       │        │ performance tuning recommendations.  │
       ├────────┼──────────────────────────────────────┤
       │        │                                      │
       │ fanout │ Distribute packets between several   │
       │        │ queues.                              │
       └────────┴──────────────────────────────────────┘

   <b>DUP</b> <b>STATEMENT</b>
       The dup statement is used to duplicate a packet and send the copy to a different destination.

           <b>dup</b> <b>to</b> <u>device</u>
           <b>dup</b> <b>to</b> <u>address</u> <b>device</b> <u>device</u>

       <b>Table</b> <b>76.</b> <b>Dup</b> <b>statement</b> <b>values</b>
       ┌────────────┬──────────────────────────────┬──────────────────────────────┐
       │ <b>Expression</b> │ <b>Description</b>                  │ <b>Type</b>                         │
       ├────────────┼──────────────────────────────┼──────────────────────────────┤
       │            │                              │                              │
       │ address    │ Specifies that the copy of   │ ipv4_addr, ipv6_addr, e.g.   │
       │            │ the packet should be sent to │ abcd::1234, or you can use a │
       │            │ a new gateway.               │ mapping, e.g. ip saddr map { │
       │            │                              │ 192.168.1.2 : 10.1.1.1 }     │
       ├────────────┼──────────────────────────────┼──────────────────────────────┤
       │            │                              │                              │
       │ device     │ Specifies that the copy      │ string                       │
       │            │ should be transmitted via    │                              │
       │            │ device.                      │                              │
       └────────────┴──────────────────────────────┴──────────────────────────────┘

       <b>Using</b> <b>the</b> <b>dup</b> <b>statement</b>.

           # send to machine with ip address 10.2.3.4 on eth0
           ip filter forward dup to 10.2.3.4 device "eth0"

           # copy raw frame to another interface
           netdev ingress dup to "eth0"
           dup to "eth0"

           # combine with map dst addr to gateways
           dup to ip daddr map { 192.168.7.1 : "eth0", 192.168.7.2 : "eth1" }

   <b>FWD</b> <b>STATEMENT</b>
       The fwd statement is used to redirect a raw packet to another interface. It is only available in the
       netdev family ingress and egress hooks. It is similar to the dup statement except that no copy is made.

       You can also specify the address of the next hop and the device to forward the packet to. This updates
       the source and destination MAC address of the packet by transmitting it through the neighboring layer.
       This also decrements the ttl field of the IP packet. This provides a way to effectively bypass the
       classical forwarding path, thus skipping the fib (forwarding information base) lookup.

           <b>fwd</b> <b>to</b> <u>device</u>
           <b>fwd</b> [<b>ip</b> | <b>ip6</b>] <b>to</b> <u>address</u> <b>device</b> <u>device</u>

       <b>Using</b> <b>the</b> <b>fwd</b> <b>statement</b>.

           # redirect raw packet to device
           netdev ingress fwd to "eth0"

           # forward packet to next hop 192.168.200.1 via eth0 device
           netdev ingress ether saddr set fwd ip to 192.168.200.1 device "eth0"

   <b>SET</b> <b>STATEMENT</b>
       The set statement is used to dynamically add or update elements in a set from the packet path. The set
       setname must already exist in the given table and must have been created with one or both of the dynamic
       and the timeout flags. The dynamic flag is required if the set statement expression includes a stateful
       object. The timeout flag is implied if the set is created with a timeout, and is required if the set
       statement updates elements, rather than adding them. Furthermore, these sets should specify both a
       maximum set size (to prevent memory exhaustion), and their elements should have a timeout (so their
       number will not grow indefinitely) either from the set definition or from the statement that adds or
       updates them. The set statement can be used to e.g. create dynamic blacklists.

       Dynamic updates are also supported with maps. In this case, the <b>add</b> or <b>update</b> rule needs to provide both
       the key and the data element (value), separated via <u>:</u>.

           {<b>add</b> | <b>update</b>} <b>@</b><u>setname</u> <b>{</b> <u>expression</u> [<b>timeout</b> <u>timeout</u>] [<b>comment</b> <u>string</u>] <b>}</b>

       <b>Example</b> <b>for</b> <b>simple</b> <b>blacklist</b>.

           # declare a set, bound to table "filter", in family "ip".
           # Timeout and size are mandatory because we will add elements from packet path.
           # Entries will timeout after one minute, after which they might be
           # re-added if limit condition persists.
           nft add set ip filter blackhole \
               "{ type ipv4_addr; flags dynamic; timeout 1m; size 65536; }"

           # declare a set to store the limit per saddr.
           # This must be separate from blackhole since the timeout is different
           nft add set ip filter flood \
               "{ type ipv4_addr; flags dynamic; timeout 10s; size 128000; }"

           # whitelist internal interface.
           nft add rule ip filter input meta iifname "internal" accept

           # drop packets coming from blacklisted ip addresses.
           nft add rule ip filter input ip saddr @blackhole counter drop

           # add source ip addresses to the blacklist if more than 10 tcp connection
           # requests occurred per second and ip address.
           nft add rule ip filter input tcp flags syn tcp dport ssh \
               add @flood { ip saddr limit rate over 10/second } \
               add @blackhole { ip saddr } \
               drop

           # inspect state of the sets.
           nft list set ip filter flood
           nft list set ip filter blackhole

           # manually add two addresses to the blackhole.
           nft add element filter blackhole { 10.2.3.4, 10.23.1.42 }

   <b>MAP</b> <b>STATEMENT</b>
       The map statement is used to lookup data based on some specific input key.

           <u>expression</u> <b>map</b> <b>{</b> <u>MAP_ELEMENTS</u> <b>}</b>

           <u>MAP_ELEMENTS</u> := <u>MAP_ELEMENT</u> [<b>,</b> <u>MAP_ELEMENTS</u>]
           <u>MAP_ELEMENT</u>  := <u>key</u> <b>:</b> <u>value</u>

       The <u>key</u> is a value returned by <u>expression</u>.

       <b>Using</b> <b>the</b> <b>map</b> <b>statement</b>.

           # select DNAT target based on TCP dport:
           # connections to port 80 are redirected to 192.168.1.100,
           # connections to port 8888 are redirected to 192.168.1.101
           nft add rule ip nat prerouting dnat tcp dport map { 80 : 192.168.1.100, 8888 : 192.168.1.101 }

           # source address based SNAT:
           # packets from net 192.168.1.0/24 will appear as originating from 10.0.0.1,
           # packets from net 192.168.2.0/24 will appear as originating from 10.0.0.2
           nft add rule ip nat postrouting snat to ip saddr map { 192.168.1.0/24 : 10.0.0.1, 192.168.2.0/24 : 10.0.0.2 }

   <b>VMAP</b> <b>STATEMENT</b>
       The verdict map (vmap) statement works analogous to the map statement, but contains verdicts as values.

           <u>expression</u> <b>vmap</b> <b>{</b> <u>VMAP_ELEMENTS</u> <b>}</b>

           <u>VMAP_ELEMENTS</u> := <u>VMAP_ELEMENT</u> [<b>,</b> <u>VMAP_ELEMENTS</u>]
           <u>VMAP_ELEMENT</u>  := <u>key</u> <b>:</b> <u>verdict</u>

       <b>Using</b> <b>the</b> <b>vmap</b> <b>statement</b>.

           # jump to different chains depending on layer 4 protocol type:
           nft add rule ip filter input ip protocol vmap { tcp : jump tcp-chain, udp : jump udp-chain , icmp : jump icmp-chain }

   <b>XT</b> <b>STATEMENT</b>
       This represents an xt statement from xtables compat interface. It is a fallback if translation is not
       available or not complete.

           <b>xt</b> <u>TYPE</u> <u>NAME</u>

           <u>TYPE</u> := <b>match</b> | <b>target</b> | <b>watcher</b>

       Seeing this means the ruleset (or parts of it) were created by <b>iptables-nft</b> and one should use that to
       manage it.

       <b>BEWARE:</b> nftables won’t restore these statements.

</pre><h4><b>ADDITIONAL</b> <b>COMMANDS</b></h4><pre>
       These are some additional commands included in nft.

   <b>LIST</b> <b>HOOKS</b>
       This shows the list of functions that have been registered for the given protocol family, including
       functions that have been registered implicitly by kernel modules such as nf_conntrack.

           <b>list</b> <b>hooks</b> [<u>family</u>]
           <b>list</b> <b>hooks</b> <b>netdev</b> [ <b>device</b> <u>DEVICE_NAME</u> ]

       <b>list</b> <b>hooks</b> is enough to display everything that is active on the system. Hooks in the netdev family are
       tied to a network device. If no device name is given, nft will query all network devices in the current
       network namespace. Example Usage:

       <b>List</b> <b>all</b> <b>active</b> <b>netfilter</b> <b>hooks</b> <b>in</b> <b>either</b> <b>the</b> <b>ip</b> <b>or</b> <b>ip6</b> <b>stack</b>.

           % nft list hooks inet
           family ip {
                   hook prerouting {
                           -0000000400 ipv4_conntrack_defrag [nf_defrag_ipv4]
                           -0000000200 ipv4_conntrack_in [nf_conntrack]
                           -0000000100 nf_nat_ipv4_pre_routing [nf_nat]
                   }
                   hook input {
                            0000000000 chain inet filter input [nf_tables]
                           +0000000100 nf_nat_ipv4_local_in [nf_nat]
           [..]

       The above shows a host that has nat, conntrack and ipv4 packet defragmentation enabled. For each hook
       location for the queried family a list of active hooks using the format

       <b>priority</b> <b>identifier</b> [<b>module_name</b>]

       will be shown.

       The <b>priority</b> value dictates the order in which the hooks are called. The list is sorted, the lowest
       number is run first.

       The priority value of hooks registered by the kernel cannot be changed. For basechains registered by
       nftables, this value corresponds to the <b>priority</b> value specified in the base chain definition.

       After the numerical value, information about the hook is shown. For basechains defined in nftables this
       includes the table family, the table name and the basechains name. For hooks coming from kernel modules,
       the function name is used instead.

       If a <b>module</b> <b>name</b> is given, the hook was registered by the kernel module with this name. You can use
       <u>modinfo</u> <b>module</b> <b>name</b> to obtain more information about the module.

       This functionality requires a kernel built with the option CONFIG_NETFILTER_NETLINK_HOOK enabled, either
       as a module or builtin. The module is named <b>nfnetlink_hook</b>.

   <b>MONITOR</b>
       The monitor command allows you to listen to Netlink events produced by the nf_tables subsystem. These are
       either related to creation and deletion of objects or to packets for which <b>meta</b> <b>nftrace</b> was enabled. When
       they occur, nft will print to stdout the monitored events in either JSON or native nft format.

           <b>monitor</b> [<b>new</b> | <b>destroy</b>] <u>MONITOR_OBJECT</u>
           <b>monitor</b> <b>trace</b>

           <u>MONITOR_OBJECT</u> := <b>tables</b> | <b>chains</b> | <b>sets</b> | <b>rules</b> | <b>elements</b> | <b>ruleset</b>

       To filter events related to a concrete object, use one of the keywords in <u>MONITOR_OBJECT</u>.

       To filter events related to a concrete action, use keyword <b>new</b> or <b>destroy</b>.

       The second form of invocation takes no further options and exclusively prints events generated for
       packets with <b>nftrace</b> enabled.

       Hit ^C to finish the monitor operation.

       <b>Listen</b> <b>to</b> <b>all</b> <b>events,</b> <b>report</b> <b>in</b> <b>native</b> <b>nft</b> <b>format</b>.

           % nft monitor

       <b>Listen</b> <b>to</b> <b>deleted</b> <b>rules,</b> <b>report</b> <b>in</b> <b>JSON</b> <b>format</b>.

           % nft -j monitor destroy rules

       <b>Listen</b> <b>to</b> <b>both</b> <b>new</b> <b>and</b> <b>destroyed</b> <b>chains,</b> <b>in</b> <b>native</b> <b>nft</b> <b>format</b>.

           % nft monitor chains

       <b>Listen</b> <b>to</b> <b>ruleset</b> <b>events</b> <b>such</b> <b>as</b> <b>table,</b> <b>chain,</b> <b>rule,</b> <b>set,</b> <b>counters</b> <b>and</b> <b>quotas,</b> <b>in</b> <b>native</b> <b>nft</b> <b>format</b>.

           % nft monitor ruleset

       <b>Trace</b> <b>incoming</b> <b>packets</b> <b>from</b> <b>host</b> <b>10.0.0.1</b>.

           % nft add rule filter input ip saddr 10.0.0.1 meta nftrace set 1
           % nft monitor trace

</pre><h4><b>ERROR</b> <b>REPORTING</b></h4><pre>
       When an error is detected, nft shows the line(s) containing the error, the position of the erroneous
       parts in the input stream and marks up the erroneous parts using carets (^). If the error results from
       the combination of two expressions or statements, the part imposing the constraints which are violated is
       marked using tildes (~).

       For errors returned by the kernel, nft cannot detect which parts of the input caused the error and the
       entire command is marked.

       <b>Error</b> <b>caused</b> <b>by</b> <b>single</b> <b>incorrect</b> <b>expression</b>.

           &lt;cmdline&gt;:1:19-22: Error: Interface does not exist
           filter output oif eth0
                             ^^^^

       <b>Error</b> <b>caused</b> <b>by</b> <b>invalid</b> <b>combination</b> <b>of</b> <b>two</b> <b>expressions</b>.

           &lt;cmdline&gt;:1:28-36: Error: Right hand side of relational expression (==) must be constant
           filter output tcp dport == tcp dport
                                   ~~ ^^^^^^^^^

       <b>Error</b> <b>returned</b> <b>by</b> <b>the</b> <b>kernel</b>.

           &lt;cmdline&gt;:0:0-23: Error: Could not process rule: Operation not permitted
           filter output oif wlan0
           ^^^^^^^^^^^^^^^^^^^^^^^

</pre><h4><b>EXIT</b> <b>STATUS</b></h4><pre>
       On success, nft exits with a status of 0. Unspecified errors cause it to exit with a status of 1, memory
       allocation errors with a status of 2, unable to open Netlink socket with 3.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
           <a href="../man3/libnftables.3.html">libnftables</a>(3), <a href="../man5/libnftables-json.5.html">libnftables-json</a>(5), <a href="../man8/iptables.8.html">iptables</a>(8), <a href="../man8/ip6tables.8.html">ip6tables</a>(8), <a href="../man8/arptables.8.html">arptables</a>(8), <a href="../man8/ebtables.8.html">ebtables</a>(8), <a href="../man8/ip.8.html">ip</a>(8), <a href="../man8/tc.8.html">tc</a>(8)

       There is an official wiki at: https://wiki.nftables.org

</pre><h4><b>AUTHORS</b></h4><pre>
       nftables was written by Patrick McHardy and Pablo Neira Ayuso, among many other contributors from the
       Netfilter community.

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright © 2008-2014 Patrick McHardy &lt;<a href="mailto:kaber@trash.net">kaber@trash.net</a>&gt; Copyright © 2013-2018 Pablo Neira Ayuso
       &lt;<a href="mailto:pablo@netfilter.org">pablo@netfilter.org</a>&gt;

       nftables is free software; you can redistribute it and/or modify it under the terms of the GNU General
       Public License version 2 as published by the Free Software Foundation.

       This documentation is licensed under the terms of the Creative Commons Attribution-ShareAlike 4.0
       license, CC BY-SA 4.0 <a href="http://creativecommons.org/licenses/by-sa/4.0/">http://creativecommons.org/licenses/by-sa/4.0/</a>.

                                                   04/22/2025                                             <u><a href="../man8/NFT.8.html">NFT</a></u>(8)
</pre>
 </div>
</div></section>
</div>
</body>
</html>