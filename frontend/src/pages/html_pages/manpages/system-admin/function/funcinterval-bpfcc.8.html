<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>funcinterval - Time interval between the same function, tracepoint as a histogram.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/bpfcc-tools">bpfcc-tools_0.31.0+ds-7ubuntu2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       funcinterval - Time interval between the same function, tracepoint as a histogram.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>funcinterval</b> <b>[-h]</b> <b>[-p</b> <b>PID]</b> <b>[-i</b> <b>INTERVAL]</b> <b>[-d</b> <b>DURATION]</b> <b>[-T]</b> <b>[-u]</b> <b>[-m]</b> <b>[-v]</b> <b>pattern</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This tool times interval between the same function as a histogram.

       eBPF/bcc  is  very  suitable  for  platform  performance tuning.  By funclatency, we can profile specific
       functions to know how latency this function costs. However, sometimes performance drop is not  about  the
       latency of function but the interval between function calls.  funcinterval is born for this purpose.

       This tool uses in-kernel eBPF maps for storing timestamps and the histogram, for efficiency.

       WARNING:  This  uses  dynamic tracing of (what can be many) functions, an activity that has had issues on
       some kernel versions (risk of panics or freezes). Test, and know what you are doing, before use.

       Since this uses BPF, only the root user can use this tool.

</pre><h4><b>REQUIREMENTS</b></h4><pre>
       CONFIG_BPF and bcc.

</pre><h4><b>OPTIONS</b></h4><pre>
       pattern Function name.  -h Print usage message.

       -p PID Trace this process ID only.

       -i INTERVAL
              Print output every interval seconds.

       -d DURATION
              Total duration of trace, in seconds.

       -T     Include timestamps on output.

       -u     Output histogram in microseconds.

       -m     Output histogram in milliseconds.

       -v     Print the BPF program (for debugging purposes).

</pre><h4><b>EXAMPLES</b></h4><pre>
       Time the interval of do_sys_open() kernel function as a histogram:
              # <b>funcinterval</b> <b>do_sys_open</b>

       Time the interval of xhci_ring_ep_doorbell(), in microseconds:
              # <b>funcinterval</b> <b>-u</b> <b>xhci_ring_ep_doorbell</b>

       Time the interval of do_nanosleep(), in milliseconds
              # <b>funcinterval</b> <b>-m</b> <b>do_nanosleep</b>

       Output every 5 seconds, with timestamps:
              # <b>funcinterval</b> <b>-mTi</b> <b>5</b> <b>vfs_read</b>

       Time process 181 only:
              # <b>funcinterval</b> <b>-p</b> <b>181</b> <b>vfs_read</b>

       Time the interval of mm_vmscan_direct_reclaim_begin tracepoint:
              # <b>funcinterval</b> <b>t:vmscan:mm_vmscan_direct_reclaim_begin</b>

       Time the interval of c:malloc used by top every 3 seconds:
              # <b>funcinterval</b> <b>-p</b> <b>`pidof</b> <b>-s</b> <b>top`</b> <b>-i</b> <b>3</b> <b>c:malloc</b>

       Time /usr/local/bin/python main function:
              # <b>funcinterval</b> <b>/usr/local/bin/python:main</b>

</pre><h4><b>FIELDS</b></h4><pre>
       necs   Nanosecond range

       usecs  Microsecond range

       msecs  Millisecond range

       count  How many calls fell into this range

       distribution
              An ASCII bar chart to visualize the distribution (count column)

</pre><h4><b>OVERHEAD</b></h4><pre>
       This traces kernel functions and maintains in-kernel timestamps and a histogram, which are asynchronously
       copied to user-space. While this method is very efficient, the rate of kernel functions can also be  very
       high  (&gt;1M/sec),  at which point the overhead is expected to be measurable. Measure in a test environment
       and understand overheads before use. You can also use funccount to measure the rate of  kernel  functions
       over a short duration, to set some expectations before use.

</pre><h4><b>SOURCE</b></h4><pre>
       This is from bcc.

              https://github.com/iovisor/bcc

       Also  look  in  the bcc distribution for a companion _examples.txt file containing example usage, output,
       and commentary for this tool.

</pre><h4><b>OS</b></h4><pre>
       Linux

</pre><h4><b>STABILITY</b></h4><pre>
       Unstable - in development.

</pre><h4><b>AUTHOR</b></h4><pre>
       Edward Wu

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man8/funclatency.8.html">funclatency</a>(8) <a href="../man8/funccount.8.html">funccount</a>(8)

USER COMMANDS                                      2020-05-27                                    <u><a href="../man8/funcinterval.8.html">funcinterval</a></u>(8)
</pre>
 </div>
</div></section>
</div>
</body>
</html>