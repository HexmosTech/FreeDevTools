<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>tcpdump - dump traffic on a network</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcpdump">tcpdump_4.99.5-2ubuntu1_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       tcpdump - dump traffic on a network

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>tcpdump</b> [ <b>-AbdDefhHIJKlLnNOpqStuUvxX#</b> ] [ <b>-B</b> <u>buffer_size</u> ]
               [ <b>-c</b> <u>count</u> ] [ <b>--count</b> ] [ <b>-C</b> <u>file_size</u> ]
               [ <b>-E</b> <u>spi@ipaddr</u> <u>algo:secret,...</u>  ]
               [ <b>-F</b> <u>file</u> ] [ <b>-G</b> <u>rotate_seconds</u> ] [ <b>-i</b> <u>interface</u> ]
               [ <b>--immediate-mode</b> ] [ <b>-j</b> <u>tstamp_type</u> ] [ <b>-m</b> <u>module</u> ]
               [ <b>-M</b> <u>secret</u> ] [ <b>--number</b> ] [ <b>--print</b> ] [ <b>-Q</b> <u>in|out|inout</u> ]
               [ <b>-r</b> <u>file</u> ] [ <b>-s</b> <u>snaplen</u> ] [ <b>-T</b> <u>type</u> ] [ <b>--version</b> ]
               [ <b>-V</b> <u>file</u> ] [ <b>-w</b> <u>file</u> ] [ <b>-W</b> <u>filecount</u> ] [ <b>-y</b> <u>datalinktype</u> ]
               [ <b>-z</b> <u>postrotate-command</u> ] [ <b>-Z</b> <u>user</u> ]
               [ <b>--time-stamp-precision=</b><u>tstamp_precision</u> ]
               [ <b>--micro</b> ] [ <b>--nano</b> ]
               [ <u>expression</u> ]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <u>Tcpdump</u> prints out a description of the contents of packets on a network interface that match the Boolean
       <u>expression</u>  (see  <b><a href="../man7/pcap-filter.7.html">pcap-filter</a></b>(7) for the <u>expression</u> syntax); the description is preceded by a time stamp,
       printed, by default, as hours, minutes, seconds, and fractions of a second since midnight.  It  can  also
       be  run  with  the  <b>-w</b> flag, which causes it to save the packet data to a file for later analysis, and/or
       with the <b>-r</b> flag, which causes it to read from a saved packet file rather than to  read  packets  from  a
       network  interface.   It can also be run with the <b>-V</b> flag, which causes it to read a list of saved packet
       files. In all cases, only packets that match <u>expression</u> will be processed by <u>tcpdump</u>.

       <u>Tcpdump</u> will, if not run with the <b>-c</b> flag, continue capturing packets until it is interrupted by a SIGINT
       signal (generated, for example, by typing your interrupt character, typically  control-C)  or  a  SIGTERM
       signal  (typically  generated with the <b><a href="../man1/kill.1.html">kill</a></b>(1) command); if run with the <b>-c</b> flag, it will capture packets
       until it is interrupted by a SIGINT or SIGTERM signal or  the  specified  number  of  packets  have  been
       processed.

       When <u>tcpdump</u> finishes capturing packets, it will report counts of:

              packets ``captured'' (this is the number of packets that <u>tcpdump</u> has received and processed);

              packets  ``received  by  filter''  (the  meaning of this depends on the OS on which you're running
              <u>tcpdump</u>, and possibly on the way the OS was configured - if a filter was specified on the  command
              line,  on  some  OSes  it  counts  packets  regardless  of whether they were matched by the filter
              expression and, even if they were matched by the filter expression, regardless of whether  <u>tcpdump</u>
              has  read  and  processed  them yet, on other OSes it counts only packets that were matched by the
              filter expression regardless of whether <u>tcpdump</u> has read and processed them yet, and on other OSes
              it counts only packets that were matched by the filter expression and were processed by <u>tcpdump</u>);

              packets ``dropped by kernel'' (this is the number of packets that were dropped, due to a  lack  of
              buffer  space,  by  the  packet capture mechanism in the OS on which <u>tcpdump</u> is running, if the OS
              reports that information to applications; if not, it will be reported as 0).

       On platforms that support the SIGINFO signal, such as most BSDs (including macOS) and Digital/Tru64 UNIX,
       it will report those counts when it receives a SIGINFO signal (generated, for  example,  by  typing  your
       ``status''  character,  typically  control-T,  although  on some platforms, such as macOS, the ``status''
       character is not set by default, so you must set it with <b><a href="../man1/stty.1.html">stty</a></b>(1) in order to use it)  and  will  continue
       capturing packets. On platforms that do not support the SIGINFO signal, the same can be achieved by using
       the SIGUSR1 signal.

       Using  the  SIGUSR2  signal  along with the <b>-w</b> flag will forcibly flush the packet buffer into the output
       file.

       Reading packets from a  network  interface  may  require  that  you  have  special  privileges;  see  the
       <b><a href="../man3PCAP/pcap.3PCAP.html">pcap</a></b>(3PCAP) man page for details.  Reading a saved packet file doesn't require special privileges.

</pre><h4><b>OPTIONS</b></h4><pre>
       <b>-A</b>     Print each packet (minus its link level header) in ASCII.  Handy for capturing web pages.

       <b>-b</b>     Print the AS number in BGP packets in ASDOT notation rather than ASPLAIN notation.

       <b>-B</b> <u>buffer_size</u>
       <b>--buffer-size=</b><u>buffer_size</u>
              Set the operating system capture buffer size to <u>buffer_size</u>, in units of KiB (1024 bytes).

       <b>-c</b> <u>count</u>
              Exit after receiving <u>count</u> packets.

       <b>--count</b>
              Print only on stdout the packet count when reading capture file(s) instead of parsing/printing the
              packets.  If  a  filter  is  specified  on the command line, <u>tcpdump</u> counts only packets that were
              matched by the filter expression.

       <b>-C</b> <u>file_size</u>
              Before writing a raw packet to a savefile,  check  whether  the  file  is  currently  larger  than
              <u>file_size</u>  and,  if  so, close the current savefile and open a new one.  Savefiles after the first
              savefile will have the name specified with the <b>-w</b> flag, with a number after it, starting at 1  and
              continuing  upward.   The units of <u>file_size</u> are millions of bytes (1,000,000 bytes, not 1,048,576
              bytes).

              Note that when used with <b>-Z</b> option (enabled by default), privileges  are  dropped  before  opening
              first savefile.

       <b>-d</b>     Dump the compiled packet-matching code in a human readable form to standard output and stop.

              Please mind that although code compilation is always DLT-specific, typically it is impossible (and
              unnecessary)  to  specify which DLT to use for the dump because <u>tcpdump</u> uses either the DLT of the
              input pcap file specified with <b>-r</b>, or the default DLT of the network interface specified with  <b>-i</b>,
              or  the  particular  DLT  of the network interface specified with <b>-y</b> and <b>-i</b> respectively. In these
              cases the dump shows the same exact code that would filter the input file or the network interface
              without <b>-d</b>.

              However, when neither <b>-r</b> nor <b>-i</b> is specified, specifying  <b>-d</b>  prevents  <u>tcpdump</u>  from  guessing  a
              suitable  network  interface  (see <b>-i</b>).  In this case the DLT defaults to EN10MB and can be set to
              another valid value manually with <b>-y</b>.

       <b>-dd</b>    Dump packet-matching code as a <b>C</b> program fragment.

       <b>-ddd</b>   Dump packet-matching code as decimal numbers (preceded with a count).

       <b>-D</b>
       <b>--list-interfaces</b>
              Print the list of the network interfaces available on the system and on which <u>tcpdump</u> can  capture
              packets.   For each network interface, a number and an interface name, possibly followed by a text
              description of the interface, are printed.  The interface name or the number can  be  supplied  to
              the <b>-i</b> flag to specify an interface on which to capture.

              This  can  be  useful on systems that don't have a command to list them (e.g., Windows systems, or
              UNIX systems lacking <b>ifconfig</b> <b>-a</b>); the number can be useful on Windows  2000  and  later  systems,
              where the interface name is a somewhat complex string.

              The <b>-D</b> flag will not be supported if <u>tcpdump</u> was built with an older version of <u>libpcap</u> that lacks
              the <b><a href="../man3PCAP/pcap_findalldevs.3PCAP.html">pcap_findalldevs</a></b>(3PCAP) function.

       <b>-e</b>     Print  the link-level header on each dump line.  This can be used, for example, to print MAC layer
              addresses for protocols such as Ethernet and IEEE 802.11.

       <b>-E</b>     Use <u>spi@ipaddr</u> <u>algo:secret</u> for decrypting IPsec ESP packets that are addressed to <u>addr</u> and contain
              Security Parameter Index value <u>spi</u>. This  combination  may  be  repeated  with  comma  or  newline
              separation.

              Note that setting the secret for IPv4 ESP packets is supported at this time.

              Algorithms  may be <b>des-cbc</b>, <b>3des-cbc</b>, <b>blowfish-cbc</b>, <b>rc3-cbc</b>, <b>cast128-cbc</b>, or <b>none</b>.  The default is
              <b>des-cbc</b>.  The ability to decrypt packets is only present if <u>tcpdump</u> was compiled with cryptography
              enabled.

              <u>secret</u> is the ASCII text for ESP secret key.  If preceded by 0x, then a hex value will be read.

              The option assumes RFC 2406 ESP, not RFC 1827 ESP.  The option is only for debugging purposes, and
              the use of this option with a true `secret' key is discouraged.  By presenting  IPsec  secret  key
              onto command line you make it visible to others, via <u><a href="../man1/ps.1.html">ps</a></u>(1) and other occasions.

              In  addition  to  the  above  syntax,  the  syntax  <u>file</u> <u>name</u> may be used to have tcpdump read the
              provided file in. The file is  opened  upon  receiving  the  first  ESP  packet,  so  any  special
              permissions that tcpdump may have been given should already have been given up.

       <b>-f</b>     Print  `foreign'  IPv4  addresses numerically rather than symbolically (this option is intended to
              get around serious brain damage in Sun's NIS server — usually it hangs  forever  translating  non-
              local internet numbers).

              The  test for `foreign' IPv4 addresses is done using the IPv4 address and netmask of the interface
              on that capture is being done.  If that address or netmask are not available, either  because  the
              interface  on  that  capture  is  being  done has no address or netmask or because it is the "any"
              pseudo-interface, which is available in Linux and in recent versions of  macOS  and  Solaris,  and
              which can capture on more than one interface, this option will not work correctly.

       <b>-F</b> <u>file</u>
              Use  <u>file</u>  as input for the filter expression.  An additional expression given on the command line
              is ignored.

       <b>-G</b> <u>rotate_seconds</u>
              If specified, rotates the dump file specified with the <b>-w</b>  option  every  <u>rotate_seconds</u>  seconds.
              Savefiles  will  have  the  name  specified by <b>-w</b> which should include a time format as defined by
              <b><a href="../man3/strftime.3.html">strftime</a></b>(3).  If no time format is specified, each new file will overwrite the previous.  Whenever
              a generated filename is not unique, tcpdump will overwrite the preexisting data; providing a  time
              specification that is coarser than the capture period is therefore not advised.

              If used in conjunction with the <b>-C</b> option, filenames will take the form of `<u>file</u>&lt;count&gt;'.

       <b>-h</b>
       <b>--help</b> Print the tcpdump and libpcap version strings, print a usage message, and exit.

       <b>--version</b>
              Print the tcpdump and libpcap version strings and exit.

       <b>-H</b>     Attempt to detect 802.11s draft mesh headers.

       <b>-i</b> <u>interface</u>
       <b>--interface=</b><u>interface</u>
              Listen,  report  the  list of link-layer types, report the list of time stamp types, or report the
              results of compiling a filter expression on <u>interface</u>.  If unspecified and if the <b>-d</b> flag  is  not
              given, <u>tcpdump</u> searches the system interface list for the lowest numbered, configured up interface
              (excluding loopback), which may turn out to be, for example, ``eth0''.

              On  Linux  systems  with  2.2  or  later  kernels  and on recent versions of macOS and Solaris, an
              <u>interface</u> argument of ``any'' can be used to capture  packets  from  all  interfaces.   Note  that
              captures on the ``any'' pseudo-interface will not be done in promiscuous mode.

              If  the  <b>-D</b>  flag  is  supported,  an  interface number as printed by that flag can be used as the
              <u>interface</u> argument, if no interface on the system has that number as a name.

       <b>-I</b>
       <b>--monitor-mode</b>
              Put the interface in "monitor mode"; this is supported only on IEEE 802.11 Wi-Fi  interfaces,  and
              supported only on some operating systems.

              Note  that  in  monitor  mode  the  adapter  might  disassociate  from the network with which it's
              associated, so that you will not be able to use any wireless networks  with  that  adapter.   This
              could  prevent  accessing files on a network server, or resolving host names or network addresses,
              if you are capturing in monitor mode and  are  not  connected  to  another  network  with  another
              adapter.

              This  flag  will  affect  the output of the <b>-L</b> flag.  If <b>-I</b> isn't specified, only those link-layer
              types available when not in monitor mode will be shown; if <b>-I</b> is specified, only those  link-layer
              types available when in monitor mode will be shown.

       <b>--immediate-mode</b>
              Capture  in  "immediate  mode".   In  this  mode, packets are delivered to tcpdump as soon as they
              arrive, rather than being buffered for efficiency.  This is  the  default  when  printing  packets
              rather than saving packets to a ``savefile'' if the packets are being printed to a terminal rather
              than to a file or pipe.

       <b>-j</b> <u>tstamp_type</u>
       <b>--time-stamp-type=</b><u>tstamp_type</u>
              Set the time stamp type for the capture to <u>tstamp_type</u>.  The names to use for the time stamp types
              are  given  in  <b><a href="../man7/pcap-tstamp.7.html">pcap-tstamp</a></b>(7);  not  all the types listed there will necessarily be valid for any
              given interface.

       <b>-J</b>
       <b>--list-time-stamp-types</b>
              List the supported time stamp types for the interface and exit.  If the time stamp type cannot  be
              set for the interface, no time stamp types are listed.

       <b>--time-stamp-precision=</b><u>tstamp_precision</u>
              When  capturing,  set  the  time  stamp  precision for the capture to <u>tstamp_precision</u>.  Note that
              availability of high precision time stamps (nanoseconds) and their actual accuracy is platform and
              hardware dependent.  Also note that when writing captures  made  with  nanosecond  accuracy  to  a
              savefile,  the  time stamps are written with nanosecond resolution, and the file is written with a
              different magic number, to indicate that the time stamps are in seconds and nanoseconds;  not  all
              programs that read pcap savefiles will be able to read those captures.

              When  reading  a  savefile, convert time stamps to the precision specified by <u>timestamp_precision</u>,
              and display them with that resolution.  If the precision specified is less than the  precision  of
              time stamps in the file, the conversion will lose precision.

              The  supported  values  for  <u>timestamp_precision</u> are <b>micro</b> for microsecond resolution and <b>nano</b> for
              nanosecond resolution.  The default is microsecond resolution.

       <b>--micro</b>
       <b>--nano</b> Shorthands for <b>--time-stamp-precision=micro</b> or  <b>--time-stamp-precision=nano</b>,  adjusting  the  time
              stamp  precision  accordingly.  When reading packets from a savefile, using <b>--micro</b> truncates time
              stamps if the savefile was created with nanosecond precision.  In  contrast,  a  savefile  created
              with microsecond precision will have trailing zeroes added to the time stamp when <b>--nano</b> is used.

       <b>-K</b>
       <b>--dont-verify-checksums</b>
              Don't  attempt  to  verify  IP, TCP, or UDP checksums.  This is useful for interfaces that perform
              some or all of those checksum calculation in hardware; otherwise, all outgoing TCP checksums  will
              be flagged as bad.

       <b>-l</b>     Make stdout line buffered.  Useful if you want to see the data while capturing it.  E.g.,

                     <b>tcpdump</b> <b>-l</b> <b>|</b> <b>tee</b> <b>dat</b>

              or

                     <b>tcpdump</b> <b>-l</b> <b>&gt;</b> <b>dat</b> <b>&amp;</b> <b>tail</b> <b>-f</b> <b>dat</b>

              Note  that  on  Windows,``line  buffered''  means  ``unbuffered'', so that WinDump will write each
              character individually if <b>-l</b> is specified.

              <b>-U</b> is similar to <b>-l</b> in its behavior, but it will cause output to be ``packet-buffered'',  so  that
              the  output  is  written  to stdout at the end of each packet rather than at the end of each line;
              this is buffered on all platforms, including Windows.

       <b>-L</b>
       <b>--list-data-link-types</b>
              List the known data link types for the interface, in the specified mode, and exit.   The  list  of
              known  data  link  types may be dependent on the specified mode; for example, on some platforms, a
              Wi-Fi interface might support one set of data link types when not in monitor mode (for example, it
              might support only fake Ethernet headers, or might support 802.11 headers but not  support  802.11
              headers  with  radio  information)  and  another  set of data link types when in monitor mode (for
              example, it might support 802.11 headers, or  802.11  headers  with  radio  information,  only  in
              monitor mode).

       <b>-m</b> <u>module</u>
              Load  SMI  MIB module definitions from file <u>module</u>.  This option can be used several times to load
              several MIB modules into <u>tcpdump</u>.

       <b>-M</b> <u>secret</u>
              Use <u>secret</u> as a shared secret for validating the digests found in TCP segments  with  the  TCP-MD5
              option (RFC 2385), if present.

       <b>-n</b>     Don't convert addresses (i.e., host addresses, port numbers, etc.) to names.

       <b>-N</b>     Don't  print  domain  name  qualification of host names.  E.g., if you give this flag then <u>tcpdump</u>
              will print ``nic'' instead of ``nic.ddn.mil''.

       <b>-#</b>
       <b>--number</b>
              Print a packet number at the beginning of the line.

       <b>-O</b>
       <b>--no-optimize</b>
              Do not run the packet-matching code optimizer.  This is useful only if you suspect a  bug  in  the
              optimizer.

       <b>-p</b>
       <b>--no-promiscuous-mode</b>
              <u>Don't</u>  put  the  interface into promiscuous mode.  Note that the interface might be in promiscuous
              mode for some other reason; hence, `-p' cannot be used as an abbreviation for `ether host  {local-
              hw-addr} or ether broadcast'.

       <b>--print</b>
              Print parsed packet output, even if the raw packets are being saved to a file with the <b>-w</b> flag.

       <b>-Q</b> <u>direction</u>
       <b>--direction=</b><u>direction</u>
              Choose  send/receive direction <u>direction</u> for which packets should be captured. Possible values are
              `in', `out' and `inout'. Not available on all platforms.

       <b>-q</b>     Quick (quiet?) output.  Print less protocol information so output lines are shorter.

       <b>-r</b> <u>file</u>
              Read packets from <u>file</u> (which was created with the <b>-w</b> option or by other tools that write pcap  or
              pcapng files).  Standard input is used if <u>file</u> is ``-''.

       <b>-S</b>
       <b>--absolute-tcp-sequence-numbers</b>
              Print absolute, rather than relative, TCP sequence numbers.

       <b>-s</b> <u>snaplen</u>
       <b>--snapshot-length=</b><u>snaplen</u>
              Snarf  <u>snaplen</u>  bytes  of  data from each packet rather than the default of 262144 bytes.  Packets
              truncated because of a limited snapshot are indicated in the output with ``[|<u>proto</u>]'', where <u>proto</u>
              is the name of the protocol level at which the truncation has occurred.

              Note that taking larger snapshots both increases the amount of time it takes  to  process  packets
              and,  effectively,  decreases  the amount of packet buffering.  This may cause packets to be lost.
              Note also that taking smaller snapshots will discard  data  from  protocols  above  the  transport
              layer,  which  loses  information  that  may  be important.  NFS and AFS requests and replies, for
              example, are very large, and much of the detail won't be available if a too-short snapshot  length
              is selected.

              If  you  need  to  reduce  the  snapshot  size  below the default, you should limit <u>snaplen</u> to the
              smallest number that will capture the protocol information you're interested in.  Setting  <u>snaplen</u>
              to  0  sets it to the default of 262144, for backwards compatibility with recent older versions of
              <u>tcpdump</u>.

       <b>-T</b> <u>type</u>
              Force packets selected by "<u>expression</u>" to be interpreted  the  specified  <u>type</u>.   Currently  known
              types  are  <b>aodv</b>  (Ad-hoc  On-demand  Distance  Vector  protocol), <b>carp</b> (Common Address Redundancy
              Protocol), <b>cnfp</b> (Cisco NetFlow protocol),  <b>domain</b>  (Domain  Name  System),  <b>lmp</b>  (Link  Management
              Protocol), <b>pgm</b> (Pragmatic General Multicast), <b>pgm_zmtp1</b> (ZMTP/1.0 inside PGM/EPGM), <b>ptp</b> (Precision
              Time Protocol), <b>radius</b> (RADIUS), <b>resp</b> (REdis Serialization Protocol), <b>rpc</b> (Remote Procedure Call),
              <b>rtcp</b>  (Real-Time  Applications  control  protocol),  <b>rtp</b>  (Real-Time  Applications protocol), <b>snmp</b>
              (Simple Network Management Protocol), <b>someip</b> (SOME/IP), <b>tftp</b> (Trivial File Transfer Protocol), <b>vat</b>
              (Visual Audio Tool), <b>vxlan</b> (Virtual eXtensible Local Area Network), <b>wb</b> (distributed  White  Board)
              and <b>zmtp1</b> (ZeroMQ Message Transport Protocol 1.0).

              Note  that the <b>pgm</b> type above affects UDP interpretation only, the native PGM is always recognised
              as IP protocol 113 regardless. UDP-encapsulated PGM is often called "EPGM" or "PGM/UDP".

              Note that the <b>pgm_zmtp1</b> type above affects interpretation of both native  PGM  and  UDP  at  once.
              During the native PGM decoding the application data of an ODATA/RDATA packet would be decoded as a
              ZeroMQ  datagram with ZMTP/1.0 frames.  During the UDP decoding in addition to that any UDP packet
              would be treated as an encapsulated PGM packet.

       <b>-t</b>     <u>Don't</u> print a timestamp on each dump line.

       <b>-tt</b>    Print the timestamp, as seconds since January 1, 1970, 00:00:00, UTC, and fractions  of  a  second
              since that time, on each dump line.

       <b>-ttt</b>   Print  a  delta  (microsecond  or  nanosecond  resolution  depending on the <b>--time-stamp-precision</b>
              option) between current and  previous  line  on  each  dump  line.   The  default  is  microsecond
              resolution.

       <b>-tttt</b>  Print  a timestamp, as hours, minutes, seconds, and fractions of a second since midnight, preceded
              by the date, on each dump line.

       <b>-ttttt</b> Print a delta (microsecond  or  nanosecond  resolution  depending  on  the  <b>--time-stamp-precision</b>
              option) between current and first line on each dump line.  The default is microsecond resolution.

       <b>-u</b>     Print undecoded NFS handles.

       <b>-U</b>
       <b>--packet-buffered</b>
              If  the  <b>-w</b> option is not specified, or if it is specified but the <b>--print</b> flag is also specified,
              make the printed packet output ``packet-buffered''; i.e., as the description of  the  contents  of
              each  packet  is printed, it will be written to the standard output, rather than, when not writing
              to a terminal, being written only when the output buffer fills.

              If the <b>-w</b> option is specified, make the saved raw packet output ``packet-buffered''; i.e., as each
              packet is saved, it will be written to the output file, rather than being written  only  when  the
              output buffer fills.

              The <b>-U</b> flag will not be supported if <u>tcpdump</u> was built with an older version of <u>libpcap</u> that lacks
              the <b><a href="../man3PCAP/pcap_dump_flush.3PCAP.html">pcap_dump_flush</a></b>(3PCAP) function.

       <b>-v</b>     When parsing and printing, produce (slightly more) verbose output.  For example, the time to live,
              identification,  total  length  and  options in an IP packet are printed.  Also enables additional
              packet integrity checks such as verifying the IP and ICMP header checksum.

              When writing to a file with the <b>-w</b> option and at the same time not reading from a file with the <b>-r</b>
              option, report to stderr, once per second, the number of packets captured. In Solaris, FreeBSD and
              possibly other operating systems this periodic update currently can cause loss of captured packets
              on their way from the kernel to tcpdump.

       <b>-vv</b>    Even more verbose output.  For example, additional fields are printed from NFS reply packets,  and
              SMB packets are fully decoded.

       <b>-vvv</b>   Even  more  verbose  output.   For example, telnet <b>SB</b> ... <b>SE</b> options are printed in full.  With <b>-X</b>
              Telnet options are printed in hex as well.

       <b>-V</b> <u>file</u>
              Read a list of filenames from <u>file</u>. Standard input is used if <u>file</u> is ``-''.

       <b>-w</b> <u>file</u>
              Write the raw packets to <u>file</u> rather than parsing and  printing  them  out.   They  can  later  be
              printed with the -r option.  Standard output is used if <u>file</u> is ``-''.

              This  output  will be buffered if written to a file or pipe, so a program reading from the file or
              pipe may not see packets for an arbitrary amount of time after they are received.  Use the <b>-U</b> flag
              to cause packets to be written as soon as they are received.

              The MIME type <u>application/vnd.tcpdump.pcap</u> has been registered  with  IANA  for  <u>pcap</u>  files.  The
              filename  extension  <u>.pcap</u>  appears to be the most commonly used along with <u>.cap</u> and <u>.dmp</u>. <u>Tcpdump</u>
              itself doesn't check the extension when reading capture files and doesn't add  an  extension  when
              writing  them  (it uses magic numbers in the file header instead). However, many operating systems
              and applications will use the  extension  if  it  is  present  and  adding  one  (e.g.  .pcap)  is
              recommended.

              See <b><a href="../man5/pcap-savefile.5.html">pcap-savefile</a></b>(5) for a description of the file format.

       <b>-W</b> <u>filecount</u>
              Used  in  conjunction  with  the  <b>-C</b>  option,  this  will limit the number of files created to the
              specified number, and begin overwriting files from  the  beginning,  thus  creating  a  'rotating'
              buffer.   In addition, it will name the files with enough leading 0s to support the maximum number
              of files, allowing them to sort correctly.

              Used in conjunction with the <b>-G</b> option, this will limit the number of rotated dump files that  get
              created, exiting with status 0 when reaching the limit.

              If used in conjunction with both <b>-C</b> and <b>-G,</b> the <b>-W</b> option will currently be ignored, and will only
              affect the file name.

       <b>-x</b>     When  parsing  and printing, in addition to printing the headers of each packet, print the data of
              each packet (minus its link level header) in hex.  The smaller of the  entire  packet  or  <u>snaplen</u>
              bytes  will  be  printed.  Note that this is the entire link-layer packet, so for link layers that
              pad (e.g. Ethernet), the padding bytes will also be  printed  when  the  higher  layer  packet  is
              shorter  than  the  required  padding.   In the current implementation this flag may have the same
              effect as <b>-xx</b> if the packet is truncated.

       <b>-xx</b>    When parsing and printing, in addition to printing the headers of each packet, print the  data  of
              each packet, <u>including</u> its link level header, in hex.

       <b>-X</b>     When  parsing  and printing, in addition to printing the headers of each packet, print the data of
              each packet (minus its link level header) in hex and ASCII.  This is very handy for analysing  new
              protocols.   In the current implementation this flag may have the same effect as <b>-XX</b> if the packet
              is truncated.

       <b>-XX</b>    When parsing and printing, in addition to printing the headers of each packet, print the  data  of
              each packet, <u>including</u> its link level header, in hex and ASCII.

       <b>-y</b> <u>datalinktype</u>
       <b>--linktype=</b><u>datalinktype</u>
              Set  the  data  link  type  to  use while capturing packets (see <b>-L</b>) or just compiling and dumping
              packet-matching code (see <b>-d</b>) to <u>datalinktype</u>.

       <b>-z</b> <u>postrotate-command</u>
              Used in conjunction with the <b>-C</b> or <b>-G</b> options, this will make  <u>tcpdump</u>  run  "  <u>postrotate-command</u>
              <u>file</u>  "  where  <u>file</u>  is the savefile being closed after each rotation. For example, specifying <b>-z</b>
              <b>gzip</b> or <b>-z</b> <b>bzip2</b> will compress each savefile using gzip or bzip2.

              Note that tcpdump will run the command in parallel to the capture, using the  lowest  priority  so
              that this doesn't disturb the capture process.

              And  in  case  you would like to use a command that itself takes flags or different arguments, you
              can always write a shell script that will take the savefile name as the only  argument,  make  the
              flags &amp; arguments arrangements and execute the command that you want.

       <b>-Z</b> <u>user</u>
       <b>--relinquish-privileges=</b><u>user</u>
              If <u>tcpdump</u> is running as root, after opening the capture device or input savefile, change the user
              ID to <u>user</u> and the group ID to the primary group of <u>user</u>.

              This behavior is enabled by default (<b>-Z</b> <b>tcpdump</b>), and can be disabled by <b>-Z</b> <b>root</b>.

        <u>expression</u>
              selects  which  packets will be dumped.  If no <u>expression</u> is given, all packets on the net will be
              dumped.  Otherwise, only packets for which <u>expression</u> is `true' will be dumped.

              For the <u>expression</u> syntax, see <b><a href="../man7/pcap-filter.7.html">pcap-filter</a></b>(7).

              The <u>expression</u> argument can be passed to <u>tcpdump</u> as either a single Shell argument, or as multiple
              Shell arguments, whichever is more  convenient.   Generally,  if  the  expression  contains  Shell
              metacharacters,  such  as  backslashes used to escape protocol names, it is easier to pass it as a
              single, quoted argument rather than to escape the Shell metacharacters.   Multiple  arguments  are
              concatenated with spaces before being parsed.

</pre><h4><b>EXAMPLES</b></h4><pre>
       To print all packets arriving at or departing from <u>sundown</u>:
              <b>tcpdump</b> <b>host</b> <b>sundown</b>

       To print traffic between <u>helios</u> and either <u>hot</u> or <u>ace</u>:
              <b>tcpdump</b> <b>host</b> <b>helios</b> <b>and</b> <b>\(</b> <b>hot</b> <b>or</b> <b>ace</b> <b>\)</b>

       To print all IP packets between <u>ace</u> and any host except <u>helios</u>:
              <b>tcpdump</b> <b>ip</b> <b>host</b> <b>ace</b> <b>and</b> <b>not</b> <b>helios</b>

       To print all traffic between local hosts and hosts at Berkeley:
              <b>tcpdump</b> <b>net</b> <b>ucb-ether</b>

       To  print  all  ftp traffic through internet gateway <u>snup</u>: (note that the expression is quoted to prevent
       the shell from (mis-)interpreting the parentheses):
              <b>tcpdump</b> <b>'gateway</b> <b>snup</b> <b>and</b> <b>(port</b> <b>ftp</b> <b>or</b> <b>ftp-data)'</b>

       To print traffic neither sourced from nor destined for local hosts (if you gateway to one other net, this
       stuff should never make it onto your local net).
              <b>tcpdump</b> <b>ip</b> <b>and</b> <b>not</b> <b>net</b> <u>localnet</u>

       To print the start and end packets (the SYN and FIN packets) of each TCP  conversation  that  involves  a
       non-local host.
              <b>tcpdump</b> <b>'tcp[tcpflags]</b> <b>&amp;</b> <b>(tcp-syn|tcp-fin)</b> <b>!=</b> <b>0</b> <b>and</b> <b>not</b> <b>src</b> <b>and</b> <b>dst</b> <b>net</b> <u>localnet</u><b>'</b>

       To print the TCP packets with flags RST and ACK both set.  (i.e. select only the RST and ACK flags in the
       flags field, and if the result is "RST and ACK both set", match)
              <b>tcpdump</b> <b>'tcp[tcpflags]</b> <b>&amp;</b> <b>(tcp-rst|tcp-ack)</b> <b>==</b> <b>(tcp-rst|tcp-ack)'</b>

       To  print  all IPv4 HTTP packets to and from port 80, i.e. print only packets that contain data, not, for
       example, SYN and FIN packets and ACK-only packets.  (IPv6 is left as an exercise for the reader.)
              <b>tcpdump</b> <b>'tcp</b> <b>port</b> <b>80</b> <b>and</b> <b>(((ip[2:2]</b> <b>-</b> <b>((ip[0]&amp;0xf)&lt;&lt;2))</b> <b>-</b> <b>((tcp[12]&amp;0xf0)&gt;&gt;2))</b> <b>!=</b> <b>0)'</b>

       To print IP packets longer than 576 bytes sent through gateway <u>snup</u>:
              <b>tcpdump</b> <b>'gateway</b> <b>snup</b> <b>and</b> <b>ip[2:2]</b> <b>&gt;</b> <b>576'</b>

       To print IP broadcast or multicast packets that were <u>not</u> sent via Ethernet broadcast or multicast:
              <b>tcpdump</b> <b>'ether[0]</b> <b>&amp;</b> <b>1</b> <b>=</b> <b>0</b> <b>and</b> <b>ip[16]</b> <b>&gt;=</b> <b>224'</b>

       To print all ICMP packets that are not echo requests/replies (i.e., not ping packets):
              <b>tcpdump</b> <b>'icmp[icmptype]</b> <b>!=</b> <b>icmp-echo</b> <b>and</b> <b>icmp[icmptype]</b> <b>!=</b> <b>icmp-echoreply'</b>

</pre><h4><b>OUTPUT</b> <b>FORMAT</b></h4><pre>
       The output of <u>tcpdump</u> is protocol dependent.  The following gives a brief  description  and  examples  of
       most of the formats.

   <b>Timestamps</b>
       By default, all output lines are preceded by a timestamp.  The timestamp is the current clock time in the
       form
              <u>hh:mm:ss.frac</u>
       and  is  as  accurate  as  the kernel's clock.  The timestamp reflects the time the kernel applied a time
       stamp to the packet.  No attempt is made to account for the time lag between when the  network  interface
       finished  receiving  the  packet from the network and when the kernel applied a time stamp to the packet;
       that time lag could include a delay between the time when the  network  interface  finished  receiving  a
       packet  from the network and the time when an interrupt was delivered to the kernel to get it to read the
       packet and a delay between the time when the kernel serviced the `new packet' interrupt and the time when
       it applied a time stamp to the packet.

   <b>Interface</b>
       When the <u>any</u> interface is selected on capture or when a link-type <u>LINUX_SLL2</u> capture  file  is  read  the
       interface  name  is  printed  after  the  timestamp.  This is followed by the packet type with <u>In</u> and <u>Out</u>
       denoting a packet destined for this host or originating  from  this  host  respectively.  Other  possible
       values are <u>B</u> for broadcast packets, <u>M</u> for multicast packets, and <u>P</u> for packets destined for other hosts.

   <b>Link</b> <b>Level</b> <b>Headers</b>
       If  the  '-e'  option  is  given,  the  link  level  header is printed out.  On Ethernets, the source and
       destination addresses, protocol, and packet length are printed.

       On FDDI networks, the  '-e' option causes <u>tcpdump</u> to print the `frame control'  field,   the  source  and
       destination  addresses,  and the packet length.  (The `frame control' field governs the interpretation of
       the rest of the packet.  Normal packets (such as those containing IP datagrams) are `async' packets, with
       a priority value between 0 and 7; for example, `<b>async4</b>'.  Such packets are assumed to  contain  an  802.2
       Logical  Link Control (LLC) packet; the LLC header is printed if it is <u>not</u> an ISO datagram or a so-called
       SNAP packet.

       On Token Ring networks, the '-e' option causes <u>tcpdump</u> to print the `access control' and `frame  control'
       fields,  the  source  and destination addresses, and the packet length.  As on FDDI networks, packets are
       assumed to contain an LLC packet.  Regardless of whether the '-e' option is specified or not, the  source
       routing information is printed for source-routed packets.

       On  802.11  networks,  the  '-e'  option  causes  <u>tcpdump</u> to print the `frame control' fields, all of the
       addresses in the 802.11 header, and the packet length.  As on  FDDI  networks,  packets  are  assumed  to
       contain an LLC packet.

       <u>(N.B.:</u> <u>The</u> <u>following</u> <u>description</u> <u>assumes</u> <u>familiarity</u> <u>with</u> <u>the</u> <u>SLIP</u> <u>compression</u> <u>algorithm</u> <u>described</u> <u>in</u> <u>RFC</u>
       <u>1144.)</u>

       On  SLIP  links,  a  direction  indicator  (``I''  for  inbound,  ``O''  for  outbound), packet type, and
       compression information are printed out.  The packet type is printed first.   The  three  types  are  <u>ip</u>,
       <u>utcp</u>,  and <u>ctcp</u>.  No further link information is printed for <u>ip</u> packets.  For TCP packets, the connection
       identifier is printed following the type.  If the packet is compressed, its  encoded  header  is  printed
       out.   The  special  cases are printed out as <b>*S+</b><u>n</u> and <b>*SA+</b><u>n</u>, where <u>n</u> is the amount by which the sequence
       number (or sequence number and ack) has changed.  If it is not a special case, zero or more  changes  are
       printed.   A  change  is indicated by U (urgent pointer), W (window), A (ack), S (sequence number), and I
       (packet ID), followed by a delta (+n or -n), or a new value (=n).  Finally, the amount  of  data  in  the
       packet and compressed header length are printed.

       For  example,  the  following  line  shows an outbound compressed TCP packet, with an implicit connection
       identifier; the ack has changed by 6, the sequence number by 49, and the packet ID  by  6;  there  are  3
       bytes of data and 6 bytes of compressed header:
              <b>O</b> <b>ctcp</b> <b>*</b> <b>A+6</b> <b>S+49</b> <b>I+6</b> <b>3</b> <b>(6)</b>

   <b>ARP/RARP</b> <b>Packets</b>
       ARP/RARP  output  shows  the  type  of  request  and  its  arguments.   The format is intended to be self
       explanatory.  Here is a short sample taken from the start of an `rlogin' from host <u>rtsg</u> to host <u>csam</u>:
              arp who-has csam tell rtsg
              arp reply csam is-at CSAM
       The first line says that rtsg sent an ARP packet asking for the Ethernet address of internet  host  csam.
       Csam  replies  with  its  Ethernet  address (in this example, Ethernet addresses are in caps and internet
       addresses in lower case).

       This would look less redundant if we had done <u>tcpdump</u> <u>-n</u>:
              arp who-has 128.3.254.6 tell 128.3.254.68
              arp reply 128.3.254.6 is-at 02:07:01:00:01:c4

       If we had done <u>tcpdump</u> <u>-e</u>, the fact that the first packet is broadcast and the second  is  point-to-point
       would be visible:
              RTSG Broadcast 0806  64: arp who-has csam tell rtsg
              CSAM RTSG 0806  64: arp reply csam is-at CSAM
       For  the  first  packet  this  says  the Ethernet source address is RTSG, the destination is the Ethernet
       broadcast address, the type field contained hex 0806 (type ETHER_ARP) and the total length was 64 bytes.

   <b>IPv4</b> <b>Packets</b>
       If the link-layer header is not being printed, for IPv4 packets, <b>IP</b> is printed after the time stamp.

       If the <b>-v</b> flag is specified, information from the IPv4 header is shown in parentheses after the <b>IP</b> or the
       link-layer header.  The general format of this information is:
              tos <u>tos</u>, ttl <u>ttl</u>, id <u>id</u>, offset <u>offset</u>, flags [<u>flags</u>], proto <u>proto</u>, length <u>length</u>, options (<u>options</u>)
       <u>tos</u> is the type of service field; if the ECN bits are non-zero, those are reported as <b><a href="../man1/ECT.1.html">ECT</a>(1)</b>, <b><a href="../man0/ECT.0.html">ECT</a>(0)</b>,  or
       <b>CE</b>.   <u>ttl</u>  is  the  time-to-live;  it  is not reported if it is zero.  <u>id</u> is the IP identification field.
       <u>offset</u> is the fragment offset field; it is printed whether this is part of a fragmented datagram or  not.
       <u>flags</u>  are  the  MF and DF flags; <b>+</b> is reported if MF is set, and <b>DF</b> is reported if F is set.  If neither
       are set, <b>.</b> is reported.  <u>proto</u> is the protocol ID field.  <u>length</u> is the total length field; if the packet
       is a presumed TSO (TCP Segmentation Offload) send, [was 0, presumed TSO] is reported.  <u>options</u> are the IP
       options, if any.

       Next, for TCP and UDP packets, the source and destination IP addresses and TCP or UDP ports, with  a  dot
       between  each  IP address and its corresponding port, will be printed, with a &gt; separating the source and
       destination.  For other protocols, the addresses will be printed, with a  &gt;  separating  the  source  and
       destination.  Higher level protocol information, if any, will be printed after that.

       For  fragmented  IP  datagrams,  the  first fragment contains the higher level protocol header; fragments
       after the first contain no higher level protocol header.  Fragmentation information will be printed  only
       with the <b>-v</b> flag, in the IP header information, as described above.

   <b>TCP</b> <b>Packets</b>
       <u>(N.B.:The</u>  <u>following</u>  <u>description</u> <u>assumes</u> <u>familiarity</u> <u>with</u> <u>the</u> <u>TCP</u> <u>protocol</u> <u>described</u> <u>in</u> <u>RFC</u> <u>793.</u>  <u>If</u> <u>you</u>
       <u>are</u> <u>not</u> <u>familiar</u> <u>with</u> <u>the</u> <u>protocol,</u> <u>this</u> <u>description</u> <u>will</u> <u>not</u> <u>be</u> <u>of</u> <u>much</u> <u>use</u> <u>to</u> <u>you.)</u>

       The general format of a TCP protocol line is:
              <u>src</u> &gt; <u>dst</u>: Flags [<u>tcpflags</u>], seq <u>data-seqno</u>, ack <u>ackno</u>, win <u>window</u>, urg <u>urgent</u>, options [<u>opts</u>], length <u>len</u>
       <u>Src</u> and <u>dst</u> are the source and destination IP addresses and ports.  <u>Tcpflags</u> are some  combination  of  S
       (SYN),  F (FIN), P (PSH), R (RST), U (URG), W (CWR), E (ECE) or `.' (ACK), or `none' if no flags are set.
       <u>Data-seqno</u> describes the portion of sequence space covered by  the  data  in  this  packet  (see  example
       below).   <u>Ackno</u>  is  sequence  number  of  the next data expected the other direction on this connection.
       <u>Window</u> is the number of bytes of receive buffer space available the other direction on  this  connection.
       <u>Urg</u>  indicates  there is `urgent' data in the packet.  <u>Opts</u> are TCP options (e.g., mss 1024).  <u>Len</u> is the
       length of payload data.

       <u>Iptype</u>, <u>Src</u>, <u>dst</u>, and <u>flags</u> are always present.  The other fields depend on the contents of the  packet's
       TCP protocol header and are output only if appropriate.

       Here is the opening portion of an rlogin from host <u>rtsg</u> to host <u>csam</u>.
              IP rtsg.1023 &gt; csam.login: Flags [S], seq 768512:768512, win 4096, opts [mss 1024]
              IP csam.login &gt; rtsg.1023: Flags [S.], seq, 947648:947648, ack 768513, win 4096, opts [mss 1024]
              IP rtsg.1023 &gt; csam.login: Flags [.], ack 1, win 4096
              IP rtsg.1023 &gt; csam.login: Flags [P.], seq 1:2, ack 1, win 4096, length 1
              IP csam.login &gt; rtsg.1023: Flags [.], ack 2, win 4096
              IP rtsg.1023 &gt; csam.login: Flags [P.], seq 2:21, ack 1, win 4096, length 19
              IP csam.login &gt; rtsg.1023: Flags [P.], seq 1:2, ack 21, win 4077, length 1
              IP csam.login &gt; rtsg.1023: Flags [P.], seq 2:3, ack 21, win 4077, urg 1, length 1
              IP csam.login &gt; rtsg.1023: Flags [P.], seq 3:4, ack 21, win 4077, urg 1, length 1
       The first line says that TCP port 1023 on rtsg sent a packet to port <u>login</u> on csam.  The <b>S</b> indicates that
       the  <u>SYN</u> flag was set.  The packet sequence number was 768512 and it contained no data.  (The notation is
       `first:last' which means `sequence numbers <u>first</u> up to but not including <u>last</u>'.)   There  was  no  piggy-
       backed  ACK,  the  available  receive  window  was  4096  bytes  and  there was a max-segment-size option
       requesting an MSS of 1024 bytes.

       Csam replies with a similar packet except it includes a piggy-backed ACK for rtsg's SYN.  Rtsg then  ACKs
       csam's  SYN.   The  `.'  means  the  ACK  flag was set.  The packet contained no data so there is no data
       sequence number or length.  Note that the ACK sequence number is a small integer  (1).   The  first  time
       <u>tcpdump</u>  sees a TCP `conversation', it prints the sequence number from the packet.  On subsequent packets
       of the conversation, the difference between  the  current  packet's  sequence  number  and  this  initial
       sequence  number  is  printed.   This  means  that sequence numbers after the first can be interpreted as
       relative byte positions in the conversation's data stream (with the first data byte each direction  being
       `1').  `-S' will override this feature, causing the original sequence numbers to be output.

       On  the  6th  line,  rtsg  sends csam 19 bytes of data (bytes 2 through 20 in the rtsg → csam side of the
       conversation).  The PSH flag is set in the packet.  On the 7th line, csam says it's received data sent by
       rtsg up to but not including byte 21.  Most of this data is apparently sitting in the socket buffer since
       csam's receive window has gotten 19 bytes smaller.  Csam also sends one byte of  data  to  rtsg  in  this
       packet.  On the 8th and 9th lines, csam sends two bytes of urgent, pushed data to rtsg.

       If  the  snapshot was small enough that <u>tcpdump</u> didn't capture the full TCP header, it interprets as much
       of the header as it can and then reports ``[|<u>tcp</u>]'' to indicate the remainder could not  be  interpreted.
       If the header contains a bogus option (one with a length that's either too small or beyond the end of the
       header),  <u>tcpdump</u>  reports  it  as  ``[<u>bad</u>  <u>opt</u>]'' and does not interpret any further options (since it's
       impossible to tell where they start).  If the header length indicates options  are  present  but  the  IP
       datagram length is not long enough for the options to actually be there, <u>tcpdump</u> reports it as ``[<u>bad</u> <u>hdr</u>
       <u>length</u>]''.

   <b>Particular</b> <b>TCP</b> <b>Flag</b> <b>Combinations</b> <b>(SYN-ACK,</b> <b>URG-ACK,</b> <b>etc.)</b>
       There are 8 bits in the control bits section of the TCP header:

              <u>CWR</u> <u>|</u> <u>ECE</u> <u>|</u> <u>URG</u> <u>|</u> <u>ACK</u> <u>|</u> <u>PSH</u> <u>|</u> <u>RST</u> <u>|</u> <u>SYN</u> <u>|</u> <u>FIN</u>

       Let's assume that we want to watch packets used in establishing a TCP connection.  Recall that TCP uses a
       3-way handshake protocol when it initializes a new connection; the connection sequence with regard to the
       TCP control bits is

              1) Caller sends SYN
              2) Recipient responds with SYN, ACK
              3) Caller sends ACK

       Now  we're  interested  in capturing packets that have only the SYN bit set (Step 1).  Note that we don't
       want packets from step 2 (SYN-ACK), just a  plain  initial  SYN.   What  we  need  is  a  correct  filter
       expression for <u>tcpdump</u>.

       Recall the structure of a TCP header without options:

        0                            15                              31
       -----------------------------------------------------------------
       |          source port          |       destination port        |
       -----------------------------------------------------------------
       |                        sequence number                        |
       -----------------------------------------------------------------
       |                     acknowledgment number                     |
       -----------------------------------------------------------------
       |  HL   | rsvd  |C|E|U|A|P|R|S|F|        window size            |
       -----------------------------------------------------------------
       |         TCP checksum          |       urgent pointer          |
       -----------------------------------------------------------------

       A  TCP  header  usually holds 20 octets of data, unless options are present.  The first line of the graph
       contains octets 0 - 3, the second line shows octets 4 - 7 etc.

       Starting to count with 0, the relevant TCP control bits are contained in octet 13:

        0             7|             15|             23|             31
       ----------------|---------------|---------------|----------------
       |  HL   | rsvd  |C|E|U|A|P|R|S|F|        window size            |
       ----------------|---------------|---------------|----------------
       |               |  13th octet   |               |               |

       Let's have a closer look at octet no. 13:

                       |               |
                       |---------------|
                       |C|E|U|A|P|R|S|F|
                       |---------------|
                       |7   5   3     0|

       These are the TCP control bits we are interested in.  We have numbered the bits in this octet from  0  to
       7, right to left, so the PSH bit is bit number 3, while the URG bit is number 5.

       Recall  that  we  want to capture packets with only SYN set.  Let's see what happens to octet 13 if a TCP
       datagram arrives with the SYN bit set in its header:

                       |C|E|U|A|P|R|S|F|
                       |---------------|
                       |0 0 0 0 0 0 1 0|
                       |---------------|
                       |7 6 5 4 3 2 1 0|

       Looking at the control bits section we see that only bit number 1 (SYN) is set.

       Assuming that octet number 13 is an 8-bit unsigned integer in network byte order,  the  binary  value  of
       this octet is

              00000010

       and its decimal representation is

          7     6     5     4     3     2     1     0
       0*2 + 0*2 + 0*2 + 0*2 + 0*2 + 0*2 + 1*2 + 0*2  =  2

       We're  almost  done,  because now we know that if only SYN is set, the value of the 13th octet in the TCP
       header, when interpreted as a 8-bit unsigned integer in network byte order, must be exactly 2.

       This relationship can be expressed as
              <b>tcp[13]</b> <b>==</b> <b>2</b>

       We can use this expression as the filter for <u>tcpdump</u> in order to watch packets which have only SYN set:
              <b>tcpdump</b> <b>-i</b> <b>xl0</b> <b>'tcp[13]</b> <b>==</b> <b>2'</b>

       The expression says "let the 13th octet of a TCP datagram have the decimal value  2",  which  is  exactly
       what we want.

       Now,  let's assume that we need to capture SYN packets, but we don't care if ACK or any other TCP control
       bit is set at the same time.  Let's see what happens to octet 13 when a TCP  datagram  with  SYN-ACK  set
       arrives:

            |C|E|U|A|P|R|S|F|
            |---------------|
            |0 0 0 1 0 0 1 0|
            |---------------|
            |7 6 5 4 3 2 1 0|

       Now bits 1 and 4 are set in the 13th octet.  The binary value of octet 13 is

                   00010010

       which translates to decimal

          7     6     5     4     3     2     1     0
       0*2 + 0*2 + 0*2 + 1*2 + 0*2 + 0*2 + 1*2 + 0*2   = 18

       Now  we  can't  just use 'tcp[13] == 18' in the <u>tcpdump</u> filter expression, because that would select only
       those packets that have SYN-ACK set, but not those with only SYN set.  Remember that we don't care if ACK
       or any other control bit is set as long as SYN is set.

       In order to achieve our goal, we need to logically AND the binary value of octet 13 with some other value
       to preserve the SYN bit.  We know that we want SYN to be set in any case,  so  we'll  logically  AND  the
       value in the 13th octet with the binary value of a SYN:

                 00010010 SYN-ACK              00000010 SYN
            AND  00000010 (we want SYN)   AND  00000010 (we want SYN)
                 --------                      --------
            =    00000010                 =    00000010

       We see that this AND operation delivers the same result regardless whether ACK or another TCP control bit
       is set.  The decimal representation of the AND value as well as the result of this operation is 2 (binary
       00000010), so we know that for packets with SYN set the following relation must hold true:

              ( ( value of octet 13 ) AND ( 2 ) ) == ( 2 )

       This points us to the <u>tcpdump</u> filter expression
                   tcpdump -i xl0 'tcp[13] &amp; 2 == 2'

       Some  offsets  and  field  values  may  be  expressed as names rather than as numeric values. For example
       tcp[13] may be replaced with tcp[tcpflags]. The following TCP flag field values are also available:  tcp-
       fin, tcp-syn, tcp-rst, tcp-push, tcp-ack, tcp-urg, tcp-ece and tcp-cwr.

       This can be demonstrated as:
                   tcpdump -i xl0 'tcp[tcpflags] &amp; tcp-push != 0'

       Note  that  you  should  use single quotes or a backslash in the expression to hide the AND ('&amp;') special
       character from the shell.

   <b>UDP</b> <b>Packets</b>
       UDP format is illustrated by this rwho packet:
              actinide.who &gt; broadcast.who: udp 84
       This says that port <u>who</u> on host <u>actinide</u> sent a UDP datagram to port <u>who</u> on host <u>broadcast</u>, the  Internet
       broadcast address.  The packet contained 84 bytes of user data.

       Some  UDP  services  are  recognized  (from  the  source or destination port number) and the higher level
       protocol information printed.  In particular, Domain Name service requests (RFC 1034/1035)  and  Sun  RPC
       calls (RFC 1050) to NFS.

   <b>TCP</b> <b>or</b> <b>UDP</b> <b>Name</b> <b>Server</b> <b>Requests</b>
       <u>(N.B.:The</u>  <u>following</u>  <u>description</u>  <u>assumes</u>  <u>familiarity</u> <u>with</u> <u>the</u> <u>Domain</u> <u>Service</u> <u>protocol</u> <u>described</u> <u>in</u> <u>RFC</u>
       <u>1035.</u>  <u>If</u> <u>you</u> <u>are</u> <u>not</u> <u>familiar</u> <u>with</u> <u>the</u> <u>protocol,</u> <u>the</u> <u>following</u> <u>description</u> <u>will</u> <u>appear</u> <u>to</u> <u>be</u> <u>written</u>  <u>in</u>
       <u>Greek.)</u>

       Name server requests are formatted as
              <u>src</u> <u>&gt;</u> <u>dst:</u> <u>id</u> <u>op?</u> <u>flags</u> <u>qtype</u> <u>qclass</u> <u>name</u> <u>(len)</u>
              h2opolo.1538 &gt; helios.domain: 3+ A? ucbvax.berkeley.edu. (37)
       Host  <u>h2opolo</u>  asked the domain server on <u>helios</u> for an address record (qtype=A) associated with the name
       <u>ucbvax.berkeley.edu.</u>  The query id was `3'.  The `+' indicates the <u>recursion</u> <u>desired</u> flag was  set.   The
       query length was 37 bytes, excluding the TCP or UDP and IP protocol headers.  The query operation was the
       normal  one,  <u>Query</u>,  so  the op field was omitted.  If the op had been anything else, it would have been
       printed between the `3' and the `+'.  Similarly, the qclass was the normal one, <u>C_IN</u>, and  omitted.   Any
       other qclass would have been printed immediately after the `A'.

       A  few  anomalies  are  checked  and  may result in extra fields enclosed in square brackets:  If a query
       contains an answer, authority records or additional records section, <u>ancount</u>,  <u>nscount</u>,  or  <u>arcount</u>  are
       printed  as `[<u>n</u>a]', `[<u>n</u>n]' or  `[<u>n</u>au]' where <u>n</u> is the appropriate count.  If any of the response bits are
       set (AA, RA or rcode) or any of the `must be zero' bits are set in bytes two  and  three,  `[b2&amp;3=<u>x</u>]'  is
       printed, where <u>x</u> is the hex value of header bytes two and three.

   <b>TCP</b> <b>or</b> <b>UDP</b> <b>Name</b> <b>Server</b> <b>Responses</b>
       Name server responses are formatted as
              <u>src</u> <u>&gt;</u> <u>dst:</u>  <u>id</u> <u>op</u> <u>rcode</u> <u>flags</u> <u>a/n/au</u> <u>type</u> <u>class</u> <u>data</u> <u>(len)</u>
              helios.domain &gt; h2opolo.1538: 3 3/3/7 A 128.32.137.3 (273)
              helios.domain &gt; h2opolo.1537: 2 NXDomain* 0/1/0 (97)
       In  the  first  example,  <u>helios</u> responds to query id 3 from <u>h2opolo</u> with 3 answer records, 3 name server
       records and 7 additional records.  The first answer record is type A (address) and its data  is  internet
       address 128.32.137.3.  The total size of the response was 273 bytes, excluding TCP or UDP and IP headers.
       The op (Query) and response code (NoError) were omitted, as was the class (C_IN) of the A record.

       In  the  second example, <u>helios</u> responds to query 2 with a response code of nonexistent domain (NXDomain)
       with no answers, one name server and no authority records.  The  `*'  indicates  that  the  <u>authoritative</u>
       <u>answer</u> bit was set.  Since there were no answers, no type, class or data were printed.

       Other  flag  characters  that  might appear are `-' (recursion available, RA, <u>not</u> set) and `|' (truncated
       message, TC, set).  If the `question' section doesn't contain exactly one entry, `[<u>n</u>q]' is printed.

   <b>SMB/CIFS</b> <b>Decoding</b>
       <u>tcpdump</u> now includes fairly extensive SMB/CIFS/NBT decoding for data on  UDP/137,  UDP/138  and  TCP/139.
       Some primitive decoding of IPX and NetBEUI SMB data is also done.

       By  default  a  fairly  minimal  decode is done, with a much more detailed decode done if -v is used.  Be
       warned that with -v a single SMB packet may take up a page or more, so only use -v if you really want all
       the gory details.

       For   information    on    SMB    packet    formats    and    what    all    the    fields    mean    see
       https://download.samba.org/pub/samba/specs/  and other online resources.  The SMB patches were written by
       Andrew Tridgell (<a href="mailto:tridge@samba.org">tridge@samba.org</a>).

   <b>NFS</b> <b>Requests</b> <b>and</b> <b>Replies</b>
       Sun NFS (Network File System) requests and replies are printed as:
              <u>src.sport</u> <u>&gt;</u> <u>dst.nfs:</u> <u>NFS</u> <u>request</u> <u>xid</u> <u>xid</u> <u>len</u> <u>op</u> <u>args</u>
              <u>src.nfs</u> <u>&gt;</u> <u>dst.dport:</u> <u>NFS</u> <u>reply</u> <u>xid</u> <u>xid</u> <u>reply</u> <u>stat</u> <u>len</u> <u>op</u> <u>results</u>
              sushi.1023 &gt; wrl.nfs: NFS request xid 26377
                   112 readlink fh 21,24/10.73165
              wrl.nfs &gt; sushi.1023: NFS reply xid 26377
                   reply ok 40 readlink "..<a href="file:/var">/var</a>"
              sushi.1022 &gt; wrl.nfs: NFS request xid 8219
                   144 lookup fh 9,74/4096.6878 "xcolors"
              wrl.nfs &gt; sushi.1022: NFS reply xid 8219
                   reply ok 128 lookup fh 9,74/4134.3150
       In the first line, host <u>sushi</u> sends a transaction with id <u>26377</u> to  <u>wrl</u>.   The  request  was  112  bytes,
       excluding  the UDP and IP headers.  The operation was a <u>readlink</u> (read symbolic link) on file handle (<u>fh</u>)
       21,24/10.731657119.  (If one is lucky, as in  this  case,  the  file  handle  can  be  interpreted  as  a
       major,minor  device number pair, followed by the inode number and generation number.) In the second line,
       <u>wrl</u> replies `ok' with the same transaction id and the contents of the link.

       In the third line, <u>sushi</u> asks (using a new transaction id) <u>wrl</u> to lookup the name `<u>xcolors</u>' in  directory
       file 9,74/4096.6878. In the fourth line, <u>wrl</u> sends a reply with the respective transaction id.

       Note  that the data printed depends on the operation type.  The format is intended to be self explanatory
       if read in conjunction with an NFS protocol spec.  Also note that older versions of tcpdump  printed  NFS
       packets  in a slightly different format: the transaction id (xid) would be printed instead of the non-NFS
       port number of the packet.

       If the -v (verbose) flag is given, additional information is printed.  For example:
              sushi.1023 &gt; wrl.nfs: NFS request xid 79658
                   148 read fh 21,11/12.195 8192 bytes @ 24576
              wrl.nfs &gt; sushi.1023: NFS reply xid 79658
                   reply ok 1472 read REG 100664 ids 417/0 sz 29388
       (-v also prints the IP header TTL, ID, length, and fragmentation fields, which  have  been  omitted  from
       this  example.)   In  the  first  line, <u>sushi</u> asks <u>wrl</u> to read 8192 bytes from file 21,11/12.195, at byte
       offset 24576.  <u>Wrl</u> replies `ok'; the packet shown on the second line is the first fragment of the  reply,
       and  hence  is  only  1472  bytes  long  (the  other bytes will follow in subsequent fragments, but these
       fragments do not have NFS or even UDP headers and so might  not  be  printed,  depending  on  the  filter
       expression  used).   Because  the  -v  flag  is given, some of the file attributes (which are returned in
       addition to the file data) are printed: the file type (``REG'', for regular  file),  the  file  mode  (in
       octal), the UID and GID, and the file size.

       If the -v flag is given more than once, even more details are printed.

       NFS  reply  packets  do  not  explicitly  identify  the  RPC  operation.  Instead, <u>tcpdump</u> keeps track of
       ``recent'' requests, and matches them to the replies using the transaction  ID.   If  a  reply  does  not
       closely follow the corresponding request, it might not be parsable.

   <b>AFS</b> <b>Requests</b> <b>and</b> <b>Replies</b>
       Transarc AFS (Andrew File System) requests and replies are printed as:

              <u>src.sport</u> <u>&gt;</u> <u>dst.dport:</u> <u>rx</u> <u>packet-type</u>
              <u>src.sport</u> <u>&gt;</u> <u>dst.dport:</u> <u>rx</u> <u>packet-type</u> <u>service</u> <u>call</u> <u>call-name</u> <u>args</u>
              <u>src.sport</u> <u>&gt;</u> <u>dst.dport:</u> <u>rx</u> <u>packet-type</u> <u>service</u> <u>reply</u> <u>call-name</u> <u>args</u>
              elvis.7001 &gt; pike.afsfs:
                   rx data fs call rename old fid 536876964/1/1 ".newsrc.new"
                   new fid 536876964/1/1 ".newsrc"
              pike.afsfs &gt; elvis.7001: rx data fs reply rename
       In  the  first  line,  host  elvis  sends  a  RX  packet  to  pike.   This was a RX data packet to the fs
       (fileserver) service, and is the start of an RPC call.  The RPC call was a rename, with the old directory
       file id of 536876964/1/1 and  an  old  filename  of  `.newsrc.new',  and  a  new  directory  file  id  of
       536876964/1/1  and  a  new  filename of `.newsrc'.  The host pike responds with a RPC reply to the rename
       call (which was successful, because it was a data packet and not an abort packet).

       In general, all AFS RPCs are decoded at least by RPC call name.  Most AFS RPCs have at least some of  the
       arguments decoded (generally only the `interesting' arguments, for some definition of interesting).

       The  format  is  intended to be self-describing, but it will probably not be useful to people who are not
       familiar with the workings of AFS and RX.

       If the -v (verbose) flag is given twice, acknowledgement packets and  additional  header  information  is
       printed, such as the RX call ID, call number, sequence number, serial number, and the RX packet flags.

       If  the -v flag is given twice, additional information is printed, such as the RX call ID, serial number,
       and the RX packet flags.  The MTU negotiation information is also printed from RX ack packets.

       If the -v flag is given three times, the security index and service id are printed.

       Error codes are printed for abort packets, with the exception  of  Ubik  beacon  packets  (because  abort
       packets are used to signify a yes vote for the Ubik protocol).

       AFS  reply  packets  do  not  explicitly  identify  the  RPC  operation.  Instead, <u>tcpdump</u> keeps track of
       ``recent'' requests, and matches them to the replies using the call number and service ID.   If  a  reply
       does not closely follow the corresponding request, it might not be parsable.

   <b>KIP</b> <b>AppleTalk</b> <b>(DDP</b> <b>in</b> <b>UDP)</b>
       AppleTalk  DDP packets encapsulated in UDP datagrams are de-encapsulated and dumped as DDP packets (i.e.,
       all the UDP header information is discarded).  The file <u>/etc/atalk.names</u> is used to  translate  AppleTalk
       net and node numbers to names.  Lines in this file have the form
              <u>number</u>    <u>name</u>

              1.254          ether
              16.1      icsd-net
              1.254.110 ace
       The  first two lines give the names of AppleTalk networks.  The third line gives the name of a particular
       host (a host is distinguished from a net by the 3rd octet in the number - a  net  number  <u>must</u>  have  two
       octets  and a host number <u>must</u> have three octets.)  The number and name should be separated by whitespace
       (blanks or tabs).  The <u>/etc/atalk.names</u> file may contain blank lines or  comment  lines  (lines  starting
       with a `#').

       AppleTalk addresses are printed in the form
              <u>net.host.port</u>

              144.1.209.2 &gt; icsd-net.112.220
              office.2 &gt; icsd-net.112.220
              jssmag.149.235 &gt; icsd-net.2
       (If  the  <u>/etc/atalk.names</u>  doesn't exist or doesn't contain an entry for some AppleTalk host/net number,
       addresses are printed in numeric form.)  In the first example, NBP (DDP port 2) on net 144.1 node 209  is
       sending  to  whatever  is listening on port 220 of net icsd node 112.  The second line is the same except
       the full name of the source node is known (`office').  The third line is a send  from  port  235  on  net
       jssmag node 149 to broadcast on the icsd-net NBP port (note that the broadcast address (255) is indicated
       by  a  net  name  with no host number - for this reason it's a good idea to keep node names and net names
       distinct in /etc/atalk.names).

       NBP (name binding protocol)  and  ATP  (AppleTalk  transaction  protocol)  packets  have  their  contents
       interpreted.   Other  protocols  just  dump the protocol name (or number if no name is registered for the
       protocol) and packet size.

   <b>NBP</b> <b>Packets</b>
       NBP packets are formatted like the following examples:
              icsd-net.112.220 &gt; jssmag.2: nbp-lkup 190: "=:LaserWriter@*"
              jssmag.209.2 &gt; icsd-net.112.220: nbp-reply 190: "RM1140:LaserWriter@*" 250
              techpit.2 &gt; icsd-net.112.220: nbp-reply 190: "techpit:LaserWriter@*" 186
       The first line is a name lookup request for laserwriters sent by net icsd host 112 and broadcast  on  net
       jssmag.   The nbp id for the lookup is 190.  The second line shows a reply for this request (note that it
       has the same id) from host jssmag.209 saying that it has a laserwriter resource named "RM1140" registered
       on port 250.  The third line is another reply to the same request saying  host  techpit  has  laserwriter
       "techpit" registered on port 186.

   <b>ATP</b> <b>Packets</b>
       ATP packet formatting is demonstrated by the following example:
              jssmag.209.165 &gt; helios.132: atp-req  12266&lt;0-7&gt; 0xae030001
              helios.132 &gt; jssmag.209.165: atp-resp 12266:0 (512) 0xae040000
              helios.132 &gt; jssmag.209.165: atp-resp 12266:1 (512) 0xae040000
              helios.132 &gt; jssmag.209.165: atp-resp 12266:2 (512) 0xae040000
              helios.132 &gt; jssmag.209.165: atp-resp 12266:3 (512) 0xae040000
              helios.132 &gt; jssmag.209.165: atp-resp 12266:4 (512) 0xae040000
              helios.132 &gt; jssmag.209.165: atp-resp 12266:5 (512) 0xae040000
              helios.132 &gt; jssmag.209.165: atp-resp 12266:6 (512) 0xae040000
              helios.132 &gt; jssmag.209.165: atp-resp*12266:7 (512) 0xae040000
              jssmag.209.165 &gt; helios.132: atp-req  12266&lt;3,5&gt; 0xae030001
              helios.132 &gt; jssmag.209.165: atp-resp 12266:3 (512) 0xae040000
              helios.132 &gt; jssmag.209.165: atp-resp 12266:5 (512) 0xae040000
              jssmag.209.165 &gt; helios.132: atp-rel  12266&lt;0-7&gt; 0xae030001
              jssmag.209.133 &gt; helios.132: atp-req* 12267&lt;0-7&gt; 0xae030002
       Jssmag.209  initiates  transaction id 12266 with host helios by requesting up to 8 packets (the `&lt;0-7&gt;').
       The hex number at the end of the line is the value of the `userdata' field in the request.

       Helios responds with 8 512-byte packets.  The `:digit' following the  transaction  id  gives  the  packet
       sequence  number  in  the  transaction  and  the  number  in  parens is the amount of data in the packet,
       excluding the ATP header.  The `*' on packet 7 indicates that the EOM bit was set.

       Jssmag.209 then requests that packets 3 &amp; 5  be  retransmitted.   Helios  resends  them  then  jssmag.209
       releases  the  transaction.   Finally,  jssmag.209  initiates  the  next request.  The `*' on the request
       indicates that XO (`exactly once') was <u>not</u> set.

</pre><h4><b>BACKWARD</b> <b>COMPATIBILITY</b></h4><pre>
       The TCP flag names <b>tcp-ece</b> and <b>tcp-cwr</b> became available when linking with libpcap 1.9.0 or later.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/stty.1.html">stty</a></b>(1), <b><a href="../man3PCAP/pcap.3PCAP.html">pcap</a></b>(3PCAP), <b><a href="../man4/bpf.4.html">bpf</a></b>(4), <b><a href="../man4P/nit.4P.html">nit</a></b>(4P), <b><a href="../man5/pcap-savefile.5.html">pcap-savefile</a></b>(5), <b><a href="../man7/pcap-filter.7.html">pcap-filter</a></b>(7), <b><a href="../man7/pcap-tstamp.7.html">pcap-tstamp</a></b>(7)

              <u>https://www.iana.org/assignments/media-types/application/vnd.tcpdump.pcap</u>

</pre><h4><b>AUTHORS</b></h4><pre>
       The original authors are:

       Van Jacobson, Craig Leres  and  Steven  McCanne,  all  of  the  Lawrence  Berkeley  National  Laboratory,
       University of California, Berkeley, CA.

       It is currently maintained by The Tcpdump Group.

       The current version is available via HTTPS:

              <u>https://www.tcpdump.org/</u>

       The original distribution is available via anonymous ftp:

              <u><a href="ftp://ftp.ee.lbl.gov/old/tcpdump.tar.Z">ftp://ftp.ee.lbl.gov/old/tcpdump.tar.Z</a></u>

       IPv6/IPsec  support  is  added  by WIDE/KAME project.  This program uses OpenSSL/LibreSSL, under specific
       configurations.

</pre><h4><b>BUGS</b></h4><pre>
       To report a security issue please send an e-mail to <a href="mailto:security@tcpdump.org">security@tcpdump.org</a>.

       To report bugs and other problems, contribute patches, request a feature, provide generic  feedback  etc.
       please see the file <u>CONTRIBUTING.md</u> in the tcpdump source tree root.

       NIT doesn't let you watch your own outbound traffic, BPF will.  We recommend that you use the latter.

       Some  attempt  should be made to reassemble IP fragments or, at least to compute the right length for the
       higher level protocol.

       Name server inverse queries are not dumped correctly: the (empty) question section is printed rather than
       real query in the answer section.  Some believe that inverse queries are themselves a bug and  prefer  to
       fix the program generating them rather than <u>tcpdump</u>.

       A  packet trace that crosses a daylight savings time change will give skewed time stamps (the time change
       is ignored).

       Filter expressions on fields other than those in Token Ring headers will  not  correctly  handle  source-
       routed Token Ring packets.

       Filter  expressions  on  fields  other than those in 802.11 headers will not correctly handle 802.11 data
       packets with both To DS and From DS set.

       <b>ip6</b> <b>proto</b> should chase header chain, but at this moment it does not.  <b>ip6</b> <b>protochain</b> is supplied for this
       behavior.

       Arithmetic expression against transport layer headers, like <b>tcp[0]</b>, does not work against  IPv6  packets.
       It only looks at IPv4 packets.

                                                  26 March 2024                                       <u><a href="../man8/TCPDUMP.8.html">TCPDUMP</a></u>(8)
</pre>
 </div>
</div></section>
</div>
</body>
</html>