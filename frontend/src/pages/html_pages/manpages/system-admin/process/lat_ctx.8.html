<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>lat_ctx - context switching benchmark</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/lmbench">lmbench_3.0-a9+debian.1-9_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       lat_ctx - context switching benchmark

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>lat_ctx</b>  [  <u>-P</u>  <u>&lt;parallelism&gt;</u>  ]  [  <u>-W</u> <u>&lt;warmups&gt;</u> ] [ <u>-N</u> <u>&lt;repetitions&gt;</u> ] [ <u>-s</u> <u>&lt;size_in_kbytes&gt;</u> ] <u>#procs</u> [
       <u>#procs</u> <u>...</u>  ]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       <b>lat_ctx</b> measures context switching time for any reasonable number of processes of  any  reasonable  size.
       The  processes are connected in a ring of Unix pipes.  Each process reads a token from its pipe, possibly
       does some work, and then writes the token to the next process.

       Processes may vary in number.  Smaller numbers of processes result in faster context switches.  More than
       20 processes is not supported.

       Processes may vary in size.  A size of zero is the baseline process that does  nothing  except  pass  the
       token  on to the next process.  A process size of greater than zero means that the process does some work
       before passing on the token.  The work is simulated as the summing up of an array of the specified  size.
       The summing is an unrolled loop of about a 2.7 thousand instructions.

       The  effect  is that both the data and the instruction cache get polluted by some amount before the token
       is passed on.  The data cache gets polluted by approximately the process ``size''.  The instruction cache
       gets polluted by a constant amount, approximately 2.7 thousand instructions.

       The pollution of the caches results in larger context switching times for the larger processes.  This may
       be confusing because the benchmark takes pains to measure only the context switch time, not including the
       overhead of doing the work.  The subtle point is that the overhead is measured using hot caches.  As  the
       number  and  size  of  the  processes  increases,  the caches are more and more polluted until the set of
       processes do not fit.  The context switch times go up because a context switch is defined as  the  switch
       time  plus the time it takes to restore all of the process state, including cache state.  This means that
       the switch includes the time for the cache misses on larger processes.

</pre><h4><b>OUTPUT</b></h4><pre>
       Output format is intended as input to <b>xgraph</b> or some similar program.  The  format  is  multi  line,  the
       first  line  is  a  title  that  specifies the size and non-context switching overhead of the test.  Each
       subsequent line is a pair of numbers that indicates the number of processes and the  cost  of  a  context
       switch.   The overhead and the context switch times are in micro second units.  The numbers below are for
       a SPARCstation 2.

       <b>"size=0</b> <b>ovr=179</b>
       <b>2</b> <b>71</b>
       <b>4</b> <b>104</b>
       <b>8</b> <b>134</b>
       <b>16</b> <b>333</b>
       <b>20</b> <b>438</b>

</pre><h4><b>BUGS</b></h4><pre>
       The numbers produced by this benchmark are somewhat inaccurate; they vary by about 10 to 15% from run  to
       run.   A  series  of  runs  may  be  done and the lowest numbers reported.  The lower the number the more
       accurate the results.

       The reasons for the inaccuracies are possibly interaction between the VM system and the processor caches.
       It is possible that sometimes the benchmark processes are laid out in memory such that  there  are  fewer
       TLB/cache conflicts than other times.  This is pure speculation on our part.

</pre><h4><b>ACKNOWLEDGEMENT</b></h4><pre>
       Funding for the development of this tool was provided by Sun Microsystems Computer Corporation.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man8/lmbench.8.html">lmbench</a>(8).

</pre><h4><b>AUTHOR</b></h4><pre>
       Carl Staelin and Larry McVoy

       Comments, suggestions, and bug reports are always welcome.

(c)1994-2000 Carl Staelin and Larry McVoy            $Date$                                           <u><a href="../man8/LAT_CTX.8.html">LAT_CTX</a></u>(8)
</pre>
 </div>
</div></section>
</div>
</body>
</html>