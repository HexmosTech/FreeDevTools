<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>netem - Network Emulator</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/iproute2">iproute2_6.14.0-1ubuntu3_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       netem - Network Emulator

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>tc</b> <b>qdisc</b> <b>...</b> <b>dev</b> <u>DEVICE</u> ] <b>add</b> <b>netem</b> <u>OPTIONS</u>

       <u>OPTIONS</u>  :=  [  <u>LIMIT</u> ] [ <u>DELAY</u> ] [ <u>LOSS</u> ] [ <u>CORRUPT</u> ] [ <u>DUPLICATION</u> ] [ <u>REORDERING</u> ] [ <u>RATE</u> ] [ <u>SLOT</u> ] [
       <u>SEED</u> ]

       <u>LIMIT</u> := <b>limit</b> <u>packets</u>

       <u>DELAY</u> := <b>delay</b> <u>TIME</u> [ <u>JITTER</u> [ <u>CORRELATION</u> ]]]
              [ <b>distribution</b> { <b>uniform</b> | <b>normal</b> | <b>pareto</b> | <b>paretonormal</b> } ]

       <u>LOSS</u> := <b>loss</b> { <b>random</b> <u>PERCENT</u> [ <u>CORRELATION</u> ]  |
                      <b>state</b> <u>p13</u> [ <u>p31</u> [ <u>p32</u> [ <u>p23</u> [ <u>p14</u>]]]] |
                      <b>gemodel</b> <u>p</u> [ <u>r</u> [ <u>1-h</u> [ <u>1-k</u> ]]] }  [ <b>ecn</b> ]

       <u>CORRUPT</u> := <b>corrupt</b> <u>PERCENT</u> [ <u>CORRELATION</u> ]]

       <u>DUPLICATION</u> := <b>duplicate</b> <u>PERCENT</u> [ <u>CORRELATION</u> ]]

       <u>REORDERING</u> := <b>reorder</b> <u>PERCENT</u> [ <u>CORRELATION</u> ] [ <b>gap</b> <u>DISTANCE</u> ]

       <u>RATE</u> := <b>rate</b> <u>RATE</u> [ <u>PACKETOVERHEAD</u> [ <u>CELLSIZE</u> [ <u>CELLOVERHEAD</u> ]]]]

       <u>SLOT</u> := <b>slot</b> { <u>MIN_DELAY</u> [ <u>MAX_DELAY</u> ] |
                      <b>distribution</b> { <b>uniform</b> | <b>normal</b> | <b>pareto</b> | <b>paretonormal</b> | <u>FILE</u> } <u>DELAY</u> <u>JITTER</u> }
                    [ <b>packets</b> <u>PACKETS</u> ] [ <b>bytes</b> <u>BYTES</u> ]

       <u>SEED</u> := <b>seed</b> <u>VALUE</u>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <b>netem</b> queue discipline provides Network Emulation functionality for testing  protocols  by  emulating
       the properties of real-world networks.

       The  queue  discipline  provides  one  or  more  network  impairments  to  packets  such as: delay, loss,
       duplication, and packet corruption.

</pre><h4><b>OPTIONS</b></h4><pre>
       <b>limit</b> <u>COUNT</u>
              Limits the maximum number of packets the qdisc may hold when doing delay.

       <b>delay</b>  <u>TIME</u> [ <u>JITTER</u> [ <u>CORRELATION</u> ]]]
              Delays the packets before sending.  The optional parameters allow introducing  a  delay  variation
              and  a  correlation.  Delay and jitter values are expressed in milliseconds; Correlation is set by
              specifying a percent of how much the previous delay will impact the current random value.

       <b>distribution</b> <u>TYPE</u>
              Specifies a pattern for delay distribution.

              <b>uniform</b>
                     Use an equally weighted distribution of packet delays.

              <b>normal</b> Use a Gaussian distribution of delays.  Sometimes called a Bell Curve.

              <b>pareto</b> Use a  Pareto  distribution  of  packet  delays.   This  is  useful  to  emulate  long-tail
                     distributions.

              <b>paretonormal</b>
                     This is a mix of <b>pareto</b> and <b>normal</b> distribution which has properties of both Bell curve and
                     long tail.

       <b>loss</b> <u>MODEL</u>
              Drop packets based on a loss model.  <u>MODEL</u> can be one of

              <b>random</b> <u>PERCENT</u>
                     Each packet loss is independent.

              <b>state</b> <u>P13</u> <u>[</u> <u>P31</u> <u>[</u> <u>P32</u> <u>[</u> <u>P23</u> <u>P14</u> <u>]]]</u>
                     Use a 4-state Markov chain to describe packet loss.
                     <u>P13</u>  is the packet loss.  Optional parameters extend the model to 2-state <u>P31</u>, 3-state <u>P23</u>,
                     <u>P32</u> and 4-state <u>P14</u>.

                     The Markov chain states are:

                     <b>1</b>      good packet reception (no loss).

                     <b>2</b>      good reception within a burst.

                     <b>3</b>      burst losses.

                     <b>4</b>      independent losses.

              <b>gemodel</b> <u>PERCENT</u> <u>[</u> <u>R</u> <u>[</u> <u>1-H</u> <u>[</u> <u>1-K</u> <u>]]]</u>
                     Use a Gilbert-Elliot (burst loss) model based on:

                     <u>PERCENT</u>
                            probability of starting bad (lossy) state.

                     <u>R</u>      probability of exiting bad state.

                     <u>1-H</u>    loss probability in bad state.

                     <u>1-K</u>    loss probability in good state.

       <b>ecn</b>    Use Explicit Congestion Notification (ECN) to mark packets instead of dropping them.  A loss model
              has to be used for this to be enabled.

       <b>corrupt</b> <u>PERCENT</u>
              modifies the contents of the packet at a random position based on <u>PERCENT</u>.

       <b>duplicate</b> <u>PERCENT</u>
              creates a copy of the packet before queuing.

       <b>reorder</b> <u>PERCENT</u>
              modifies the order of packet in the queue.

       <b>gap</b> <u>DISTANCE</u>
              sends some packets immediately.  The first packets <u>(DISTANCE</u> <u>-</u> <u>1)</u> are delayed and the next  packet
              is sent immediately.

       <b>rate</b> <u>RATE</u> <u>[</u> <u>PACKETOVERHEAD</u> <u>[</u> <u>CELLSIZE</u>  <u>[</u> <u>CELLOVERHEAD</u> <u>]]]</u>
              Delays packets based on packet size to emulate a fixed link speed.  Optional parameters:

              <u>PACKETOVERHEAD</u>
                     Specify a per packet overhead in bytes.  Used to simulate additional link layer headers.  A
                     negative  value  can  be used to simlate when the Ethernet header is stripped (e.g. -14) or
                     header compression is used.

              <u>CELLSIZE</u>
                     simulate link layer schemes like ATM.

              <u>CELLOVERHEAD</u>
                     specify per cell overhead.

       Rate throttling impacted by several factors including the kernel clock granularity. This will show up  in
       an artificial packet compression (bursts).

       <b>slot</b> <u>MIN_DELAY</u> <u>[</u>  <u>MAX_DELAY</u>  <u>]</u>
              allows  emulating  slotted networks.  Defer delivering accumulated packets to within a slot.  Each
              available slot is configured with a minimum delay to acquire, and an optional maximum delay.

       <b>slot</b> <b>distribution</b>
              allows configuring based on distribution similar to <b>distribution</b> option for packet delays.

              These slot options can provide a crude approximation of bursty MACs such as DOCSIS, WiFi, and LTE.

              Slot emulation is limited by several factors: the kernel clock granularity, as with  a  rate,  and
              attempts to deliver many packets within a slot will be smeared by the timer resolution, and by the
              underlying native bandwidth also.

              It  is  possible to combine slotting with a rate, in which case complex behaviors where either the
              rate, or the slot limits on bytes or packets per slot, govern the actual delivered rate.

       <b>seed</b> <u>VALUE</u>
              Specifies a seed to guide and reproduce the randomly generated loss or corruption events.

</pre><h4><b>LIMITATIONS</b></h4><pre>
       Netem is limited by the timer granularity in  the  kernel.   Rate  and  delay  maybe  impacted  by  clock
       interrupts.

       Mixing  forms  of  reordering may lead to unexpected results.  For any method of reordering to work, some
       delay is necessary.  If the delay is less than the inter-packet arrival time then no reordering  will  be
       seen.   Due  to  mechanisms like TSQ (TCP Small Queues), for TCP performance test results to be realistic
       netem must be placed on the ingress of the receiver host.

       Combining netem with other qdisc is possible but may not always work because netem use skb control  block
       to set delays.

</pre><h4><b>EXAMPLES</b></h4><pre>
       # tc qdisc add dev eth0 root netem delay 100ms
           Add fixed amount of delay to all packets going out on device eth0.  Each packet will have added delay
           of 100ms ± 10ms.

       # tc qdisc change dev eth0 root netem delay 100ms 10ms 25%
           This  causes the added delay of 100ms ± 10ms and the next packet delay value will be biased by 25% on
           the most recent delay.  This isn't a true statistical correlation, but an approximation.

       # tc qdisc change dev eth0 root netem delay 100ms 20ms distribution normal
           This delays packets according to a normal distribution (Bell curve) over a range of 100ms ± 20ms.

       # tc qdisc change dev eth0 root netem loss 0.1%
           This causes 1/10th of a percent (i.e 1 out of 1000) packets to be randomly dropped.

           An optional correlation may also be added.  This causes the random number generator to be less random
           and can be used to emulate packet burst losses.

       # tc qdisc change dev eth0 root netem duplicate 1%
           This causes one percent of the packets sent on eth0 to be duplicated.

       # tc qdisc change dev eth0 root netem loss 0.3% 25%
           This will cause 0.3% of packets to be lost, and each successive probability depends is biased by  25%
           of the previous one.

       There  are  two  different ways to specify reordering.  The gap method uses a fixed sequence and reorders
       every Nth packet.
       # tc qdisc change dev eth0 root netem gap 5 delay 10ms
           This causes every 5th (10th, 15th, …) packet to go to be sent immediately and every other  packet  to
           be delayed by 10ms.  This is predictable and useful for base protocol testing like reassembly.

       The reorder form uses a percentage of the packets to get misordered.
       # tc qdisc change dev eth0 root netem delay 10ms reorder 25% 50%
       In  this  example,  25%  of packets (with a correlation of 50%) will get sent immediately, others will be
       delayed by 10ms.

       Packets will also get reordered if jitter is large enough.
       # tc qdisc change dev eth0 root netem delay 100ms 75ms
           If the first packet gets a random delay of 100ms (100ms base - 0ms jitter) and the second  packet  is
           sent  1ms  later  and gets a delay of 50ms (100ms base - 50ms jitter); the second packet will be sent
           first.  This is because the queue discipline tfifo inside netem, keeps packets in order  by  time  to
           send.

       If you don't want this behavior then replace the internal queue discipline tfifo with a simple FIFO queue
       discipline.
       # tc qdisc add dev eth0 root handle 1: netem delay 10ms 100ms
       # tc qdisc add dev eth0 parent 1:1 pfifo limit 1000

       Example of using rate control and cells size.
       # tc qdisc add dev eth0 root netem rate 5kbit 20 100 5
           Delay  all  outgoing packets on device eth0 with a rate of 5kbit, a per packet overhead of 20 byte, a
           cellsize of 100 byte and a per celloverhead of 5 bytes.

       It is possible to selectively apply impairment using traffic classification.
       # tc qdisc add dev eth0 root handle 1: prio
       # tc qdisc add dev eth0 parent 1:3 handle 30:    tbf rate 20kbit buffer 1600 limit  3000
       # tc qdisc add dev eth0 parent 30:1 handle 31:    netem delay 200ms 10ms distribution normal
       # tc filter add dev eth0 protocol ip parent 1:0 prio 3 u32    match ip dst 65.172.181.4/32 flowid 1:3
           This example uses a priority queueing discipline; a TBF is added to do rate  control;  and  a  simple
           netem delay.  A filter classifies all packets going to 65.172.181.4 as being priority 3.

</pre><h4><b>SOURCES</b></h4><pre>
        1. Hemminger   S.   ,   "Network  Emulation  with  NetEm",  Open  Source  Development  Lab,  April  2005
           <a href="http://devresources.linux-foundation.org/shemminger/netem/LCA2005_paper.pdf">http://devresources.linux-foundation.org/shemminger/netem/LCA2005_paper.pdf</a>

        2. Salsano S., Ludovici F., Ordine A., "Definition of a general and  intuitive  loss  model  for  packet
           networks   and   its  implementation  in  the  Netem  module  in  the  Linux  kernel",  available  at
           <a href="http://netgroup.uniroma2.it/NetemCLG">http://netgroup.uniroma2.it/NetemCLG</a>

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man8/tc.8.html">tc</a></b>(8)

</pre><h4><b>AUTHOR</b></h4><pre>
       Netem was written by Stephen Hemminger at Linux foundation and was inspired by NISTnet.

       Original manpage was created by Fabio Ludovici &lt;fabio.ludovici at yahoo dot it&gt; and  Hagen  Paul  Pfeifer
       &lt;<a href="mailto:hagen@jauu.net">hagen@jauu.net</a>&gt;.

iproute2                                        25 November 2011                                        <u><a href="../man8/NETEM.8.html">NETEM</a></u>(8)
</pre>
 </div>
</div></section>
</div>
</body>
</html>