<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>i2cget - read from I2C/SMBus chip registers</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/i2c-tools">i2c-tools_4.4-2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       i2cget - read from I2C/SMBus chip registers

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>i2cget</b> [<b>-f</b>] [<b>-y</b>] [<b>-a</b>] <u>i2cbus</u> <u>chip-address</u> [<u>data-address</u> [<u>mode</u> [<u>length</u>]]]
       <b>i2cget</b> <b>-V</b>
       <b>i2cget</b> <b>-h</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       i2cget is a small helper program to read registers visible through the I2C bus (or SMBus).

</pre><h4><b>OPTIONS</b></h4><pre>
       <b>-V</b>     Display the version and exit.

       <b>-h</b>     Display the help and exit.

       <b>-f</b>     Force  access to the device even if it is already busy. By default, i2cget will refuse to access a
              device which is already under the control of a kernel driver. Using this flag is dangerous, it can
              seriously confuse the kernel driver in question. It can also cause i2cget  to  return  an  invalid
              value. So use at your own risk and only if you know what you're doing.

       <b>-y</b>     Disable  interactive  mode.  By  default, i2cget will wait for a confirmation from the user before
              messing with the I2C bus. When this flag is used, it will perform the operation directly. This  is
              mainly meant to be used in scripts. Use with caution.

       <b>-a</b>     Allow using addresses between 0x00 - 0x07 and 0x78 - 0x7f. Not recommended.

       There  are  two  required  options  to  i2cget.  <u>i2cbus</u> indicates the number or name of the I2C bus to be
       scanned.  This number should correspond to one  of  the  busses  listed  by  <u>i2cdetect</u>  <u>-l</u>.  <u>chip-address</u>
       specifies the address of the chip on that bus, and is an integer between 0x08 and 0x77.

       <u>data-address</u> specifies the address on that chip to read from, and is an integer between 0x00 and 0xFF. If
       omitted, the currently active register will be read (if that makes sense for the considered chip).

       The  <u>mode</u>  parameter,  if specified, is one of the letters <b>b</b>, <b>w</b>, <b>c</b>, <b>s</b>, or <b>i</b>, corresponding to a read byte
       data, a read word data, a write byte/read byte, an SMBus block read, or an I2C  block  read  transaction,
       respectively.  A  <b>p</b>  can  also  be  appended  to  the  <u>mode</u> parameter to enable PEC, except for I2C block
       transactions. If the <u>mode</u> parameter is omitted, i2cget defaults to a read byte data  transaction,  unless
       <u>data-address</u>  is  also  omitted,  in which case the default (and only valid) transaction is a single read
       byte.

       The <u>length</u> parameter, if applicable and specified, sets the length of the block transaction. Valid values
       are between 1 and 32. Default value is 32.

</pre><h4><b>WARNING</b></h4><pre>
       i2cget can be extremely dangerous if used improperly. I2C and SMBus are designed in such a  way  that  an
       SMBus  read transaction can be seen as a write transaction by certain chips. This is particularly true if
       setting <u>mode</u> to <b>cp</b> (write byte/read byte with PEC). Be extremely careful using this program.

</pre><h4><b>EXAMPLES</b></h4><pre>
       Get the value of 8-bit register 0x11 of the I2C device at 7-bit address 0x2d on bus 1 (i2c-1), after user
       confirmation:
              # i2cget 1 0x2d 0x11

       Get the value of 16-bit register 0x00 of the I2C device at 7-bit address 0x48 on  bus  1  (i2c-1),  after
       user confirmation:
              # i2cget 1 0x48 0x00 w

       Set  the internal pointer register of a 24C02 EEPROM at 7-bit address 0x50 on bus 9 (i2c-9) to 0x00, then
       read the first 2 bytes from that EEPROM:
              # i2cset -y 9 0x50 0x00 ; i2cget -y 9 0x50 ; i2cget -y 9 0x50
       This assumes that the device automatically increments its internal pointer register on  every  read,  and
       supports  read  byte  transactions (read without specifying the register address, "Receive Byte" in SMBus
       terminology.)  Most EEPROM devices behave that way. Note that this is only safe as long as nobody else is
       accessing the I2C device at the same time. A  safer  approach  would  be  to  use  a  "Read  Word"  SMBus
       transaction instead, or an I2C Block Read transaction to read more than 2 bytes.

       Set  the  internal  pointer  register of a 24C32 EEPROM at 7-bit address 0x53 on bus 9 (i2c-9) to 0x0000,
       then read the first 2 bytes from that EEPROM:
              # i2cset -y 9 0x53 0x00 0x00 ; i2cget -y 9 0x53 ; i2cget -y 9 0x53
       This again assumes that the device automatically increments its internal pointer register on every  read,
       and  supports  read  byte  transactions.  While  the  previous example was for a small EEPROM using 8-bit
       internal addressing, this example is for a larger EEPROM using 16-bit internal  addressing.  Beware  that
       running  this  command on a small EEPROM using 8-bit internal addressing would actually <u>write</u> 0x00 to the
       first byte of that EEPROM. The safety concerns raised above still stand, however in this case there is no
       SMBus equivalent, so this is the only way to read data from a large EEPROM if your master isn't fully I2C
       capable. With a fully I2C capable master, you would use <u>i2ctransfer</u> to achieve the same  in  a  safe  and
       faster way.

       Read the first 8 bytes of an EEPROM device at 7-bit address 0x50 on bus 4 (i2c-4):
              # i2cget -y 4 0x50 0x00 i 8

</pre><h4><b>BUGS</b></h4><pre>
       To report bugs or send fixes, please write to the Linux I2C mailing list &lt;<a href="mailto:linux-i2c@vger.kernel.org">linux-i2c@vger.kernel.org</a>&gt; with
       Cc to the current maintainer: Jean Delvare &lt;<a href="mailto:jdelvare@suse.de">jdelvare@suse.de</a>&gt;.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man8/i2cdetect.8.html">i2cdetect</a>(8), <a href="../man8/i2cdump.8.html">i2cdump</a>(8), <a href="../man8/i2cset.8.html">i2cset</a>(8), <a href="../man8/i2ctransfer.8.html">i2ctransfer</a>(8)

</pre><h4><b>AUTHOR</b></h4><pre>
       Jean Delvare

       This manual page was strongly inspired from those written by David Z Maze for i2cset.

                                                    May 2022                                           <u><a href="../man8/I2CGET.8.html">I2CGET</a></u>(8)
</pre>
 </div>
</div></section>
</div>
</body>
</html>