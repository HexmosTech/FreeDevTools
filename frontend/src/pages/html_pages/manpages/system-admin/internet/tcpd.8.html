<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>tcpd - access control facility for internet services</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/tcpd">tcpd_7.6.q-36_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       tcpd - access control facility for internet services

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <u>tcpd</u>  program can be set up to monitor incoming requests for <u>telnet</u>, <u>finger</u>, <u>ftp</u>, <u>exec</u>, <u>rsh</u>, <u>rlogin</u>,
       <u>tftp</u>, <u>talk</u>, <u>comsat</u> and other services that have a one-to-one mapping onto executable files.

       The program supports both 4.3BSD-style sockets and System V.4-style TLI.  Functionality  may  be  limited
       when the protocol underneath TLI is not an internet protocol.

       There  are  two  possible  modes  of  operation:  execution of <u>tcpd</u> before a service started by <u>inetd</u>, or
       linking a daemon with the <u>libwrap</u> shared library  as  documented  in  the  <u><a href="../man3/hosts_access.3.html">hosts_access</a></u>(3)  manual  page.
       Operation  when  started by <u>inetd</u> is as follows: whenever a request for service arrives, the <u>inetd</u> daemon
       is tricked into running the <u>tcpd</u> program instead of the desired server. <u>tcpd</u> logs the  request  and  does
       some additional checks. When all is well, <u>tcpd</u> runs the appropriate server program and goes away.

       Optional  features  are:  pattern-based  access  control,  client  username lookups with the RFC 931 etc.
       protocol, protection against hosts that pretend to have someone elses host name, and  protection  against
       hosts that pretend to have someone elses network address.

</pre><h4><b>LOGGING</b></h4><pre>
       Connections  that are monitored by <u>tcpd</u> are reported through the <u><a href="../man3/syslog.3.html">syslog</a></u>(3) facility. Each record contains
       a time stamp, the client host name and the name of the requested service.  The information can be  useful
       to detect unwanted activities, especially when logfile information from several hosts is merged.

       In  order  to  find  out  where  your  logs  are  going,  examine  the syslog configuration file, usually
       /etc/syslog.conf.

</pre><h4><b>ACCESS</b> <b>CONTROL</b></h4><pre>
       Optionally, <u>tcpd</u> supports a simple form of access control that is based on pattern matching.  The access-
       control software provides hooks for the execution of shell commands when a pattern fires.   For  details,
       see the <u><a href="../man5/hosts_access.5.html">hosts_access</a></u>(5) manual page.

</pre><h4><b>HOST</b> <b>NAME</b> <b>VERIFICATION</b></h4><pre>
       The  authentication  scheme  of  some  protocols (<u>rlogin,</u> <u>rsh</u>) relies on host names. Some implementations
       believe the host name that they get from any random name server; other implementations are  more  careful
       but use a flawed algorithm.

       <u>tcpd</u>  verifies  the  client  host name that is returned by the address-&gt;name DNS server by looking at the
       host name and address that are returned by the name-&gt;address DNS server.  If any discrepancy is detected,
       <u>tcpd</u> concludes that it is dealing with a host that pretends to have someone elses host name.

       If the sources are compiled with -DPARANOID, <u>tcpd</u> will drop the connection in case of a host name/address
       mismatch.  Otherwise, the hostname can be matched with the <u>PARANOID</u> wildcard, after which suitable action
       can be taken.

</pre><h4><b>HOST</b> <b>ADDRESS</b> <b>SPOOFING</b></h4><pre>
       Optionally, <u>tcpd</u> disables source-routing socket options on every connection that it deals with. This will
       take care of most attacks from hosts that pretend to have  an  address  that  belongs  to  someone  elses
       network.  UDP  services  do  not  benefit from this protection. This feature must be turned on at compile
       time.

</pre><h4><b>RFC</b> <b>931</b></h4><pre>
       When RFC 931 etc. lookups are enabled (compile-time option) <u>tcpd</u> will attempt to establish  the  name  of
       the client user. This will succeed only if the client host runs an RFC 931-compliant daemon.  Client user
       name lookups will not work for datagram-oriented connections, and may cause noticeable delays in the case
       of connections from PCs.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The details of using <u>tcpd</u> depend on pathname information that was compiled into the program.

</pre><h4><b>EXAMPLE</b> <b>1</b></h4><pre>
       This  example  applies  when  <u>tcpd</u>  expects that the original network daemons will be moved to an "other"
       place.

       In order to monitor access to the <u>finger</u> service, move the original finger daemon to  the  "other"  place
       and  install  tcpd  in  the place of the original finger daemon. No changes are required to configuration
       files.

            # mkdir /other/place
            # mv /usr/sbin/in.fingerd /other/place
            # cp tcpd /usr/sbin/in.fingerd

       The example assumes that the network daemons live in /usr/sbin. On some systems, network daemons live  in
       <a href="file:/usr/sbin">/usr/sbin</a> or in <a href="file:/usr/libexec">/usr/libexec</a>, or have no `in.´ prefix to their name.

</pre><h4><b>EXAMPLE</b> <b>2</b></h4><pre>
       This example applies when <u>tcpd</u> expects that the network daemons are left in their original place.

       In  order to monitor access to the <u>finger</u> service, perform the following edits on the <u>inetd</u> configuration
       file (usually <u>/etc/inetd.conf</u>):

            finger  stream  tcp  nowait  nobody  /usr/sbin/in.fingerd  in.fingerd

       becomes:

            finger  stream  tcp  nowait  nobody  /usr/sbin/tcpd     in.fingerd

       The example assumes that the network daemons live in /usr/sbin. On some systems, network daemons live  in
       <a href="file:/usr/sbin">/usr/sbin</a> or in <a href="file:/usr/libexec">/usr/libexec</a>, the daemons have no `in.´ prefix to their name, or there is no userid field
       in the inetd configuration file.

       Similar changes will be needed for the other services that are to be covered by <u>tcpd</u>.  Send a `kill -HUP´
       to the <u><a href="../man8/inetd.8.html">inetd</a></u>(8) process to make the changes effective.

</pre><h4><b>EXAMPLE</b> <b>3</b></h4><pre>
       In  the  case  of  daemons that do not live in a common directory ("secret" or otherwise), edit the <u>inetd</u>
       configuration file so that it specifies an absolute path name for the process name field. For example:

           ntalk  dgram  udp  wait  root  /usr/sbin/tcpd  /usr/local/lib/ntalkd

       Only the last component (ntalkd) of the pathname will be used for access control and logging.

</pre><h4><b>BUGS</b></h4><pre>
       Some UDP (and RPC) daemons linger around for a while after they have finished their work, in case another
       request comes in.  In the inetd configuration file these services are registered with  the  <u>wait</u>  option.
       Only the request that started such a daemon will be logged.

       The  program  does  not  work with RPC services over TCP. These services are registered as <u>rpc/tcp</u> in the
       inetd configuration file. The only non-trivial service that is affected by this limitation is <u>rexd</u>, which
       is used by the <u><a href="../man1/on.1.html">on</a>(1)</u> command. This is no great loss.  On  most  systems,  <u>rexd</u>  is  less  secure  than  a
       wildcard in /etc/hosts.equiv.

       RPC  broadcast requests (for example: <u>rwall,</u> <u>rup,</u> <u>rusers</u>) always appear to come from the responding host.
       What happens is that the client broadcasts the request to  all  <u>portmap</u>  daemons  on  its  network;  each
       <u>portmap</u>  daemon  forwards  the  request  to  a  local daemon. As far as the <u>rwall</u> etc.  daemons know, the
       request comes from the local host.

</pre><h4><b>FILES</b></h4><pre>
       The default locations of the host access control tables are:

       <a href="file:/etc/hosts.allow">/etc/hosts.allow</a>
       <a href="file:/etc/hosts.deny">/etc/hosts.deny</a>

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man3/hosts_access.3.html">hosts_access</a>(3), functions provided by the libwrap library.
       <a href="../man5/hosts_access.5.html">hosts_access</a>(5), format of the tcpd access control tables.
       <a href="../man5/syslog.conf.5.html">syslog.conf</a>(5), format of the syslogd control file.
       <a href="../man5/inetd.conf.5.html">inetd.conf</a>(5), format of the inetd control file.

</pre><h4><b>AUTHORS</b></h4><pre>
       Wietse Venema (<a href="mailto:wietse@wzv.win.tue.nl">wietse@wzv.win.tue.nl</a>),
       Department of Mathematics and Computing Science,
       Eindhoven University of Technology
       Den Dolech 2, P.O. Box 513,
       5600 MB Eindhoven, The Netherlands

                                                                                                         <u><a href="../man8/TCPD.8.html">TCPD</a></u>(8)
</pre>
 </div>
</div></section>
</div>
</body>
</html>