<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>iosnoop - trace block I/O events as they occur. Uses Linux ftrace.</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/questing/+package/perf-tools-unstable">perf-tools-unstable_1.0.1~20200130+git49b8cdf-1ubuntu1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       iosnoop - trace block I/O events as they occur. Uses Linux ftrace.

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>iosnoop</b> [-hQst] [-d device] [-i iotype] [-p pid] [-n name] [duration]

</pre><h4><b>DESCRIPTION</b></h4><pre>
       iosnoop prints block device I/O events as they happen, with useful details such as PID, device, I/O type,
       block number, I/O size, and latency.

       This  traces  disk  I/O  at  the  block  device  interface,  using  the block: tracepoints. This can help
       characterize the I/O requested for the storage devices and their resulting performance.  I/O  completions
       can also be studied event-by-event for debugging disk and controller I/O scheduling issues.

       NOTE:  Use  of  a  duration buffers I/O, which reduces overheads, but this also introduces a limit to the
       number of I/O that will be captured. See the duration section in OPTIONS.

       Since this uses ftrace, only the root user can use this tool.

</pre><h4><b>REQUIREMENTS</b></h4><pre>
       FTRACE    CONFIG,    and    the    tracepoints    block:block_rq_insert,    block:block_rq_issue,     and
       block:block_rq_complete,  which  you  may already have enabled and available on recent Linux kernels. And
       awk.

</pre><h4><b>OPTIONS</b></h4><pre>
       -d device
              Only show I/O issued by this device. (eg, "202,1"). This matches the DEV  column  in  the  iosnoop
              output, and is filtered in-kernel.

       -i iotype
              Only  show  I/O  issued  that  matches  this I/O type. This matches the TYPE column in the iosnoop
              output, and wildcards ("*") can be used at the beginning or end  (only).  Eg,  "*R*"  matches  all
              reads. This is filtered in-kernel.

       -p PID Only  show I/O issued by this PID. This filters in-kernel. Note that I/O may be issued indirectly;
              for example, as the result of a memory allocation, causing dirty buffers (maybe from another  PID)
              to be written to storage.

              With the -Q option, the identified PID is more accurate, however, LATms now includes queueing time
              (see the -Q option).

       -n name
              Only  show  I/O  issued  by  processes with this name. Partial strings and regular expressions are
              allowed. This is a post-filter, so all I/O is traced and then filtered in user space. As with PID,
              this includes indirectly issued I/O, and -Q can be used to improve accuracy (see the -Q option).

       -h     Print usage message.

       -Q     Use block I/O queue insertion as the start tracepoint (block:block_rq_insert),  instead  of  block
              I/O  issue  (block:block_rq_issue). This makes the following changes: COMM and PID are more likely
              to identify the origin process, as are -p PID and -n name; STARTs shows queue  insert;  and  LATms
              shows I/O time including time spent on the block I/O queue.

       -s     Include  a  column  for  the  start time (issue time) of the I/O, in seconds.  If the -Q option is
              used, this is the time the I/O is inserted on the block I/O queue.

       -t     Include a column for the completion time of the I/O, in seconds.

       duration
              Set the duration of tracing, in seconds. Trace output will be buffered and  printed  at  the  end.
              This also reduces overheads by buffering in-kernel, instead of printing events as they occur.

              The  ftrace buffer has a fixed size per-CPU (see /sys/kernel/debug/tracing/buffer_size_kb). If you
              think events are missing, try increasing that size (the bufsize_kb setting in iosnoop).  With  the
              default setting (4 Mbytes), I'd expect this to happen around 50k I/O.

</pre><h4><b>EXAMPLES</b></h4><pre>
       Default output, print I/O activity as it occurs:
              # <b>iosnoop</b>

       Buffer for 5 seconds (lower overhead) and write to a file:
              # <b>iosnoop</b> <b>5</b> <b>&gt;</b> <b>outfile</b>

       Trace based on block I/O queue insertion, showing queueing time:
              # <b>iosnoop</b> <b>-Q</b>

       Trace reads only:
              # <b>iosnoop</b> <b>-i</b> <b>'*R*'</b>

       Trace I/O issued to device 202,1 only:
              # <b>iosnoop</b> <b>-d</b> <b>202,1</b>

       Include I/O start and completion timestamps:
              # <b>iosnoop</b> <b>-ts</b>

       Include I/O queueing and completion timestamps:
              # <b>iosnop</b> <b>-Qts</b>

       Trace I/O issued when PID 181 was on-CPU only:
              # <b>iosnoop</b> <b>-p</b> <b>181</b>

       Trace I/O queued when PID 181 was on-CPU (more accurate), and include queue time:
              # <b>iosnoop</b> <b>-Qp</b> <b>181</b>

</pre><h4><b>FIELDS</b></h4><pre>
       COMM   Process  name  (command) for the PID that was on-CPU when the I/O was issued, or inserted if -Q is
              used. See PID. This column is truncated to 12 characters.

       PID    Process ID which was on-CPU when the I/O was issued, or inserted if -Q is used. This will  usually
              be  the process directly requesting I/O, however, it may also include indirect I/O. For example, a
              memory allocation by this PID which causes dirty memory from another PID to be flushed to disk.

       TYPE   Type of I/O. R=read, W=write, M=metadata, S=sync, A=readahead, F=flush or FUA (force unit access),
              D=discard, E=secure, N=null (not RWFD).

       DEV    Storage device ID.

       BLOCK  Disk block for the operation (location, relative to this device).

       BYTES  Size of the I/O, in bytes.

       LATms  Latency (time) for the I/O, in milliseconds.

</pre><h4><b>OVERHEAD</b></h4><pre>
       By default, iosnoop works without buffering, printing  I/O  events  as  they  happen  (uses  trace_pipe),
       context  switching  and  consuming CPU to do so. This has a limit of about 10,000 IOPS (depending on your
       platform), at which point iosnoop will be consuming 1 CPU. The duration  mode  uses  buffering,  and  can
       handle  much  higher  IOPS rates, however, the buffer has a limit of about 50,000 I/O, after which events
       will be dropped. You can tune this with bufsize_kb, which is per-CPU. Also note that the "-n"  option  is
       currently post-filtered, so all events are traced.

       The  overhead  may be acceptable in many situations. If it isn't, this tool can be reimplemented in C, or
       using a different tracer (eg, perf_events, SystemTap, ktap.)

</pre><h4><b>SOURCE</b></h4><pre>
       This is from the perf-tools collection.

              https://github.com/brendangregg/perf-tools

       Also look under the examples directory for a text file containing example usage, output,  and  commentary
       for this tool.

</pre><h4><b>OS</b></h4><pre>
       Linux

</pre><h4><b>STABILITY</b></h4><pre>
       Unstable - in development.

</pre><h4><b>AUTHOR</b></h4><pre>
       Brendan Gregg

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <a href="../man8/iolatency.8.html">iolatency</a>(8), <a href="../man1/iostat.1.html">iostat</a>(1), <a href="../man8/lsblk.8.html">lsblk</a>(8)

USER COMMANDS                                      2014-07-12                                         <u><a href="../man8/iosnoop.8.html">iosnoop</a></u>(8)
</pre>
 </div>
</div></section>
</div>
</body>
</html>