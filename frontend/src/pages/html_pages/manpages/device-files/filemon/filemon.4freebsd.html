<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>filemon — the filemon device</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       filemon — the filemon device

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;dev/filemon/filemon.h&gt;</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>filemon</b>  device  allows  a  process  to  collect  file  operations data of its children.  The device
       <u>/dev/filemon</u> responds to two <u><a href="../man2/ioctl.2.html">ioctl</a></u>(2) calls.

       <b>filemon</b> is not intended to be a security auditing tool.  Many system calls are not tracked  and  binaries
       of  foreign  ABI  will not be fully audited.  It is intended for auditing of processes for the purpose of
       determining its dependencies in an efficient and easily parsable format.  An example of this  is  <u><a href="../man1/make.1.html">make</a></u>(1)
       which uses this module with <b>.MAKE.MODE=meta</b> to handle incremental builds more smartly.

       System calls are denoted using the following single letters:

       ‘A’     <u><a href="../man2/openat.2.html">openat</a></u>(2).  The next log entry may be lacking an absolute path or be inaccurate.
       ‘C’     <u><a href="../man2/chdir.2.html">chdir</a></u>(2)
       ‘D’     <u><a href="../man2/unlink.2.html">unlink</a></u>(2)
       ‘E’     <u><a href="../man2/exec.2.html">exec</a></u>(2)
       ‘F’     <u><a href="../man2/fork.2.html">fork</a></u>(2), <u><a href="../man2/vfork.2.html">vfork</a></u>(2)
       ‘L’     <u><a href="../man2/link.2.html">link</a></u>(2), <u><a href="../man2/linkat.2.html">linkat</a></u>(2), <u><a href="../man2/symlink.2.html">symlink</a></u>(2), <u><a href="../man2/symlinkat.2.html">symlinkat</a></u>(2)
       ‘M’     <u><a href="../man2/rename.2.html">rename</a></u>(2)
       ‘R’     <u><a href="../man2/open.2.html">open</a></u>(2) or <u><a href="../man2/openat.2.html">openat</a></u>(2) for read
       ‘W’     <u><a href="../man2/open.2.html">open</a></u>(2) or <u><a href="../man2/openat.2.html">openat</a></u>(2) for write
       ‘X’     <b>_</b><u><a href="../man2/exit.2.html">exit</a></u>(2)

       Note  that  ‘R’  following  ‘W’  records  can represent a single <u><a href="../man2/open.2.html">open</a></u>(2) for R/W, or two separate <u><a href="../man2/open.2.html">open</a></u>(2)
       calls, one for ‘R’ and one for ‘W’.  Note that only successful system calls are captured.

</pre><h4><b>IOCTLS</b></h4><pre>
       User mode programs communicate with the <b>filemon</b> driver through a number of  ioctls  which  are  described
       below.  Each takes a single argument.

       FILEMON_SET_FD   Write the internal tracing buffer to the supplied open file descriptor.

       FILEMON_SET_PID  Child  process  ID to trace.  This should normally be done under the control of a parent
                        in the child after <u><a href="../man2/fork.2.html">fork</a></u>(2) but before anything else.  See the example below.

</pre><h4><b>RETURN</b> <b>VALUES</b></h4><pre>
       The <b>ioctl</b>() function returns the value 0 if successful; otherwise the value -1 is returned and the global
       variable <u>errno</u> is set to indicate the error.

</pre><h4><b>ERRORS</b></h4><pre>
       The <b>ioctl</b>() system call with FILEMON_SET_FD will fail if:

       [EEXIST]           The <b>filemon</b> handle is already associated with a file descriptor.

       The <b>ioctl</b>() system call with FILEMON_SET_PID will fail if:

       [ESRCH]            No process having the specified process ID exists.

       [EBUSY]            The process ID specified is already being traced and was not the current process.

       The <b>close</b>() system call on the filemon file descriptor may fail with the  errors  from  <u><a href="../man2/write.2.html">write</a></u>(2)  if  any
       error is encountered while writing the log.  It may also fail if:

       [EFAULT]           An  invalid  address  was  used for a traced system call argument, resulting in no log
                          entry for the system call.

       [ENAMETOOLONG]     An argument for a traced system call was too long, resulting in no log entry  for  the
                          system call.

</pre><h4><b>FILES</b></h4><pre>
       <u>/dev/filemon</u>

</pre><h4><b>EXAMPLES</b></h4><pre>
       #include &lt;sys/types.h&gt;
       #include &lt;sys/stat.h&gt;
       #include &lt;sys/wait.h&gt;
       #include &lt;sys/ioctl.h&gt;
       #include &lt;dev/filemon/filemon.h&gt;
       #include &lt;<a href="file:/usr/include/fcntl.h">fcntl.h</a>&gt;
       #include &lt;<a href="file:/usr/include/err.h">err.h</a>&gt;
       #include &lt;<a href="file:/usr/include/unistd.h">unistd.h</a>&gt;

       static void
       open_filemon(void)
       {
               pid_t child;
               int fm_fd, fm_log;

               if ((fm_fd = open("/dev/filemon", O_RDWR | O_CLOEXEC)) == -1)
                       err(1, "open(\"/dev/filemon\", O_RDWR)");
               if ((fm_log = open("filemon.out",
                   O_CREAT | O_WRONLY | O_TRUNC | O_CLOEXEC, DEFFILEMODE)) == -1)
                       err(1, "open(filemon.out)");

               if (ioctl(fm_fd, FILEMON_SET_FD, &amp;fm_log) == -1)
                       err(1, "Cannot set filemon log file descriptor");

               if ((child = fork()) == 0) {
                       child = getpid();
                       if (ioctl(fm_fd, FILEMON_SET_PID, &amp;child) == -1)
                               err(1, "Cannot set filemon PID");
                       /* Do something here. */
               } else {
                       wait(&amp;child);
                       close(fm_fd);
               }
       }

       Creates  a  file named <u>filemon.out</u> and configures the <b>filemon</b> device to write the <b>filemon</b> buffer contents
       to it.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man1/dtrace.1.html">dtrace</a></u>(1), <u><a href="../man1/ktrace.1.html">ktrace</a></u>(1), <u><a href="../man1/script.1.html">script</a></u>(1), <u><a href="../man1/truss.1.html">truss</a></u>(1), <u><a href="../man2/ioctl.2.html">ioctl</a></u>(2)

</pre><h4><b>HISTORY</b></h4><pre>
       A <b>filemon</b> device appeared in FreeBSD 9.1.

</pre><h4><b>BUGS</b></h4><pre>
       Unloading the module may panic the system, thus requires using <b>kldunload</b> <b>-f</b>.

Debian                                           March 22, 2016                                       <u><a href="../man4/FILEMON.4.html">FILEMON</a></u>(4)
</pre>
 </div>
</div></section>
</div>
</body>
</html>