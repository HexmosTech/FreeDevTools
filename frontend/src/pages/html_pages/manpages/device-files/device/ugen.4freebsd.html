<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ugen — USB generic device support</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ugen — USB generic device support

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>ugen</b> is integrated into the <u><a href="../man4/usb.4.html">usb</a></u>(4) kernel module.

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>ugen</b>  driver  provides  support  for all USB devices that do not have a special driver.  It supports
       access to all parts of the device, but not in a way that is as convenient as a special purpose driver.

       There can be up to 127 USB devices connected to a USB bus.  Each USB device can have up to 16  endpoints.
       Each  of  these endpoints will communicate in one of four different modes: control, isochronous, bulk, or
       interrupt.  Each of the endpoints will have a different device node.  The four least significant bits  in
       the  minor device number determine which endpoint the device accesses, and the rest of the bits determine
       which USB device.

       If an endpoint address is used both for input and output, the device can  be  opened  for  both  read  or
       write.

       To find out which endpoints exist, there are a series of <u><a href="../man2/ioctl.2.html">ioctl</a></u>(2) operations on the control endpoint that
       return the USB descriptors of the device, configurations, interfaces, and endpoints.

       The  control  transfer  mode  can  only  happen  on the control endpoint which is always endpoint 0.  The
       control endpoint accepts a request and may respond with an answer to such a  request.   Control  requests
       are issued by <u><a href="../man2/ioctl.2.html">ioctl</a></u>(2) calls.

       The  bulk  transfer  mode  can be in or out depending on the endpoint.  To perform I/O on a bulk endpoint
       <u><a href="../man2/read.2.html">read</a></u>(2) and <u><a href="../man2/write.2.html">write</a></u>(2) should be used.  All I/O operations on a bulk endpoint are unbuffered.

       The interrupt transfer mode can be in or out depending on the endpoint.  To perform I/O on  an  interrupt
       endpoint <u><a href="../man2/read.2.html">read</a></u>(2) and <u><a href="../man2/write.2.html">write</a></u>(2) should be used.  A moderate amount of buffering is done by the driver.

       All endpoints handle the following <u><a href="../man2/ioctl.2.html">ioctl</a></u>(2) calls:

       USB_SET_SHORT_XFER (<u>int</u>)
               Allow short read transfer.  Normally a transfer from the device which is shorter than the request
               specified is reported as an error.

       USB_SET_TIMEOUT (<u>int</u>)
               Set  the  timeout on the device operations The time is specified in milliseconds.  The value 0 is
               used to indicate that there is no timeout.

       The control endpoint (endpoint 0) handles the following <u><a href="../man2/ioctl.2.html">ioctl</a></u>(2) calls:

       USB_GET_CONFIG (<u>int</u>)
               Get the device configuration number.

       USB_SET_CONFIG (<u>int</u>)
               Set the device into the given configuration number.

               This operation can only be performed when the control endpoint is the sole open endpoint.

       USB_GET_ALTINTERFACE (<u>struct</u> <u>usb_alt_interface</u>)
               Get the alternative setting number for the interface with the given index.  The  <u>uai_config_index</u>
               is ignored in this call.

               struct usb_alt_interface {
                       int     uai_config_index;
                       int     uai_interface_index;
                       int     uai_alt_no;
               };

       USB_SET_ALTINTERFACE (<u>struct</u> <u>usb_alt_interface</u>)
               Set  the  alternative  setting  to  the  given number in the interface with the given index.  The
               <u>uai_config_index</u> is ignored in this call.

               This operation can only be performed when no endpoints for the interface are open.

       USB_GET_NO_ALT (<u>struct</u> <u>usb_alt_interface</u>)
               Return the number of different alternate settings in the <u>uai_alt_no</u> field.

       USB_GET_DEVICE_DESC (<u>usb_device_descriptor_t</u>)
               Return the device descriptor.

       USB_GET_CONFIG_DESC (<u>struct</u> <u>usb_config_desc</u>)
               Return the descriptor for the configuration with the given index.  For convenience,  the  current
               configuration can be specified by USB_CURRENT_CONFIG_INDEX.

               struct usb_config_desc {
                       int     ucd_config_index;
                       usb_config_descriptor_t ucd_desc;
               };

       USB_GET_INTERFACE_DESC (<u>struct</u> <u>usb_interface_desc</u>)
               Return  the interface descriptor for an interface specified by its configuration index, interface
               index, and alternative index.  For convenience, the  current  alternative  can  be  specified  by
               USB_CURRENT_ALT_INDEX.

               struct usb_interface_desc {
                       int     uid_config_index;
                       int     uid_interface_index;
                       int     uid_alt_index;
                       usb_interface_descriptor_t uid_desc;
               };

       USB_GET_ENDPOINT_DESC (<u>struct</u> <u>usb_endpoint_desc</u>)
               Return  the  endpoint descriptor for the endpoint specified by its configuration index, interface
               index, alternative index, and endpoint index.

               struct usb_endpoint_desc {
                       int     ued_config_index;
                       int     ued_interface_index;
                       int     ued_alt_index;
                       int     ued_endpoint_index;
                       usb_endpoint_descriptor_t ued_desc;
               };

       USB_GET_FULL_DESC (<u>struct</u> <u>usb_full_desc</u>)
               Return all the descriptors for the given configuration.

               struct usb_full_desc {
                       int     ufd_config_index;
                       u_int   ufd_size;
                       u_char  *ufd_data;
               };
               The <u>ufd_data</u> field should point to a memory area of the size given in the  <u>ufd_size</u>  field.   The
               proper  size  can  be  determined  by  first  issuing  a  USB_GET_CONFIG_DESC  and inspecting the
               <u>wTotalLength</u> field.

       USB_GET_STRING_DESC (<u>struct</u> <u>usb_string_desc</u>)
               Get a string descriptor for the given language ID and string index.

               struct usb_string_desc {
                       int     usd_string_index;
                       int     usd_language_id;
                       usb_string_descriptor_t usd_desc;
               };

       USB_DO_REQUEST (<u>struct</u> <u>usb_ctl_request</u>)
               Send a USB request to the device on the control endpoint.  Any data sent to/from  the  device  is
               located  at  <u>ucr_data</u>.  The size of the transferred data is determined from the <u>ucr_request</u>.  The
               <u>ucr_addr</u> field is ignored in this call.  The <u>ucr_flags</u> field can be used to flag that the request
               is allowed to be shorter than the requested size, and <u>ucr_actlen</u> will contain the actual size  on
               completion.

               struct usb_ctl_request {
                       int     ucr_addr;
                       usb_device_request_t ucr_request;
                       void    *ucr_data;
                       int     ucr_flags;
               #define USBD_SHORT_XFER_OK      0x04    /* allow short reads */
                       int     ucr_actlen;             /* actual length transferred */
               };
               This is a dangerous operation in that it can perform arbitrary operations on the device.  Some of
               the most dangerous (e.g., changing the device address) are not allowed.

       USB_GET_DEVICEINFO (<u>struct</u> <u>usb_device_info</u>)
               Get an information summary for the device.  This call will not issue any USB transactions.

       Note  that  there  are  two  different  ways  of addressing configurations, interfaces, alternatives, and
       endpoints: by index or by number.  The index is the ordinal number (starting from 0) of the descriptor as
       presented by the device.  The number is the respective number of the entity as found in  its  descriptor.
       Enumeration of descriptors uses the index, getting and setting typically uses numbers.

       Example:  all  endpoints  (except  the  control  endpoint)  for the current configuration can be found by
       iterating the <u>interface_index</u> from 0 to <u>config_desc-&gt;bNumInterface</u>-1 and for each of these, iterating the
       <u>endpoint_index</u>  from  0  to  <u>interface_desc-&gt;bNumEndpoints</u>.   The   <u>config_index</u>   should   be   set   to
       USB_CURRENT_CONFIG_INDEX and <u>alt_index</u> should be set to USB_CURRENT_ALT_INDEX.

</pre><h4><b>SYSCTL</b> <b>VARIABLES</b></h4><pre>
       The following variables are available as both <u><a href="../man8/sysctl.8.html">sysctl</a></u>(8) variables and <u><a href="../man8/loader.8.html">loader</a></u>(8) tunables:

       <u>hw.usb.ugen.debug</u>
               Debug  output  level,  where  0  is  debugging  disabled and larger values increase debug message
               verbosity.  Default is 0.

</pre><h4><b>FILES</b></h4><pre>
       <u>/dev/ugenN.E</u>  Endpoint <u>E</u> of device <u>N</u>.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man4/usb.4.html">usb</a></u>(4)

</pre><h4><b>HISTORY</b></h4><pre>
       The <b>ugen</b> driver appeared in NetBSD 1.4.

Debian                                           April 24, 2018                                          <u><a href="../man4/UGEN.4.html">UGEN</a></u>(4)
</pre>
 </div>
</div></section>
</div>
</body>
</html>