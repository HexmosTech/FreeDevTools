<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>aio — asynchronous I/O</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       aio — asynchronous I/O

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>aio</b>  facility  provides  system  calls  for  asynchronous  I/O.  Asynchronous I/O operations are not
       completed synchronously by the calling thread.  Instead, the calling thread invokes one  system  call  to
       request  an  asynchronous  I/O  operation.   The  status  of a completed request is retrieved later via a
       separate system call.

       Asynchronous I/O operations on some file descriptor types may block an AIO daemon indefinitely  resulting
       in  process  and/or  system hangs.  Operations on these file descriptor types are considered “unsafe” and
       disabled by default.  They can be enabled by setting the <u>vfs.aio.enable_unsafe</u> sysctl node to a  non-zero
       value.

       Asynchronous  I/O  operations on sockets, raw disk devices, and regular files on local filesystems do not
       block indefinitely and are always enabled.

       The <b>aio</b> facility uses kernel processes (also known as AIO  daemons)  to  service  most  asynchronous  I/O
       requests.   These  processes are grouped into pools containing a variable number of processes.  Each pool
       will add or remove processes to the pool based on load.  Pools can be configured  by  sysctl  nodes  that
       define  the  minimum  and  maximum number of processes as well as the amount of time an idle process will
       wait before exiting.

       One pool of AIO daemons is used to service asynchronous I/O requests for sockets.   These  processes  are
       named “soaiod&lt;N&gt;”.  The following sysctl nodes are used with this pool:

       <u>kern.ipc.aio.num_procs</u>
               The current number of processes in the pool.

       <u>kern.ipc.aio.target_procs</u>
               The minimum number of processes that should be present in the pool.

       <u>kern.ipc.aio.max_procs</u>
               The maximum number of processes permitted in the pool.

       <u>kern.ipc.aio.lifetime</u>
               The  amount of time a process is permitted to idle in clock ticks.  If a process is idle for this
               amount of time and there are more processes in the pool than the target minimum, the process will
               exit.

       A second pool of AIO daemons is used to service all  other  asynchronous  I/O  requests  except  for  I/O
       requests  to  raw  disks.  These processes are named “aiod&lt;N&gt;”.  The following sysctl nodes are used with
       this pool:

       <u>vfs.aio.num_aio_procs</u>
               The current number of processes in the pool.

       <u>vfs.aio.target_aio_procs</u>
               The minimum number of processes that should be present in the pool.

       <u>vfs.aio.max_aio_procs</u>
               The maximum number of processes permitted in the pool.

       <u>vfs.aio.aiod_lifetime</u>
               The amount of time a process is permitted to idle in clock ticks.  If a process is idle for  this
               amount of time and there are more processes in the pool than the target minimum, the process will
               exit.

       Asynchronous  I/O  requests  for raw disks are queued directly to the disk device layer after temporarily
       wiring the user pages associated with the request.  These requests are not serviced by  any  of  the  AIO
       daemon pools.

       Several  limits  on the number of asynchronous I/O requests are imposed both system-wide and per-process.
       These limits are configured via the following sysctls:

       <u>vfs.aio.max_buf_aio</u>
               The maximum number of queued asynchronous I/O requests for  raw  disks  permitted  for  a  single
               process.   Asynchronous  I/O requests that have completed but whose status has not been retrieved
               via <u><a href="../man2/aio_return.2.html">aio_return</a></u>(2) or <u><a href="../man2/aio_waitcomplete.2.html">aio_waitcomplete</a></u>(2) are not counted against this limit.

       <u>vfs.aio.num_buf_aio</u>
               The number of queued asynchronous I/O requests for raw disks system-wide.

       <u>vfs.aio.max_aio_queue_per_proc</u>
               The maximum number of asynchronous I/O requests for a single process serviced concurrently by the
               default AIO daemon pool.

       <u>vfs.aio.max_aio_per_proc</u>
               The maximum number of outstanding asynchronous I/O requests permitted for a single process.  This
               includes requests that have not been serviced, requests currently being  serviced,  and  requests
               that   have   completed   but   whose   status  has  not  been  retrieved  via  <u><a href="../man2/aio_return.2.html">aio_return</a></u>(2)  or
               <u><a href="../man2/aio_waitcomplete.2.html">aio_waitcomplete</a></u>(2).

       <u>vfs.aio.num_queue_count</u>
               The number of outstanding asynchronous I/O requests system-wide.

       <u>vfs.aio.max_aio_queue</u>
               The maximum number of outstanding asynchronous I/O requests permitted system-wide.

       Asynchronous I/O control buffers should be zeroed before initializing individual  fields.   This  ensures
       all fields are initialized.

       All  asynchronous I/O control buffers contain a <u>sigevent</u> structure in the <u>aio_sigevent</u> field which can be
       used to request notification when an operation completes.

       For SIGEV_KEVENT notifications, the <u>sigevent</u> s <u>sigev_notify_kqueue</u> field should contain the descriptor of
       the kqueue that the event  should  be  attached  to,  its  <u>sigev_notify_kevent_flags</u>  field  may  contain
       EV_ONESHOT,  EV_CLEAR, and/or EV_DISPATCH, and its <u>sigev_notify</u> field should be set to SIGEV_KEVENT.  The
       posted kevent will contain:

       <b>Member</b>    <b>Value</b>
       <u>ident</u>     asynchronous I/O control buffer pointer
       <u>filter</u>    EVFILT_AIO
       <u>flags</u>     EV_EOF
       <u>udata</u>     value stored in <u>aio_sigevent.sigev_value</u>

       For SIGEV_SIGNO and SIGEV_THREAD_ID notifications, the information for the  queued  signal  will  include
       SI_ASYNCIO in the <u>si_code</u> field and the value stored in <u>sigevent.sigev_value</u> in the <u>si_value</u> field.

       For   SIGEV_THREAD  notifications,  the  value  stored  in  <u>aio_sigevent.sigev_value</u>  is  passed  to  the
       <u>aio_sigevent.sigev_notify_function</u> as described in <u><a href="../man3/sigevent.3.html">sigevent</a></u>(3).

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man2/aio_cancel.2.html">aio_cancel</a></u>(2),   <u><a href="../man2/aio_error.2.html">aio_error</a></u>(2),   <u><a href="../man2/aio_read.2.html">aio_read</a></u>(2),   <u><a href="../man2/aio_return.2.html">aio_return</a></u>(2),    <u><a href="../man2/aio_suspend.2.html">aio_suspend</a></u>(2),    <u><a href="../man2/aio_waitcomplete.2.html">aio_waitcomplete</a></u>(2),
       <u><a href="../man2/aio_write.2.html">aio_write</a></u>(2), <u><a href="../man2/lio_listio.2.html">lio_listio</a></u>(2), <u><a href="../man3/sigevent.3.html">sigevent</a></u>(3), <u><a href="../man8/sysctl.8.html">sysctl</a></u>(8)

</pre><h4><b>HISTORY</b></h4><pre>
       The  <b>aio</b>  facility  appeared  as  a  kernel  option  in  FreeBSD  3.0.  The <b>aio</b> kernel module appeared in
       FreeBSD 5.0.  The <b>aio</b> facility was integrated into all kernels in FreeBSD 11.0.

Debian                                            June 22, 2017                                           <u><a href="../man4/AIO.4.html">AIO</a></u>(4)
</pre>
 </div>
</div></section>
</div>
</body>
</html>