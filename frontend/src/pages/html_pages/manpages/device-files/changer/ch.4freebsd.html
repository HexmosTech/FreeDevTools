<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ch — SCSI media-changer (juke box) driver</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ch — SCSI media-changer (juke box) driver

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>device</b> <b>ch</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <b>ch</b> driver provides support for a <u>SCSI</u> media changer.  It allows many slots of media to be multiplexed
       between  a number of drives.  The changer device may optionally be equipped with a bar code reader, which
       reads label information attached to the media.

       A SCSI adapter must also be  separately  configured  into  the  system  before  a  SCSI  changer  can  be
       configured.

       As  the SCSI adapter is probed during boot, the <u>SCSI</u> bus is scanned for devices.  Any devices found which
       answer as 'Changer' type devices will be 'attached' to the <b>ch</b> driver.  In FreeBSD releases prior to  2.1,
       the  first  found  will  be  attached  as  <u>ch0</u> and the next, <u>ch1</u> etc.  Beginning in 2.1 it is possible to
       specify what ch unit a  device  should  come  on  line  as;  refer  to  <u><a href="../man4/scsi.4.html">scsi</a></u>(4)  for  details  on  kernel
       configuration.

</pre><h4><b>KERNEL</b> <b>CONFIGURATION</b></h4><pre>
       It  is only necessary to explicitly configure one <b>ch</b> device; data structures are dynamically allocated as
       media changes are found on the SCSI bus.

</pre><h4><b>IOCTLS</b></h4><pre>
       User mode programs communicate with the changer driver through a number of  ioctls  which  are  described
       below.  Changer element addresses used in the communication between the kernel and the changer device are
       mapped to zero-based logical addresses.  Element types are specified as follows:

       CHET_MT  Medium transport element (picker).

       CHET_ST  Storage element (slot).

       CHET_IE  Import/export element (portal).

       CHET_DT  Data transfer element (drive).

       The following <u><a href="../man2/ioctl.2.html">ioctl</a></u>(2) calls apply to the changer.  They are defined in the header file &lt;<u>sys/chio.h</u>&gt;.

       CHIOMOVE      (<u>struct</u>  <u>changer_move</u>)  Move  a  medium from one element to another (<b>MOVE</b> <b>MEDIUM</b>) using the
                     current picker.  The source and  destination  elements  are  specified  in  a  changer_move
                     structure, which includes at least the following fields:

                           u_int cm_fromtype; /* element type to move from */
                           u_int cm_fromunit; /* logical unit of from element */
                           u_int cm_totype;   /* element type to move to */
                           u_int cm_tounit;   /* logical unit of to element */
                           u_int cm_flags;    /* misc. flags */
                     If the CM_INVERT in the <u>cm_flags</u> field is set, the medium changer is instructed to flip the
                     medium while moving it.

       CHIOEXCHANGE  (<u>struct</u>  <u>changer_exchange</u>)  Move  the  medium  located  in  the source element to the first
                     destination element, and move the medium that had been in the first destination element  to
                     the  second  destination  element.   In  case  of  a simple exchange, the source and second
                     destination elements should be the same.   The  current  picker  is  used  to  perform  the
                     operation.   The  addresses  of  the  affected  elements  is  specified  to  the ioctl in a
                     <u>changer_exchange</u> structure which includes at least the following fields:

                           u_int ce_srctype;        /* element type of source */
                           u_int ce_srcunit;        /* logical unit of source */
                           u_int ce_fdsttype; /* element type of first destination */
                           u_int ce_fdstunit; /* logical unit of first destination */
                           u_int ce_sdsttype; /* element type of second destination */
                           u_int ce_sdstunit; /* logical unit of second destination */
                           u_int ce_flags;  /* misc. flags */
                     In <u>ce_flags</u>, CM_INVERT1 and/or CM_INVERT2 may be set to flip the  first  or  second  medium
                     during the exchange operation, respectively.

                     <u>This</u> <u>operation</u> <u>is</u> <u>untested</u>.

       CHIOPOSITION  (<u>struct</u>  <u>changer_position</u>)  Position  the current picker in front of the specified element.
                     The element is specified with a changer_position structure, which  includes  at  least  the
                     following elements:

                           u_int cp_type;  /* element type */
                           u_int cp_unit;  /* logical unit of element */
                           u_int cp_flags; /* misc. flags */
                     The <u>cp_flags</u> field may be set to CP_INVERT to invert the picker during the operation.

       CHIOGPICKER   (<u>int</u>) Return the logical address of the current picker.

       CHIOSPICKER   (<u>int</u>) Select the picker specified by the given logical address.

       CHIOGPARAMS   (<u>struct</u>  <u>changer_params</u>)  Return  the configuration parameters for the media changer.  This
                     ioctl fills the changer_params structure passed by the user with  at  least  the  following
                     fields:

                           u_int cp_npickers; /* number of pickers */
                           u_int cp_nslots;   /* number of slots */
                           u_int cp_nportals; /* number of import/export portals */
                           u_int cp_ndrives;  /* number of drives */

                     This  call  can be used by applications to query the dimensions of the jukebox before using
                     the CHIGSTATUS ioctl to query the jukebox status.

       CHIOIELEM     Perform the <b>INITIALIZE</b> <b>ELEMENT</b> <b>STATUS</b> call on the media changer device.   This  forces  the
                     media  changer  to update its internal status information with respect to loaded media.  It
                     also scans any barcode labels provided that it has a label reader.  The <b>ch</b> driver's  status
                     is not affected by this call.

       CHIOGSTATUS   (<u>struct</u>  <u>changer_element_status_request</u>)  Perform the <b>READ</b> <b>ELEMENT</b> <b>STATUS</b> call on the media
                     changer device.  This call reads the element status information of the  media  changer  and
                     converts it to an array of <u>changer_element_status</u> structures.

                     With  each  call  to  CHIOGSTATUS,  the  status  of one or more elements of one type may be
                     queried.

                     The application passes a <u>changer_element_status_request</u> structure to the  <b>ch</b>  driver  which
                     contains the following fields:

                           u_int                          cesr_element_type;
                           u_int                          cesr_element_base;
                           u_int                          cesr_element_count;
                           u_int                          cesr_flags;
                           struct changer_element_status *cesr_element_status;

                     This structure is read by the driver to determine the type, logical base address and number
                     of  elements for which information is to be returned in the array of <u>changer_element_status</u>
                     structures pointed to by the <u>cesr_element_status</u>  field.   The  application  must  allocate
                     enough  memory  for  <u>cesr_element_count</u>  status structures (see below).  The <u>cesr_flags</u> can
                     optionally be set to CESR_VOLTAGS to indicate that volume tag (bar code) information is  to
                     be read from the jukebox and returned.

                     The  <u>cesr_element_base</u>  and  <u>cesr_element_count</u>  fields  must  be valid with respect to the
                     physical configuration of the changer.  If they are not, the CHIOGSTATUS ioctl returns  the
                     EINVAL error code.

                     The  information  about  the  elements  is  returned  in an array of <u>changer_element_status</u>
                     structures.  This structure include at least the following fields:

                           u_int            ces_addr;      /* element address in media changer */
                           u_char           ces_flags;     /* see CESTATUS definitions below */
                           u_char           ces_sensecode; /* additional sense code for element */
                           u_char           ces_sensequal; /* additional sense code qualifier */
                           u_char           ces_invert;    /* invert bit */
                           u_char           ces_svalid;    /* source address (ces_source) valid */
                           u_short          ces_source;    /* source address of medium */
                           changer_voltag_t ces_pvoltag;   /* primary volume tag */
                           changer_voltag_t ces_avoltag;   /* alternate volume tag */
                           u_char           ces_idvalid;   /* ces_scsi_id is valid */
                           u_char           ces_scsi_id;   /* SCSI id of element (if ces_idvalid is nonzero) */
                           u_char           ces_lunvalid;  /* ces_scsi_lun is valid */
                           u_char           ces_scsi_lun;  /* SCSI lun of element (if ces_lunvalid is nonzero) */

                     The <u>ces_addr</u> field contains the address of the element in  the  coordinate  system  of  the
                     media  changer.   It  is not used by the driver, and should be used for diagnostic purposes
                     only.

                     The following flags are defined for the <u>ces_flags</u> field:

                     CESTATUS_FULL    A medium is present.

                     CESTATUS_IMPEXP  The medium has been deposited by the operator (and not by a picker).

                     CESTATUS_EXCEPT  The element is in  an  exceptional  state  (e.g.  invalid  barcode  label,
                                      barcode not yet scanned).

                     CESTATUS_ACCESS  The element is accessible by the picker.

                     CESTATUS_EXENAB  The element supports medium export.

                     CESTATUS_INENAB  The element supports medium import.

                     Note that not all flags are valid for all element types.

</pre><h4><b>NOTES</b></h4><pre>
       This  version of the <b>ch</b> driver has been tested with a DEC TZ875 (5 slot, one DLT drive) and a Breece Hill
       Q47 (60 slot, four DLT drives, barcode reader).

       Many of the features the <b>ch</b> driver supports are not thoroughly tested due to the fact  that  the  devices
       available  for  testing  do  not support the necessary commands.  This is true for alternate volume tags,
       media flipping, import/export element handling, multiple picker operation and other things.

</pre><h4><b>FILES</b></h4><pre>
       <u>/dev/ch[0-9]</u>  device entries

</pre><h4><b>DIAGNOSTICS</b></h4><pre>
       If the media changer does not support features requested by the <b>ch</b> driver, it will produce  both  console
       error messages and failure return codes to the ioctls described here.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man1/chio.1.html">chio</a></u>(1), <u><a href="../man4/cam.4.html">cam</a></u>(4), <u><a href="../man4/cd.4.html">cd</a></u>(4), <u><a href="../man4/da.4.html">da</a></u>(4), <u><a href="../man4/sa.4.html">sa</a></u>(4)

</pre><h4><b>HISTORY</b></h4><pre>
       The <b>ch</b> driver appeared in 386BSD 0.1.

</pre><h4><b>AUTHORS</b></h4><pre>
       The   <b>ch</b>   driver   was   written   by   Jason   R.  Thorpe  &lt;<u><a href="mailto:thorpej@and.com">thorpej@and.com</a></u>&gt;  for  And  Communications,
       <u><a href="http://www.and.com/">http://www.and.com/</a></u>.  It was added to the system by  Stefan  Grefen  &lt;<u><a href="mailto:grefen@goofy.zdv.uni-mainz.de">grefen@goofy.zdv.uni-mainz.de</a></u>&gt;  who
       apparently  had  such a device.  It was ported to CAM by Kenneth Merry &lt;<u><a href="mailto:ken@FreeBSD.org">ken@FreeBSD.org</a></u>&gt;.  It was updated
       to support volume tags by Hans Huebner &lt;<u><a href="mailto:hans@artcom.de">hans@artcom.de</a></u>&gt;.

Debian                                            May 14, 1998                                             <u><a href="../man4/CH.4.html">CH</a></u>(4)
</pre>
 </div>
</div></section>
</div>
</body>
</html>