<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>vkbd — the virtual AT keyboard interface</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       vkbd — the virtual AT keyboard interface

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>device</b> <b>vkbd</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>vkbd</b>  interface  is  a  software  loopback mechanism that can be loosely described as the virtual AT
       keyboard analog of the <u><a href="../man4/pty.4.html">pty</a></u>(4), that is, <b>vkbd</b> does for virtual AT keyboards what the  <u><a href="../man4/pty.4.html">pty</a></u>(4)  driver  does
       for terminals.

       The  <b>vkbd</b>  driver,  like  the <u><a href="../man4/pty.4.html">pty</a></u>(4) driver, provides two interfaces: a keyboard interface like the usual
       facility it is simulating (a virtual AT keyboard in the case of <b>vkbd</b>, or a terminal for  <u><a href="../man4/pty.4.html">pty</a></u>(4)),  and  a
       character-special device “control” interface.

       The virtual AT keyboards are named <u>vkbd0</u>, <u>vkbd1</u>, etc., one for each control device that has been opened.

       The <b>vkbd</b> interface permits opens on the special control device <u>/dev/vkbdctl</u>.  When this device is opened,
       <b>vkbd</b> will return a handle for the lowest unused <u>vkbdctl</u> device (use <u><a href="../man3/devname.3.html">devname</a></u>(3) to determine which).

       Each  virtual  AT  keyboard  supports  the  usual keyboard interface <u><a href="../man2/ioctl.2.html">ioctl</a></u>(2)s, and thus can be used with
       <u><a href="../man1/kbdcontrol.1.html">kbdcontrol</a></u>(1) like any other keyboard.  The control device supports exactly the  same  <u><a href="../man2/ioctl.2.html">ioctl</a></u>(2)s  as  the
       virtual  AT  keyboard  device.   Writing  AT  scan  codes to the control device generates an input on the
       virtual AT keyboard, as if the (non-existent) hardware had just received it.

       The virtual AT keyboard control device, normally <u>/dev/vkbdctl</u>⟨<u>N</u>⟩, is exclusive-open (it cannot be  opened
       if  it  is  already open) and is restricted to the super-user.  A <u><a href="../man2/read.2.html">read</a></u>(2) call will return the virtual AT
       keyboard status structure (defined in &lt;<u>dev/vkbd/vkbd_var.h</u>&gt;) if one is available; if not, it will  either
       block until one is or return EWOULDBLOCK, depending on whether non-blocking I/O has been enabled.

       A  <u><a href="../man2/write.2.html">write</a></u>(2)  call  passes AT scan codes to be “received” from the virtual AT keyboard.  Each AT scan code
       must be passed as <u>unsigned</u> <u>int</u>.  Although AT scan codes must be passes as <u>unsigned</u> <u>int</u>s, the size of  the
       buffer passed to <u><a href="../man2/write.2.html">write</a></u>(2) still should be in bytes, i.e.,

             static unsigned int     codes[] =
             {
             /*      Make    Break */
                     0x1e,   0x9e
             };

             int
             main(void)
             {
                     int     fd, len;

                     fd = open("/dev/vkbdctl0", O_RDWR);
                     if (fd &lt; 0)
                             err(1, "open");

                     /* Note sizeof(codes) - not 2! */
                     len = write(fd, codes, sizeof(codes));
                     if (len &lt; 0)
                             err(1, "write");

                     close(fd);

                     return (0);
             }

       Write will block if there is not enough space in the input queue.

       The control device also supports <u><a href="../man2/select.2.html">select</a></u>(2) for read and write.

       On  the  last close of the control device, the virtual AT keyboard is removed.  All queued scan codes are
       thrown away.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man1/kbdcontrol.1.html">kbdcontrol</a></u>(1), <u><a href="../man4/atkbdc.4.html">atkbdc</a></u>(4), <u><a href="../man4/psm.4.html">psm</a></u>(4), <u><a href="../man4/syscons.4.html">syscons</a></u>(4), <u><a href="../man4/vt.4.html">vt</a></u>(4)

</pre><h4><b>HISTORY</b></h4><pre>
       The <b>vkbd</b> module was implemented in FreeBSD 6.0.

</pre><h4><b>AUTHORS</b></h4><pre>
       Maksim Yevmenkin &lt;<u><a href="mailto:m_evmenkin@yahoo.com">m_evmenkin@yahoo.com</a></u>&gt;

</pre><h4><b>CAVEATS</b></h4><pre>
       The <b>vkbd</b> interface is a software loopback mechanism, and, thus <u><a href="../man4/ddb.4.html">ddb</a></u>(4) will not  work  with  it.   Current
       implementation  of  the <u><a href="../man4/syscons.4.html">syscons</a></u>(4) driver can accept input from only one keyboard, even if it is virtual.
       Thus it is not possible to have both wired and virtual keyboard to be active at the same  time.   It  is,
       however, in principal possible to obtain AT scan codes from the different sources and write them into the
       same virtual keyboard.  The virtual keyboard state synchronization is the user's responsibility.

Debian                                           August 12, 2004                                         <u><a href="../man4/VKBD.4.html">VKBD</a></u>(4)
</pre>
 </div>
</div></section>
</div>
</body>
</html>