<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>lp — printer port Internet Protocol driver</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       lp — printer port Internet Protocol driver

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>ifconfig</b> <u>plip0</u> <u>myaddress</u> <u>hisaddress</u> [<b>-link0</b>]

       <b>device</b> <b>ppbus</b>
       <b>device</b> <b>plip</b>
       <b>device</b> <b>ppc</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>lp</b> driver allows a PC parallel printer port to be used as a point-to-point network interface between
       two similarly configured systems.  Data is transferred 4 bits at a time, using the printer  status  lines
       for  input:  hence  there  is  no  requirement  for  special  bidirectional hardware and any standard AT-
       compatible printer port with working interrupts may be used.

       During the boot process, for each  <b>plip</b>  device  which  is  probed  and  has  an  interrupt  assigned,  a
       corresponding <b>network</b> device is created.

       Configuring  an  <b>lp</b> device with <u><a href="../man8/ifconfig.8.html">ifconfig</a></u>(8) causes the corresponding <b>parallel</b> <b>port</b> <b>bus</b> to be reserved for
       PLIP until the network interface is configured 'down'.

       The communication protocol is selected by the <b>link0</b> flag:

       <b>-link0</b>      (default) Use FreeBSD mode (LPIP).  This is the  simpler  of  the  two  modes  and  therefore
                   slightly more efficient.

       <b>link0</b>       Use  Crynwr/Linux compatible mode (CLPIP).  This mode has a simulated Ethernet packet header,
                   and is easier to interface to other types of equipment.

       The interface MTU defaults to 1500, but may be set  to  any  value.   Both  ends  of  the  link  must  be
       configured with the same MTU.

   <b>Cable</b> <b>Connections</b>
       The cable connecting the two parallel ports should be wired as follows:

               Pin     Pin     Description
               2       15      Data0 -&gt; ERROR*
               3       13      Data1 -&gt; SLCT
               4       12      Data2 -&gt; PE
               5       10      Data3 -&gt; ACK*
               6       11      Data4 -&gt; BUSY
               15      2       ERROR* -&gt; Data0
               13      3       SLCT   -&gt; Data1
               12      4       PE     -&gt; Data2
               10      5       ACK*   -&gt; Data3
               11      6       BUSY   -&gt; Data4
               18-25   18-25   Ground

       Cables with this wiring are widely available as 'Laplink' cables, and are often coloured yellow.

       The connections are symmetric, and provide 5 lines in each direction (four data plus one handshake).  The
       two modes use the same wiring, but make a different choice of which line to use as handshake.

   <b>FreeBSD</b> <b>LPIP</b> <b>mode</b>
       The signal lines are used as follows:

       <u>Data0</u> <u>(Pin</u> <u>2)</u>    Data out, bit 0.

       <u>Data1</u> <u>(Pin</u> <u>3)</u>    Data out, bit 1.

       <u>Data2</u> <u>(Pin</u> <u>4)</u>    Data out, bit 2.

       <u>Data3</u> <u>(Pin</u> <u>5)</u>    Handshake out.

       <u>Data4</u> <u>(Pin</u> <u>6)</u>    Data out, bit 3.

       <u>ERROR*</u> <u>(pin</u> <u>15)</u>  Data in, bit 0.

       <u>SLCT</u> <u>(pin</u> <u>13)</u>    Data in, bit 1.

       <u>PE</u> <u>(pin</u> <u>12)</u>      Data in, bit 2.

       <u>BUSY</u> <u>(pin</u> <u>11)</u>    Data in, bit 3.

       <u>ACK*</u> <u>(pin</u> <u>10)</u>    Handshake in.

       When  idle,  all  data lines are at zero.  Each byte is signalled in four steps: sender writes the 4 most
       significant bits and raises the handshake line; receiver reads the 4 bits and  raises  its  handshake  to
       acknowledge;  sender  places  the  4  least  significant bits on the data lines and lowers the handshake;
       receiver reads the data and lowers its handshake.

       The packet format has a two-byte header, comprising the fixed values 0x08, 0x00, immediately followed  by
       the IP header and data.

       The  start  of  a  packet is indicated by simply signalling the first byte of the header.  The end of the
       packet is indicated by inverting the data lines (i.e., writing the ones-complement of the previous nibble
       to be transmitted) without changing the state of the handshake.

       Note that the end-of-packet marker assumes that the handshake signal and the data-out bits can be written
       in a single instruction - otherwise certain byte values in the packet data would falsely  be  interpreted
       as  end-of-packet.   This  is  not a problem for the PC printer port, but requires care when implementing
       this protocol on other equipment.

   <b>Crynwr/Linux</b> <b>CLPIP</b> <b>mode</b>
       The signal lines are used as follows:

       <u>Data0</u> <u>(Pin</u> <u>2)</u>    Data out, bit 0.

       <u>Data1</u> <u>(Pin</u> <u>3)</u>    Data out, bit 1.

       <u>Data2</u> <u>(Pin</u> <u>4)</u>    Data out, bit 2.

       <u>Data3</u> <u>(Pin</u> <u>5)</u>    Data out, bit 3.

       <u>Data4</u> <u>(Pin</u> <u>6)</u>    Handshake out.

       <u>ERROR*</u> <u>(pin</u> <u>15)</u>  Data in, bit 0.

       <u>SLCT</u> <u>(pin</u> <u>13)</u>    Data in, bit 1.

       <u>PE</u> <u>(pin</u> <u>12)</u>      Data in, bit 2.

       <u>ACK*</u> <u>(pin</u> <u>10)</u>    Data in, bit 3.

       <u>BUSY</u> <u>(pin</u> <u>11)</u>    Handshake in.

       When idle, all data lines are at zero.  Each byte is signalled in four steps: sender writes the  4  least
       significant  bits  and  raises  the handshake line; receiver reads the 4 bits and raises its handshake to
       acknowledge; sender places the 4 most significant bits on  the  data  lines  and  lowers  the  handshake;
       receiver  reads  the data and lowers its handshake.  [Note that this is the opposite nibble order to LPIP
       mode].

       Packet format is:

       Length (least significant byte)
       Length (most significant byte)
       12 bytes of supposed MAC addresses (ignored by FreeBSD).
       Fixed byte 0x08
       Fixed byte 0x00
       &lt;IP datagram&gt;
       Checksum byte.

       The length includes the 14 header bytes, but not the length bytes themselves nor the checksum byte.

       The checksum is a simple arithmetic sum of all the bytes (again, including the header but not checksum or
       length bytes).  FreeBSD calculates outgoing checksums, but does not validate incoming ones.

       The start of packet has to be signalled specially, since the line chosen for handshake-in cannot be  used
       to generate an interrupt.  The sender writes the value 0x08 to the data lines, and waits for the receiver
       to  respond  by  writing 0x01 to its data lines.  The sender then starts signalling the first byte of the
       packet (the length byte).

       End of packet is deduced from the packet length and is not signalled specially (although the  data  lines
       are restored to the zero, idle state to avoid spuriously indicating the start of the next packet).

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man4/ppbus.4.html">ppbus</a></u>(4), <u><a href="../man4/ppc.4.html">ppc</a></u>(4), <u><a href="../man8/ifconfig.8.html">ifconfig</a></u>(8)

</pre><h4><b>BUGS</b></h4><pre>
       Busy-waiting  loops  are  used  while  handshaking bytes, (and worse still when waiting for the receiving
       system to respond to an interrupt for the start of a packet).  Hence a fast system talking to a slow  one
       will  consume  excessive amounts of CPU.  This is unavoidable in the case of CLPIP mode due to the choice
       of handshake lines; it could theoretically be improved in the case of LPIP mode.

       Polling timeouts are controlled by counting loop iterations rather than timers, and so are  dependent  on
       CPU speed.  This is somewhat stabilised by the need to perform (slow) ISA bus cycles to actually read the
       port.

Debian                                            March 4, 1996                                            <u><a href="../man4/LP.4.html">LP</a></u>(4)
</pre>
 </div>
</div></section>
</div>
</body>
</html>