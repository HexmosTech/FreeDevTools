<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>disarray - distributed container (rheolef-7.2)</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/librheolef-dev">librheolef-dev_7.2-3build6_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       disarray - distributed container (rheolef-7.2)

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This class provides a std::vector like container for a distributed memory model array.

       The disarray interface is similar to those of the std::vector with the addition of some communication
       features for a distributed memory model.

</pre><h4><b>EXAMPLE</b></h4><pre>
           int main (int argc, char**argv) {
             environment distributed(argc, argv);
             distributor ownership (100);
             disarray&lt;double&gt; x (ownership, 3.14);
             dout &lt;&lt; x &lt;&lt; endl;
           }

</pre><h4><b>NOTATION</b></h4><pre>
       There are two kind of indexes:

       dis_i

            This index refers to the complete array. It is valid on all processes.

       i

            This index refers to the subset of the array that is owned by the current process. It is valid only
           on the local process.

       Read and write accessors to the subset of the array that is owned by the current process are still
       denoted by square brackets, e.g. value = x[i] and x[i] = value, respectively.

       Read and write accessors to the complete array, including array subsets that are owned by some others
       processors, are introduced with the help of new member functions:

       x.dis_entry(dis_i) = value

            write access at any location

       value = x.dis_at(dis_i)

            read access at any location

       In order to optimize communications, they should be grouped.

</pre><h4><b>GROUPED</b> <b>WRITES</b></h4><pre>
       Loop on any dis_i and write your value:

           for (...) {
             x.dis_entry (dis_i) = value;
           }

        Finally, perform all communications in one pass:

           x.dis_entry_assembly();

        After this command, each value is stored in x, at its right place, depending on dis_i and its ownership.
       Note that, when dis_i is owned by the current process, the value is directly written as x[i] = value and
       no communication are generated.

</pre><h4><b>GROUPED</b> <b>READS</b></h4><pre>
       First, define the set of indexes that you want to access:

           std::set&lt;size_t&gt; dis_i_set;

        Then, loop on dis_i all these indexes and append it to this set:

           for (...) {
             dis_i_set.insert (dis_i);
           }

        Next, perform communications:

           x.set_dis_indexes (dis_i_set);

        After this command, each values associated to the dis_i index, and that belongs to the index set, is
       also available also on the current processor:

           for (...) {
             value = x.dis_at (dis_i);
           }

        Note that, when dis_i is owned by the current process, the value is directly read as value = x[i] and no
       communication are generated.

</pre><h4><b>TEMPLATE</b> <b>PARAMETERS</b></h4><pre>
       Recall that the std::class that takes two template parameters, a T one for the stored elements and a A
       one for the memory allocator, the present disarray class take three template parameters:

       • T: the stored object type

       • M: the memory model, i.e. sequential or distributed, by default default_memory_model with is defined at
         the <b>configuration</b> stage

       • A: the memory allocator, by default std::allocator

</pre><h4><b>CONSTRUCTOR</b></h4><pre>
       In the sequential case, the class interface provides a simplified constructor:

           int local_size = 100;
           disarray&lt;double,sequential&gt; x (local_size, init_val);

        This  declaration  is similar to those of a std::vector one: no communications are possible. In order to
       enable communication, your have to replace the local_size by information on how the array is  distributed
       in memory:

             distributor ownership (100);
             disarray&lt;double&gt; x (ownership, 3.14);

        The <b><a href="../man4/distributor.4.html">distributor</a>(4)</b> class does this job.

</pre><h4><b>IMPLEMENTATION</b></h4><pre>
       This documentation has been generated from file linalg/lib/disarray.h

       template &lt;class T, class A&gt;
       class disarray&lt;T,distributed,A&gt; : public smart_pointer&lt;disarray_rep&lt;T,distributed,A&gt; &gt; {
       public:

       // typedefs:

           typedef disarray_rep&lt;T,distributed,A&gt; rep;
           typedef smart_pointer&lt;rep&gt;            base;

           typedef distributed                   memory_type;
           typedef typename rep::size_type       size_type;
           typedef typename rep::difference_type difference_type;
           typedef typename rep::value_type      value_type;
           typedef typename rep::reference       reference;
           typedef typename rep::dis_reference   dis_reference;
           typedef typename rep::iterator        iterator;
           typedef typename rep::const_reference const_reference;
           typedef typename rep::const_iterator  const_iterator;
           typedef typename rep::scatter_map_type scatter_map_type;

       // allocators:

           disarray       (const distributor&amp; ownership = distributor(), const T&amp; init_val = T(), const A&amp; alloc = A());
           void resize (const distributor&amp; ownership = distributor(), const T&amp; init_val = T());

       // local accessors &amp; modifiers:

           A get_allocator() const              { return base::data().get_allocator(); }
           size_type     size () const          { return base::data().size(); }
           size_type dis_size () const          { return base::data().dis_size(); }
           const distributor&amp; ownership() const { return base::data().ownership(); }
           const communicator&amp; comm() const     { return base::data().comm(); }

           reference       operator[] (size_type i)       { return base::data().operator[] (i); }
           const_reference operator[] (size_type i) const { return base::data().operator[] (i); }
           reference       operator() (size_type i)       { return base::data().operator[] (i); }
           const_reference operator() (size_type i) const { return base::data().operator[] (i); }

                 iterator begin()       { return base::data().begin(); }
           const_iterator begin() const { return base::data().begin(); }
                 iterator end()         { return base::data().end(); }
           const_iterator end() const   { return base::data().end(); }

       // global accessor:

           template&lt;class Set, class Map&gt;
           void append_dis_entry (const Set&amp; ext_idx_set, Map&amp; ext_idx_map) const { base::data().append_dis_entry (ext_idx_set, ext_idx_map); }

           template&lt;class Set, class Map&gt;
           void get_dis_entry    (const Set&amp; ext_idx_set, Map&amp; ext_idx_map) const { base::data().get_dis_entry (ext_idx_set, ext_idx_map); }

           template&lt;class Set&gt;
           void append_dis_indexes (const Set&amp; ext_idx_set) const { base::data().append_dis_indexes (ext_idx_set); }
           void reset_dis_indexes() const { base::data().reset_dis_indexes(); }
           void get_dis_indexes (std::set&lt;size_type&gt;&amp; ext_idx_set) const { base::data().get_dis_indexes (ext_idx_set); }

           template&lt;class Set&gt;
           void set_dis_indexes    (const Set&amp; ext_idx_set) const { base::data().set_dis_indexes (ext_idx_set); }

           const T&amp; dis_at (size_type dis_i) const { return base::data().dis_at (dis_i); }

           // get all external pairs (dis_i, values):
           const scatter_map_type&amp; get_dis_map_entries() const { return base::data().get_dis_map_entries(); }

       // global modifiers (for compatibility with distributed interface):

           dis_reference dis_entry (size_type dis_i) { return base::data().dis_entry(dis_i); }

           template&lt;class SetOp = typename details::default_set_op_traits&lt;T&gt;::type&gt;
           void dis_entry_assembly_begin (SetOp my_set_op = SetOp()) { base::data().dis_entry_assembly_begin (my_set_op); }
           template&lt;class SetOp = typename details::default_set_op_traits&lt;T&gt;::type&gt;
           void dis_entry_assembly_end   (SetOp my_set_op = SetOp()) { base::data().dis_entry_assembly_end   (my_set_op); }
           template&lt;class SetOp = typename details::default_set_op_traits&lt;T&gt;::type&gt;
           void dis_entry_assembly       (SetOp my_set_op = SetOp()) { base::data().dis_entry_assembly       (my_set_op); }

           void dis_entry_assembly_begin() { base::data().template dis_entry_assembly_begin&lt;typename details::default_set_op_traits&lt;T&gt;::type&gt;(); }
           void dis_entry_assembly_end()   { base::data().template dis_entry_assembly_end&lt;typename details::default_set_op_traits&lt;T&gt;::type&gt;(); }
           void dis_entry_assembly()       { dis_entry_assembly_begin(); dis_entry_assembly_end(); }

       // apply a partition:

           template&lt;class RepSize&gt;
           void repartition (                              // old_numbering for *this
               const RepSize&amp;        partition,            // old_ownership
               disarray&lt;T,distributed&gt;&amp; new_disarray,            // new_ownership (created)
               RepSize&amp;              old_numbering,        // new_ownership
               RepSize&amp;              new_numbering) const  // old_ownership
               { return base::data().repartition (partition.data(), new_disarray.data(), old_numbering.data(), new_numbering.data()); }

           template&lt;class RepSize&gt;
           void permutation_apply (                       // old_numbering for *this
               const RepSize&amp;          new_numbering,     // old_ownership
               disarray&lt;T,distributed,A&gt;&amp; new_disarray) const   // new_ownership (already allocated)
               { base::data().permutation_apply (new_numbering.data(), new_disarray.data()); }

           void reverse_permutation (                                 // old_ownership for *this=iold2dis_inew
               disarray&lt;size_type,distributed,A&gt;&amp; inew2dis_iold) const   // new_ownership
               { base::data().reverse_permutation (inew2dis_iold.data()); }

       // i/o:

           odiststream&amp; put_values (odiststream&amp; ops) const { return base::data().put_values(ops); }
           idiststream&amp; get_values (idiststream&amp; ips)       { return base::data().get_values(ips); }
           void dump (std::string name) const      { return base::data().dump(name); }

           template &lt;class GetFunction&gt;
           idiststream&amp; get_values (idiststream&amp; ips, GetFunction get_element)       { return base::data().get_values(ips, get_element); }
           template &lt;class PutFunction&gt;
           odiststream&amp; put_values (odiststream&amp; ops, PutFunction put_element) const { return base::data().put_values(ops, put_element); }
           template &lt;class PutFunction, class A2&gt; odiststream&amp; permuted_put_values (
                       odiststream&amp; ops, const disarray&lt;size_type,distributed,A2&gt;&amp; perm, PutFunction put_element) const
                                                                            { return base::data().permuted_put_values (ops, perm.data(), put_element); }
       };

</pre><h4><b>AUTHOR</b></h4><pre>
       Pierre  Saramito  &lt;<a href="mailto:Pierre.Saramito@imag.fr">Pierre.Saramito@imag.fr</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright    (C)   2000-2018   Pierre   Saramito   &lt;<a href="mailto:Pierre.Saramito@imag.fr">Pierre.Saramito@imag.fr</a>&gt; GPLv3+: GNU GPL version 3 or
       later  &lt;<a href="http://gnu.org/licenses/gpl.html">http://gnu.org/licenses/gpl.html</a>&gt;.  This  is  free   software:   you   are  free  to  change  and
       redistribute it.  There is NO WARRANTY, to the extent permitted by law.

rheolef                                            Version 7.2                                <u><a href="../man4rheolef/disarray.4rheolef.html">disarray</a></u>(4rheolef)
</pre>
 </div>
</div></section>
</div>
</body>
</html>