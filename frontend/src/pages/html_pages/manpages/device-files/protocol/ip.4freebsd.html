<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ip — Internet Protocol</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ip — Internet Protocol

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/types.h&gt;</b>
       <b>#include</b> <b>&lt;sys/socket.h&gt;</b>
       <b>#include</b> <b>&lt;<a href="file:/usr/include/netinet/in.h">netinet/in.h</a>&gt;</b>

       <u>int</u>
       <b>socket</b>(<u>AF_INET</u>, <u>SOCK_RAW</u>, <u>proto</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       IP  is  the  transport layer protocol used by the Internet protocol family.  Options may be set at the IP
       level when using higher-level protocols that are based on IP (such as TCP  and  UDP).   It  may  also  be
       accessed through a “raw socket” when developing new protocols, or special-purpose applications.

       There are several IP-level <u><a href="../man2/setsockopt.2.html">setsockopt</a></u>(2) and <u><a href="../man2/getsockopt.2.html">getsockopt</a></u>(2) options.  IP_OPTIONS may be used to provide IP
       options  to  be  transmitted in the IP header of each outgoing packet or to examine the header options on
       incoming packets.  IP options may be used with any socket type in the Internet family.  The format of  IP
       options  to be sent is that specified by the IP protocol specification (RFC-791), with one exception: the
       list of addresses for Source Route options must include the first-hop gateway at  the  beginning  of  the
       list  of  gateways.   The  first-hop  gateway address will be extracted from the option list and the size
       adjusted accordingly before use.  To disable previously specified options, use a zero-length buffer:

       setsockopt(s, IPPROTO_IP, IP_OPTIONS, NULL, 0);

       IP_TOS and IP_TTL may be used to set the type-of-service and time-to-live fields in  the  IP  header  for
       SOCK_STREAM, SOCK_DGRAM, and certain types of SOCK_RAW sockets.  For example,

       int tos = IPTOS_LOWDELAY;       /* see &lt;netinet/ip.h&gt; */
       setsockopt(s, IPPROTO_IP, IP_TOS, &amp;tos, sizeof(tos));

       int ttl = 60;                   /* max = 255 */
       setsockopt(s, IPPROTO_IP, IP_TTL, &amp;ttl, sizeof(ttl));

       IP_MINTTL  may  be  used  to set the minimum acceptable TTL a packet must have when received on a socket.
       All packets with a lower TTL are silently dropped.  This option is only really useful when  set  to  255,
       preventing packets from outside the directly connected networks reaching local listeners on sockets.

       IP_DONTFRAG may be used to set the Don't Fragment flag on IP packets.  Currently this option is respected
       only  on  <u><a href="../man4/udp.4.html">udp</a></u>(4)  and  raw <b>ip</b> sockets, unless the IP_HDRINCL option has been set.  On <u><a href="../man4/tcp.4.html">tcp</a></u>(4) sockets, the
       Don't Fragment flag is controlled by the Path MTU Discovery option.  Sending a packet larger than the MTU
       size of the egress interface, determined by the destination address, returns an EMSGSIZE error.

       If the IP_ORIGDSTADDR option is enabled on a SOCK_DGRAM socket,  the  <u><a href="../man2/recvmsg.2.html">recvmsg</a></u>(2)  call  will  return  the
       destination  IP  address  and  destination  port for a UDP datagram.  The <u>msg_control</u> field in the <u>msghdr</u>
       structure points to a buffer that contains a <u>cmsghdr</u> structure followed  by  the  sockaddr_in  structure.
       The <u>cmsghdr</u> fields have the following values:

       cmsg_len = CMSG_LEN(sizeof(struct sockaddr_in))
       cmsg_level = IPPROTO_IP
       cmsg_type = IP_ORIGDSTADDR

       If  the  IP_RECVDSTADDR  option  is  enabled  on a SOCK_DGRAM socket, the <u><a href="../man2/recvmsg.2.html">recvmsg</a></u>(2) call will return the
       destination IP address for a UDP datagram.  The <u>msg_control</u> field in the <u>msghdr</u>  structure  points  to  a
       buffer  that  contains  a  <u>cmsghdr</u>  structure  followed  by  the IP address.  The <u>cmsghdr</u> fields have the
       following values:

       cmsg_len = CMSG_LEN(sizeof(struct in_addr))
       cmsg_level = IPPROTO_IP
       cmsg_type = IP_RECVDSTADDR

       The source address to be used for outgoing UDP datagrams on a socket can be specified as  ancillary  data
       with  a  type  code  of  IP_SENDSRCADDR.  The msg_control field in the msghdr structure should point to a
       buffer that contains a <u>cmsghdr</u> structure followed by the IP address.  The cmsghdr fields should have  the
       following values:

       cmsg_len = CMSG_LEN(sizeof(struct in_addr))
       cmsg_level = IPPROTO_IP
       cmsg_type = IP_SENDSRCADDR

       The  socket  should  be  either  bound  to  INADDR_ANY  and  a  local port, and the address supplied with
       IP_SENDSRCADDR should't be INADDR_ANY, or the socket should be bound to a local address and  the  address
       supplied  with  IP_SENDSRCADDR  should be INADDR_ANY.  In the latter case bound address is overridden via
       generic source  address  selection  logic,  which  would  choose  IP  address  of  interface  closest  to
       destination.

       For   convenience,  IP_SENDSRCADDR  is  defined  to  have  the  same  value  as  IP_RECVDSTADDR,  so  the
       IP_RECVDSTADDR control message from <u><a href="../man2/recvmsg.2.html">recvmsg</a></u>(2) can be used directly as a control message for <u><a href="../man2/sendmsg.2.html">sendmsg</a></u>(2).

       If the IP_ONESBCAST option is enabled on a SOCK_DGRAM or a SOCK_RAW socket, the  destination  address  of
       outgoing  broadcast  datagrams  on  that  socket  will  be  forced  to  the undirected broadcast address,
       INADDR_BROADCAST, before transmission.  This is in contrast to the default behavior of the system,  which
       is to transmit undirected broadcasts via the first network interface with the IFF_BROADCAST flag set.

       This  option  allows  applications  to choose which interface is used to transmit an undirected broadcast
       datagram.  For example, the following code would force an undirected broadcast to be transmitted via  the
       interface configured with the broadcast address 192.168.2.255:

       char msg[512];
       struct sockaddr_in sin;
       int onesbcast = 1;      /* 0 = disable (default), 1 = enable */

       setsockopt(s, IPPROTO_IP, IP_ONESBCAST, &amp;onesbcast, sizeof(onesbcast));
       sin.sin_addr.s_addr = inet_addr("192.168.2.255");
       sin.sin_port = <a href="../man1234/htons.1234.html">htons</a>(1234);
       sendto(s, msg, <a href="../manmsg/sizeof.msg.html">sizeof</a>(msg), 0, &amp;sin, sizeof(sin));

       It  is  the  application's  responsibility  to  set the IP_TTL option to an appropriate value in order to
       prevent broadcast storms.  The application must have  sufficient  credentials  to  set  the  SO_BROADCAST
       socket level option, otherwise the IP_ONESBCAST option has no effect.

       If the IP_BINDANY option is enabled on a SOCK_STREAM, SOCK_DGRAM or a SOCK_RAW socket, one can <u><a href="../man2/bind.2.html">bind</a></u>(2) to
       any address, even one not bound to any available network interface in the system.  This functionality (in
       conjunction  with  special  firewall  rules)  can  be  used  for  implementing  a transparent proxy.  The
       PRIV_NETINET_BINDANY privilege is needed to set this option.

       If the IP_RECVTTL option is enabled on a SOCK_DGRAM socket, the <u><a href="../man2/recvmsg.2.html">recvmsg</a></u>(2) call will return  the  IP  TTL
       (time  to  live)  field  for  a  UDP datagram.  The msg_control field in the msghdr structure points to a
       buffer that contains a cmsghdr structure followed by the TTL.  The  cmsghdr  fields  have  the  following
       values:

       cmsg_len = CMSG_LEN(sizeof(u_char))
       cmsg_level = IPPROTO_IP
       cmsg_type = IP_RECVTTL

       If  the  IP_RECVTOS  option is enabled on a SOCK_DGRAM socket, the <u><a href="../man2/recvmsg.2.html">recvmsg</a></u>(2) call will return the IP TOS
       (type of service) field for a UDP datagram.  The msg_control field in the msghdr structure  points  to  a
       buffer  that  contains  a  cmsghdr  structure followed by the TOS.  The cmsghdr fields have the following
       values:

       cmsg_len = CMSG_LEN(sizeof(u_char))
       cmsg_level = IPPROTO_IP
       cmsg_type = IP_RECVTOS

       If the IP_RECVIF option is enabled  on  a  SOCK_DGRAM  socket,  the  <u><a href="../man2/recvmsg.2.html">recvmsg</a></u>(2)  call  returns  a  <u>struct</u>
       <u>sockaddr_dl</u>  corresponding  to  the interface on which the packet was received.  The <u>msg_control</u> field in
       the <u>msghdr</u> structure points to a buffer  that  contains  a  <u>cmsghdr</u>  structure  followed  by  the  <u>struct</u>
       <u>sockaddr_dl</u>.  The <u>cmsghdr</u> fields have the following values:

       cmsg_len = CMSG_LEN(sizeof(struct sockaddr_dl))
       cmsg_level = IPPROTO_IP
       cmsg_type = IP_RECVIF

       IP_PORTRANGE may be used to set the port range used for selecting a local port number on a socket with an
       unspecified (zero) port number.  It has the following possible values:

       IP_PORTRANGE_DEFAULT  use   the   default   range   of   values,   normally   IPPORT_HIFIRSTAUTO  through
                             IPPORT_HILASTAUTO.    This   is   adjustable   through    the    sysctl    setting:
                             <u>net.inet.ip.portrange.first</u> and <u>net.inet.ip.portrange.last</u>.

       IP_PORTRANGE_HIGH     use  a  high  range  of  values, normally IPPORT_HIFIRSTAUTO and IPPORT_HILASTAUTO.
                             This is adjustable through the sysctl  setting:  <u>net.inet.ip.portrange.hifirst</u>  and
                             <u>net.inet.ip.portrange.hilast</u>.

       IP_PORTRANGE_LOW      use  a low range of ports, which are normally restricted to privileged processes on
                             Unix  systems.   The  range  is  normally  from  IPPORT_RESERVED  -   1   down   to
                             <b>IPPORT_RESERVEDSTART</b>  in  descending  order.  This is adjustable through the sysctl
                             setting: <u>net.inet.ip.portrange.lowfirst</u> and <u>net.inet.ip.portrange.lowlast</u>.

       The range of privileged ports which only may be opened by root-owned processes may  be  modified  by  the
       <u>net.inet.ip.portrange.reservedlow</u>  and  <u>net.inet.ip.portrange.reservedhigh</u>  sysctl  settings.  The values
       default to the traditional range, 0 through IPPORT_RESERVED - 1 (0  through  1023),  respectively.   Note
       that  these  settings  do  not  affect  and  are not accounted for in the use or calculation of the other
       <u>net.inet.ip.portrange</u> values above.  Changing these values departs from Unix tradition and  has  security
       consequences that the administrator should carefully evaluate before modifying these settings.

       Ports  are  allocated  at  random  within the specified port range in order to increase the difficulty of
       random spoofing attacks.  In scenarios such as benchmarking, this behavior may be undesirable.  In  these
       cases,  <u>net.inet.ip.portrange.randomized</u>  can  be  used  to  toggle  randomization  off.   If  more  than
       <u>net.inet.ip.portrange.randomcps</u> ports have been allocated in the last second, then return  to  sequential
       port  allocation.   Return  to  random  allocation only once the current port allocation rate drops below
       <u>net.inet.ip.portrange.randomcps</u> for  at  least  <u>net.inet.ip.portrange.randomtime</u>  seconds.   The  default
       values  for  <u>net.inet.ip.portrange.randomcps</u> and <u>net.inet.ip.portrange.randomtime</u> are 10 port allocations
       per second and 45 seconds correspondingly.

   <b>Multicast</b> <b>Options</b>
       IP multicasting is supported only on AF_INET sockets  of  type  SOCK_DGRAM  and  SOCK_RAW,  and  only  on
       networks where the interface driver supports multicasting.

       The  IP_MULTICAST_TTL  option changes the time-to-live (TTL) for outgoing multicast datagrams in order to
       control the scope of the multicasts:

       u_char ttl;     /* range: 0 to 255, default = 1 */
       setsockopt(s, IPPROTO_IP, IP_MULTICAST_TTL, &amp;ttl, sizeof(ttl));

       Datagrams with a TTL of 1 are not forwarded beyond the local network.  Multicast datagrams with a TTL  of
       0 will not be transmitted on any network, but may be delivered locally if the sending host belongs to the
       destination  group  and  if  multicast  loopback has not been disabled on the sending socket (see below).
       Multicast datagrams with TTL greater than 1 may be forwarded to other networks if a multicast  router  is
       attached to the local network.

       For  hosts  with  multiple  interfaces,  where  an interface has not been specified for a multicast group
       membership, each multicast transmission is sent from the primary network interface.  The  IP_MULTICAST_IF
       option overrides the default for subsequent transmissions from a given socket:

       struct in_addr addr;
       setsockopt(s, IPPROTO_IP, IP_MULTICAST_IF, &amp;addr, sizeof(addr));

       where  "addr"  is  the  local  IP  address  of the desired interface or INADDR_ANY to specify the default
       interface.

       To specify an interface by index, an instance of <u>ip_mreqn</u> may be passed instead.  The <u>imr_ifindex</u>  member
       should  be  set to the index of the desired interface, or 0 to specify the default interface.  The kernel
       differentiates between these two structures by their size.

       The use of <u>IP_MULTICAST_IF</u> is <u>not</u> <u>recommended</u>, as multicast memberships are  scoped  to  each  individual
       interface.  It is supported for legacy use only by applications, such as routing daemons, which expect to
       be  able  to  transmit link-local IPv4 multicast datagrams (224.0.0.0/24) on multiple interfaces, without
       requesting an individual membership for each interface.

       An interface's local IP address and  multicast  capability  can  be  obtained  via  the  SIOCGIFCONF  and
       SIOCGIFFLAGS ioctls.  Normal applications should not need to use this option.

       If  a  multicast  datagram  is  sent to a group to which the sending host itself belongs (on the outgoing
       interface), a copy of the datagram is, by default, looped back by the IP layer for local  delivery.   The
       IP_MULTICAST_LOOP  option  gives the sender explicit control over whether or not subsequent datagrams are
       looped back:

       u_char loop;    /* 0 = disable, 1 = enable (default) */
       setsockopt(s, IPPROTO_IP, IP_MULTICAST_LOOP, &amp;loop, sizeof(loop));

       This option improves performance for applications that may have no more than one  instance  on  a  single
       host  (such  as  a routing daemon), by eliminating the overhead of receiving their own transmissions.  It
       should generally not be used by applications for which there may be more than one instance  on  a  single
       host  (such  as  a conferencing program) or for which the sender does not belong to the destination group
       (such as a time querying program).

       The sysctl setting <u>net.inet.ip.mcast.loop</u> controls the default setting of  the  IP_MULTICAST_LOOP  socket
       option for new sockets.

       A  multicast  datagram  sent with an initial TTL greater than 1 may be delivered to the sending host on a
       different interface from that on which it was sent, if the host belongs to the destination group on  that
       other interface.  The loopback control option has no effect on such delivery.

       A  host  must become a member of a multicast group before it can receive datagrams sent to the group.  To
       join a multicast group, use the IP_ADD_MEMBERSHIP option:

       struct ip_mreqn mreqn;
       setsockopt(s, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;mreqn, <a href="../manmreqn/sizeof.mreqn.html">sizeof</a>(mreqn));

       where <u>mreqn</u> is the following structure:

       struct ip_mreqn {
           struct in_addr imr_multiaddr; /* IP multicast address of group */
           struct in_addr imr_interface; /* local IP address of interface */
           int            imr_ifindex;   /* interface index */
       }

       <u>imr_ifindex</u> should be set to the index of  a  particular  multicast-capable  interface  if  the  host  is
       multihomed.  If <u>imr_ifindex</u> is non-zero, value of <u>imr_interface</u> is ignored.  Otherwise, if <u>imr_ifindex</u> is
       0,  kernel will use IP address from <u>imr_interface</u> to lookup the interface.  Value of <u>imr_interface</u> may be
       set to <u>INADDR_ANY</u> to choose the default interface, although this is not recommended; this  is  considered
       to  be  the  first  interface corresponding to the default route.  Otherwise, the first multicast-capable
       interface configured in the system will be used.

       Legacy <u>struct</u> <u>ip_mreq</u>, that lacks <u>imr_ifindex</u> field is also supported  by  IP_ADD_MEMBERSHIP  setsockopt.
       In  this case kernel would behave as if <u>imr_ifindex</u> was set to zero: <u>imr_interface</u> will be used to lookup
       interface.

       Prior to FreeBSD 7.0, if the <u>imr_interface</u> member is within the network range <b>0.0.0.0/8</b>, it is treated as
       an interface index in the system interface MIB, as per the RIP Version 2 MIB  Extension  (RFC-1724).   In
       versions  of  FreeBSD since 7.0, this behavior is no longer supported.  Developers should instead use the
       RFC 3678 multicast source filter APIs; in particular, MCAST_JOIN_GROUP.

       Up to IP_MAX_MEMBERSHIPS memberships may be added on a single socket.  Membership is  associated  with  a
       single  interface;  programs running on multihomed hosts may need to join the same group on more than one
       interface.

       To drop a membership, use:

       struct ip_mreq mreq;
       setsockopt(s, IPPROTO_IP, IP_DROP_MEMBERSHIP, &amp;mreq, <a href="../manmreq/sizeof.mreq.html">sizeof</a>(mreq));

       where <u>mreq</u> contains the same values as used to add the membership.   Memberships  are  dropped  when  the
       socket is closed or the process exits.

       The  IGMP  protocol  uses the primary IP address of the interface as its identifier for group membership.
       This is the first IP address configured on the interface.  If this address is  removed  or  changed,  the
       results  are  undefined,  as the IGMP membership state will then be inconsistent.  If multiple IP aliases
       are configured on the same interface, they will be ignored.

       This shortcoming was addressed in IPv6;  MLDv2  requires  that  the  unique  link-local  address  for  an
       interface is used to identify an MLDv2 listener.

   <b>Source-Specific</b> <b>Multicast</b> <b>Options</b>
       Since  FreeBSD 8.0, the use of Source-Specific Multicast (SSM) is supported.  These extensions require an
       IGMPv3 multicast router in order to make best use of them.  If a legacy multicast router  is  present  on
       the  link, FreeBSD will simply downgrade to the version of IGMP spoken by the router, and the benefits of
       source filtering on the upstream link will not be present, although the kernel will continue  to  squelch
       transmissions from blocked sources.

       Each group membership on a socket now has a filter mode:

       MCAST_EXCLUDE  Datagrams  sent  to  this  group  are  accepted, unless the source is in a list of blocked
                      source addresses.

       MCAST_INCLUDE  Datagrams sent to this group are accepted only if the source is  in  a  list  of  accepted
                      source addresses.

       Groups  joined  using  the  legacy IP_ADD_MEMBERSHIP option are placed in exclusive-mode, and are able to
       request that certain sources are blocked or allowed.  This is known as the <u>delta-based</u> <u>API</u>.

       To block a multicast source on an existing group membership:

       struct ip_mreq_source mreqs;
       setsockopt(s, IPPROTO_IP, IP_BLOCK_SOURCE, &amp;mreqs, <a href="../manmreqs/sizeof.mreqs.html">sizeof</a>(mreqs));

       where <u>mreqs</u> is the following structure:

       struct ip_mreq_source {
           struct in_addr imr_multiaddr; /* IP multicast address of group */
           struct in_addr imr_sourceaddr; /* IP address of source */
           struct in_addr imr_interface; /* local IP address of interface */
       }
       <u>imr_sourceaddr</u> should be set to the address of the source to be blocked.

       To unblock a multicast source on an existing group:

       struct ip_mreq_source mreqs;
       setsockopt(s, IPPROTO_IP, IP_UNBLOCK_SOURCE, &amp;mreqs, <a href="../manmreqs/sizeof.mreqs.html">sizeof</a>(mreqs));

       The IP_BLOCK_SOURCE and IP_UNBLOCK_SOURCE options are <u>not</u> <u>permitted</u> for inclusive-mode group memberships.

       To join a multicast group in MCAST_INCLUDE mode with a  single  source,  or  add  another  source  to  an
       existing inclusive-mode membership:

       struct ip_mreq_source mreqs;
       setsockopt(s, IPPROTO_IP, IP_ADD_SOURCE_MEMBERSHIP, &amp;mreqs, <a href="../manmreqs/sizeof.mreqs.html">sizeof</a>(mreqs));

       To leave a single source from an existing group in inclusive mode:

       struct ip_mreq_source mreqs;
       setsockopt(s, IPPROTO_IP, IP_DROP_SOURCE_MEMBERSHIP, &amp;mreqs, <a href="../manmreqs/sizeof.mreqs.html">sizeof</a>(mreqs));
       If this is the last accepted source for the group, the membership will be dropped.

       The  IP_ADD_SOURCE_MEMBERSHIP  and  IP_DROP_SOURCE_MEMBERSHIP options are <u>not</u> <u>accepted</u> for exclusive-mode
       group memberships.  However, both exclusive and  inclusive  mode  memberships  support  the  use  of  the
       <u>full-state</u>  <u>API</u>  documented  in  RFC  3678.  For management of source filter lists using this API, please
       refer to <u><a href="../man3/sourcefilter.3.html">sourcefilter</a></u>(3).

       The sysctl settings <u>net.inet.ip.mcast.maxsocksrc</u> and <u>net.inet.ip.mcast.maxgrpsrc</u> are used to  specify  an
       upper  limit  on  the  number  of  per-socket  and  per-group  source filter entries which the kernel may
       allocate.

   <b>Raw</b> <b>IP</b> <b>Sockets</b>
       Raw IP sockets are connectionless, and are normally used with the <u><a href="../man2/sendto.2.html">sendto</a></u>(2) and <u><a href="../man2/recvfrom.2.html">recvfrom</a></u>(2) calls, though
       the <u><a href="../man2/connect.2.html">connect</a></u>(2) call may also be used to fix the destination for future packets (in which case the <u><a href="../man2/read.2.html">read</a></u>(2)
       or <u><a href="../man2/recv.2.html">recv</a></u>(2) and <u><a href="../man2/write.2.html">write</a></u>(2) or <u><a href="../man2/send.2.html">send</a></u>(2) system calls may be used).

       If <u>proto</u> is 0, the default protocol IPPROTO_RAW is used for outgoing packets, and only  incoming  packets
       destined  for  that  protocol  are  received.  If <u>proto</u> is non-zero, that protocol number will be used on
       outgoing packets and to filter incoming packets.

       Outgoing packets automatically have an IP header prepended to them (based on the destination address  and
       the  protocol  number  the socket is created with), unless the IP_HDRINCL option has been set.  Unlike in
       previous BSD releases, incoming packets are received with IP  header  and  options  intact,  leaving  all
       fields in network byte order.

       IP_HDRINCL  indicates  the  complete  IP  header  is included with the data and may be used only with the
       SOCK_RAW type.

       #include &lt;<a href="file:/usr/include/netinet/in_systm.h">netinet/in_systm.h</a>&gt;
       #include &lt;<a href="file:/usr/include/netinet/ip.h">netinet/ip.h</a>&gt;

       int hincl = 1;                  /* 1 = on, 0 = off */
       setsockopt(s, IPPROTO_IP, IP_HDRINCL, &amp;hincl, sizeof(hincl));

       Unlike previous BSD releases, the program must set all  the  fields  of  the  IP  header,  including  the
       following:

       ip-&gt;ip_v = IPVERSION;
       ip-&gt;ip_hl = hlen &gt;&gt; 2;
       ip-&gt;ip_id = 0;  /* 0 means kernel set appropriate value */
       ip-&gt;ip_off = htons(offset);
       ip-&gt;ip_len = htons(len);

       The  packet should be provided as is to be sent over wire.  This implies all fields, including <u>ip_len</u> and
       <u>ip_off</u> to be in network byte order.  See <u><a href="../man3/byteorder.3.html">byteorder</a></u>(3) for more information on network byte order.  If the
       <u>ip_id</u> field is set to 0 then the kernel will choose an appropriate value.  If the header  source  address
       is set to INADDR_ANY, the kernel will choose an appropriate address.

</pre><h4><b>ERRORS</b></h4><pre>
       A socket operation may fail with one of the following errors returned:

       [EISCONN]          when  trying  to  establish  a  connection  on a socket which already has one, or when
                          trying to send a datagram with the destination address specified  and  the  socket  is
                          already connected;

       [ENOTCONN]         when  trying  to  send  a  datagram,  but no destination address is specified, and the
                          socket has not been connected;

       [ENOBUFS]          when the system runs out of memory for an internal data structure;

       [EADDRNOTAVAIL]    when an attempt is made to create a socket with a network address for which no network
                          interface exists.

       [EACCES]           when an attempt is made to create a raw IP socket by a non-privileged process.

       The following errors specific to IP may occur when setting or getting IP options:

       [EINVAL]           An unknown socket option name was given.

       [EINVAL]           The IP option field was improperly formed;  an  option  field  was  shorter  than  the
                          minimum value or longer than the option buffer provided.

       The  following  errors  may  occur  when  attempting  to  send  IP  datagrams via a “raw socket” with the
       IP_HDRINCL option set:

       [EINVAL]           The user-supplied <u>ip_len</u> field was not equal to the length of the datagram written  to
                          the socket.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man2/getsockopt.2.html">getsockopt</a></u>(2),  <u><a href="../man2/recv.2.html">recv</a></u>(2), <u><a href="../man2/send.2.html">send</a></u>(2), <u><a href="../man3/byteorder.3.html">byteorder</a></u>(3), <u><a href="../man3/CMSG_DATA.3.html">CMSG_DATA</a></u>(3), <u><a href="../man3/sourcefilter.3.html">sourcefilter</a></u>(3), <u><a href="../man4/icmp.4.html">icmp</a></u>(4), <u><a href="../man4/igmp.4.html">igmp</a></u>(4), <u><a href="../man4/inet.4.html">inet</a></u>(4),
       <u><a href="../man4/intro.4.html">intro</a></u>(4), <u><a href="../man4/multicast.4.html">multicast</a></u>(4)

       D. Thaler, B. Fenner, and B. Quinn, <u>Socket</u> <u>Interface</u> <u>Extensions</u> <u>for</u> <u>Multicast</u> <u>Source</u> <u>Filters</u>,  RFC  3678,
       Jan 2004.

</pre><h4><b>HISTORY</b></h4><pre>
       The <b>ip</b> protocol appeared in 4.2BSD.  The <u>ip_mreqn</u> structure appeared in Linux 2.4.

</pre><h4><b>BUGS</b></h4><pre>
       Before FreeBSD 10.0 packets received on raw IP sockets had the <u>ip_hl</u> subtracted from the <u>ip_len</u> field.

       Before FreeBSD 11.0 packets received on raw IP sockets had the <u>ip_len</u> and <u>ip_off</u> fields converted to host
       byte  order.   Packets  written  to  raw  IP sockets were expected to have <u>ip_len</u> and <u>ip_off</u> in host byte
       order.

Debian                                            May 24, 2020                                             <u><a href="../man4/IP.4.html">IP</a></u>(4)
</pre>
 </div>
</div></section>
</div>
</body>
</html>