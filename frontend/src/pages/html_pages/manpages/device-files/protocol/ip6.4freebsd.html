<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ip6 — Internet Protocol version 6 (IPv6) network layer</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ip6 — Internet Protocol version 6 (IPv6) network layer

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/socket.h&gt;</b>
       <b>#include</b> <b>&lt;<a href="file:/usr/include/netinet/in.h">netinet/in.h</a>&gt;</b>

       <u>int</u>
       <b>socket</b>(<u>AF_INET6</u>, <u>SOCK_RAW</u>, <u>proto</u>);

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  IPv6  network layer is used by the IPv6 protocol family for transporting data.  IPv6 packets contain
       an IPv6 header that is not provided as part of the payload contents when passed to an application.   IPv6
       header  options affect the behavior of this protocol and may be used by high-level protocols (such as the
       <u><a href="../man4/tcp.4.html">tcp</a></u>(4) and <u><a href="../man4/udp.4.html">udp</a></u>(4) protocols) as well as directly by “raw sockets”,  which  process  IPv6  messages  at  a
       lower-level and may be useful for developing new protocols and special-purpose applications.

   <b>Header</b>
       All  IPv6  packets  begin  with  an  IPv6  header.   When  data  received by the kernel are passed to the
       application, this header is not included in buffer, even when raw sockets are being used.  Likewise, when
       data are sent to the kernel for transmit from the application, the buffer is not  examined  for  an  IPv6
       header:  the  kernel always constructs the header.  To directly access IPv6 headers from received packets
       and specify them as part of the buffer passed to the kernel, link-level access (<u><a href="../man4/bpf.4.html">bpf</a></u>(4), for example) must
       instead be utilized.

       The header has the following definition:

             struct ip6_hdr {
                  union {
                       struct ip6_hdrctl {
                            uint32_t ip6_un1_flow;   /* 20 bits of flow ID */
                            uint16_t ip6_un1_plen;   /* payload length */
                            uint8_t  ip6_un1_nxt;    /* next header */
                            uint8_t  ip6_un1_hlim;   /* hop limit */
                       } ip6_un1;
                       uint8_t ip6_un2_vfc;  /* version and class */
                  } ip6_ctlun;
                  struct in6_addr ip6_src;   /* source address */
                  struct in6_addr ip6_dst;   /* destination address */
             } __packed;

             #define ip6_vfc         ip6_ctlun.ip6_un2_vfc
             #define ip6_flow        ip6_ctlun.ip6_un1.ip6_un1_flow
             #define ip6_plen        ip6_ctlun.ip6_un1.ip6_un1_plen
             #define ip6_nxt         ip6_ctlun.ip6_un1.ip6_un1_nxt
             #define ip6_hlim        ip6_ctlun.ip6_un1.ip6_un1_hlim
             #define ip6_hops        ip6_ctlun.ip6_un1.ip6_un1_hlim

       All fields are in network-byte order.  Any options specified (see “Options” below) must also be specified
       in network-byte order.

       <u>ip6_flow</u> specifies the flow ID.  <u>ip6_plen</u> specifies the payload length.  <u>ip6_nxt</u> specifies  the  type  of
       the next header.  <u>ip6_hlim</u> specifies the hop limit.

       The top 4 bits of <u>ip6_vfc</u> specify the class and the bottom 4 bits specify the version.

       <u>ip6_src</u> and <u>ip6_dst</u> specify the source and destination addresses.

       The  IPv6 header may be followed by any number of extension headers that start with the following generic
       definition:

             struct ip6_ext {
                  uint8_t ip6e_nxt;
                  uint8_t ip6e_len;
             } __packed;

   <b>Options</b>
       IPv6 allows header options on packets to manipulate the behavior of  the  protocol.   These  options  and
       other  control  requests  are  accessed  with  the  <u><a href="../man2/getsockopt.2.html">getsockopt</a></u>(2) and <u><a href="../man2/setsockopt.2.html">setsockopt</a></u>(2) system calls at level
       IPPROTO_IPV6 and by using ancillary data in <u><a href="../man2/recvmsg.2.html">recvmsg</a></u>(2) and <u><a href="../man2/sendmsg.2.html">sendmsg</a></u>(2).  They can be used to  access  most
       of the fields in the IPv6 header and extension headers.

       The following socket options are supported:

       IPV6_UNICAST_HOPS <u>int</u> <u>*</u>
               Get or set the default hop limit header field for outgoing unicast datagrams sent on this socket.

       IPV6_MULTICAST_IF <u>u_int</u> <u>*</u>
               Get  or  set  the  interface  from which multicast packets will be sent.  For hosts with multiple
               interfaces, each multicast  transmission  is  sent  from  the  primary  network  interface.   The
               interface  is specified as its index as provided by <u><a href="../man3/if_nametoindex.3.html">if_nametoindex</a></u>(3).  A value of zero specifies
               the default interface.

       IPV6_MULTICAST_HOPS <u>int</u> <u>*</u>
               Get or set the default hop limit header field for  outgoing  multicast  datagrams  sent  on  this
               socket.  This option controls the scope of multicast datagram transmissions.

               Datagrams  with a hop limit of 1 are not forwarded beyond the local network.  Multicast datagrams
               with a hop limit of zero will not be transmitted on any network but may be delivered  locally  if
               the  sending  host belongs to the destination group and if multicast loopback (see below) has not
               been disabled on the sending socket.  Multicast datagrams with a hop limit greater than 1 may  be
               forwarded to the other networks if a multicast router (such as <u><a href="../man8/mrouted.8.html">mrouted</a></u>(8) (<u>ports/net/mrouted</u>)) is
               attached to the local network.

       IPV6_MULTICAST_LOOP <u>u_int</u> <u>*</u>
               Get  or set the status of whether multicast datagrams will be looped back for local delivery when
               a multicast datagram is sent to a group to which the sending host belongs.

               This option improves performance for applications that may have no more than one  instance  on  a
               single  host  (such  as  a  router  daemon)  by  eliminating  the overhead of receiving their own
               transmissions.  It should generally not be used by applications for which there may be more  than
               one  instance  on a single host (such as a conferencing program) or for which the sender does not
               belong to the destination group (such as a time-querying program).

               A multicast datagram sent with an initial hop limit greater  than  1  may  be  delivered  to  the
               sending  host  on a different interface from that on which it was sent if the host belongs to the
               destination group on that other interface.  The multicast loopback control option has  no  effect
               on such delivery.

       IPV6_JOIN_GROUP <u>struct</u> <u>ipv6_mreq</u> <u>*</u>
               Join  a  multicast group.  A host must become a member of a multicast group before it can receive
               datagrams sent to the group.

               struct ipv6_mreq {
                       struct in6_addr ipv6mr_multiaddr;
                       unsigned int    ipv6mr_interface;
               };

               <u>ipv6mr_interface</u> may be set to zeroes to choose the default multicast interface or to  the  index
               of  a particular multicast-capable interface if the host is multihomed.  Membership is associated
               with a single interface; programs running on multihomed hosts may need to join the same group  on
               more than one interface.

               If the multicast address is unspecified (i.e., all zeroes), messages from all multicast addresses
               will be accepted by this group.  Note that setting to this value requires superuser privileges.

       IPV6_LEAVE_GROUP <u>struct</u> <u>ipv6_mreq</u> <u>*</u>
               Drop  membership from the associated multicast group.  Memberships are automatically dropped when
               the socket is closed or when the process exits.

       IPV6_PORTRANGE <u>int</u> <u>*</u>
               Get or set the allocation policy of ephemeral ports for when the  kernel  automatically  binds  a
               local address to this socket.  The following values are available:

               IPV6_PORTRANGE_DEFAULT  Use the regular range of non-reserved ports (varies, see <u><a href="../man4/ip.4.html">ip</a></u>(4)).
               IPV6_PORTRANGE_HIGH     Use a high range (varies, see <u><a href="../man4/ip.4.html">ip</a></u>(4)).
               IPV6_PORTRANGE_LOW      Use a low, reserved range (600-1023, see <u><a href="../man4/ip.4.html">ip</a></u>(4)).

       IPV6_PKTINFO <u>int</u> <u>*</u>
               Get  or set whether additional information about subsequent packets will be provided as ancillary
               data along with the payload in subsequent <u><a href="../man2/recvmsg.2.html">recvmsg</a></u>(2) calls.  The information  is  stored  in  the
               following structure in the ancillary data returned:

               struct in6_pktinfo {
                       struct in6_addr ipi6_addr;    /* src/dst IPv6 address */
                       unsigned int    ipi6_ifindex; /* send/recv if index */
               };

       IPV6_HOPLIMIT <u>int</u> <u>*</u>
               Get  or  set  whether  the  hop  limit  header  field from subsequent packets will be provided as
               ancillary data along with the payload in subsequent <u><a href="../man2/recvmsg.2.html">recvmsg</a></u>(2) calls.  The value is stored as  an
               <u>int</u> in the ancillary data returned.

       IPV6_HOPOPTS <u>int</u> <u>*</u>
               Get  or  set whether the hop-by-hop options from subsequent packets will be provided as ancillary
               data along with the payload in  subsequent  <u><a href="../man2/recvmsg.2.html">recvmsg</a></u>(2)  calls.   The  option  is  stored  in  the
               following structure in the ancillary data returned:

               struct ip6_hbh {
                       uint8_t ip6h_nxt;       /* next header */
                       uint8_t ip6h_len;       /* length in units of 8 octets */
               /* followed by options */
               } __packed;

               The <b>inet6_option_space</b>() routine and family of routines may be used to manipulate this data.

               This option requires superuser privileges.

       IPV6_DSTOPTS <u>int</u> <u>*</u>
               Get  or set whether the destination options from subsequent packets will be provided as ancillary
               data along with the payload in  subsequent  <u><a href="../man2/recvmsg.2.html">recvmsg</a></u>(2)  calls.   The  option  is  stored  in  the
               following structure in the ancillary data returned:

               struct ip6_dest {
                       uint8_t ip6d_nxt;       /* next header */
                       uint8_t ip6d_len;       /* length in units of 8 octets */
               /* followed by options */
               } __packed;

               The <b>inet6_option_space</b>() routine and family of routines may be used to manipulate this data.

               This option requires superuser privileges.

       IPV6_TCLASS <u>int</u> <u>*</u>
               Get  or set the value of the traffic class field used for outgoing datagrams on this socket.  The
               value must be between -1 and 255.  A value of -1 resets to the default value.

       IPV6_RECVTCLASS <u>int</u> <u>*</u>
               Get or set the status of whether the traffic class header field will  be  provided  as  ancillary
               data  along  with  the  payload  in subsequent <u><a href="../man2/recvmsg.2.html">recvmsg</a></u>(2) calls.  The header field is stored as a
               single value of type <u>int</u>.

       IPV6_RTHDR <u>int</u> <u>*</u>
               Get or set whether the routing header from subsequent packets will be provided as ancillary  data
               along  with  the  payload  in subsequent <u><a href="../man2/recvmsg.2.html">recvmsg</a></u>(2) calls.  The header is stored in the following
               structure in the ancillary data returned:

               struct ip6_rthdr {
                       uint8_t ip6r_nxt;       /* next header */
                       uint8_t ip6r_len;       /* length in units of 8 octets */
                       uint8_t ip6r_type;      /* routing type */
                       uint8_t ip6r_segleft;   /* segments left */
               /* followed by routing-type-specific data */
               } __packed;

               The <b>inet6_option_space</b>() routine and family of routines may be used to manipulate this data.

               This option requires superuser privileges.

       IPV6_PKTOPTIONS <u>struct</u> <u>cmsghdr</u> <u>*</u>
               Get or set all header options and extension headers at one  time  on  the  last  packet  sent  or
               received  on the socket.  All options must fit within the size of an mbuf (see <u><a href="../man9/mbuf.9.html">mbuf</a></u>(9)).  Options
               are specified as a series of <u>cmsghdr</u> structures followed by corresponding values.  <u>cmsg_level</u>  is
               set  to IPPROTO_IPV6, <u>cmsg_type</u> to one of the other values in this list, and trailing data to the
               option value.  When setting options, if the length <u>optlen</u> to <u><a href="../man2/setsockopt.2.html">setsockopt</a></u>(2) is  zero,  all  header
               options will be reset to their default values.  Otherwise, the length should specify the size the
               series of control messages consumes.

               Instead of using <u><a href="../man2/sendmsg.2.html">sendmsg</a></u>(2) to specify option values, the ancillary data used in these calls that
               correspond  to the desired header options may be directly specified as the control message in the
               series of control messages provided as the argument to <u><a href="../man2/setsockopt.2.html">setsockopt</a></u>(2).

       IPV6_CHECKSUM <u>int</u> <u>*</u>
               Get or set the byte offset into a packet where the 16-bit checksum is located.   When  set,  this
               byte offset is where incoming packets will be expected to have checksums of their data stored and
               where  outgoing  packets  will have checksums of their data computed and stored by the kernel.  A
               value of -1 specifies that no checksums will be checked on incoming packets and that no checksums
               will be computed or stored on outgoing packets.  The offset of the checksum  for  ICMPv6  sockets
               cannot be relocated or turned off.

       IPV6_V6ONLY <u>int</u> <u>*</u>
               Get  or set whether only IPv6 connections can be made to this socket.  For wildcard sockets, this
               can restrict connections to IPv6 only.

       IPV6_USE_MIN_MTU <u>int</u> <u>*</u>
               Get or set whether the minimal IPv6 maximum transmission unit (MTU) size will be  used  to  avoid
               fragmentation from occurring for subsequent outgoing datagrams.

       IPV6_AUTH_LEVEL <u>int</u> <u>*</u>
               Get or set the <u><a href="../man4/ipsec.4.html">ipsec</a></u>(4) authentication level.

       IPV6_ESP_TRANS_LEVEL <u>int</u> <u>*</u>
               Get or set the ESP transport level.

       IPV6_ESP_NETWORK_LEVEL <u>int</u> <u>*</u>
               Get or set the ESP encapsulation level.

       IPV6_IPCOMP_LEVEL <u>int</u> <u>*</u>
               Get or set the <u><a href="../man4/ipcomp.4.html">ipcomp</a></u>(4) level.

       The IPV6_PKTINFO, IPV6_HOPLIMIT, IPV6_HOPOPTS, IPV6_DSTOPTS, and IPV6_RTHDR options will return ancillary
       data  along  with payload contents in subsequent <u><a href="../man2/recvmsg.2.html">recvmsg</a></u>(2) calls with <u>cmsg_level</u> set to IPPROTO_IPV6 and
       <u>cmsg_type</u> set to respective option name value (e.g., IPV6_HOPTLIMIT).  These options  may  also  be  used
       directly  as  ancillary  <u>cmsg_type</u> values in <u><a href="../man2/sendmsg.2.html">sendmsg</a></u>(2) to set options on the packet being transmitted by
       the call.  The <u>cmsg_level</u> value must be IPPROTO_IPV6.  For these options, the ancillary data object value
       format is the same as the value returned as explained for each when received with <u><a href="../man2/recvmsg.2.html">recvmsg</a></u>(2).

       Note that using <u><a href="../man2/sendmsg.2.html">sendmsg</a></u>(2) to specify options on particular packets works only on UDP  and  raw  sockets.
       To manipulate header options for packets on TCP sockets, only the socket options may be used.

       In  some cases, there are multiple APIs defined for manipulating an IPv6 header field.  A good example is
       the outgoing interface for multicast datagrams, which can be set by the IPV6_MULTICAST_IF socket  option,
       through  the IPV6_PKTINFO option, and through the <u>sin6_scope_id</u> field of the socket address passed to the
       <u><a href="../man2/sendto.2.html">sendto</a></u>(2) system call.

       Resolving these conflicts is implementation dependent.  This implementation determines the value  in  the
       following way: options specified by using ancillary data (i.e., <u><a href="../man2/sendmsg.2.html">sendmsg</a></u>(2)) are considered first, options
       specified  by  using  IPV6_PKTOPTIONS to set “sticky” options are considered second, options specified by
       using the individual, basic, and direct socket options (e.g., IPV6_UNICAST_HOPS)  are  considered  third,
       and options specified in the socket address supplied to <u><a href="../man2/sendto.2.html">sendto</a></u>(2) are the last choice.

   <b>Multicasting</b>
       IPv6  multicasting  is  supported  only  on AF_INET6 sockets of type SOCK_DGRAM and SOCK_RAW, and only on
       networks where the interface driver supports multicasting.  Socket options (see  above)  that  manipulate
       membership    of    multicast   groups   and   other   multicast   options   include   IPV6_MULTICAST_IF,
       IPV6_MULTICAST_HOPS, IPV6_MULTICAST_LOOP, IPV6_LEAVE_GROUP, and IPV6_JOIN_GROUP.

   <b>Raw</b> <b>Sockets</b>
       Raw IPv6 sockets are connectionless and are normally used  with  the  <u><a href="../man2/sendto.2.html">sendto</a></u>(2)  and  <u><a href="../man2/recvfrom.2.html">recvfrom</a></u>(2)  calls,
       although  the  <u><a href="../man2/connect.2.html">connect</a></u>(2)  call may be used to fix the destination address for future outgoing packets so
       that <u><a href="../man2/send.2.html">send</a></u>(2) may instead be used and the <u><a href="../man2/bind.2.html">bind</a></u>(2) call may be used to fix the source  address  for  future
       outgoing packets instead of having the kernel choose a source address.

       By using <u><a href="../man2/connect.2.html">connect</a></u>(2) or <u><a href="../man2/bind.2.html">bind</a></u>(2), raw socket input is constrained to only packets with their source address
       matching  the  socket  destination  address  if <u><a href="../man2/connect.2.html">connect</a></u>(2) was used and to packets with their destination
       address matching the socket source address if <u><a href="../man2/bind.2.html">bind</a></u>(2) was used.

       If the <u>proto</u> argument to <u><a href="../man2/socket.2.html">socket</a></u>(2) is zero, the default  protocol  (IPPROTO_RAW)  is  used  for  outgoing
       packets.   For  incoming packets, protocols recognized by kernel are <b>not</b> passed to the application socket
       (e.g., <u><a href="../man4/tcp.4.html">tcp</a></u>(4) and <u><a href="../man4/udp.4.html">udp</a></u>(4)) except for some ICMPv6 messages.  The ICMPv6 messages not passed to raw sockets
       include echo, timestamp, and address mask requests.   If  <u>proto</u>  is  non-zero,  only  packets  with  this
       protocol will be passed to the socket.

       IPv6 fragments are also not passed to application sockets until they have been reassembled.  If reception
       of all packets is desired, link-level access (such as <u><a href="../man4/bpf.4.html">bpf</a></u>(4)) must be used instead.

       Outgoing  packets  automatically  have an IPv6 header prepended to them (based on the destination address
       and the protocol number the socket was created with).  Incoming packets are received  by  an  application
       without the IPv6 header or any extension headers.

       Outgoing  packets will be fragmented automatically by the kernel if they are too large.  Incoming packets
       will be reassembled before being sent to the raw socket, so packet fragments  or  fragment  headers  will
       never be seen on a raw socket.

</pre><h4><b>EXAMPLES</b></h4><pre>
       The following determines the hop limit on the next packet received:

       struct iovec iov[2];
       u_char buf[BUFSIZ];
       struct cmsghdr *cm;
       struct msghdr m;
       int optval;
       bool found;
       u_char data[2048];

       /* Create socket. */

       (void)memset(&amp;m, 0, <a href="../manm/sizeof.m.html">sizeof</a>(m));
       (void)memset(&amp;iov, 0, sizeof(iov));

       iov[0].iov_base = data;         /* buffer for packet payload */
       iov[0].iov_len = sizeof(data);  /* expected packet length */

       m.msg_name = &amp;from;             /* sockaddr_in6 of peer */
       m.msg_namelen = sizeof(from);
       m.msg_iov = iov;
       m.msg_iovlen = 1;
       m.msg_control = (caddr_t)buf;   /* buffer for control messages */
       m.msg_controllen = sizeof(buf);

       /*
        * Enable the hop limit value from received packets to be
        * returned along with the payload.
        */
       optval = 1;
       if (setsockopt(s, IPPROTO_IPV6, IPV6_HOPLIMIT, &amp;optval,
           sizeof(optval)) == -1)
               err(1, "setsockopt");

       found = false;
       do {
               if (recvmsg(s, &amp;m, 0) == -1)
                       err(1, "recvmsg");
               for (cm = CMSG_FIRSTHDR(&amp;m); cm != NULL;
                    cm = CMSG_NXTHDR(&amp;m, cm)) {
                       if (cm-&gt;cmsg_level == IPPROTO_IPV6 &amp;&amp;
                           cm-&gt;cmsg_type == IPV6_HOPLIMIT &amp;&amp;
                           cm-&gt;cmsg_len == CMSG_LEN(sizeof(int))) {
                               found = true;
                               (void)printf("hop limit: %d\n",
                                   *(int *)CMSG_DATA(cm));
                               break;
                       }
               }
       } while (!found);

</pre><h4><b>DIAGNOSTICS</b></h4><pre>
       A socket operation may fail with one of the following errors returned:

       [EISCONN]        when  trying  to establish a connection on a socket which already has one or when trying
                        to send a datagram with the destination address specified  and  the  socket  is  already
                        connected.

       [ENOTCONN]       when  trying to send a datagram, but no destination address is specified, and the socket
                        has not been connected.

       [ENOBUFS]        when the system runs out of memory for an internal data structure.

       [EADDRNOTAVAIL]  when an attempt is made to create a socket with a network address for which  no  network
                        interface exists.

       [EACCES]         when an attempt is made to create a raw IPv6 socket by a non-privileged process.

       The following errors specific to IPv6 may occur when setting or getting header options:

       [EINVAL]         An unknown socket option name was given.

       [EINVAL]         An ancillary data object was improperly formed.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man2/getsockopt.2.html">getsockopt</a></u>(2),  <u><a href="../man2/recv.2.html">recv</a></u>(2),  <u><a href="../man2/send.2.html">send</a></u>(2),  <u><a href="../man2/setsockopt.2.html">setsockopt</a></u>(2),  <u><a href="../man2/socket.2.html">socket</a></u>(2),  <u><a href="../man3/CMSG_DATA.3.html">CMSG_DATA</a></u>(3),  <u><a href="../man3/if_nametoindex.3.html">if_nametoindex</a></u>(3), <u><a href="../man4/bpf.4.html">bpf</a></u>(4),
       <u><a href="../man4/icmp6.4.html">icmp6</a></u>(4), <u><a href="../man4/inet6.4.html">inet6</a></u>(4), <u><a href="../man4/ip.4.html">ip</a></u>(4), <u><a href="../man4/netintro.4.html">netintro</a></u>(4), <u><a href="../man4/tcp.4.html">tcp</a></u>(4), <u><a href="../man4/udp.4.html">udp</a></u>(4)

       W. Stevens and M. Thomas, <u>Advanced</u> <u>Sockets</u> <u>API</u> <u>for</u> <u>IPv6</u>, RFC 2292, February 1998.

       S. Deering and R. Hinden, <u>Internet</u> <u>Protocol,</u> <u>Version</u> <u>6</u> <u>(IPv6)</u> <u>Specification</u>, RFC 2460, December 1998.

       R. Gilligan, S. Thomson, J. Bound, and W. Stevens, <u>Basic</u> <u>Socket</u> <u>Interface</u> <u>Extensions</u> <u>for</u> <u>IPv6</u>, RFC  2553,
       March 1999.

       W. Stevens, B. Fenner, and A. Rudoff, <u>UNIX</u> <u>Network</u> <u>Programming,</u> <u>third</u> <u>edition</u>.

</pre><h4><b>STANDARDS</b></h4><pre>
       Most of the socket options are defined in RFC 2292 or RFC 2553.  The IPV6_V6ONLY socket option is defined
       in  RFC  3493  Section  5.3.   The  IPV6_PORTRANGE socket option and the conflict resolution rule are not
       defined in the RFCs and should be considered implementation dependent.

Debian                                           August 19, 2018                                          <u><a href="../man4/IP6.4.html">IP6</a></u>(4)
</pre>
 </div>
</div></section>
</div>
</body>
</html>