<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>tun — tunnel software network interface</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       tun — tunnel software network interface

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>device</b> <b>tuntap</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <b>tun</b> interface is a software loopback mechanism that can be loosely described as the network interface
       analog of the <u><a href="../man4/pty.4.html">pty</a></u>(4), that is, <b>tun</b> does for network interfaces what the <u><a href="../man4/pty.4.html">pty</a></u>(4) driver does for terminals.

       The  <b>tun</b> driver, like the <u><a href="../man4/pty.4.html">pty</a></u>(4) driver, provides two interfaces: an interface like the usual facility it
       is simulating (a network interface in the case of <b>tun</b>, or a terminal for <u><a href="../man4/pty.4.html">pty</a></u>(4)), and a character-special
       device “control” interface.  A client program transfers IP (by  default)  packets  to  or  from  the  <b>tun</b>
       “control” interface.  The <u><a href="../man4/tap.4.html">tap</a></u>(4) interface provides similar functionality at the Ethernet layer: a client
       will transfer Ethernet frames to or from a <u><a href="../man4/tap.4.html">tap</a></u>(4) “control” interface.

       The  network interfaces are named “<b>tun0</b>”, “<b>tun1</b>”, etc., one for each control device that has been opened.
       These network interfaces persist until the <u>if_tuntap.ko</u> module is unloaded, or  until  removed  with  the
       <u><a href="../man8/ifconfig.8.html">ifconfig</a></u>(8) command.

       <b>tun</b>  devices are created using interface cloning.  This is done using the “ifconfig tun<b>N</b> create” command.
       This is the preferred method of creating <b>tun</b> devices.  The same method allows removal of interfaces.  For
       this, use the “ifconfig tun<b>N</b> destroy” command.

       If the <u><a href="../man8/sysctl.8.html">sysctl</a></u>(8) variable <u>net.link.tun.devfs_cloning</u> is non-zero, the <b>tun</b> interface permits opens on  the
       special  control  device  <u>/dev/tun</u>.   When this device is opened, <b>tun</b> will return a handle for the lowest
       unused <b>tun</b> device (use <u><a href="../man3/devname.3.html">devname</a></u>(3) to determine which).

       <u>Disabling</u> <u>the</u> <u>legacy</u> <u>devfs</u> <u>cloning</u> <u>functionality</u> <u>may</u> <u>break</u> <u>existing</u> <u>applications</u> <u>which</u> <u>use</u> <b>tun</b><u>,</u>  <u>such</u>  <u>as</u>
       <u>ppp</u>(<u>8</u>) <u>and</u> <u>ssh</u>(<u>1</u>)<u>.</u>  <u>It</u> <u>therefore</u> <u>defaults</u> <u>to</u> <u>being</u> <u>enabled</u> <u>until</u> <u>further</u> <u>notice.</u>

       Control  devices  (once  successfully opened) persist until <u>if_tuntap.ko</u> is unloaded in the same way that
       network interfaces persist (see above).

       Each interface supports the usual network-interface <u><a href="../man2/ioctl.2.html">ioctl</a></u>(2)s, such as SIOCAIFADDR and thus can  be  used
       with  <u><a href="../man8/ifconfig.8.html">ifconfig</a></u>(8)  like any other interface.  At boot time, they are POINTOPOINT interfaces, but this can
       be changed; see the description of the control device, below.  When the  system  chooses  to  transmit  a
       packet  on  the  network interface, the packet can be read from the control device (it appears as “input”
       there); writing a packet to the control device generates an input packet on the network interface, as  if
       the (non-existent) hardware had just received it.

       The  tunnel  device (<u>/dev/tunN</u>) is exclusive-open (it cannot be opened if it is already open).  A <u><a href="../man2/read.2.html">read</a></u>(2)
       call will return an error (EHOSTDOWN) if the interface is not  “ready”  (which  means  that  the  control
       device is open and the interface's address has been set).

       Once  the  interface  is  ready, <u><a href="../man2/read.2.html">read</a></u>(2) will return a packet if one is available; if not, it will either
       block until one is or return EWOULDBLOCK, depending on whether non-blocking I/O has been enabled.  If the
       packet is longer than is allowed for in the buffer passed to <u><a href="../man2/read.2.html">read</a></u>(2), the extra  data  will  be  silently
       dropped.

       If  the  TUNSLMODE  ioctl  has  been set, packets read from the control device will be prepended with the
       destination address as presented to the network interface output routine, <b>tunoutput</b>().   The  destination
       address  is  in  <u>struct</u>  <u>sockaddr</u>  format.   The  actual length of the prepended address is in the member
       <u>sa_len</u>.  If the TUNSIFHEAD ioctl has been set, packets will be prepended with a four byte address  family
       in  network  byte  order.  TUNSLMODE and TUNSIFHEAD are mutually exclusive.  In any case, the packet data
       follows immediately.

       A <u><a href="../man2/write.2.html">write</a></u>(2) call passes a packet in to be “received” on the pseudo-interface.  If the TUNSIFHEAD ioctl has
       been set, the address family must be prepended, otherwise the packet is assumed to be  of  type  AF_INET.
       Each  <u><a href="../man2/write.2.html">write</a></u>(2)  call  supplies  exactly  one  packet;  the packet length is taken from the amount of data
       provided to <u><a href="../man2/write.2.html">write</a></u>(2) (minus any supplied address family).  Writes will not block; if the packet cannot be
       accepted for a transient reason (e.g., no buffer space available), it is silently dropped; if the  reason
       is not transient (e.g., packet too large), an error is returned.

       The following <u><a href="../man2/ioctl.2.html">ioctl</a></u>(2) calls are supported (defined in &lt;<u>net/if_tun.h</u>&gt;):

       TUNSDEBUG   The argument should be a pointer to an <u>int</u>; this sets the internal debugging variable to that
                   value.   What,  if  anything,  this  variable controls is not documented here; see the source
                   code.

       TUNGDEBUG   The argument should be a pointer to an <u>int</u>; this stores  the  internal  debugging  variable's
                   value into it.

       TUNSIFINFO  The  argument  should  be  a  pointer to an <u>struct</u> <u>tuninfo</u> and allows setting the MTU and the
                   baudrate of the tunnel device.  The type must be the same as returned by TUNGIFINFO or set to
                   IFT_PPP else the <u><a href="../man2/ioctl.2.html">ioctl</a></u>(2) call will fail.  The <u>struct</u> <u>tuninfo</u> is declared in &lt;<u>net/if_tun.h</u>&gt;.

                   The use of this ioctl is restricted to the super-user.

       TUNGIFINFO  The argument should be a pointer to an <u>struct</u> <u>tuninfo</u>,  where  the  current  MTU,  type,  and
                   baudrate will be stored.

       TUNSIFMODE  The  argument  should  be  a  pointer  to an <u>int</u>; its value must be either IFF_POINTOPOINT or
                   IFF_BROADCAST and should have IFF_MULTICAST OR'd into  the  value  if  multicast  support  is
                   required.   The  type  of the corresponding “<b>tun</b><u>N</u>” interface is set to the supplied type.  If
                   the value is outside the above range, an EINVAL error is returned.   The  interface  must  be
                   down at the time; if it is up, an EBUSY error is returned.

       TUNSLMODE   The  argument  should  be a pointer to an <u>int</u>; a non-zero value turns off “multi-af” mode and
                   turns on “link-layer” mode, causing packets read from the tunnel device to be prepended  with
                   the network destination address (see above).

       TUNSIFPID   Will set the pid owning the tunnel device to the current process's pid.

       TUNSIFHEAD  The argument should be a pointer to an <u>int</u>; a non-zero value turns off “link-layer” mode, and
                   enables “multi-af” mode, where every packet is preceded with a four byte address family.

       TUNGIFHEAD  The  argument should be a pointer to an <u>int</u>; the ioctl sets the value to one if the device is
                   in “multi-af” mode, and zero otherwise.

       FIONBIO     Turn non-blocking I/O for reads off or on, according as the argument <u>int</u>'s value is or is not
                   zero.  (Writes are always non-blocking.)

       FIOASYNC    Turn asynchronous I/O for reads (i.e., generation of SIGIO when data is available to be read)
                   off or on, according as the argument <u>int</u>'s value is or is not zero.

       FIONREAD    If any packets are queued to be read, store the size of the first one into the argument  <u>int</u>;
                   otherwise, store zero.

       TIOCSPGRP   Set  the  process  group  to  receive SIGIO signals, when asynchronous I/O is enabled, to the
                   argument <u>int</u> value.

       TIOCGPGRP   Retrieve the process group value for SIGIO signals into the argument <u>int</u> value.

       The control device also supports <u><a href="../man2/select.2.html">select</a></u>(2) for  read;  selecting  for  write  is  pointless,  and  always
       succeeds, since writes are always non-blocking.

       On the last close of the data device, by default, the interface is brought down (as if with <b>ifconfig</b> <u>tunN</u>
       <b>down</b>).   All  queued  packets  are  thrown away.  If the interface is up when the data device is not open
       output packets are always thrown away rather than letting them pile up.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man2/ioctl.2.html">ioctl</a></u>(2), <u><a href="../man2/read.2.html">read</a></u>(2), <u><a href="../man2/select.2.html">select</a></u>(2), <u><a href="../man2/write.2.html">write</a></u>(2), <u><a href="../man3/devname.3.html">devname</a></u>(3), <u><a href="../man4/inet.4.html">inet</a></u>(4), <u><a href="../man4/intro.4.html">intro</a></u>(4), <u><a href="../man4/pty.4.html">pty</a></u>(4), <u><a href="../man4/tap.4.html">tap</a></u>(4), <u><a href="../man8/ifconfig.8.html">ifconfig</a></u>(8)

</pre><h4><b>AUTHORS</b></h4><pre>
       This manual page was originally obtained from NetBSD.

Debian                                           April 29, 2019                                           <u><a href="../man4/TUN.4.html">TUN</a></u>(4)
</pre>
 </div>
</div></section>
</div>
</body>
</html>