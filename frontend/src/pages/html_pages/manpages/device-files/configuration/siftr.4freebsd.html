<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SIFTR — Statistical Information For TCP Research</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       SIFTR — Statistical Information For TCP Research

</pre><h4><b>SYNOPSIS</b></h4><pre>
       To load the driver as a module at run-time, run the following command as root:

             kldload siftr

       Alternatively,  to  load  the  driver  as  a  module  at  boot  time,  add  the  following  line into the
       <u><a href="../man5/loader.conf.5.html">loader.conf</a></u>(5) file:

             siftr_load="YES"

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The <b>SIFTR</b> (<u>S</u>tatistical <u>I</u>nformation <u>F</u>or <u>T</u>CP <u>R</u>esearch) kernel module logs a range of statistics  on  active
       TCP  connections  to  a  log  file.   It provides the ability to make highly granular measurements of TCP
       connection state, aimed at system administrators, developers and researchers.

   <b>Compile-time</b> <b>Configuration</b>
       The default operation of <b>SIFTR</b> is to capture IPv4 TCP/IP packets.  <b>SIFTR</b> can  be  configured  to  support
       IPv4 and IPv6 by uncommenting:

             CFLAGS+=-DSIFTR_IPV6

       in ⟨sys/modules/siftr/Makefile⟩ and recompiling.

       In  the  IPv4-only  (default)  mode, standard dotted decimal notation (e.g.  "136.186.229.95") is used to
       format IPv4 addresses for logging.  In IPv6 mode, standard dotted decimal notation is used to format IPv4
       addresses, and standard colon-separated hex notation (see RFC 4291) is used to format IPv6 addresses  for
       logging.   Note that SIFTR uses uncompressed notation to format IPv6 addresses.  For example, the address
       "fe80::20f:feff:fea2:531b" would be logged as "fe80:0:0:0:20f:feff:fea2:531b".

   <b>Run-time</b> <b>Configuration</b>
       <b>SIFTR</b> utilises the <u><a href="../man8/sysctl.8.html">sysctl</a></u>(8)  interface  to  export  its  configuration  variables  to  user-space.   The
       following variables are available:

             <u>net.inet.siftr.enabled</u>
                           controls  whether the module performs its measurements or not.  By default, the value
                           is set to 0, which means the module will not be taking any measurements.  Having  the
                           module  loaded  with  <u>net.inet.siftr.enabled</u>  set  to  0  will  have no impact on the
                           performance of the network stack, as the packet filtering  hooks  are  only  inserted
                           when <u>net.inet.siftr.enabled</u> is set to 1.

             <u>net.inet.siftr.ppl</u>
                           controls  how  many  inbound/outbound packets for a given TCP connection will cause a
                           log message to be generated for the connection.  By default, the value is set  to  1,
                           which  means  the module will log a message for every packet of every TCP connection.
                           The value can be set to any integer in the range [1,2^32], and can be changed at  any
                           time, even while the module is enabled.

             <u>net.inet.siftr.logfile</u>
                           controls  the  path  to  the  file  that  the  module writes its log messages to.  By
                           default, the file /var/log/siftr.log is used.  The path can be changed at  any  time,
                           even while the module is enabled.

             <u>net.inet.siftr.genhashes</u>
                           controls  whether a hash is generated for each TCP packet seen by <b>SIFTR</b>.  By default,
                           the value is set to 0, which means no hashes are generated.  The hashes are useful to
                           correlate which TCP packet triggered the generation of a particular log message,  but
                           calculating them adds additional computational overhead into the fast path.

             <u>net.inet.siftr.port_filter</u>
                           controls on which source or destination port siftr should capture <b>SIFTR</b>.  By default,
                           the  value  is  set to 0, which means all ports are eligible for logging.  Set to any
                           other value, only packets where either the source or destination  port  is  equal  to
                           this number are logged.

   <b>Log</b> <b>Format</b>
       A  typical  <b>SIFTR</b>  log  file  will contain 3 different types of log message.  All messages are written in
       plain ASCII text.

       Note: The "\" present in the example log messages in this section indicates a line  continuation  and  is
       not part of the actual log message.

       The  first  type  of  log message is written to the file when the module is enabled and starts collecting
       data from the running kernel.  The text below shows an example module enable log.   The  fields  are  tab
       delimited key-value pairs which describe some basic information about the system.

             enable_time_secs=1238556193    enable_time_usecs=462104 \
             siftrver=1.2.2    hz=1000    tcp_rtt_scale=32 \
             sysname=FreeBSD    sysver=604000    ipmode=4

       Field descriptions are as follows:

             <u>enable_time_secs</u>
                           time at which the module was enabled, in seconds since the UNIX epoch.

             <u>enable_time_usecs</u>
                           time at which the module was enabled, in microseconds since enable_time_secs.

             <u>siftrver</u>      version of <b>SIFTR</b>.

             <u>hz</u>            tick rate of the kernel in ticks per second.

             <u>tcp_rtt_scale</u>
                           smoothed RTT estimate scaling factor.

             <u>sysname</u>       operating system name.

             <u>sysver</u>        operating system version.

             <u>ipmode</u>        IP mode as defined at compile time.  An ipmode of "4" means IPv6 is not supported and
                           IP  addresses  are logged in regular dotted quad format.  An ipmode of "6" means IPv6
                           is supported, and IP addresses are logged in dotted quad or hex format, as  described
                           in the "Compile-time Configuration" subsection.

       The  second  type  of  log message is written to the file when a data log message is generated.  The text
       below shows an example data log triggered by an IPv4 TCP/IP packet.  The data is CSV formatted.

             o,0xbec491a5,1238556193.463551,172.16.7.28,22,172.16.2.5,55931, \
             1073725440,172312,6144,66560,66608,8,1,4,1448,936,1,996,255, \
             33304,208,66608,0,208,0

       Field descriptions are as follows:

             <u>1</u>             Direction of packet that triggered the log message.  Either "i" for in,  or  "o"  for
                           out.

             <u>2</u>             Hash of the packet that triggered the log message.

             <u>3</u>             Time  at which the packet that triggered the log message was processed by the <u><a href="../man9/pfil.9.html">pfil</a></u>(9)
                           hook function, in seconds and microseconds since the UNIX epoch.

             <u>4</u>             The IPv4 or IPv6 address of the local host, in dotted quad (IPv4  packet)  or  colon-
                           separated hex (IPv6 packet) notation.

             <u>5</u>             The TCP port that the local host is communicating via.

             <u>6</u>             The  IPv4 or IPv6 address of the foreign host, in dotted quad (IPv4 packet) or colon-
                           separated hex (IPv6 packet) notation.

             <u>7</u>             The TCP port that the foreign host is communicating via.

             <u>8</u>             The slow start threshold for the flow, in bytes.

             <u>9</u>             The current congestion window for the flow, in bytes.

             <u>10</u>            The current bandwidth-controlled window for the flow, in bytes.

             <u>11</u>            The current sending window for  the  flow,  in  bytes.   The  post  scaled  value  is
                           reported,  except during the initial handshake (first few packets), during which time
                           the unscaled value is reported.

             <u>12</u>            The current receive window for the flow, in bytes.  The post scaled value  is  always
                           reported.

             <u>13</u>            The current window scaling factor for the sending window.

             <u>14</u>            The current window scaling factor for the receiving window.

             <u>15</u>            The current state of the TCP finite state machine, as defined in ⟨<u>netinet/tcp_fsm.h</u>⟩.

             <u>16</u>            The maximum segment size for the flow, in bytes.

             <u>17</u>            The current smoothed RTT estimate for the flow, in units of TCP_RTT_SCALE * HZ, where
                           TCP_RTT_SCALE  is  a  define  found  in tcp_var.h, and HZ is the kernel's tick timer.
                           Divide by TCP_RTT_SCALE * HZ to get the  RTT  in  secs.   TCP_RTT_SCALE  and  HZ  are
                           reported in the enable log message.

             <u>18</u>            SACK enabled indicator. 1 if SACK enabled, 0 otherwise.

             <u>19</u>            The  current  state  of  the  TCP  flags  for  the flow.  See ⟨<u>netinet/tcp_var.h</u>⟩ for
                           information about the various flags.

             <u>20</u>            The current retransmission timeout length for the flow, in units of HZ, where  HZ  is
                           the  kernel's  tick timer.  Divide by HZ to get the timeout length in seconds.  HZ is
                           reported in the enable log message.

             <u>21</u>            The current size of the socket send buffer in bytes.

             <u>22</u>            The current number of bytes in the socket send buffer.

             <u>23</u>            The current size of the socket receive buffer in bytes.

             <u>24</u>            The current number of bytes in the socket receive buffer.

             <u>25</u>            The current number of unacknowledged bytes in-flight.  Bytes  acknowledged  via  SACK
                           are not excluded from this count.

             <u>26</u>            The current number of segments in the reassembly queue.

             <u>27</u>            Flowid  for the connection.  A caveat: Zero '0' either represents a valid flowid or a
                           default value when it's not being set.  There is no easy way to differentiate without
                           looking at actual network interface card and drivers being used.

             <u>28</u>            Flow type for the connection.  Flowtype defines which protocol fields are  hashed  to
                           produce   the   flowid.    A  complete  listing  is  available  in  <u>sys/mbuf.h</u>  under
                           M_HASHTYPE_*.

       The third type of log message is written to the file when the module is disabled  and  ceases  collecting
       data  from  the  running kernel.  The text below shows an example module disable log.  The fields are tab
       delimited key-value pairs which provide statistics about operations since the module  was  most  recently
       enabled.

             disable_time_secs=1238556197    disable_time_usecs=933607 \
             num_inbound_tcp_pkts=356    num_outbound_tcp_pkts=627 \
             total_tcp_pkts=983    num_inbound_skipped_pkts_malloc=0 \
             num_outbound_skipped_pkts_malloc=0    num_inbound_skipped_pkts_mtx=0 \
             num_outbound_skipped_pkts_mtx=0    num_inbound_skipped_pkts_tcb=0 \
             num_outbound_skipped_pkts_tcb=0    num_inbound_skipped_pkts_icb=0 \
             num_outbound_skipped_pkts_icb=0    total_skipped_tcp_pkts=0 \
             flow_list=172.16.7.28;22-172.16.2.5;55931,

       Field descriptions are as follows:

             <u>disable_time_secs</u>
                           Time at which the module was disabled, in seconds since the UNIX epoch.

             <u>disable_time_usecs</u>
                           Time at which the module was disabled, in microseconds since disable_time_secs.

             <u>num_inbound_tcp_pkts</u>
                           Number  of  TCP  packets  that  traversed  up  the network stack.  This only includes
                           inbound TCP packets during the periods when <b>SIFTR</b> was enabled.

             <u>num_outbound_tcp_pkts</u>
                           Number of TCP packets that traversed down the  network  stack.   This  only  includes
                           outbound TCP packets during the periods when <b>SIFTR</b> was enabled.

             <u>total_tcp_pkts</u>
                           The summation of num_inbound_tcp_pkts and num_outbound_tcp_pkts.

             <u>num_inbound_skipped_pkts_malloc</u>
                           Number of inbound packets that were not processed because of failed malloc() calls.

             <u>num_outbound_skipped_pkts_malloc</u>
                           Number of outbound packets that were not processed because of failed malloc() calls.

             <u>num_inbound_skipped_pkts_mtx</u>
                           Number  of  inbound  packets  that  were  not processed because of failure to add the
                           packet to the packet processing queue.

             <u>num_outbound_skipped_pkts_mtx</u>
                           Number of outbound packets that were not processed because  of  failure  to  add  the
                           packet to the packet processing queue.

             <u>num_inbound_skipped_pkts_tcb</u>
                           Number  of inbound packets that were not processed because of failure to find the TCP
                           control block associated with the packet.

             <u>num_outbound_skipped_pkts_tcb</u>
                           Number of outbound packets that were not processed because of failure to find the TCP
                           control block associated with the packet.

             <u>num_inbound_skipped_pkts_icb</u>
                           Number of inbound packets that were not processed because of failure to find  the  IP
                           control block associated with the packet.

             <u>num_outbound_skipped_pkts_icb</u>
                           Number  of outbound packets that were not processed because of failure to find the IP
                           control block associated with the packet.

             <u>total_skipped_tcp_pkts</u>
                           The summation of all skipped packet counters.

             <u>flow_list</u>     A CSV list of TCP flows that triggered data log messages to be  generated  since  the
                           module   was   loaded.    Each   flow   entry   in  the  CSV  list  is  formatted  as
                           "local_ip;local_port-foreign_ip;foreign_port".  If there are no entries in  the  list
                           (i.e., no data log messages were generated), the value will be blank.  If there is at
                           least one entry in the list, a trailing comma will always be present.

       The  total  number  of  data  log messages found in the log file for a module enable/disable cycle should
       equate to total_tcp_pkts - total_skipped_tcp_pkts.

</pre><h4><b>IMPLEMENTATION</b> <b>NOTES</b></h4><pre>
       <b>SIFTR</b> hooks into the network stack using the <u><a href="../man9/pfil.9.html">pfil</a></u>(9) interface.  In its  current  incarnation,  it  hooks
       into  the  AF_INET/AF_INET6  (IPv4/IPv6)  <u><a href="../man9/pfil.9.html">pfil</a></u>(9) filtering points, which means it sees packets at the IP
       layer of the network stack.  This means that TCP packets inbound to the stack are intercepted before they
       have been processed by the TCP layer.  Packets outbound from the stack are intercepted  after  they  have
       been processed by the TCP layer.

       The diagram below illustrates how <b>SIFTR</b> inserts itself into the stack.

             ----------------------------------
                        Upper Layers
             ----------------------------------
                 ^                       |
                 |                       |
                 |                       |
                 |                       v
              TCP in                  TCP out
             ----------------------------------
                 ^                      |
                 |________     _________|
                         |     |
                         |     v
                        ---------
                        | SIFTR |
                        ---------
                         ^     |
                 ________|     |__________
                 |                       |
                 |                       v
             IPv{4/6} in            IPv{4/6} out
             ----------------------------------
                 ^                       |
                 |                       |
                 |                       v
             Layer 2 in             Layer 2 out
             ----------------------------------
                       Physical Layer
             ----------------------------------

       <b>SIFTR</b> uses the <u><a href="../man9/alq.9.html">alq</a></u>(9) interface to manage writing data to disk.

       At  first glance, you might mistakenly think that <b>SIFTR</b> extracts information from individual TCP packets.
       This is not the case.  <b>SIFTR</b> uses TCP packet events (inbound and outbound) for each TCP flow  originating
       from  the system to trigger a dump of the state of the TCP control block for that flow.  With the PPL set
       to 1, we are in effect sampling each TCP flow's  control  block  state  as  frequently  as  flow  packets
       enter/leave  the  system.  For example, setting PPL to 2 halves the sampling rate i.e., every second flow
       packet (inbound OR outbound) causes a dump of the control block state.

       The distinction between interrogating individual  packets  versus  interrogating  the  control  block  is
       important,  because  <b>SIFTR</b>  does  not  remove the need for packet capturing tools like <u><a href="../man1/tcpdump.1.html">tcpdump</a></u>(1).  <b>SIFTR</b>
       allows you to correlate and observe the cause-and-affect relationship between what you see  on  the  wire
       (captured using a tool like <u><a href="../man1/tcpdump.1.html">tcpdump</a></u>(1)) and changes in the TCP control block corresponding to the flow of
       interest.  It is therefore useful to use <b>SIFTR</b> and a tool like <u><a href="../man1/tcpdump.1.html">tcpdump</a></u>(1) to gather the necessary data to
       piece  together  the  complete picture.  Use of either tool on its own will not be able to provide all of
       the necessary data.

       As a result of needing to interrogate the TCP control block, certain packets during the  lifecycle  of  a
       connection  are  unable  to  trigger  a <b>SIFTR</b> log message.  The initial handshake takes place without the
       existence of a control block and the final ACK is exchanged when the connection is in the TIMEWAIT state.

       <b>SIFTR</b> was designed to minimise the delay introduced to packets traversing the network stack.  This design
       called for a highly optimised and minimal hook function that  extracted  the  minimal  details  necessary
       whilst  holding  the  packet  up,  and  passing these details to another thread for actual processing and
       logging.

       This multithreaded design does introduce some contention issues when accessing the data structure  shared
       between  the  threads  of  operation.  When the hook function tries to place details in the structure, it
       must first acquire an exclusive lock.  Likewise, when the processing thread tries to  read  details  from
       the  structure, it must also acquire an exclusive lock to do so.  If one thread holds the lock, the other
       must wait before it can obtain it.  This does introduce some additional bounded delay into  the  kernel's
       packet processing code path.

       In  some  cases (e.g., low memory, connection termination), TCP packets that enter the <b>SIFTR</b> <u><a href="../man9/pfil.9.html">pfil</a></u>(9) hook
       function will not trigger a log message to be generated.  <b>SIFTR</b> refers to  this  outcome  as  a  "skipped
       packet".   Note that <b>SIFTR</b> always ensures that packets are allowed to continue through the stack, even if
       they could not successfully trigger a data log message.  <b>SIFTR</b> will therefore not  introduce  any  packet
       loss for TCP/IP packets traversing the network stack.

   <b>Important</b> <b>Behaviours</b>
       The behaviour of a log file path change whilst the module is enabled is as follows:

       1.   Attempt  to  open  the  new file path for writing.  If this fails, the path change will fail and the
            existing path will continue to be used.

       2.   Assuming the new path is valid and opened successfully:

            <b>-</b>   Flush all pending log messages to the old file path.

            <b>-</b>   Close the old file path.

            <b>-</b>   Switch the active log file pointer to point at the new file path.

            <b>-</b>   Commence logging to the new file.

       During the time between the flush of pending log messages to the old file and commencing logging  to  the
       new  file,  new log messages will still be generated and buffered.  As soon as the new file path is ready
       for writing, the accumulated log messages will be written out to the file.

</pre><h4><b>EXAMPLES</b></h4><pre>
       To enable the module's operations, run the following command as root: sysctl net.inet.siftr.enabled=1

       To change the granularity of log messages such that 1 log message is generated for every 10  TCP  packets
       per connection, run the following command as root: sysctl net.inet.siftr.ppl=10

       To  change  the  log  file  location  to  /tmp/siftr.log,  run  the  following  command  as  root: sysctl
       net.inet.siftr.logfile=/tmp/siftr.log

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man1/tcpdump.1.html">tcpdump</a></u>(1), <u><a href="../man4/tcp.4.html">tcp</a></u>(4), <u><a href="../man8/sysctl.8.html">sysctl</a></u>(8), <u><a href="../man9/alq.9.html">alq</a></u>(9), <u><a href="../man9/pfil.9.html">pfil</a></u>(9)

</pre><h4><b>ACKNOWLEDGEMENTS</b></h4><pre>
       Development of this software was made possible in part by  grants  from  the  Cisco  University  Research
       Program Fund at Community Foundation Silicon Valley, and the FreeBSD Foundation.

</pre><h4><b>HISTORY</b></h4><pre>
       <b>SIFTR</b> first appeared in FreeBSD 7.4 and FreeBSD 8.2.

       <b>SIFTR</b>  was  first  released  in  2007  by  Lawrence  Stewart and James Healy whilst working on the NewTCP
       research project at Swinburne University of Technology's  Centre  for  Advanced  Internet  Architectures,
       Melbourne,  Australia,  which  was  made  possible  in part by a grant from the Cisco University Research
       Program Fund at Community Foundation Silicon Valley.  More details are available at:

       <a href="http://caia.swin.edu.au/urp/newtcp/">http://caia.swin.edu.au/urp/newtcp/</a>

       Work on <b>SIFTR</b> v1.2.x was sponsored by the FreeBSD Foundation as part of the "Enhancing  the  FreeBSD  TCP
       Implementation" project 2008-2009.  More details are available at:

       <a href="http://www.freebsdfoundation.org/">http://www.freebsdfoundation.org/</a>

       <a href="http://caia.swin.edu.au/freebsd/etcp09/">http://caia.swin.edu.au/freebsd/etcp09/</a>

</pre><h4><b>AUTHORS</b></h4><pre>
       <b>SIFTR</b> was written by Lawrence Stewart &lt;<u><a href="mailto:lstewart@FreeBSD.org">lstewart@FreeBSD.org</a></u>&gt; and James Healy &lt;<u><a href="mailto:jimmy@deefa.com">jimmy@deefa.com</a></u>&gt;.

       This manual page was written by Lawrence Stewart &lt;<u><a href="mailto:lstewart@FreeBSD.org">lstewart@FreeBSD.org</a></u>&gt;.

</pre><h4><b>BUGS</b></h4><pre>
       Current known limitations and any relevant workarounds are outlined below:

       <b>-</b>   The  internal queue used to pass information between the threads of operation is currently unbounded.
           This allows <b>SIFTR</b> to cope with bursty network traffic, but sustained high  packet-per-second  traffic
           can cause exhaustion of kernel memory if the processing thread cannot keep up with the packet rate.

       <b>-</b>   If  using  <b>SIFTR</b> on a machine that is also running other modules utilising the <u><a href="../man9/pfil.9.html">pfil</a></u>(9) framework e.g.
           <u><a href="../man4/dummynet.4.html">dummynet</a></u>(4), <u><a href="../man8/ipfw.8.html">ipfw</a></u>(8), <u><a href="../man4/pf.4.html">pf</a></u>(4), the order in which you  load  the  modules  is  important.   You  should
           kldload  the other modules first, as this will ensure TCP packets undergo any necessary manipulations
           before <b>SIFTR</b> "sees" and processes them.

       <b>-</b>   There is a known, harmless lock order reversal warning between the <u><a href="../man9/pfil.9.html">pfil</a></u>(9) mutex and tcbinfo TCP lock
           reported by <u><a href="../man4/witness.4.html">witness</a></u>(4) when <b>SIFTR</b> is enabled in a kernel compiled with <u><a href="../man4/witness.4.html">witness</a></u>(4) support.

       <b>-</b>   There is no way to filter which TCP flows you wish to capture data for.  Post processing is  required
           to separate out data belonging to particular flows of interest.

       <b>-</b>   The  module  does  not detect deletion of the log file path.  New log messages will simply be lost if
           the log file being used by <b>SIFTR</b> is deleted whilst the module is set to use the file.  Switching to a
           new log file using the <u>net.inet.siftr.logfile</u> variable  will  create  the  new  file  and  allow  log
           messages  to  begin  being written to disk again.  The new log file path must differ from the path to
           the deleted file.

       <b>-</b>   The hash table used within the code is sized to hold 65536 flows.  This is not a hard limit,  because
           chaining is used to handle collisions within the hash table structure.  However, we suspect (based on
           analogies  with  other  hash  table  performance  data)  that the hash table look up performance (and
           therefore the module's packet processing performance) will degrade in an exponential  manner  as  the
           number of unique flows handled in a module enable/disable cycle approaches and surpasses 65536.

       <b>-</b>   There  is no garbage collection performed on the flow hash table.  The only way currently to flush it
           is to disable <b>SIFTR</b>.

       <b>-</b>   The PPL variable applies to packets that make it  into  the  processing  thread,  not  total  packets
           received  in  the hook function.  Packets are skipped before the PPL variable is applied, which means
           there may be a slight discrepancy in the triggering of log messages.  For example, if PPL was set  to
           10,  and  the 8th packet since the last log message is skipped, the 11th packet will actually trigger
           the log message to be generated.  This is  discussed  in  greater  depth  in  CAIA  technical  report
           070824A.

       <b>-</b>   At  the  time  of  writing,  there was no simple way to hook into the TCP layer to intercept packets.
           <b>SIFTR</b>'s use of IP layer hook points means all IP traffic will be processed by the <b>SIFTR</b> <u><a href="../man9/pfil.9.html">pfil</a></u>(9)  hook
           function, which introduces minor, but nonetheless unnecessary packet delay and processing overhead on
           the  system  for non-TCP packets as well.  Hooking in at the IP layer is also not ideal from the data
           gathering point of view.  Packets traversing up the stack will be intercepted and cause a log message
           generation BEFORE they have been processed by the TCP layer, which means we cannot observe the cause-
           and-affect relationship between inbound events and the corresponding TCP control block  as  precisely
           as could be.  Ideally, <b>SIFTR</b> should intercept packets after they have been processed by the TCP layer
           i.e.   intercept  packets  coming  up  the  stack  after they have been processed by tcp_input(), and
           intercept packets coming down the stack after they have been processed by tcp_output().  The  current
           code  still gives satisfactory granularity though, as inbound events tend to trigger outbound events,
           allowing the cause-and-effect to be observed indirectly by capturing the state on outbound events  as
           well.

       <b>-</b>   The "inflight bytes" value logged by <b>SIFTR</b> does not take into account bytes that have been SACK'ed by
           the receiving host.

       <b>-</b>   Packet hash generation does not currently work for IPv6 based TCP packets.

       <b>-</b>   Compressed  notation  is  not used for IPv6 address representation.  This consumes more bytes than is
           necessary in log output.

Debian                                           October 7, 2019                                        <u><a href="../man4/SIFTR.4.html">SIFTR</a></u>(4)
</pre>
 </div>
</div></section>
</div>
</body>
</html>