<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>gdb — external kernel debugger</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       gdb — external kernel debugger

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>makeoptions</b> <b>DEBUG=-g</b>
       <b>options</b> <b>DDB</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>gdb</b>  kernel  debugger  is a variation of <u><a href="../man1/gdb.1.html">gdb</a></u>(1) which understands some aspects of the FreeBSD kernel
       environment.  It can be used in a number of ways:

       <b>•</b>   It can be used to examine the memory of the processor on which it runs.

       <b>•</b>   It can be used to analyse a processor dump after a panic.

       <b>•</b>   It can be used to debug another system interactively via a serial or firewire link.   In  this  mode,
           the processor can be stopped and single stepped.

       <b>•</b>   With  a  firewire  link,  it  can  be  used  to  examine  the  memory  of a remote system without the
           participation of that system.  In this mode, the processor cannot be stopped and single stepped,  but
           it can be of use when the remote system has crashed and is no longer responding.

       When  used for remote debugging, <b>gdb</b> requires the presence of the <u><a href="../man4/ddb.4.html">ddb</a></u>(4) kernel debugger.  Commands exist
       to switch between <b>gdb</b> and <u><a href="../man4/ddb.4.html">ddb</a></u>(4).

</pre><h4><b>PREPARING</b> <b>FOR</b> <b>DEBUGGING</b></h4><pre>
       When debugging kernels, it is practically essential  to  have  built  a  kernel  with  debugging  symbols
       (<b>makeoptions</b>  <b>DEBUG=-g</b>).  It is easiest to perform operations from the kernel build directory, by default
       <u>/usr/obj/usr/src/sys/GENERIC</u>.

       First, ensure you have a copy of the debug macros in the directory:

             <b>make</b> <b>gdbinit</b>

       This command performs some transformations on the  macros  installed  in  <u>/usr/src/tools/debugscripts</u>  to
       adapt them to the local environment.

   <b>Inspecting</b> <b>the</b> <b>environment</b> <b>of</b> <b>the</b> <b>local</b> <b>machine</b>
       To look at and change the contents of the memory of the system you are running on,

             <b>gdb</b> <b>-k</b> <b>-wcore</b> <b>kernel.debug</b> <b>/dev/mem</b>

       In  this  mode, you need the <b>-k</b> flag to indicate to <u><a href="../man1/gdb.1.html">gdb</a></u>(1) that the “dump file” <u>/dev/mem</u> is a kernel data
       file.  You can look at live data, and if you include the <b>-wcore</b> option, you can change it at your  peril.
       The  system does not stop (obviously), so a number of things will not work.  You can set breakpoints, but
       you cannot “continue” execution, so they will not work.

   <b>Debugging</b> <b>a</b> <b>crash</b> <b>dump</b>
       By default, crash dumps are stored in the directory <u><a href="file:/var/crash">/var/crash</a></u>.  Investigate them from the  kernel  build
       directory with:

             <b>gdb</b> <b>-k</b> <b>kernel.debug</b> <b>/var/crash/vmcore.29</b>

       In this mode, the system is obviously stopped, so you can only look at it.

   <b>Debugging</b> <b>a</b> <b>live</b> <b>system</b> <b>with</b> <b>a</b> <b>remote</b> <b>link</b>
       In  the  following  discussion,  the  term  “local system” refers to the system running the debugger, and
       “remote system” refers to the live system being debugged.

       To debug a live system with a remote link, the kernel must be compiled with the option <b>options</b> <b>DDB</b>.   The
       option  <b>options</b>  <b>BREAK_TO_DEBUGGER</b>  enables  the  debugging  machine  stop  the  debugged  machine once a
       connection has been established by pressing ‘^C’.

   <b>Debugging</b> <b>a</b> <b>live</b> <b>system</b> <b>with</b> <b>a</b> <b>remote</b> <b>serial</b> <b>link</b>
       When using a serial port for the remote link on the i386 platform, the serial port must be identified  by
       setting  the  flag  bit  <b>0x80</b>  for  the specified interface.  Generally, this port will also be used as a
       serial console (flag bit <b>0x10</b>), so the entry in <u>/boot/device.hints</u> should be:

             <b>hint.sio.0.flags="0x90"</b>

   <b>Debugging</b> <b>a</b> <b>live</b> <b>system</b> <b>with</b> <b>a</b> <b>remote</b> <b>firewire</b> <b>link</b>
       As with serial debugging, to debug a live system with a firewire link, the kernel must be  compiled  with
       the option <b>options</b> <b>DDB</b>.

       A number of steps must be performed to set up a firewire link:

       <b>•</b>   Ensure  that both systems have <u><a href="../man4/firewire.4.html">firewire</a></u>(4) support, and that the kernel of the remote system includes
           the <u><a href="../man4/dcons.4.html">dcons</a></u>(4) and <u><a href="../man4/dcons_crom.4.html">dcons_crom</a></u>(4) drivers.  If they are not compiled into the kernel, load the KLDs:

                 <b>kldload</b> <b>firewire</b>

           On the remote system only:

                 kldload dcons
                 kldload dcons_crom

           You should see something like this in the <u><a href="../man8/dmesg.8.html">dmesg</a></u>(8) output of the remote system:

                 fwohci0: BUS reset
                 fwohci0: node_id=0x8800ffc0, gen=2, non CYCLEMASTER mode
                 firewire0: 2 nodes, maxhop &lt;= 1, cable IRM = 1
                 firewire0: bus manager 1
                 firewire0: New S400 device ID:00c04f3226e88061
                 dcons_crom0: &lt;dcons configuration ROM&gt; on firewire0
                 dcons_crom0: bus_addr 0x22a000

           It is a good idea to load these modules at boot time with the following entry in <u>/boot/loader.conf</u>:

                 <b>dcons_crom_enable="YES"</b>

           This ensures that all  three  modules  are  loaded.   There  is  no  harm  in  loading  <u><a href="../man4/dcons.4.html">dcons</a></u>(4)  and
           <u><a href="../man4/dcons_crom.4.html">dcons_crom</a></u>(4)  on  the local system, but if you only want to load the <u><a href="../man4/firewire.4.html">firewire</a></u>(4) module, include the
           following in <u>/boot/loader.conf</u>:

                 <b>firewire_enable="YES"</b>

       <b>•</b>   Next, use <u><a href="../man8/fwcontrol.8.html">fwcontrol</a></u>(8) to find the firewire node corresponding to the remote machine.  On  the  local
           machine you might see:

                 # fwcontrol
                 2 devices (info_len=2)
                 node        EUI64        status
                    1  0x00c04f3226e88061      0
                    0  0x000199000003622b      1

           The  first  node  is always the local system, so in this case, node 0 is the remote system.  If there
           are more than two systems, check from the other end to find which  node  corresponds  to  the  remote
           system.  On the remote machine, it looks like this:

                 # fwcontrol
                 2 devices (info_len=2)
                 node        EUI64        status
                    0  0x000199000003622b      0
                    1  0x00c04f3226e88061      1

       <b>•</b>   Next, establish a firewire connection with <u><a href="../man8/dconschat.8.html">dconschat</a></u>(8):

                 <b>dconschat</b> <b>-br</b> <b>-G</b> <b>5556</b> <b>-t</b> <b>0x000199000003622b</b>

           <b>0x000199000003622b</b>  is  the  EUI64  address  of  the  remote  node,  as determined from the output of
           <u><a href="../man8/fwcontrol.8.html">fwcontrol</a></u>(8) above.  When started in this manner, <u><a href="../man8/dconschat.8.html">dconschat</a></u>(8) establishes a local tunnel  connection
           from  port  <b>localhost:5556</b>  to the remote debugger.  You can also establish a console port connection
           with the <b>-C</b> option to the same invocation <u><a href="../man8/dconschat.8.html">dconschat</a></u>(8).  See the  <u><a href="../man8/dconschat.8.html">dconschat</a></u>(8)  manpage  for  further
           details.

           The <u><a href="../man8/dconschat.8.html">dconschat</a></u>(8) utility does not return control to the user.  It displays error messages and console
           output for the remote system, so it is a good idea to start it in its own window.

       <b>•</b>   Finally, establish connection:

                 # gdb kernel.debug
                 GNU gdb 5.2.1 (FreeBSD)
                 <u>(political</u> <u>statements</u> <u>omitted)</u>
                 Ready to go.  Enter 'tr' to connect to the remote target
                 with /dev/cuau0, 'tr /dev/cuau1' to connect to a different port
                 or 'trf portno' to connect to the remote target with the firewire
                 interface.  portno defaults to 5556.

                 Type 'getsyms' after connection to load kld symbols.

                 If you are debugging a local system, you can use 'kldsyms' instead
                 to load the kld symbols.  That is a less obnoxious interface.
                 (gdb) trf
                 0xc21bd378 in ?? ()

           The  <b>trf</b>  macro  assumes a connection on port 5556.  If you want to use a different port (by changing
           the invocation of <u><a href="../man8/dconschat.8.html">dconschat</a></u>(8) above), use the <b>tr</b> macro instead.  For example, if  you  want  to  use
           port 4711, run <u><a href="../man8/dconschat.8.html">dconschat</a></u>(8) like this:

                 <b>dconschat</b> <b>-br</b> <b>-G</b> <b>4711</b> <b>-t</b> <b>0x000199000003622b</b>

           Then establish connection with:

                 (gdb) tr localhost:4711
                 0xc21bd378 in ?? ()

   <b>Non-cooperative</b> <b>debugging</b> <b>a</b> <b>live</b> <b>system</b> <b>with</b> <b>a</b> <b>remote</b> <b>firewire</b> <b>link</b>
       In  addition to the conventional debugging via firewire described in the previous section, it is possible
       to debug a remote system without its cooperation, once an initial connection has been established.   This
       corresponds  to  debugging a local machine using <u>/dev/mem</u>.  It can be very useful if a system crashes and
       the   debugger   no   longer   responds.    To   use   this   method,   set   the   <u><a href="../man8/sysctl.8.html">sysctl</a></u>(8)   variables
       <u>hw.firewire.fwmem.eui64_hi</u>  and  <u>hw.firewire.fwmem.eui64_lo</u> to the upper and lower halves of the EUI64 ID
       of the remote system, respectively.  From the previous example, the remote machine shows:

             # fwcontrol
             2 devices (info_len=2)
             node        EUI64        status
                0  0x000199000003622b      0
                1  0x00c04f3226e88061      1

       Enter:

             # sysctl -w hw.firewire.fwmem.eui64_hi=0x00019900
             hw.firewire.fwmem.eui64_hi: 0 -&gt; 104704
             # sysctl -w hw.firewire.fwmem.eui64_lo=0x0003622b
             hw.firewire.fwmem.eui64_lo: 0 -&gt; 221739

       Note that the variables must be explicitly stated in hexadecimal.  After this, you can examine the remote
       machine's state with the following input:

             # gdb -k kernel.debug /dev/fwmem0.0
             GNU gdb 5.2.1 (FreeBSD)
             <u>(messages</u> <u>omitted)</u>
             Reading symbols from /boot/kernel/dcons.ko...done.
             Loaded symbols for /boot/kernel/dcons.ko
             Reading symbols from /boot/kernel/dcons_crom.ko...done.
             Loaded symbols for /boot/kernel/dcons_crom.ko
             #0  sched_switch (td=0xc0922fe0) at /usr/src/sys/kern/sched_4bsd.c:621
             0xc21bd378 in ?? ()

       In this case, it is not necessary to load the symbols explicitly.  The remote system continues to run.

</pre><h4><b>COMMANDS</b></h4><pre>
       The user interface to <b>gdb</b> is via <u><a href="../man1/gdb.1.html">gdb</a></u>(1), so <u><a href="../man1/gdb.1.html">gdb</a></u>(1) commands also work.  This section discusses  only  the
       extensions for kernel debugging that get installed in the kernel build directory.

   <b>Debugging</b> <b>environment</b>
       The following macros manipulate the debugging environment:

       <b>ddb</b>     Switch back to <u><a href="../man4/ddb.4.html">ddb</a></u>(4).  This command is only meaningful when performing remote debugging.

       <b>getsyms</b>
               Display  <b>kldstat</b> information for the target machine and invite user to paste it back in.  This is
               required because <b>gdb</b> does not allow data to be passed to shell  scripts.   It  is  necessary  for
               remote debugging and crash dumps; for local memory debugging use <b>kldsyms</b> instead.

       <b>kldsyms</b>
               Read in the symbol tables for the debugging machine.  This does not work for remote debugging and
               crash dumps; use <b>getsyms</b> instead.

       <b>tr</b> <u>interface</u>
               Debug a remote system via the specified serial or firewire interface.

       <b>tr0</b>     Debug a remote system via serial interface <u>/dev/cuau0</u>.

       <b>tr1</b>     Debug a remote system via serial interface <u>/dev/cuau1</u>.

       <b>trf</b>     Debug a remote system via firewire interface at default port 5556.

       The commands <b>tr0</b>, <b>tr1</b> and <b>trf</b> are convenience commands which invoke <b>tr</b>.

   <b>The</b> <b>current</b> <b>process</b> <b>environment</b>
       The  following  macros  are convenience functions intended to make things easier than the standard <u><a href="../man1/gdb.1.html">gdb</a></u>(1)
       commands.

       <b>f0</b>      Select stack frame 0 and show assembler-level details.

       <b>f1</b>      Select stack frame 1 and show assembler-level details.

       <b>f2</b>      Select stack frame 2 and show assembler-level details.

       <b>f3</b>      Select stack frame 3 and show assembler-level details.

       <b>f4</b>      Select stack frame 4 and show assembler-level details.

       <b>f5</b>      Select stack frame 5 and show assembler-level details.

       <b>xb</b>      Show 12 words in hex, starting at current <u>ebp</u> value.

       <b>xi</b>      List the next 10 instructions from the current <u>eip</u> value.

       <b>xp</b>      Show the register contents and the first four parameters of the current stack frame.

       <b>xp0</b>     Show the first parameter of current stack frame in various formats.

       <b>xp1</b>     Show the second parameter of current stack frame in various formats.

       <b>xp2</b>     Show the third parameter of current stack frame in various formats.

       <b>xp3</b>     Show the fourth parameter of current stack frame in various formats.

       <b>xp4</b>     Show the fifth parameter of current stack frame in various formats.

       <b>xs</b>      Show the last 12 words on stack in hexadecimal.

       <b>xxp</b>     Show the register contents and the first ten parameters.

       <b>z</b>       Single step 1 instruction (over calls) and show next instruction.

       <b>zs</b>      Single step 1 instruction (through calls) and show next instruction.

   <b>Examining</b> <b>other</b> <b>processes</b>
       The following macros access other processes.  The  <b>gdb</b>  debugger  does  not  understand  the  concept  of
       multiple processes, so they effectively bypass the entire <b>gdb</b> environment.

       <b>btp</b> <u>pid</u>
               Show a backtrace for the process <u>pid</u>.

       <b>btpa</b>    Show backtraces for all processes in the system.

       <b>btpp</b>    Show a backtrace for the process previously selected with <b>defproc</b>.

       <b>btr</b> <u>ebp</u>
               Show a backtrace from the <u>ebp</u> address specified.

       <b>defproc</b> <u>pid</u>
               Specify the PID of the process for some other commands in this section.

       <b>fr</b> <u>frame</u>
               Show frame <u>frame</u> of the stack of the process previously selected with <b>defproc</b>.

       <b>pcb</b> <u>proc</u>
               Show some PCB contents of the process <u>proc</u>.

   <b>Examining</b> <b>data</b> <b>structures</b>
       You  can  use  standard  <u><a href="../man1/gdb.1.html">gdb</a></u>(1) commands to look at most data structures.  The macros in this section are
       convenience functions which typically display the data in a more readable  format,  or  which  omit  less
       interesting parts of the structure.

       <b>bp</b>      Show information about the buffer header pointed to by the variable <u>bp</u> in the current frame.

       <b>bpd</b>     Show the contents (<u>char</u> <u>*</u>) of <u>bp-&gt;data</u> in the current frame.

       <b>bpl</b>     Show  detailed  information  about the buffer header (<u>struct</u> <u>bp</u>) pointed at by the local variable
               <u>bp</u>.

       <b>bpp</b> <u>bp</u>  Show summary information about the buffer header (<u>struct</u> <u>bp</u>) pointed at by the parameter <u>bp</u>.

       <b>bx</b>      Print a number of fields from the buffer header pointed at in by the pointer <u>bp</u>  in  the  current
               environment.

       <b>vdev</b>    Show some information of the <u>vnode</u> pointed to by the local variable <u>vp</u>.

   <b>Miscellaneous</b> <b>macros</b>
       <b>checkmem</b>
               Check  unallocated memory for modifications.  This assumes that the kernel has been compiled with
               <b>options</b> <b>DIAGNOSTIC</b>.  This causes the contents of free memory to be set to <b>0xdeadc0de</b>.

       <b>dmesg</b>   Print the system message buffer.  This corresponds to the <u><a href="../man8/dmesg.8.html">dmesg</a></u>(8) utility.  This macro  used  to
               be  called  <b>msgbuf</b>.   It  can take a very long time over a serial line, and it is even slower via
               firewire or local memory due to inefficiencies in <b>gdb</b>.  When  debugging  a  crash  dump  or  over
               firewire,  it  is  not  necessary  to  start  <b>gdb</b>  to  access the message buffer: instead, use an
               appropriate variation of

                     dmesg -M /var/crash/vmcore.0 -N kernel.debug
                     dmesg -M /dev/fwmem0.0 -N kernel.debug

       <b>kldstat</b>
               Equivalent of the <u><a href="../man8/kldstat.8.html">kldstat</a></u>(8) utility without options.

       <b>pname</b>   Print the command name of the current process.

       <b>ps</b>      Show process status.  This corresponds in concept, but not in appearance, to the  <u><a href="../man1/ps.1.html">ps</a></u>(1)  utility.
               When  debugging  a  crash  dump or over firewire, it is not necessary to start <b>gdb</b> to display the
               <u><a href="../man1/ps.1.html">ps</a></u>(1) output: instead, use an appropriate variation of

                     ps -M /var/crash/vmcore.0 -N kernel.debug
                     ps -M /dev/fwmem0.0 -N kernel.debug

       <b>y</b>       Kludge for writing macros.  When writing macros, it is convenient to paste them back into the <b>gdb</b>
               window.  Unfortunately, if the macro is already defined, <b>gdb</b> insists on asking

                     <b>Redefine</b> <b>foo?</b>

               It will not give up until you answer ‘y’.  This command is that answer.   It  does  nothing  else
               except to print a warning message to remind you to remove it again.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man1/gdb.1.html">gdb</a></u>(1), <u><a href="../man1/ps.1.html">ps</a></u>(1), <u><a href="../man4/ddb.4.html">ddb</a></u>(4), <u><a href="../man4/firewire.4.html">firewire</a></u>(4), <u><a href="../man8/dconschat.8.html">dconschat</a></u>(8), <u><a href="../man8/dmesg.8.html">dmesg</a></u>(8), <u><a href="../man8/fwcontrol.8.html">fwcontrol</a></u>(8), <u><a href="../man8/kldload.8.html">kldload</a></u>(8)

</pre><h4><b>AUTHORS</b></h4><pre>
       This man page was written by Greg Lehey &lt;<u><a href="mailto:grog@FreeBSD.org">grog@FreeBSD.org</a></u>&gt;.

</pre><h4><b>BUGS</b></h4><pre>
       The  <u><a href="../man1/gdb.1.html">gdb</a></u>(1) debugger was never designed to debug kernels, and it is not a very good match.  Many problems
       exist.

       The <b>gdb</b> implementation is very inefficient, and many operations are slow.

       Serial debugging is even slower, and race conditions can make it difficult to run the link at  more  than
       9600 bps.  Firewire connections do not have this problem.

       The  debugging  macros  “just  grew.”  In  general,  the person who wrote them did so while looking for a
       specific problem, so they may not be general enough, and they may behave badly  when  used  in  ways  for
       which they were not intended, even if those ways make sense.

       Many of these commands only work on the ia32 architecture.

Debian                                            May 17, 2016                                            <u><a href="../man4/GDB.4.html">GDB</a></u>(4)
</pre>
 </div>
</div></section>
</div>
</body>
</html>