<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>lirc - lirc devices</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/manpages">manpages_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       lirc - lirc devices

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <u>/dev/lirc*</u>  character devices provide a low-level bidirectional interface to infra-red (IR) remotes.
       Most of these devices can receive, and some can send.  When receiving or sending data, the  driver  works
       in two different modes depending on the underlying hardware.

       Some  hardware  (typically TV-cards) decodes the IR signal internally and provides decoded button presses
       as scancode values.  Drivers for this kind of hardware work in <b>LIRC_MODE_SCANCODE</b>  mode.   Such  hardware
       usually does not support sending IR signals.  Furthermore, such hardware can only decode a limited set of
       IR  protocols, usually only the protocol of the specific remote which is bundled with, for example, a TV-
       card.

       Other hardware provides a stream of pulse/space durations.  Such drivers work  in  <b>LIRC_MODE_MODE2</b>  mode.
       Such  hardware  can  be used with (almost) any kind of remote.  This type of hardware can also be used in
       <b>LIRC_MODE_SCANCODE</b> mode, in which case the kernel IR decoders will decode the IR.  These decoders can  be
       written  in  extended BPF (see <b><a href="../man2/bpf.2.html">bpf</a></b>(2)) and attached to the <b>lirc</b> device.  Sometimes, this kind of hardware
       also supports sending IR data.

       The <b>LIRC_GET_FEATURES</b> ioctl (see below) allows probing for whether receiving and  sending  is  supported,
       and in which modes, amongst other features.

   <b>Reading</b> <b>input</b> <b>with</b> <b>the</b> <b>LIRC_MODE_MODE2</b> <b>mode</b>
       In  the <b>LIRC_MODE_MODE2</b> <b>mode</b>, the data returned by <b><a href="../man2/read.2.html">read</a></b>(2) provides 32-bit values representing a space or
       a pulse duration.  The time of the duration (microseconds) is encoded in the lower 24 bits.  Pulse  (also
       known  as  flash)  indicates  a  duration of infrared light being detected, and space (also known as gap)
       indicates a duration with no infrared.  If the duration  of  space  exceeds  the  inactivity  timeout,  a
       special  timeout  package  is delivered, which marks the end of a message.  The upper 8 bits indicate the
       type of package:

       <b>LIRC_MODE2_SPACE</b>
           Value reflects a space duration (microseconds).

       <b>LIRC_MODE2_PULSE</b>
           Value reflects a pulse duration (microseconds).

       <b>LIRC_MODE2_FREQUENCY</b>
           Value reflects a frequency (Hz); see the <b>LIRC_SET_MEASURE_CARRIER_MODE</b> ioctl.

       <b>LIRC_MODE2_TIMEOUT</b>
           Value  reflects  a  space  duration  (microseconds).   The  package  reflects  a  timeout;  see   the
           <b>LIRC_SET_REC_TIMEOUT_REPORTS</b> ioctl.

       <b>LIRC_MODE2_OVERFLOW</b>
           The IR receiver encountered an overflow, and as a result data is missing (since Linux 5.18).

   <b>Reading</b> <b>input</b> <b>with</b> <b>the</b> <b>LIRC_MODE_SCANCODE</b> <b>mode</b>
       In  the  <b>LIRC_MODE_SCANCODE</b>  mode,  the  data returned by <b><a href="../man2/read.2.html">read</a></b>(2) reflects decoded button presses, in the
       struct <u>lirc_scancode</u>.  The scancode is stored in the <u>scancode</u> field, and the IR  protocol  is  stored  in
       <u>rc_proto</u>.  This field has one the values of the <u>enum</u> <u>rc_proto</u>.

   <b>Writing</b> <b>output</b> <b>with</b> <b>the</b> <b>LIRC_MODE_PULSE</b> <b>mode</b>
       The  data  written  to  the  character device using <b><a href="../man2/write.2.html">write</a></b>(2) is a pulse/space sequence of integer values.
       Pulses and spaces are only marked implicitly by their position.  The data  must  start  and  end  with  a
       pulse, thus it must always include an odd number of samples.  The <b><a href="../man2/write.2.html">write</a></b>(2) function blocks until the data
       has  been transmitted by the hardware.  If more data is provided than the hardware can send, the <b><a href="../man2/write.2.html">write</a></b>(2)
       call fails with the error <b>EINVAL</b>.

   <b>Writing</b> <b>output</b> <b>with</b> <b>the</b> <b>LIRC_MODE_SCANCODE</b> <b>mode</b>
       The data written to the character devices must be  a  single  struct  <u>lirc_scancode</u>.   The  <u>scancode</u>  and
       <u>rc_proto</u>  fields  must  filled  in,  all other fields must be 0.  The kernel IR encoders will convert the
       scancode to pulses and spaces.  The protocol or scancode is invalid, or the <b>lirc</b> device cannot transmit.

</pre><h4><b>IOCTL</b> <b>COMMANDS</b></h4><pre>
       #include &lt;<a href="file:/usr/include/linux/lirc.h">linux/lirc.h</a>&gt;    /* But see BUGS */

       int ioctl(int fd, int cmd, int *val);

       The following <b><a href="../man2/ioctl.2.html">ioctl</a></b>(2) operations are provided by the <b>lirc</b> character device to probe or  change  specific
       <b>lirc</b> hardware settings.

   <b>Always</b> <b>Supported</b> <b>Commands</b>
       <u>/dev/lirc*</u> devices always support the following commands:

       <b>LIRC_GET_FEATURES</b> (<u>void</u>)
           Returns a bit mask of combined features bits; see FEATURES.

       If a device returns an error code for <b>LIRC_GET_FEATURES</b>, it is safe to assume it is not a <b>lirc</b> device.

   <b>Optional</b> <b>Commands</b>
       Some  <b>lirc</b> devices support the commands listed below.  Unless otherwise stated, these fail with the error
       <b>ENOTTY</b> if the operation isn't supported, or with the error <b>EINVAL</b> if the  operation  failed,  or  invalid
       arguments  were  provided.   If  a  driver  does  not  announce support of certain features, invoking the
       corresponding ioctls will fail with the error <b>ENOTTY</b>.

       <b>LIRC_GET_REC_MODE</b> (<u>void</u>)
              If the <b>lirc</b> device has no receiver, this operation fails with the  error  <b>ENOTTY</b>.   Otherwise,  it
              returns the receive mode, which will be one of:

              <b>LIRC_MODE_MODE2</b>
                     The driver returns a sequence of pulse/space durations.

              <b>LIRC_MODE_SCANCODE</b>
                     The  driver  returns struct <u>lirc_scancode</u> values, each of which represents a decoded button
                     press.

       <b>LIRC_SET_REC_MODE</b> (<u>int</u>)
              Set the receive mode.  <u>val</u> is either <b>LIRC_MODE_SCANCODE</b> or <b>LIRC_MODE_MODE2</b>.  If  the  <b>lirc</b>  device
              has no receiver, this operation fails with the error <b>ENOTTY.</b>

       <b>LIRC_GET_SEND_MODE</b> (<u>void</u>)
              Return  the  send  mode.   <b>LIRC_MODE_PULSE</b> or <b>LIRC_MODE_SCANCODE</b> is supported.  If the <b>lirc</b> device
              cannot send, this operation fails with the error <b>ENOTTY.</b>

       <b>LIRC_SET_SEND_MODE</b> (<u>int</u>)
              Set the send mode.  <u>val</u> is either <b>LIRC_MODE_SCANCODE</b>  or  <b>LIRC_MODE_PULSE</b>.   If  the  <b>lirc</b>  device
              cannot send, this operation fails with the error <b>ENOTTY</b>.

       <b>LIRC_SET_SEND_CARRIER</b> (<u>int</u>)
              Set the modulation frequency.  The argument is the frequency (Hz).

       <b>LIRC_SET_SEND_DUTY_CYCLE</b> (<u>int</u>)
              Set  the carrier duty cycle.  <u>val</u> is a number in the range [0,100] which describes the pulse width
              as a percentage of the total cycle.  Currently, no special meaning is defined for 0  or  100,  but
              the values are reserved for future use.

       <b>LIRC_GET_MIN_TIMEOUT(</b><u>void</u><b>)</b>
       <b>LIRC_GET_MAX_TIMEOUT(</b><u>void</u><b>)</b>
              Some  devices  have  internal timers that can be used to detect when there has been no IR activity
              for a long time.  This can help <b><a href="../man8/lircd.8.html">lircd</a></b>(8) in detecting that an IR signal is finished and can  speed
              up  the decoding process.  These operations return integer values with the minimum/maximum timeout
              that can  be  set  (microseconds).   Some  devices  have  a  fixed  timeout.   For  such  drivers,
              <b>LIRC_GET_MIN_TIMEOUT</b> and <b>LIRC_GET_MAX_TIMEOUT</b> will fail with the error <b>ENOTTY</b>.

       <b>LIRC_SET_REC_TIMEOUT</b> (<u>int</u>)
              Set the integer value for IR inactivity timeout (microseconds).  To be accepted, the value must be
              within  the  limits  defined  by  <b>LIRC_GET_MIN_TIMEOUT</b> and <b>LIRC_GET_MAX_TIMEOUT</b>.  A value of 0 (if
              supported by the hardware) disables all hardware timeouts and data should be reported as  soon  as
              possible.   If  the exact value cannot be set, then the next possible value <u>greater</u> than the given
              value should be set.

       <b>LIRC_GET_REC_TIMEOUT</b> (<u>void</u>)
              Return the current inactivity timeout (microseconds).  Available since Linux 4.18.

       <b>LIRC_SET_REC_TIMEOUT_REPORTS</b> (<u>int</u>)
              Enable (<u>val</u> is 1) or disable (<u>val</u> is 0) timeout packages in <b>LIRC_MODE_MODE2</b>.  The behavior of this
              operation has varied across kernel versions:

              •  Since Linux 5.17: timeout packages are always enabled and this ioctl is a no-op.

              •  Since Linux 4.16: timeout packages are enabled by  default.   Each  time  the  <b>lirc</b>  device  is
                 opened,  the  <b>LIRC_SET_REC_TIMEOUT</b>  operation can be used to disable (and, if desired, to later
                 re-enable) the timeout on the file descriptor.

              •  In Linux 4.15 and earlier: timeout packages are disabled by default,  and  enabling  them  (via
                 <b>LIRC_SET_REC_TIMEOUT</b>)  on any file descriptor associated with the <b>lirc</b> device has the effect of
                 enabling timeouts for all file  descriptors  referring  to  that  device  (until  timeouts  are
                 disabled again).

       <b>LIRC_SET_REC_CARRIER</b> (<u>int</u>)
              Set the upper bound of the receive carrier frequency (Hz).  See <b>LIRC_SET_REC_CARRIER_RANGE</b>.

       <b>LIRC_SET_REC_CARRIER_RANGE</b> (<u>int</u>)
              Sets  the  lower  bound of the receive carrier frequency (Hz).  For this to take affect, first set
              the lower bound using the <b>LIRC_SET_REC_CARRIER_RANGE</b> ioctl, and then the  upper  bound  using  the
              <b>LIRC_SET_REC_CARRIER</b> ioctl.

       <b>LIRC_SET_MEASURE_CARRIER_MODE</b> (<u>int</u>)
              Enable (<u>val</u> is 1) or disable (<u>val</u> is 0) the measure mode.  If enabled, from the next key press on,
              the driver will send <b>LIRC_MODE2_FREQUENCY</b> packets.  By default, this should be turned off.

       <b>LIRC_GET_REC_RESOLUTION</b> (<u>void</u>)
              Return the driver resolution (microseconds).

       <b>LIRC_SET_TRANSMITTER_MASK</b> (<u>int</u>)
              Enable  the  set  of  transmitters  specified in <u>val</u>, which contains a bit mask where each enabled
              transmitter is a 1.  The first transmitter is encoded by the least significant  bit,  and  so  on.
              When  an  invalid bit mask is given, for example a bit is set even though the device does not have
              so many transmitters, this operation returns the number of available transmitters and does nothing
              otherwise.

       <b>LIRC_SET_WIDEBAND_RECEIVER</b> (<u>int</u>)
              Some devices are equipped with a special wide band receiver which is intended to be used to  learn
              the output of an existing remote.  This ioctl can be used to enable (<u>val</u> equals 1) or disable (<u>val</u>
              equals  0)  this  functionality.  This might be useful for devices that otherwise have narrow band
              receivers that prevent them to be used with certain remotes.  Wide band receivers may also be more
              precise.  On the other hand, their disadvantage usually is reduced range of reception.

              Note: wide band receiver may be implicitly enabled if you enable carrier reports.  In  that  case,
              it  will  be  disabled  as  soon  as  you  disable carrier reports.  Trying to disable a wide band
              receiver while carrier reports are active will do nothing.

</pre><h4><b>FEATURES</b></h4><pre>
       the <b>LIRC_GET_FEATURES</b> ioctl returns a bit mask describing features of the driver.  The following bits may
       be returned in the mask:

       <b>LIRC_CAN_REC_MODE2</b>
              The driver is capable of receiving using <b>LIRC_MODE_MODE2</b>.

       <b>LIRC_CAN_REC_SCANCODE</b>
              The driver is capable of receiving using <b>LIRC_MODE_SCANCODE</b>.

       <b>LIRC_CAN_SET_SEND_CARRIER</b>
              The driver supports changing the modulation frequency using <b>LIRC_SET_SEND_CARRIER</b>.

       <b>LIRC_CAN_SET_SEND_DUTY_CYCLE</b>
              The driver supports changing the duty cycle using <b>LIRC_SET_SEND_DUTY_CYCLE</b>.

       <b>LIRC_CAN_SET_TRANSMITTER_MASK</b>
              The driver supports changing the active transmitter(s) using <b>LIRC_SET_TRANSMITTER_MASK</b>.

       <b>LIRC_CAN_SET_REC_CARRIER</b>
              The driver supports setting the receive carrier frequency using  <b>LIRC_SET_REC_CARRIER</b>.   Any  <b>lirc</b>
              device  since the drivers were merged in Linux 2.6.36 must have <b>LIRC_CAN_SET_REC_CARRIER_RANGE</b> set
              if <b>LIRC_CAN_SET_REC_CARRIER</b> feature is set.

       <b>LIRC_CAN_SET_REC_CARRIER_RANGE</b>
              The driver supports <b>LIRC_SET_REC_CARRIER_RANGE</b>.  The lower bound of the carrier must first be  set
              using the <b>LIRC_SET_REC_CARRIER_RANGE</b> ioctl, before using the <b>LIRC_SET_REC_CARRIER</b> ioctl to set the
              upper bound.

       <b>LIRC_CAN_GET_REC_RESOLUTION</b>
              The driver supports <b>LIRC_GET_REC_RESOLUTION</b>.

       <b>LIRC_CAN_SET_REC_TIMEOUT</b>
              The driver supports <b>LIRC_SET_REC_TIMEOUT</b>.

       <b>LIRC_CAN_MEASURE_CARRIER</b>
              The driver supports measuring of the modulation frequency using <b>LIRC_SET_MEASURE_CARRIER_MODE</b>.

       <b>LIRC_CAN_USE_WIDEBAND_RECEIVER</b>
              The driver supports learning mode using <b>LIRC_SET_WIDEBAND_RECEIVER</b>.

       <b>LIRC_CAN_SEND_PULSE</b>
              The driver supports sending using <b>LIRC_MODE_PULSE</b> or <b>LIRC_MODE_SCANCODE</b>

</pre><h4><b>BUGS</b></h4><pre>
       Using  these  devices  requires  the kernel source header file <u>lirc.h</u>.  This file is not available before
       Linux 4.6.  Users of older kernels could use the file bundled in <a href="http://www.lirc.org">http://www.lirc.org</a>.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/ir-ctl.1.html">ir-ctl</a></b>(1), <b><a href="../man8/lircd.8.html">lircd</a></b>(8), <b><a href="../man2/bpf.2.html">bpf</a></b>(2)

       https://www.kernel.org/doc/html/latest/userspace-api/media/rc/lirc-dev.html

Linux man-pages 6.9.1                              2024-05-02                                            <u><a href="../man4/lirc.4.html">lirc</a></u>(4)
</pre>
 </div>
</div></section>
</div>
</body>
</html>