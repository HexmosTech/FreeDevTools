<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>vec - distributed vector (rheolef-7.2)</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/librheolef-dev">librheolef-dev_7.2-3build6_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       vec - distributed vector (rheolef-7.2)

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This vector class supports both the sequential and the distributed memory model. In addition, standard
       linear algebra is supported.

</pre><h4><b>EXAMPLE</b></h4><pre>
           vec&lt;double&gt; x (100, 3.14);
           vec&lt;double&gt; y (100, 6.28);
           vec&lt;double&gt; z = 2.5*x + y;
           dout &lt;&lt; x &lt;&lt; endl;

</pre><h4><b>IMPLEMENTATION</b></h4><pre>
       This documentation has been generated from file linalg/lib/vec.h

       The vec class is a template class with both the floating type and the memory model as parameters. The
       implementation bases on the <b><a href="../man4/disarray.4.html">disarray</a>(4)</b> container.

       template &lt;class T, class M = rheo_default_memory_model&gt;
       class vec : public disarray&lt;T, M&gt; {
       public:

       // typedef:

           typedef disarray&lt;T, M&gt;                                   base;
           typedef T                                                value_type;
           typedef typename base::size_type                         size_type;
           typedef std::ptrdiff_t                                   difference_type;
           typedef range                                            range_type;
           typedef typename base::reference                         reference;
           typedef typename base::const_reference                   const_reference;
           typedef typename base::iterator                          iterator;
           typedef typename base::const_iterator                    const_iterator;
           typedef typename float_traits &lt;value_type&gt;::type         float_type;

       // allocator/deallocator:

           vec (const vec&lt;T,M&gt;&amp;);
           vec&lt;T,M&gt;&amp; operator= (const vec&lt;T,M&gt;&amp; x);

           vec (const distributor&amp; ownership,
               const T&amp;  init_val = std::numeric_limits&lt;T&gt;::max());

           vec (const std::initializer_list&lt;details::vec_concat_value&lt;T,M&gt; &gt;&amp; init_list);

           vec&lt;T,M&gt;&amp; operator= (const std::initializer_list&lt;details::vec_concat_value&lt;T,M&gt; &gt;&amp; init_list);
           vec(size_type dis_size = 0,
               const T&amp;  init_val = std::numeric_limits&lt;T&gt;::max());

           void resize (
               const distributor&amp; ownership,
               const T&amp;  init_val = std::numeric_limits&lt;T&gt;::max());

           void resize (
               size_type size = 0,
               const T&amp;  init_val = std::numeric_limits&lt;T&gt;::max());

       // accessors:

           const_reference operator[] (size_type i) const;
           reference       operator[] (size_type i);

           T min () const;
           T max () const;
           T max_abs () const;

           int constraint_process_rank() const;

       // range:

           vec(const vec_range&lt;T,M&gt;&amp; vr);
           vec(const vec_range_const&lt;T,M&gt;&amp; vr);
           vec&lt;T,M&gt;&amp; operator= (const vec_range&lt;T,M&gt;&amp; vr);
           vec&lt;T,M&gt;&amp; operator= (const vec_range_const&lt;T,M&gt;&amp; vr);

           vec_range_const&lt;T,M&gt; operator[] (const range_type&amp; r) const;
           vec_range&lt;T,M&gt;       operator[] (const range_type&amp; r);

       // assignment to a constant:

           vec&lt;T,M&gt;&amp; operator= (const int&amp; expr);
           vec&lt;T,M&gt;&amp; operator= (const T&amp; expr);

       // expression template:

           template &lt;class Expr,
                     class Sfinae
                         = typename std::enable_if&lt;
                                    details::is_vec_expr_v2_arg&lt;Expr&gt;::value
                               &amp;&amp; ! details::is_vec&lt;Expr&gt;::value
                           &gt;::type&gt;
           vec (const Expr&amp; expr);

           template &lt;class Expr,
                     class Sfinae
                         = typename std::enable_if&lt;
                                    details::is_vec_expr_v2_arg&lt;Expr&gt;::value
                               &amp;&amp; ! details::is_vec&lt;Expr&gt;::value
                           &gt;::type&gt;
           vec&lt;T, M&gt;&amp; operator=  (const Expr&amp; expr);
       };

</pre><h4><b>AUTHOR</b></h4><pre>
       Pierre  Saramito  &lt;<a href="mailto:Pierre.Saramito@imag.fr">Pierre.Saramito@imag.fr</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright   (C)  2000-2018  Pierre  Saramito  &lt;<a href="mailto:Pierre.Saramito@imag.fr">Pierre.Saramito@imag.fr</a>&gt; GPLv3+: GNU GPL version 3 or
       later  &lt;<a href="http://gnu.org/licenses/gpl.html">http://gnu.org/licenses/gpl.html</a>&gt;.  This  is  free  software:  you  are free to change and
       redistribute it.  There is NO WARRANTY, to the extent permitted by law.

rheolef                                            Version 7.2                                     <u><a href="../man4rheolef/vec.4rheolef.html">vec</a></u>(4rheolef)
</pre>
 </div>
</div></section>
</div>
</body>
</html>