<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>csr - distributed compressed sparse matrix (rheolef-7.2)</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/librheolef-dev">librheolef-dev_7.2-3build6_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       csr - distributed compressed sparse matrix (rheolef-7.2)

</pre><h4><b>DESCRIPTION</b></h4><pre>
       Sparse matrix are compressed by rows. In a distributed environment, the distribution follows the row
       <b><a href="../man4/distributor.4.html">distributor</a>(4)</b>.

</pre><h4><b>ALGEBRA</b></h4><pre>
       This class supports the standard linear algebra. Adding or subtracting two matrices simply writes a+b and
       a-b, respectively. Multiplying a matrix by a scalar writes lambda*a and the matrix-matrix product also
       writes a*b. Matrix-vector product expresses a*x where x is a vector described by the <b><a href="../man4/vec.4.html">vec</a>(4)</b> class.

       By extension, trans(a) returns the transpose. Multiplying a vector by the transpose matrix writes
       a.trans_mult(x) and do not requires to build the transpose matrix.

</pre><h4><b>IMPLEMENTATION</b></h4><pre>
       This documentation has been generated from file linalg/lib/csr.h

       The csr class is a template class with both the floating type and the memory model as parameters. Here is
       the interface for the sequential memory model. The distributed case presents a similar interface.

       template&lt;class T&gt;
       class csr&lt;T,sequential&gt; : public smart_pointer&lt;csr_rep&lt;T,sequential&gt; &gt; {
       public:

       // typedefs:

           typedef csr_rep&lt;T,sequential&gt;             rep;
           typedef smart_pointer&lt;rep&gt;                base;
           typedef typename rep::memory_type         memory_type;
           typedef typename rep::size_type           size_type;
           typedef typename rep::element_type        element_type;
           typedef typename rep::iterator            iterator;
           typedef typename rep::const_iterator      const_iterator;
           typedef typename rep::data_iterator       data_iterator;
           typedef typename rep::const_data_iterator const_data_iterator;

       // allocators/deallocators:

           csr() : base(new_macro(rep())) {}
           template&lt;class A&gt;
           explicit csr(const asr&lt;T,sequential,A&gt;&amp; a) : base(new_macro(rep(a))) {}
           void resize (size_type loc_nrow1 = 0, size_type loc_ncol1 = 0, size_type loc_nnz1 = 0)
               { base::data().resize(loc_nrow1, loc_ncol1, loc_nnz1); }
           void resize (const distributor&amp; row_ownership, const distributor&amp; col_ownership, size_type nnz1 = 0)
               { base::data().resize(row_ownership, col_ownership, nnz1); }

       // allocators from initializer list

           csr (const std::initializer_list&lt;details::csr_concat_value&lt;T,sequential&gt; &gt;&amp; init_list);
           csr (const std::initializer_list&lt;details::csr_concat_line&lt;T,sequential&gt; &gt;&amp;  init_list);

       // accessors:

           // global sizes
           const distributor&amp; row_ownership() const { return base::data().row_ownership(); }
           const distributor&amp; col_ownership() const { return base::data().col_ownership(); }
           size_type dis_nrow () const              { return row_ownership().dis_size(); }
           size_type dis_ncol () const              { return col_ownership().dis_size(); }
           size_type dis_nnz () const               { return base::data().nnz(); }
           size_type dis_ext_nnz () const           { return 0; }
           bool is_symmetric() const                { return base::data().is_symmetric(); }
           void set_symmetry (bool is_symm) const   { base::data().set_symmetry(is_symm); }
           void set_symmetry_by_check (const T&amp; tol = std::numeric_limits&lt;T&gt;::epsilon()) const
                                                    { base::data().set_symmetry_by_check(); }
           bool is_definite_positive() const        { return base::data().is_definite_positive(); }
           void set_definite_positive (bool is_defpos) const { base::data().set_definite_positive(is_defpos); }
           size_type pattern_dimension() const      { return base::data().pattern_dimension(); }
           void set_pattern_dimension(size_type dim) const { base::data().set_pattern_dimension(dim); }
           T max_abs () const                       { return base::data().max_abs(); }

           // local sizes
           size_type nrow () const                  { return base::data().nrow(); }
           size_type ncol () const                  { return base::data().ncol(); }
           size_type nnz () const                   { return base::data().nnz(); }

           // range on local memory
           size_type row_first_index () const       { return base::data().row_first_index(); }
           size_type row_last_index () const        { return base::data().row_last_index(); }
           size_type col_first_index () const       { return base::data().col_first_index(); }
           size_type col_last_index () const        { return base::data().col_last_index(); }

           const_iterator begin() const             { return base::data().begin(); }
           const_iterator end()   const             { return base::data().end(); }
           iterator begin_nonconst()                { return base::data().begin(); }
           iterator end_nonconst()                  { return base::data().end(); }

           // accessors, only for distributed (for interface compatibility)
           size_type ext_nnz() const                { return 0; }
           const_iterator ext_begin() const         { return const_iterator(); }
           const_iterator ext_end()   const         { return const_iterator(); }
                 iterator ext_begin_nonconst()      { return iterator(); }
                 iterator ext_end_nonconst()        { return iterator(); }
           size_type jext2dis_j (size_type jext) const { return 0; }

           int constraint_process_rank() const;

       // algebra:

           // y := a*x
           void mult (const vec&lt;element_type,sequential&gt;&amp; x, vec&lt;element_type,sequential&gt;&amp; y) const {
             base::data().mult (x,y);
           }
           vec&lt;element_type,sequential&gt; operator* (const vec&lt;element_type,sequential&gt;&amp; x) const {
             vec&lt;element_type,sequential&gt; y (row_ownership(), element_type());
             mult (x, y);
             return y;
           }
           void trans_mult (const vec&lt;element_type,sequential&gt;&amp; x, vec&lt;element_type,sequential&gt;&amp; y) const {
             base::data().trans_mult (x,y);
           }
           vec&lt;element_type,sequential&gt; trans_mult (const vec&lt;element_type,sequential&gt;&amp; x) const {
             vec&lt;element_type,sequential&gt; y (col_ownership(), element_type());
             trans_mult (x, y);
             return y;
           }
           // a+b, a-b, a*b
           csr&lt;T,sequential&gt; operator+ (const csr&lt;T,sequential&gt;&amp; b) const;
           csr&lt;T,sequential&gt; operator- (const csr&lt;T,sequential&gt;&amp; b) const;
           csr&lt;T,sequential&gt; operator* (const csr&lt;T,sequential&gt;&amp; b) const;

           // lambda*a
           csr&lt;T,sequential&gt;&amp; operator*= (const T&amp; lambda) {
             base::data().operator*= (lambda);
             return *this;
           }
       // output:

           void dump (const std::string&amp; name) const { base::data().dump(name); }
       };

</pre><h4><b>AUTHOR</b></h4><pre>
       Pierre  Saramito  &lt;<a href="mailto:Pierre.Saramito@imag.fr">Pierre.Saramito@imag.fr</a>&gt;

</pre><h4><b>COPYRIGHT</b></h4><pre>
       Copyright   (C)  2000-2018  Pierre  Saramito  &lt;<a href="mailto:Pierre.Saramito@imag.fr">Pierre.Saramito@imag.fr</a>&gt; GPLv3+: GNU GPL version 3 or
       later  &lt;<a href="http://gnu.org/licenses/gpl.html">http://gnu.org/licenses/gpl.html</a>&gt;.  This  is  free  software:  you  are free to change and
       redistribute it.  There is NO WARRANTY, to the extent permitted by law.

rheolef                                            Version 7.2                                     <u><a href="../man4rheolef/csr.4rheolef.html">csr</a></u>(4rheolef)
</pre>
 </div>
</div></section>
</div>
</body>
</html>