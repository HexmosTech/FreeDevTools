<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ng_btsocket — Bluetooth sockets layer</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ng_btsocket — Bluetooth sockets layer

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>#include</b> <b>&lt;sys/types.h&gt;</b>
       <b>#include</b> <b>&lt;sys/socket.h&gt;</b>
       <b>#include</b> <b>&lt;sys/bitstring.h&gt;</b>
       <b>#include</b> <b>&lt;netgraph/bluetooth/include/ng_hci.h&gt;</b>
       <b>#include</b> <b>&lt;netgraph/bluetooth/include/ng_l2cap.h&gt;</b>
       <b>#include</b> <b>&lt;netgraph/bluetooth/include/ng_btsocket.h&gt;</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <b>ng_btsocket</b>  module  implements  three  Netgraph  node  types.  Each type in its turn implements one
       protocol within PF_BLUETOOTH domain.
   SOCK_RAW HCI sockets
       Implemented by <b>btsock_hci_raw</b> Netgraph type.  Raw HCI sockets allow sending of raw HCI command  datagrams
       only  to  correspondents  named  in <u><a href="../man2/send.2.html">send</a></u>(2) calls.  Raw HCI datagrams (HCI commands, events and data) are
       generally received with <u><a href="../man2/recvfrom.2.html">recvfrom</a></u>(2), which returns the next datagram with its return  address.   Raw  HCI
       sockets can also be used to control HCI nodes.

       The Bluetooth raw HCI socket address is defined as follows:

             /* Bluetooth version of struct sockaddr for raw HCI sockets */
             struct sockaddr_hci {
                     u_char  hci_len;      /* total length */
                     u_char  hci_family;   /* address family */
                     char    hci_node[32]; /* address (size == NG_NODESIZ ) */
             };

       Raw HCI sockets support a number of <u><a href="../man2/ioctl.2.html">ioctl</a></u>(2) requests such as:

       SIOC_HCI_RAW_NODE_GET_STATE
            Returns current state for the HCI node.

       SIOC_HCI_RAW_NODE_INIT
            Turn on “inited” bit for the HCI node.

       SIOC_HCI_RAW_NODE_GET_DEBUG
            Returns current debug level for the HCI node.

       SIOC_HCI_RAW_NODE_SET_DEBUG
            Sets current debug level for the HCI node.

       SIOC_HCI_RAW_NODE_GET_BUFFER
            Returns current state of data buffers for the HCI node.

       SIOC_HCI_RAW_NODE_GET_BDADDR
            Returns BD_ADDR for the HCI node.

       SIOC_HCI_RAW_NODE_GET_FEATURES
            Returns the list of features supported by hardware for the HCI node.

       SIOC_HCI_RAW_NODE_GET_STAT
            Returns various statistic counters for the HCI node.

       SIOC_HCI_RAW_NODE_RESET_STAT
            Resets all statistic counters for the HCI node to zero.

       SIOC_HCI_RAW_NODE_FLUSH_NEIGHBOR_CACHE
            Remove all neighbor cache entries for the HCI node.

       SIOC_HCI_RAW_NODE_GET_NEIGHBOR_CACHE
            Returns content of the neighbor cache for the HCI node.

       SIOC_HCI_RAW_NODE_GET_CON_LIST
            Returns list of active baseband connections (i.e., ACL and SCO links) for the HCI node.

       SIOC_HCI_RAW_NODE_GET_LINK_POLICY_MASK
            Returns current link policy settings mask for the HCI node.

       SIOC_HCI_RAW_NODE_SET_LINK_POLICY_MASK
            Sets current link policy settings mask for the HCI node.

       SIOC_HCI_RAW_NODE_GET_PACKET_MASK
            Returns current packet mask for the HCI node.

       SIOC_HCI_RAW_NODE_SET_PACKET_MASK
            Sets current packet mask for the HCI node.

       SIOC_HCI_RAW_NODE_GET_ROLE_SWITCH
            Returns current value of the role switch parameter for the HCI node.

       SIOC_HCI_RAW_NODE_SET_ROLE_SWITCH
            Sets new value of the role switch parameter for the HCI node.

       The  <u>net.bluetooth.hci.sockets.raw.ioctl_timeout</u>  variable,  that  can be examined and set via <u><a href="../man8/sysctl.8.html">sysctl</a></u>(8),
       controls the control request timeout (in seconds) for raw HCI sockets.

       Raw HCI sockets support filters.  The application can filter certain HCI datagram types.  For  HCI  event
       datagrams the application can set additional filter.  The raw HCI socket filter defined as follows:

             /*
              * Raw HCI socket filter.
              *
              * For packet mask use (1 &lt;&lt; (HCI packet indicator - 1))
              * For event mask use (1 &lt;&lt; (Event - 1))
              */

             struct ng_btsocket_hci_raw_filter {
                     bitstr_t bit_decl(packet_mask, 32);
                     bitstr_t bit_decl(event_mask, (NG_HCI_EVENT_MASK_SIZE * 8));
             };

       The  SO_HCI_RAW_FILTER  option  defined  at  SOL_HCI_RAW level can be used to obtain via <u><a href="../man2/getsockopt.2.html">getsockopt</a></u>(2) or
       change via <u><a href="../man2/setsockopt.2.html">setsockopt</a></u>(2) raw HCI socket's filter.
       The Bluetooth L2CAP socket address is defined as follows:

             /* Bluetooth version of struct sockaddr for L2CAP sockets */
             struct sockaddr_l2cap {
                     u_char    l2cap_len;    /* total length */
                     u_char    l2cap_family; /* address family */
                     uint16_t  l2cap_psm;    /* Protocol/Service Multiplexor */
                     bdaddr_t  l2cap_bdaddr; /* address */
             };

   SOCK_RAW L2CAP sockets
       Implemented by <b>btsock_l2c_raw</b> Netgraph type.  Raw L2CAP sockets  do  not  provide  access  to  raw  L2CAP
       datagrams.   These  sockets  used  to  control  L2CAP  nodes  and to issue special L2CAP requests such as
       ECHO_REQUEST and GET_INFO request.

       Raw L2CAP sockets support number of <u><a href="../man2/ioctl.2.html">ioctl</a></u>(2) requests such as:

       SIOC_L2CAP_NODE_GET_FLAGS
            Returns current state for the L2CAP node.

       SIOC_L2CAP_NODE_GET_DEBUG
            Returns current debug level for the L2CAP node.

       SIOC_L2CAP_NODE_SET_DEBUG
            Sets current debug level for the L2CAP node.

       SIOC_L2CAP_NODE_GET_CON_LIST
            Returns list of active baseband connections (i.e., ACL links) for the L2CAP node.

       SIOC_L2CAP_NODE_GET_CHAN_LIST
            Returns list of active channels for the L2CAP node.

       SIOC_L2CAP_NODE_GET_AUTO_DISCON_TIMO
            Returns current value of the auto disconnect timeout for the L2CAP node.

       SIOC_L2CAP_NODE_SET_AUTO_DISCON_TIMO
            Sets current value of the auto disconnect timeout for the L2CAP node.

       SIOC_L2CAP_L2CA_PING
            Issues L2CAP ECHO_REQUEST.

       SIOC_L2CAP_L2CA_GET_INFO
            Issues L2CAP GET_INFO request.

       The <u>net.bluetooth.l2cap.sockets.raw.ioctl_timeout</u> variable, that can be examined and set  via  <u><a href="../man8/sysctl.8.html">sysctl</a></u>(8),
       controls the control request timeout (in seconds) for raw L2CAP sockets.

   SOCK_SEQPACKET L2CAP sockets
       Implemented by <b>btsock_l2c</b> Netgraph type.  L2CAP sockets are either “active” or “passive”.  Active sockets
       initiate  connections  to  passive  sockets.   By  default, L2CAP sockets are created active; to create a
       passive socket, the <u><a href="../man2/listen.2.html">listen</a></u>(2) system call must be used after binding the socket with the  <u><a href="../man2/bind.2.html">bind</a></u>(2)  system
       call.   Only  passive  sockets  may  use  the <u><a href="../man2/accept.2.html">accept</a></u>(2) call to accept incoming connections.  Only active
       sockets may use the <u><a href="../man2/connect.2.html">connect</a></u>(2) call to initiate connections.

       L2CAP sockets support “wildcard addressing”.  In this case, socket must  be  bound  to  NG_HCI_BDADDR_ANY
       address.   Note  that PSM (Protocol/Service Multiplexor) field is always required.  Once a connection has
       been established, the socket's address is fixed by the peer entity's location.  The address  assigned  to
       the  socket  is  the  address  associated  with  the  Bluetooth  device  through  which packets are being
       transmitted and received, and PSM (Protocol/Service Multiplexor).

       L2CAP sockets support number of options defined at SOL_L2CAP level which can be  set  with  <u><a href="../man2/setsockopt.2.html">setsockopt</a></u>(2)
       and tested with <u><a href="../man2/getsockopt.2.html">getsockopt</a></u>(2):

       SO_L2CAP_IMTU
            Get (set) maximum payload size the local socket is capable of accepting.

       SO_L2CAP_OMTU
            Get maximum payload size the remote socket is capable of accepting.

       SO_L2CAP_IFLOW
            Get incoming flow specification for the socket.  <u>Not</u> <u>implemented.</u>

       SO_L2CAP_OFLOW
            Get (set) outgoing flow specification for the socket.  <u>Not</u> <u>implemented.</u>

       SO_L2CAP_FLUSH
            Get (set) value of the flush timeout.  <u>Not</u> <u>implemented.</u>
       The Bluetooth RFCOMM socket address is defined as follows:

             /* Bluetooth version of struct sockaddr for RFCOMM sockets */
             struct sockaddr_rfcomm {
                     u_char   rfcomm_len;     /* total length */
                     u_char   rfcomm_family;  /* address family */
                     bdaddr_t rfcomm_bdaddr;  /* address */
                     uint8_t  rfcomm_channel; /* channel */
             };

   SOCK_STREAM RFCOMM sockets
       Note  that  RFCOMM  sockets do not have associated Netgraph node type.  RFCOMM sockets are implemented as
       additional layer on top of L2CAP sockets.  RFCOMM sockets  are  either  “active”  or  “passive”.   Active
       sockets  initiate  connections  to  passive  sockets.   By default, RFCOMM sockets are created active; to
       create a passive socket, the <u><a href="../man2/listen.2.html">listen</a></u>(2) system call must be used after binding the socket with the <u><a href="../man2/bind.2.html">bind</a></u>(2)
       system call.  Only passive sockets may use the <u><a href="../man2/accept.2.html">accept</a></u>(2)  call  to  accept  incoming  connections.   Only
       active sockets may use the <u><a href="../man2/connect.2.html">connect</a></u>(2) call to initiate connections.

       RFCOMM  sockets  support  “wildcard addressing”.  In this case, socket must be bound to NG_HCI_BDADDR_ANY
       address.  Note that RFCOMM channel field is always required.  Once a connection has been established, the
       socket's address is fixed by the peer entity's location.  The address  assigned  to  the  socket  is  the
       address  associated  with  the Bluetooth device through which packets are being transmitted and received,
       and RFCOMM channel.

       The following options, which can be tested with <u><a href="../man2/getsockopt.2.html">getsockopt</a></u>(2) call, are defined at SOL_RFCOMM  level  for
       RFCOMM sockets:

       SO_RFCOMM_MTU
            Returns  the  maximum  transfer  unit  size (in bytes) for the underlying RFCOMM channel.  Note that
            application still can write/read bigger chunks to/from the socket.

       SO_RFCOMM_FC_INFO
            Return the flow control information for the underlying RFCOMM channel.

       The <u>net.bluetooth.rfcomm.sockets.stream.timeout</u> variable, that can be examined  and  set  via  <u><a href="../man8/sysctl.8.html">sysctl</a></u>(8),
       controls the connection timeout (in seconds) for RFCOMM sockets.

</pre><h4><b>HOOKS</b></h4><pre>
       These  node  types support hooks with arbitrary names (as long as they are unique) and always accept hook
       connection requests.

</pre><h4><b>NETGRAPH</b> <b>CONTROL</b> <b>MESSAGES</b></h4><pre>
       These node types support the generic control messages.

</pre><h4><b>SHUTDOWN</b></h4><pre>
       These nodes are persistent and cannot be shut down.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man1/btsockstat.1.html">btsockstat</a></u>(1), <u><a href="../man2/socket.2.html">socket</a></u>(2), <u><a href="../man4/netgraph.4.html">netgraph</a></u>(4), <u><a href="../man4/ng_bluetooth.4.html">ng_bluetooth</a></u>(4), <u><a href="../man4/ng_hci.4.html">ng_hci</a></u>(4), <u><a href="../man4/ng_l2cap.4.html">ng_l2cap</a></u>(4), <u><a href="../man8/ngctl.8.html">ngctl</a></u>(8), <u><a href="../man8/sysctl.8.html">sysctl</a></u>(8)

</pre><h4><b>HISTORY</b></h4><pre>
       The <b>ng_btsocket</b> module was implemented in FreeBSD 5.0.

</pre><h4><b>AUTHORS</b></h4><pre>
       Maksim Yevmenkin &lt;<u><a href="mailto:m_evmenkin@yahoo.com">m_evmenkin@yahoo.com</a></u>&gt;

</pre><h4><b>BUGS</b></h4><pre>
       Most likely.  Please report if found.

Debian                                          November 13, 2012                                 <u><a href="../man4/NG_BTSOCKET.4.html">NG_BTSOCKET</a></u>(4)
</pre>
 </div>
</div></section>
</div>
</body>
</html>