<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>m-intf - InterFile 3.3 medical image format (MedCon)</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/libmdc-dev">libmdc-dev_0.24.0-gtk3+dfsg-2_amd64</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       m-intf - InterFile 3.3 medical image format (MedCon)

</pre><h4><b>DESCRIPTION</b></h4><pre>
  The  file consists of two parts, the administrative data in ASCII and the binary image data. It is possible to
  put both in one file, but we prefer to separate the data into two files. The administrative  data  in  a  file
  with extension `.h33' and the binary data in a file with extension `.i33'.

  This  is  a wonderful feature! Because of the separate header in ASCII you could write your own header for any
  raw image data you may have. I regularly use InterFile  for  turning  unsupported  formats  into  a  supported
  format.  Try  to  extract  the  raw  image data from the unknown format and add an appropriate header with all
  information you know about.

  The basic defines for the format:

  ---------------------------------------------------------------------------

  #define MDC_INTF_MAXKEYCHARS 256

  char keystr[MDC_INTF_MAXKEYCHARS];

  /* the  data type */
  #define MDC_INTF_STATIC      1
  #define MDC_INTF_DYNAMIC     2
  #define MDC_INTF_GATED       3
  #define MDC_INTF_TOMOGRAPH   4
  #define MDC_INTF_CURVE       5
  #define MDC_INTF_ROI         6

  /* the process status */
  #define MDC_INTF_ACQUIRED      1
  #define MDC_INTF_RECONSTRUCTED 2

  /* gated spect nesting outer level */
  #define MDC_INTF_NESTING_SPECT 1
  #define MDC_INTF_NESTING_GATED 2

  typedef struct MdcInterFile_t {

    int data_type, process_status, pixel_type, gspect_nesting;
    Uint32 width, height, images_per_dimension, time_slots;
    Uint32 data_offset, data_blocks, imagesize, number_images;
    Uint32 energy_windows, frame_groups, time_windows, detector_heads;
    float pixel_xsize, pixel_ysize, slice_thickness, centre_centre_separation;
    float study_duration, image_duration, image_pause, group_pause, ext_rot;
    Int8 patient_rot, patient_orient, slice_orient;
    double version;

  } MDC_INTERFILE;

  ---------------------------------------------------------------------------

  What does the format support or not support:

  ===========================================================================
  Item            Supported                             Not Supported
  ===========================================================================
  Color Map     : grayscale                                  -
  File Endian   : little or big                              -
  Pixeltypes    : 1-bit, all integers                        -
                  float, double, ASCII
  ===========================================================================
  Scaling factors  : quantify &amp; calibrate factors/image  are NOT supported,
                     unless you define your own key-value pairs
  ---------------------------------------------------------------------------
  Dimensions/Image : different dimensions for each image are supported
  ---------------------------------------------------------------------------
  Pixeltypes/Image : different pixeltypes for each image are supported, but
                     decoders are not required to be able to read.
                     MedCon does support different pixeltypes per image.
  ===========================================================================

  Underneath you will find a description of the format.

  1. ADMINISTRATIVE DATA
     ===================

       a)   The administrative data are only composed of key-value pairs and exist in the form  of  ASCII  text.
            The administrative data should be terminated with a &lt;Ctrl-Z).

       b)   All  administrative data are to be supplied in the form of key-value pairs in ASCII with delimiters.
            A `key' is the name of a parameter taking a specific `value', an example being:

                                      patient name := Elvis Presley &lt;cr&gt;&lt;lf&gt;

       c)   The maximum permitted number of characters for a key or a value or a comment is 255 characters.

       d)   Neither keys nor values  are  to  be  treated  as  case  sensitive.  The  characters  &lt;space&gt;  &lt;tab&gt;
            &lt;underscore&gt; &lt;!&gt; may all be treated as white space and ignored.

       e)   All  relevant keys should be included in the intermediate file. A null value is permitted which will
            invoke the default where specified. The required keys are preceded by an exclamation mark.

       f)   A hole line or key-value pairs may have comments appended to them by preceding the  comment  with  a
            semicolon &lt;;&gt;.

       g)   A required key ("name of data file") is included to point to the image data file, even if the binary
            data is in the same file of the administrative data.

       h)   The  two alternate keys ("data starting block") or ("data offset in bytes") are used to indicate the
            offset of the binary data in the file as specified by the key ("name  of  data  file").  The  ("data
            starting block")  represents the offset in number of blocks or 2048 bytes. The use of the key ("data
            offset in bytes") permits the offset to the binary data to be freely specified.

  2. IMAGE DATA
     ==========

       a)   The  order of the pixel data shall increment by column from left to right, and then by row, from top
            to bottom.

       b)   Image data shall be in either bit, signed or unsigned integer format,  IEEE  floating  point  format
            (float or double) or ASCII. When the data pixels are written in ASCII, the text line must not exceed
            255 characters.

       c)   The  default  value  for the key ("imagedata byte order") is BIGENDIAN, but LITTLEENDIAN is allowed.
            The byte order must be respected for integer and floating point numbers.

       d)   Bit data will stored in a single byte, representing 8 pixel values and ordered such  that  the  most
            significant bit corresponds to the leftmost pixel.

  3. LIST OF KEYS - VERSION 3.3    (Updated for Gated SPECT)
     ==========================

  !INTERFILE  := &lt;NULL&gt;
  ;to indicate that this is an Interfile file

  !imaging modality := &lt;ASCII&gt; nucmed
  ;only nucmed is defined for the purpose of this document

  !originating system := &lt;ASCII&gt;
  ;eg.GAMMA-11, MDS, ADAC, etc.

  !version of keys := &lt;Numeric&gt; 3.3
  ;future versions shall increment

  date of keys := &lt;DateFormat&gt; 1996:09:26
  ;date of version 3.3 in date format

  conversion program := &lt;ASCII&gt;
  ;name of program used

  program author := &lt;ASCII&gt;
  ;your chance of fame and fortune

  program version := &lt;Numeric&gt;
  ;to keep track of conversion programs

  program date := &lt;DateFormat&gt;
  ;date of program

  !GENERAL DATA := &lt;NULL&gt;
  ;required but can be treated as comment

  original institution := &lt;ASCII&gt;
  ;name of hospital etc.

  contact person := &lt;ASCII&gt;
  ;another chance of fame (and fortune?)

  data description := &lt;ASCII&gt;
  ;whatever you want

  !data starting block := &lt;Numeric&gt; 0
  ;the value is the offset in blocks of 2048 bytes in either the
  ;administrative or the data file depending on the key value for
  ;name of data file (see below)
  |      ;OR
  !data offset in bytes:= &lt;Numeric&gt; 0
  ;as above but the offset may be specified freely in bytes

  !name of data file := &lt;ASCII&gt; &lt;NULL&gt;
  ;&lt;NULL&gt; if no image data exists
  ;key is a name of the file where the data are present, either when
  ;in a separate binary data file, or when in a combined
  ;administrative/binary data file

  patient name := &lt;ASCII&gt;
  ;last name, first name (recommended)

  !patient ID := &lt;ASCII&gt;
  ;as used in your hospital

  patient dob := &lt;DateFormat&gt;
  ;date of birth

  patient sex := &lt;ASCIIlist&gt; Unknown M|F|Unknown
  ;default is Unknown!

  !study ID := &lt;ASCII&gt;
  ;as local conditions dictate

  exam type := &lt;ASCII&gt;
  ;description of procedure as above

  data compression := &lt;ASCII&gt; none
  ;name of algorithm if present- e.g. JPEG, etc.

  data encode := &lt;ASCII&gt; none
  ;name of method of encoding if present- e.g. uuencode etc.

  organ := &lt;ASCII&gt; none
  ;ENLF: for mapping with DICOM tag (0018,0015) BodyPartExamined

  isotope := &lt;ASCII&gt; | &lt;ASCII&gt;/&lt;ASCII&gt; none
  ;ENLF: for mapping with DICOM radionuclide/radiopharmaceutical entries.

  dose := &lt;Numeric&gt; 0
  ;ENLF: for mapping with DICOM tag (0018,1074) RadionuclideTotalDose [MBq]

  !GENERAL IMAGE DATA := &lt;NULL&gt;
  ;again required but treated as comment

  !type of data := &lt;ASCIIlist&gt;  Other
     Static|Dynamic|Gated|Tomographic|Curve|ROI|GSPECT|Other
  ;important - this key is used for many conditionals

  !total number of images := &lt;Numeric&gt;
  ;how many images are there altogether in total in the associated
  ;data file (for all windows etc.). This overrides any other way of
  ;calculating the total number of images.

  study date := &lt;DateFormat&gt;
  ;date of the first image included in the data file

  study time := &lt;TimeFormat&gt;
  ;time for the start of first image specified

  imagedata byte order := &lt;ASCIIlist&gt; BIGENDIAN
          BIGENDIAN|LITTLEENDIAN
  ;BIGENDIAN is the default if unspecified

  process label := &lt;ASCII&gt; none
  ;ENLF: for mapping with DICOM tag (0008,103E) SeriesDescription

  quantification units := +1.696265e-05
  ;ENLF: global scale factor for mediman dialect

  NUD/rescale slope := +1.696265e-05
  ;ENLF: global scale factor for NUD systems

  NUD/rescale intercept := +0.000000e+00
  ;ENLF: global scale intercept for NUD systems

  number of energy windows := &lt;Numeric&gt; 1
  ;defaulted to one if unspecified

  for ( number of energy windows, energy window)
  {
        energy window[&lt;energy window&gt;] := &lt;ASCII&gt;
        ;ASCII text- for example "Tc99m"
        ;this starts as "energy window [1]" and then increments to
        ;energy window[2]:= &lt;ASCII&gt;
        ;and then on to
        ;energy window[3]:= &lt;ASCII&gt;
        ;etc. etc.

        energy window lower level [&lt;energy window&gt;] := &lt;Numeric&gt;
        ;value of lower energy level in keV for the corresponding window
        ;starts off as "energy window lower level [1]"
        ;and continues [2],[3] .. as above

        energy window upper level [&lt;energy window&gt;] := &lt;Numeric&gt;
        ;value of upper energy level in keV for the corresponding window
        ;starts off as "energy window upper level [1]"
        ;and continues [2],[3] .. as above

        flood corrected := &lt;ASCIIlist&gt; Y Y|N
        ;corrected if unspecified

        decay corrected := &lt;ASCIIlist&gt; N Y|N
        ;not corrected if unspecified

        if( type of data = "Static"|"ROI")
        {
        !STATIC STUDY (General) := &lt;NULL&gt;
        ;label to indicate that this is the static definition

        number of images/energy window := &lt;Numeric&gt; 1
        ;number of images in THIS energy window

        for ( number of images/energy window )
        {
              !Static Study (each frame) := &lt;NULL&gt;
              ;included at the beginning of the definition of
              ;each new static frame

              !image number := &lt;Numeric&gt;
              ;starting from 1 [see above]
              ;- must be specified!!
              ;starts from 1 and increments though all
              ;windows to its maximum value which equals the
              ;total number of images in the file!!

              !matrix size [1] :=&lt; Numeric&gt;
              ;matrix size across (number of columns)- previously x
              ;32, 64, 128 etc. but not necessarily powers of 2

              !matrix size [2] := &lt;Numeric&gt;
              ;matrix size down (number of rows)- previously y
              ;32, 64, 128 etc. but not necessarily powers of 2

              !number format := &lt;ASCIIlist&gt; unsigned integer
                  signed integer|unsigned integer
                  |long float|short float|bit|ASCII
              ;as specified

              !number of bytes per pixel := &lt;Numeric&gt;
              ;e.g. 1|2|4.. [this key ignored for bit data]

              scaling factor (mm/pixel) [1]:= &lt;Numeric&gt;
              ;size of pixel across- previously x

              scaling factor (mm/pixel) [2] := &lt;Numeric&gt;
              ;size of pixel down- previously y

              image duration (sec) := &lt;Numeric&gt;
              ;eg. 120.0  i.e. normally a float, for each image

              image start time := &lt;TimeFormat&gt;
              ;time for each image

              label := &lt;ASCII&gt;
              ;eg Anterior

              maximum pixel count := &lt;Numeric&gt;
              ;for scaling purposes, for each image

              total counts := &lt;Numeric&gt;
              ;either an integer or a float, for each image

              }
              ;End of frame loop - Repeat for each subsequent frame
          }
          ;End of static definitions

          if( type of data = "Dynamic")
          {
              !DYNAMIC STUDY (general) := &lt;NULL&gt;
              ;label to indicate that this is a dynamic study

              !number of frame groups := &lt;Numeric&gt; 1
              ;defaults to 1

              for( number of frame groups, frame group number)
              {
                    !Dynamic Study (each frame group) := &lt;NULL&gt;
                    ;Repeated for each group of frames as

                    ;indication of  the start of the
                    ;definition of the new group

                    !frame group number := &lt;Numeric&gt;
                    ;numbering starts from 1 (must be specified)

                    !matrix size [1] := &lt;Numeric&gt;
                    ;matrix size across (number of columns)
                    ;-previously matrix size x
                    ;32, 64, 128 etc. but not necessarily powers of 2

                    !matrix size [2] := &lt;Numeric&gt;
                    ;matrix size down (number of rows)- previously y
                    ;32, 64, 128 etc. but not necessarily powers of 2

                    !number format := &lt;ASCIIlist&gt; unsigned integer
                       signed integer|unsigned integer|
                       long float|short float|bit|ASCII
                    ;as specified

                    !number of bytes per pixel := &lt;Numeric&gt;
                    ;e.g. 1|2|4.. [this key ignored for bit data]

                    scaling factor (mm/pixel) [1]:= &lt;Numeric&gt;
                    ;size of pixel across- previously x

                    scaling factor (mm/pixel) [2] := &lt;Numeric&gt;
                    ;size of pixel down- previously y

                    !number of images this frame group := &lt;Numeric&gt;
                    ;for each frame group
                    ;(for each energy window)

                    !image duration (sec) := &lt;Numeric&gt;
                    ;eg 0.2, for each frame group
                    ;(for each energy window)

                    pause between images (sec) := &lt;Numeric&gt; 0.0
                    ;eg 0.0, default is 0.0

                    pause between frame groups (sec) := &lt;Numeric&gt; 0.0
                    ;eg 5.0 default 0.0, time between last
                    ;frame group (or start of study) and this frame group

                    !maximum pixel count in group := &lt;Numeric&gt;
                    ;eg 1234 (for scaling purposes)
                    ;maximum pixel for all frames in this
                    ;group and this window!!

              }
              ;Repeat for each subsequent frame group
          }

          ; End of dynamic definitions

          if( type of data = "Gated")
          {
          !GATED STUDY (general) := &lt;NULL&gt;
          ;again a flag to indicate a gated study

          !matrix size [1] := &lt;Numeric&gt;
          ;matrix size across (number of columns)- previously x
          ;32, 64, 128 etc. but not necessarily powers of 2

          !matrix size [2] := &lt;Numeric&gt;
          ;matrix size down (number of rows)- previously y
          ;32, 64, 128 etc. but not necessarily powers of 2

          !number format := &lt;ASCIIlist&gt; unsigned integer
             signed integer|unsigned integer|
             long float|short float|bit|ASCII
          ;as specified

          !number of bytes per pixel := &lt;Numeric&gt;
          ;e.g. 1|2|4|..&gt; [this key ignored for bit data]

          scaling factor (mm/pixel) [1]:= &lt;Numeric&gt;
          ;size of pixel across- previously x

          scaling factor (mm/pixel) [2] := &lt;Numeric&gt;
          ;size of pixel down- previously y

          study duration (elapsed) sec := &lt;Numeric&gt;
          ;eg 300, total elapsed time for whole study

          number of cardiac cycles (observed) := &lt;Numeric&gt;
          ;total number of cycles if known, for this
          ;energy window

          number of time windows := &lt;Numeric&gt; 1
          ;defaults to 1 if unspecified- number of different
          ;sets of time intervals

          for ( number of time windows, time window number)
          {
              !Gated Study (each time window) := &lt;NULL&gt;

              !time window number := &lt;Numeric&gt;
              ;starting from 1

              !number of images in time window := &lt;Numeric&gt;
              ;eg 24

              !image duration (sec) := &lt;Numeric&gt;
              ;eg 0.04  for each frame in THIS time window

              framing method := &lt;ASCIIlist&gt; Forward
                      Forward|Backward|Mixed|Other
              ;default is forward

              time window lower limit (sec) := &lt;Numeric&gt;
              ;float normally expected, for THIS time window

              time window upper limit (sec) := &lt;Numeric&gt;
              ;float normally expected

              % R-R cycles acquired this window := &lt;Numeric&gt;
              ;if known

              number of cardiac cycles (acquired) := &lt;Numeric&gt;
              ;eg 356 , if known

              study duration (acquired) sec := &lt;Numeric&gt;
              ;total  acquisition time duration for
              ;this window only (if it can be computed!!) as
              ;opposed to total acquisition time (when different)

              !maximum pixel count := &lt;Numeric&gt;
              ;for scaling purposes for all images in this
              ;time window (and energy window) only

              R-R histogram := &lt;ASCIIlist&gt; N Y|N
              ;flag to indicate that one exists!!

              }
              ;Repeat for each subsequent time window.

          }
          ;end of gated definitions

          if( type of data = "Tomographic")
          {

          !SPECT STUDY (general) := &lt;NULL&gt;
          ;flag to indicate tomographic data with no effect as such

          number of detector heads := &lt;Numeric&gt; 1
          ;default=1 if unspecified

          for ( number of detector heads )
          {

              !number of images/energy window := &lt;Numeric&gt;
              ;total number of images (for all heads) for
              ;THIS energy window!!

              !process status := Reconstructed Acquired|Reconstructed
              ;used below in conditional- MUST be defined

              !matrix size [1] := &lt;Numeric&gt;
              ;matrix size across (number of columns)- previously x
              ;32, 64, 128 etc. but not necessarily powers of 2

              !matrix size [2] := &lt;Numeric&gt;
              ;matrix size down (number of rows)- previously y
              ;32, 64, 128 etc. but not necessarily powers of 2

              !number format := &lt;ASCIIlist&gt; unsigned integer
                 signed integer|unsigned integer|
                 long float|short float|bit|ASCII
              ;as specified

              !number of bytes per pixel := &lt;Numeric&gt;
              ;e.g. 1|2|4|.. [this key ignored for bit data]

              scaling factor (mm/pixel) [1]:= &lt;Numeric&gt;
              ;size of pixel across- previously x

              scaling factor (mm/pixel) [2] := &lt;Numeric&gt;
              ;size of pixel down- previously y

              !number of projections := &lt;Numeric&gt;
              ;for example- 64
              ;note this is the actual number of images per
              ;head per energy window if
              ;the data are acquired, but NOT if the data are
              ;reconstructed where the number of images is
              ;specified separately as number of slices

              !extent of rotation := &lt;Numeric&gt;
              ;e.g 180, 360

              !time per projection (sec) := &lt;Numeric&gt;
              ;important for Acquired data

              study duration (sec) := &lt;Numeric&gt;
              ;eg 1280.0, for acquired data should be equal
              ;to the product of number of projections and
              ;time per projection, but could be different!!

              !maximum pixel count := &lt;Numeric&gt;
              ;for scaling- in THIS image series( this head
              ;and this energy window)

              patient orientation := &lt;ASCIIlist&gt; head_in
                   head_in|feet_in|other

              patient rotation :=  &lt;ASCIIlist&gt; supine
                   prone|supine|other

              if( process status = "acquired")
              {
                 !SPECT STUDY (acquired data):= &lt;NULL&gt;

                 !direction of rotation := &lt;ASCIIlist&gt; CW CW|CCW
                 ;CW = clockwise, CCW = counter clockwise

                 start angle := &lt;Numeric&gt;
                 ;0 is top-dead-centre, in degrees
                 ;in orientation as specified above

                 first projection angle in data set := &lt;Numeric&gt;
                 ;in degrees expressed with respect to
                 ;anterior-  angles in direction as
                 ;specified CW or CCW

                 acquisition mode := &lt;ASCIIlist&gt; stepped
                 stepped|continuous

                 Centre_of_rotation :=  &lt;ASCIIlist&gt; Corrected
                 Corrected|Single_value|For_every_angle
                 ;default is "Corrected"
                 ;"Corrected" corresponds to a null centre of rotation
                 ;correction, as previous required by Interfile, that
                 ;is, no centre of rotation information is to be
                 ;passed. The key "Single value" indicates the
                 ;conventional definition of the centre of rotation
                 ;offset to be a single value specified for all angles,
                 ;specified for each head given a multiple head
                 ;acquisition.
                 ;The key "For_every_angle" indicates that the centre
                 ;of rotation offset will be  specified for each head
                 ;and every angle. This is not currently implemented in
                 ;this Interfile definition, but will be introduced in
                 ;V4.
                 ;The mathematical centre of rotation is assumed to be
                 ;in the exact middle of the projection for example at
                 ;x= 32.5 y=32.5 for a 64x64 image where the count
                 ;starts from 1. Note that the choice of coordinates
                 ;does not matter, the only constraint being the
                 ;assumption that all projections have a length which
                 ;is an even number of pixels. The centre of rotation
                 ;is specified as the offset from that position to the
                 ;perpendicular dropped from a point on the axis of
                 ;rotation onto the head.

             if( Centre_of_rotation = "Single_value" )
             {

                 !X_offset := &lt;Numeric&gt;
                 ;x offset for all angles in mm.
                 ;x_offset is the x offset between the perpendicular
                 ;dropped from the centre of rotation and the dead
                 ;centre of the matrix,
                 ;The positive direction for the offset is considered
                 ;to be that of the increasing projection index, e.g.
                 ;for a projection with pixels of size 6mm, which
                 ;should be centred at 32.5, an offset of +6mm
                 ;indicates that the centre of rotation is at 33.5
                 ;Note that since offset is specified in mm, the pixel
                 ;size must be known.

                 Y_offset := &lt;Numeric&gt;
                 ;y offset for all angles in mm
                 ;y_offset is the y offset between that perpendicular
                 ;dropped from the centre of rotation from that point
                 ;on the axis of rotation where the y_offset is
                 ;considered to be zero, and the centre of the camera's
                 ;field of view. Thus y_offset is the RELATIVE shift of
                 ;the y-axis with respect to some arbitrary position,
                 ;normally that from the centre of the filed of view of
                 ;the first at the top dead centre position. Thus for
                 ;a single head, this value would normally be expected
                 ;to be equal to zero.

                 Radius := &lt;Numeric&gt;
                 ;radial distance to centre of rotation in mm,
                 ;for this head.

                 }
                 ;end of centre of rotation specification

                 orbit := &lt;ASCIIlist&gt; Circular Circular|non-circular

                 preprocessed := &lt;ASCII&gt;
                 ;preprocessing method

              }
              ; end of process status acquired

              if( process status = "reconstructed")
              {
                 !SPECT STUDY (reconstructed data) := &lt;NULL&gt;

                 method of reconstruction := &lt;ASCII&gt;

                 !number of slices := &lt;Numeric&gt;
                 ;i.e. number of images in this set for this
                 ;head and this energy window

                 number of reference frame := &lt;Numeric&gt; 0
                 ;if unspecified the frame number
                 ;originally used for defining slice positions
                 ;0=default [Note- not a very useful key]

                 slice orientation := &lt;ASCIIlist&gt; Transverse
                     Transverse|Coronal|Sagittal|Other
                 ;default is transverse if unspecified

                 slice thickness (pixels) := &lt;Numeric&gt; 1
                 ;if unspecified 1=default

                 centre-centre slice separation (pixels):=&lt;Numeric&gt; 1
                 ;e.g.1,2,3,4...  as distinct from slice thickness
                 ;the word centre can also be spelt as center

                 filter name :=  &lt;ASCII&gt;
                 ;e.g. Hann, Hamming, Butterworth

                 filter parameters := &lt;ASCII&gt;
                 ;Nyquist freq etc.

                 z-axis filter := &lt;ASCII&gt;
                 ;method [1,2,1] etc.

                 attenuation correction coefficient/cm := &lt;Numeric&gt; 0.0
                 ;default 0 means not done if unspecified

                 method of attenuation correction :=  &lt;ASCII&gt;  none

                 scatter corrected := &lt;ASCIIlist&gt; N Y|N

                 method of scatter correction := &lt;ASCII&gt; none

                 oblique reconstruction := &lt;ASCIIlist&gt; N Y|N

                 oblique orientation := &lt;ASCII&gt;
                 ;free text [Note ACR-NEMA convention preferred]
              }
              ;end of reconstructed tomo
         }
        ;End of tomo

  *      if( type of data = "GSPECT")
         {
  *      !GATED SPECT STUDY (general) := &lt;NULL&gt;
         ;again a flag to indicate a gated SPECT study
         ;MIXTURE OF GATED &amp; TOMO

         !matrix size [1] := &lt;Numeric&gt;
         ;matrix size across (number of columns)- previously x
         ;32, 64, 128 etc. but not necessarily powers of 2

         !matrix size [2] := &lt;Numeric&gt;
         ;matrix size down (number of rows)- previously y
         ;32, 64, 128 etc. but not necessarily powers of 2

         !number format := &lt;ASCIIlist&gt; unsigned integer
          signed integer|unsigned integer|
          long float|short float|bit|ASCII
         ;as specified

         !number of bytes per pixel := &lt;Numeric&gt;
         ;e.g. 1|2|4|..&gt; [this key ignored for bit data]

         !Gated SPECT nesting outer level := SPECT|Gated  Gated
         ; key to indictae order of images, if SPECT is outer level
         ; order is, for every angle give each gated image, if
         ; gated is outer level, then order is, for every gated
         ; time value, vie set of tomographic images

         scaling factor (mm/pixel) [1]:= &lt;Numeric&gt;
         ;size of pixel across- previously x

         scaling factor (mm/pixel) [2] := &lt;Numeric&gt;
         ;size of pixel down- previously y

         study duration (elapsed) sec := &lt;Numeric&gt;
         ;eg 300, total elapsed time for whole study

         number of cardiac cycles (observed) := &lt;Numeric&gt;
         ;total number of cycles if known, for this
         ;energy window

         number of time windows := &lt;Numeric&gt; 1
         ;defaults to 1 if unspecified- number of different
         ;sets of time intervals

         for ( number of time windows, time window number)
         {
              !Gated Study (each time window) := &lt;NULL&gt;

              !time window number := &lt;Numeric&gt;
              ;starting from 1

  *           !number of images in time window := &lt;Numeric&gt;
              ;eg 24 NOTE that here in gated SPECT is means images/angle

              !image duration (sec) := &lt;Numeric&gt;
              ;eg 0.04  for each frame in THIS time window

              framing method := &lt;ASCIIlist&gt; Forward
                      Forward|Backward|Mixed|Other
              ;default is forward

              time window lower limit (sec) := &lt;Numeric&gt;
              ;float normally expected, for THIS time window

              time window upper limit (sec) := &lt;Numeric&gt;
              ;float normally expected

              % R-R cycles acquired this window := &lt;Numeric&gt;
              ;if known

              number of cardiac cycles (acquired) := &lt;Numeric&gt;
              ;eg 356 , if known

              study duration (acquired) sec := &lt;Numeric&gt;
              ;total  acquisition time duration for
              ;this window only (if it can be computed!!) as
              ;opposed to total acquisition time (when different)

              !maximum pixel count := &lt;Numeric&gt;
              ;for scaling purposes for all images in this
              ;time window (and energy window) only

              R-R histogram := &lt;ASCIIlist&gt; N Y|N
              ;flag to indicate that one exists!!

          }
          ;Repeat for each subsequent time window.

       ;start of tomographic keys

          number of detector heads := &lt;Numeric&gt; 1
          ;default=1 if unspecified

          for ( number of detector heads )
          {

              !number of images/energy window := &lt;Numeric&gt;
              ;total number of images (for all heads) for
              ;THIS energy window!!

              !process status := Reconstructed Acquired|Reconstructed
              ;used below in conditional- MUST be defined

              !number of projections := &lt;Numeric&gt;
              ;for example- 64
              ;note this is the actual number of images per
              ;head per energy window if
              ;the data are acquired, but NOT if the data are
              ;reconstructed where the number of images is
              ;specified separately as number of slices

              !extent of rotation := &lt;Numeric&gt;
              ;e.g 180, 360

              !time per projection (sec) := &lt;Numeric&gt;
              ;important for Acquired data
              patient orientation := &lt;ASCIIlist&gt; head_in
                     head_in|feet_in|other

              patient rotation :=  &lt;ASCIIlist&gt; supine
                     prone|supine|other

              if( process status = "acquired")
              {
                 !SPECT STUDY (acquired data):= &lt;NULL&gt;

                 !direction of rotation := &lt;ASCIIlist&gt; CW CW|CCW
                 ;CW = clockwise, CCW = counter clockwise

                 start angle := &lt;Numeric&gt;
                 ;0 is top-dead-centre, in degrees
                 ;in orientation as specified above

                 first projection angle in data set := &lt;Numeric&gt;
                 ;in degrees expressed with respect to
                 ;anterior-  angles in direction as
                 ;specified CW or CCW

                 acquisition mode := &lt;ASCIIlist&gt; stepped
                      stepped|continuous

                Centre_of_rotation :=  &lt;ASCIIlist&gt; Corrected
                     Corrected|Single_value|For_every_angle
                ;default is "Corrected"
                ;"Corrected" corresponds to a null centre of rotation
                ;correction, as previous required by Interfile, that
                ;is, no centre of rotation information is to be
                ;passed. The key "Single value" indicates the
                ;conventional definition of the centre of rotation
                ;offset to be a single value specified for all angles,
                ;specified for each head given a multiple head
                ;acquisition.
                ;The key "For_every_angle" indicates that the centre
                ;of rotation offset will be  specified for each head
                ;and every angle. This is not currently implemented in
                ;this Interfile definition, but will be introduced in
                ;V4.
                ;The mathematical centre of rotation is assumed to be
                ;in the exact middle of the projection for example at
                ;x= 32.5 y=32.5 for a 64x64 image where the count
                ;starts from 1. Note that the choice of coordinates
                ;does not matter, the only constraint being the
                ;assumption that all projections have a length which
                ;is an even number of pixels. The centre of rotation
                ;is specified as the offset from that position to the
                ;perpendicular dropped from a point on the axis of
                ;rotation onto the head.

                if( Centre_of_rotation = "Single_value" )
                {

                 !X_offset := &lt;Numeric&gt;
                 ;x offset for all angles in mm.
                ;x_offset is the x offset between the perpendicular
                ;dropped from the centre of rotation and the dead
                ;centre of the matrix,
                ;The positive direction for the offset is considered
                ;to be that of the increasing projection index, e.g.
                ;for a projection with pixels of size 6mm, which
                ;should be centred at 32.5, an offset of +6mm
                ;indicates that the centre of rotation is at 33.5
                ;Note that since offset is specified in mm, the pixel
                ;size must be known.

                 Y_offset := &lt;Numeric&gt;
                 ;y offset for all angles in mm
                ;y_offset is the y offset between that perpendicular
                ;dropped from the centre of rotation from that point
                ;on the axis of rotation where the y_offset is
                ;considered to be zero, and the centre of the camera's
                ;field of view. Thus y_offset is the RELATIVE shift of
                ;the y-axis with respect to some arbitrary position,
                ;normally that from the centre of the filed of view of
                ;the first at the top dead centre position. Thus for
                ;a single head, this value would normally be expected
                ;to be equal to zero.

                 Radius := &lt;Numeric&gt;
                 ;radial distance to centre of rotation in mm,
                ;for this head.

                 }
                ;end of centre of rotation specification

                 orbit := &lt;ASCIIlist&gt; Circular Circular|non-circular

                 preprocessed := &lt;ASCII&gt;
                 ;preprocessing method
              }
              ; end of process status acquired

              if( process status = "reconstructed")
              {
                 !SPECT STUDY (reconstructed data) := &lt;NULL&gt;

                 method of reconstruction := &lt;ASCII&gt;

                 !number of slices := &lt;Numeric&gt;
                 ;i.e. number of images in this set for this
                 ;head and this energy window

                 number of reference frame := &lt;Numeric&gt; 0
                 ;if unspecified the frame number
                 ;originally used for defining slice positions
                 ;0=default [Note- not a very useful key]

                 slice orientation := &lt;ASCIIlist&gt; Transverse
                     Transverse|Coronal|Sagittal|Other
                 ;default is transverse if unspecified

                 slice thickness (pixels) := &lt;Numeric&gt; 1
                 ;if unspecified 1=default

                 centre-centre slice separation (pixels):=&lt;Numeric&gt; 1
                 ;e.g.1,2,3,4...  as distinct from slice thickness
                 ;the word centre can also be spelt as center

                 filter name :=  &lt;ASCII&gt;
                 ;e.g. Hann, Hamming, Butterworth

                 filter parameters := &lt;ASCII&gt;
                 ;Nyquist freq etc.

                 z-axis filter := &lt;ASCII&gt;
                 ;method [1,2,1] etc.

                 attenuation correction coefficient/cm := &lt;Numeric&gt; 0.0
                 ;default 0 means not done if unspecified

                 method of attenuation correction :=  &lt;ASCII&gt;  none

                 scatter corrected := &lt;ASCIIlist&gt; N Y|N

                 method of scatter correction := &lt;ASCII&gt; none

                 oblique reconstruction := &lt;ASCIIlist&gt; N Y|N

                 oblique orientation := &lt;ASCII&gt;
                 ;free text [Note ACR-NEMA convention preferred]
              }
              ;end of reconstructed tomo
         }
        ;End of GATED SPECT

  }
  ;end of loop for energy windows

  if( type of data = "Curve")
        {
         !CURVE DATA := &lt;NULL&gt;
         ;label to indicate that this is the curve definition
         ;curves should always be kept in separate data files
         ;and not together with the administrative data

         Curve_dimensions := &lt;Numeric&gt; 2
         ;how many dimensions- ONLY 2 is permitted in V3.3.
         ;Even if a single vector of values is required
         ;both matrix size[1] and [2] must be defined
         ;although one of them should take the value 1.
         ;A set of x,y values is 2 dimensional with normally
         ;matrix size[1] or matrix size[2] equal to 2.
         ;and the other matrix size specifying
         ;the number of PAIRS of values present (see Fig 1).
         ;Matrix sizes greater than 2 for BOTH dimensions are not
         ;recommended.

         !matrix size[1] := &lt;Numeric&gt;
         ;matrix size across (number of columns)

         !matrix size[2] := &lt;Numeric&gt;
         ;matrix size down (number of rows)

         !number format := &lt;ASCIIlist&gt; unsigned integer
             signed integer|unsigned integer|
             long float|short float|bit|ASCII

         !number of bytes per pixel := &lt;Numeric&gt;
         ;e.g. 1|2|4|.. [this key ignored for bit data]

         Type_of_curve :=  &lt;ASCII&gt;
         ;what kind of curve is it, for example time activity curve
         ;ROI indicates that this is a list
         ;of vectors corresponding to an ROI.

         for( Curve_dimensions, dimension)
         {

            ;When matrix size[1] or matrix size[2] equals 2 (the normal
            ;case) such that the data comprise pairs of values,
            ;then Label[1],  Units[1] etc. refers to the set of first
            ;values for each pair, and Label[2] etc. refers the set of
            ;second values for each pair.

            Label[&lt;dimension&gt;] :=  &lt;ASCII&gt;
            ;a text label for the corresponding axis  e.g. "counts"

            Units[&lt;dimension&gt;] := &lt;ASCII&gt;
            ;units of measurement for the corresponding axis
            ;e.g. "units[1]:=counts/sec"

            Min[&lt;dimension&gt;] := &lt;Numeric&gt;
            ;Minimum of set of values as indicated in units as defined,
            ;optional

            Max[&lt;dimension&gt;] := &lt;Numeric&gt;
            ;Maximum value as above, optional

        }
       ;End of loop for curve dimensions

  }
  !END OF INTERFILE := &lt;NULL&gt;

</pre><h4><b>FILES</b></h4><pre>
  /usr/local/xmedcon/source/m-intf.h      The header file.
  /usr/local/xmedcon/source/m-intf.c      The source file.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
  <a href="../man1/medcon.1.html">medcon</a>(1), <a href="../man1/xmedcon.1.html">xmedcon</a>(1), <a href="../man1/xmedcon-config.1.html">xmedcon-config</a>(1)

  <a href="../man4/m-acr.4.html">m-acr</a>(4), <a href="../man4/m-anlz.4.html">m-anlz</a>(4), <a href="../man5/m-gif.5.html">m-gif</a>(5), <a href="../man4/m-inw.4.html">m-inw</a>(4), <a href="../man4/m-ecat.4.html">m-ecat</a>(4)

  <a href="../man3/medcon.3.html">medcon</a>(3)

</pre><h4><b>AUTHOR</b></h4><pre>
  <u>(X)MedCon</u>  project  was  originally  written by Erik Nolf (eNlf) for the former PET-Centre at Ghent University
  (Belgium).

  <b>e-mail:</b>   enlf-at-users.sourceforge.net   <b>www:</b>   <a href="http://xmedcon.sourceforge.net">http://xmedcon.sourceforge.net</a>

                                                                                                       <u><a href="../man4/M-INTF.4.html">M-INTF</a></u>(4)
</pre>
 </div>
</div></section>
</div>
</body>
</html>