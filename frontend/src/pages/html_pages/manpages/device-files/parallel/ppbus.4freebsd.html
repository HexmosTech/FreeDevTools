<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ppbus — Parallel Port Bus system</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/freebsd-manpages">freebsd-manpages_12.2-2_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       ppbus — Parallel Port Bus system

</pre><h4><b>SYNOPSIS</b></h4><pre>
       <b>device</b> <b>ppbus</b>

       <b>device</b> <b>vpo</b>

       <b>device</b> <b>lpt</b>
       <b>device</b> <b>plip</b>
       <b>device</b> <b>ppi</b>
       <b>device</b> <b>pps</b>
       <b>device</b> <b>lpbb</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       The  <u>ppbus</u>  system provides a uniform, modular and architecture-independent system for the implementation
       of drivers to control various parallel devices, and to utilize different parallel port chipsets.

</pre><h4><b>DEVICE</b> <b>DRIVERS</b></h4><pre>
       In order to write new drivers  or  port  existing  drivers,  the  ppbus  system  provides  the  following
       facilities:

             <b>•</b>   architecture-independent macros or functions to access parallel ports

             <b>•</b>   mechanism to allow various devices to share the same parallel port

             <b>•</b>   a  user interface named <u><a href="../man4/ppi.4.html">ppi</a></u>(4) that allows parallel port access from outside the kernel without
                 conflicting with kernel-in drivers.

   <b>Developing</b> <b>new</b> <b>drivers</b>
       The ppbus system has been designed to support the development of standard and non-standard software:

       <u>Driver</u>    <u>Description</u>
       <b>vpo</b>       VPI0 parallel to Adaptec AIC-7110 SCSI controller driver.  It uses  standard  and  non-standard
                 parallel port accesses.
       <b>ppi</b>       Parallel port interface for general I/O
       <b>pps</b>       Pulse per second Timing Interface
       <b>lpbb</b>      Philips official parallel port I2C bit-banging interface

   <b>Porting</b> <b>existing</b> <b>drivers</b>
       Another  approach  to  the  ppbus  system is to port existing drivers.  Various drivers have already been
       ported:

       <u>Driver</u>    <u>Description</u>
       <b>lpt</b>       lpt printer driver
       <b>plip</b>      lp parallel network interface driver

       ppbus should let you port any other software even from  other  operating  systems  that  provide  similar
       services.

</pre><h4><b>PARALLEL</b> <b>PORT</b> <b>CHIPSETS</b></h4><pre>
       Parallel port chipset support is provided by <u><a href="../man4/ppc.4.html">ppc</a></u>(4).

       The  ppbus  system  provides functions and macros to allocate a new parallel port bus, then initialize it
       and upper peripheral device drivers.

       ppc makes chipset detection and initialization and then calls ppbus attach functions  to  initialize  the
       ppbus system.

</pre><h4><b>PARALLEL</b> <b>PORT</b> <b>MODEL</b></h4><pre>
       The  logical  parallel  port  model  chosen  for  the  ppbus  system  is  the  PC's  parallel port model.
       Consequently, for the i386 implementation of ppbus, most of the services provided by ppc are  macros  for
       inb()  and outb() calls.  But, for an other architecture, accesses to one of our logical registers (data,
       status, control...) may require more than one I/O access.

   <b>Description</b>
       The parallel port may operate in the following modes:

             <b>•</b>   compatible mode, also called Centronics mode

             <b>•</b>   bidirectional 8/4-bits mode, also called NIBBLE mode

             <b>•</b>   byte mode, also called PS/2 mode

             <b>•</b>   Extended Capability Port mode, ECP

             <b>•</b>   Enhanced Parallel Port mode, EPP

             <b>•</b>   mixed ECP+EPP or ECP+PS/2 modes

   <b>Compatible</b> <b>mode</b>
       This mode defines the protocol used by most PCs to transfer data to a printer.  In  this  mode,  data  is
       placed on the port's data lines, the printer status is checked for no errors and that it is not busy, and
       then a data Strobe is generated by the software to clock the data to the printer.

       Many  I/O  controllers  have  implemented  a  mode  that  uses  a  FIFO  buffer to transfer data with the
       Compatibility mode protocol.  This mode is referred to as "Fast Centronics" or "Parallel Port FIFO mode".

   <b>Bidirectional</b> <b>mode</b>
       The NIBBLE mode is the most common way to  get  reverse  channel  data  from  a  printer  or  peripheral.
       Combined with the standard host to printer mode, it provides a complete bidirectional channel.

       In  this mode, outputs are 8-bits long.  Inputs are accomplished by reading 4 of the 8 bits of the status
       register.

   <b>Byte</b> <b>mode</b>
       In this mode, the data register is used either for outputs and inputs.   Then,  any  transfer  is  8-bits
       long.

   <b>Extended</b> <b>Capability</b> <b>Port</b> <b>mode</b>
       The  ECP  protocol  was  proposed  as  an  advanced  mode for communication with printer and scanner type
       peripherals.  Like the EPP protocol, ECP mode provides for a high performance bidirectional communication
       path between the host adapter and the peripheral.

       ECP protocol features include:

             Run_Length_Encoding (RLE) data compression for host adapters

             FIFOs for both the forward and reverse channels

             DMA as well as programmed I/O for the host register interface.

   <b>Enhanced</b> <b>Parallel</b> <b>Port</b> <b>mode</b>
       The EPP protocol was originally developed as a means to provide a high  performance  parallel  port  link
       that would still be compatible with the standard parallel port.

       The  EPP  mode  has two types of cycle: address and data.  What makes the difference at hardware level is
       the strobe of the byte placed on the data lines.  Data are strobed with nAutofeed, addresses are  strobed
       with nSelectin signals.

       A  particularity of the ISA implementation of the EPP protocol is that an EPP cycle fits in an ISA cycle.
       In this fashion, parallel port peripherals can operate at close to the  same  performance  levels  as  an
       equivalent ISA plug-in card.

       At  software  level,  you may implement the protocol you wish, using data and address cycles as you want.
       This is for the IEEE1284 compatible part.  Then, peripheral vendors may implement protocol handshake with
       the following status lines: PError, nFault and Select.  Try to know how  these  lines  toggle  with  your
       peripheral, allowing the peripheral to request more data, stop the transfer and so on.

       At  any  time,  the peripheral may interrupt the host with the nAck signal without disturbing the current
       transfer.

   <b>Mixed</b> <b>modes</b>
       Some manufacturers, like SMC, have implemented chipsets that support mixed modes.   With  such  chipsets,
       mode switching is available at any time by accessing the extended control register.

</pre><h4><b>IEEE1284-1994</b> <b>Standard</b></h4><pre>
   <b>Background</b>
       This  standard  is  also  named  "IEEE  Standard Signaling Method for a Bidirectional Parallel Peripheral
       Interface for Personal Computers".  It defines a signaling method for  asynchronous,  fully  interlocked,
       bidirectional parallel communications between hosts and printers or other peripherals.  It also specifies
       a format for a peripheral identification string and a method of returning this string to the host outside
       of the bidirectional data stream.

       This  standard  is  architecture  independent  and  only specifies dialog handshake at signal level.  One
       should refer to architecture specific documentation in order to manipulate machine  dependent  registers,
       mapped memory or other methods to control these signals.

       The  IEEE1284  protocol  is  fully oriented with all supported parallel port modes.  The computer acts as
       master and the peripheral as slave.

       Any transfer is defined as a finite state automaton.  It allows software to  properly  manage  the  fully
       interlocked  scheme  of  the  signaling  method.   The  compatible  mode is supported "as is" without any
       negotiation because it is compatible.  Any other mode must be firstly negotiated by the host to check  it
       is supported by the peripheral, then to enter one of the forward idle states.

       At any time, the slave may want to send data to the host.  This is only possible from forward idle states
       (nibble, byte, ecp...).  So, the host must have previously negotiated to permit the peripheral to request
       transfer.   Interrupt  lines may be dedicated to the requesting signals to prevent time consuming polling
       methods.

       But peripheral requests are only a hint to the master host.  If the host accepts the  transfer,  it  must
       firstly  negotiate  the  reverse mode and then starts the transfer.  At any time during reverse transfer,
       the host may terminate the transfer or the slave  may  drive  wires  to  signal  that  no  more  data  is
       available.

   <b>Implementation</b>
       IEEE1284 Standard support has been implemented at the top of the ppbus system as a set of procedures that
       perform  high  level  functions like negotiation, termination, transfer in any mode without bothering you
       with low level characteristics of the standard.

       IEEE1284 interacts with the ppbus system as little as possible.  That means you still have to request the
       ppbus when you want to access it, the negotiate function does not do it for you.  And of course,  release
       it later.

</pre><h4><b>ARCHITECTURE</b></h4><pre>
   <b>adapter,</b> <b>ppbus</b> <b>and</b> <b>device</b> <b>layers</b>
       First, there is the <u>adapter</u> layer, the lowest of the ppbus system.  It provides chipset abstraction throw
       a set of low level functions that maps the logical model to the underlying hardware.

       Secondly, there is the <u>ppbus</u> layer that provides functions to:

             1.   share the parallel port bus among the daisy-chain like connected devices

             2.   manage devices linked to ppbus

             3.   propose an arch-independent interface to access the hardware layer.

       Finally, the <u>device</u> layer gathers the parallel peripheral device drivers.

   <b>Parallel</b> <b>modes</b> <b>management</b>
       We  have  to  differentiate  operating modes at various ppbus system layers.  Actually, ppbus and adapter
       operating modes on one hands and for each one, current and available modes are separated.

       With this level of abstraction a particular chipset may commute from any native mode to  any  other  mode
       emulated  with extended modes without disturbing upper layers.  For example, most chipsets support NIBBLE
       mode as native and emulated with ECP and/or EPP.

       This architecture should support IEEE1284-1994 modes.

</pre><h4><b>FEATURES</b></h4><pre>
   <b>The</b> <b>boot</b> <b>process</b>
       The boot process starts with the probe stage of the  <u><a href="../man4/ppc.4.html">ppc</a></u>(4)  driver  during  ISA  bus  (PC  architecture)
       initialization.   During attachment of the ppc driver, a new ppbus structure is allocated, then probe and
       attachment for this new bus node are called.

       ppbus attachment tries to detect any PnP parallel peripheral (according to <u>Plug</u> <u>and</u>  <u>Play</u>  <u>Parallel</u>  <u>Port</u>
       <u>Devices</u> draft from (c)1993-4 Microsoft Corporation) then probes and attaches known device drivers.

       During probe, device drivers are supposed to request the ppbus and try to set their operating mode.  This
       mode will be saved in the context structure and returned each time the driver requests the ppbus.

   <b>Bus</b> <b>allocation</b> <b>and</b> <b>interrupts</b>
       ppbus  allocation is mandatory not to corrupt I/O of other devices.  Another usage of ppbus allocation is
       to reserve the port and receive incoming interrupts.

       High level interrupt handlers are connected to the ppbus system thanks to the newbus <b>BUS_SETUP_INTR</b>() and
       <b>BUS_TEARDOWN_INTR</b>()  functions.   But,  in  order  to  attach  a  handler,  drivers  must  own  the  bus.
       Consequently, a ppbus request is mandatory in order to call the above functions (see existing drivers for
       more info).  Note that the interrupt handler is automatically released when the ppbus is released.

   <b>Microsequences</b>
       <u>Microsequences</u>  is a general purpose mechanism to allow fast low-level manipulation of the parallel port.
       Microsequences may be used to do either standard (in IEEE1284  modes)  or  non-standard  transfers.   The
       philosophy  of  microsequences  is  to  avoid  the  overhead of the ppbus layer and do most of the job at
       adapter level.

       A microsequence is an array of opcodes and parameters.  Each  opcode  codes  an  operation  (opcodes  are
       described  in  <u><a href="../man9/microseq.9.html">microseq</a></u>(9)).   Standard  I/O  operations are implemented at ppbus level whereas basic I/O
       operations and microseq language are coded at adapter level for efficiency.

       As an example, the <u><a href="../man4/vpo.4.html">vpo</a></u>(4) driver uses microsequences to implement:

             <b>•</b>   a modified version of the NIBBLE transfer mode

             <b>•</b>   various I/O sequences to initialize, select and allocate the peripheral

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <u><a href="../man4/lpt.4.html">lpt</a></u>(4), <u><a href="../man4/plip.4.html">plip</a></u>(4), <u><a href="../man4/ppc.4.html">ppc</a></u>(4), <u><a href="../man4/ppi.4.html">ppi</a></u>(4), <u><a href="../man4/vpo.4.html">vpo</a></u>(4)

</pre><h4><b>HISTORY</b></h4><pre>
       The <b>ppbus</b> manual page first appeared in FreeBSD 3.0.

</pre><h4><b>AUTHORS</b></h4><pre>
       This manual page was written by Nicolas Souchu.

Debian                                            March 1, 1998                                         <u><a href="../man4/PPBUS.4.html">PPBUS</a></u>(4)
</pre>
 </div>
</div></section>
</div>
</body>
</html>