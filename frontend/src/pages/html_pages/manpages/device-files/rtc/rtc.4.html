<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>rtc - real-time clock</title>
    <style>
        body { font-family: monospace; margin: 20px; line-height: 1.4; }
        a { color: #0066cc; }
        pre { white-space: pre-wrap; }
    </style>
</head>
<body>
    <div id="main-content">
<section class="p-strip is-bordered">
<div class="row">
<div class="col-3 u-hide--small u-hide" id="toc">
</div>
<div id="tableWrapper">
<p id="distroAndSection"></p>

Provided by: <a href="https://launchpad.net/ubuntu/plucky/+package/manpages">manpages_6.9.1-1_all</a> <br><br><pre>
</pre><h4><b>NAME</b></h4><pre>
       rtc - real-time clock

</pre><h4><b>SYNOPSIS</b></h4><pre>
       #include &lt;<a href="file:/usr/include/linux/rtc.h">linux/rtc.h</a>&gt;

       <b>int</b> <b>ioctl(</b><u>fd</u><b>,</b> <b>RTC_</b><u>request</u><b>,</b> <u>param</u><b>);</b>

</pre><h4><b>DESCRIPTION</b></h4><pre>
       This is the interface to drivers for real-time clocks (RTCs).

       Most  computers  have  one or more hardware clocks which record the current "wall clock" time.  These are
       called "Real Time Clocks" (RTCs).  One of these usually has battery backup power so that  it  tracks  the
       time even while the computer is turned off.  RTCs often provide alarms and other interrupts.

       All  i386  PCs, and ACPI-based systems, have an RTC that is compatible with the Motorola MC146818 chip on
       the original PC/AT.  Today such an RTC is usually integrated into the mainboard's chipset (south bridge),
       and uses a replaceable coin-sized backup battery.

       Non-PC  systems,  such  as  embedded  systems  built  around   system-on-chip   processors,   use   other
       implementations.  They usually won't offer the same functionality as the RTC from a PC/AT.

   <b>RTC</b> <b>vs</b> <b>system</b> <b>clock</b>
       RTCs should not be confused with the system clock, which is a software clock maintained by the kernel and
       used  to  implement  <b><a href="../man2/gettimeofday.2.html">gettimeofday</a></b>(2) and <b><a href="../man2/time.2.html">time</a></b>(2), as well as setting timestamps on files, and so on.  The
       system clock reports seconds and microseconds since a  start  point,  defined  to  be  the  POSIX  Epoch:
       1970-01-01  00:00:00  +0000 (UTC).  (One common implementation counts timer interrupts, once per "jiffy",
       at a frequency of 100, 250, or 1000 Hz.)  That is, it is supposed to report wall clock time,  which  RTCs
       also do.

       A  key  difference  between an RTC and the system clock is that RTCs run even when the system is in a low
       power state (including "off"), and the system clock can't.  Until it is initialized, the system clock can
       only report time since system boot ... not since the POSIX Epoch.  So at boot time,  and  after  resuming
       from a system low power state, the system clock will often be set to the current wall clock time using an
       RTC.   Systems  without an RTC need to set the system clock using another clock, maybe across the network
       or by entering that data manually.

   <b>RTC</b> <b>functionality</b>
       RTCs can be read and written with <b><a href="../man8/hwclock.8.html">hwclock</a></b>(8), or directly with the <b><a href="../man2/ioctl.2.html">ioctl</a></b>(2) requests listed below.

       Besides tracking the date and time, many RTCs can also generate interrupts

       •  on every clock update (i.e., once per second);

       •  at periodic intervals with a frequency that can be set to any power-of-2 multiple in the range 2 Hz to
          8192 Hz;

       •  on reaching a previously specified alarm time.

       Each of those interrupt sources can be enabled or  disabled  separately.   On  many  systems,  the  alarm
       interrupt  can be configured as a system wakeup event, which can resume the system from a low power state
       such as Suspend-to-RAM (STR, called S3 in ACPI systems), Hibernation (called S4 in ACPI systems), or even
       "off" (called S5 in ACPI systems).  On some systems, the battery backed RTC can't issue  interrupts,  but
       another one can.

       The  <u>/dev/rtc</u> (or <u>/dev/rtc0</u>, <u>/dev/rtc1</u>, etc.)  device can be opened only once (until it is closed) and it
       is read-only.  On <b><a href="../man2/read.2.html">read</a></b>(2) and <b><a href="../man2/select.2.html">select</a></b>(2) the calling process is blocked until the next interrupt from that
       RTC is received.  Following the interrupt, the process can read  a  long  integer,  of  which  the  least
       significant byte contains a bit mask encoding the types of interrupt that occurred, while the remaining 3
       bytes contain the number of interrupts since the last <b><a href="../man2/read.2.html">read</a></b>(2).

   <b><a href="../man2/ioctl.2.html">ioctl</a>(2)</b> <b>interface</b>
       The following <b><a href="../man2/ioctl.2.html">ioctl</a></b>(2) requests are defined on file descriptors connected to RTC devices:

       <b>RTC_RD_TIME</b>
              Returns this RTC's time in the following structure:

                  struct rtc_time {
                      int tm_sec;
                      int tm_min;
                      int tm_hour;
                      int tm_mday;
                      int tm_mon;
                      int tm_year;
                      int tm_wday;     /* unused */
                      int tm_yday;     /* unused */
                      int tm_isdst;    /* unused */
                  };

              The fields in this structure have the same meaning and ranges as for the <u>tm</u> structure described in
              <b><a href="../man3/gmtime.3.html">gmtime</a></b>(3).  A pointer to this structure should be passed as the third <b><a href="../man2/ioctl.2.html">ioctl</a></b>(2) argument.

       <b>RTC_SET_TIME</b>
              Sets  this  RTC's  time  to  the  time specified by the <u>rtc_time</u> structure pointed to by the third
              <b><a href="../man2/ioctl.2.html">ioctl</a></b>(2) argument.  To set the  RTC's  time  the  process  must  be  privileged  (i.e.,  have  the
              <b>CAP_SYS_TIME</b> capability).

       <b>RTC_ALM_READ</b>
       <b>RTC_ALM_SET</b>
              Read and set the alarm time, for RTCs that support alarms.  The alarm interrupt must be separately
              enabled  or disabled using the <b>RTC_AIE_ON</b>, <b>RTC_AIE_OFF</b> requests.  The third <b><a href="../man2/ioctl.2.html">ioctl</a></b>(2) argument is a
              pointer to an <u>rtc_time</u> structure.  Only the <u>tm_sec</u>, <u>tm_min</u>, and <u>tm_hour</u> fields of  this  structure
              are used.

       <b>RTC_IRQP_READ</b>
       <b>RTC_IRQP_SET</b>
              Read  and  set  the  frequency for periodic interrupts, for RTCs that support periodic interrupts.
              The periodic interrupt must be separately enabled or disabled using  the  <b>RTC_PIE_ON</b>,  <b>RTC_PIE_OFF</b>
              requests.   The  third  <b><a href="../man2/ioctl.2.html">ioctl</a></b>(2) argument is an <u>unsigned</u> <u>long</u> <u>*</u> or an <u>unsigned</u> <u>long</u>, respectively.
              The value is the frequency in interrupts per second.  The set  of  allowable  frequencies  is  the
              multiples  of  two  in  the  range  2  to  8192.   Only a privileged process (i.e., one having the
              <b>CAP_SYS_RESOURCE</b>   capability)   can   set   frequencies   above   the    value    specified    in
              <u>/proc/sys/dev/rtc/max-user-freq</u>.  (This file contains the value 64 by default.)

       <b>RTC_AIE_ON</b>
       <b>RTC_AIE_OFF</b>
              Enable  or disable the alarm interrupt, for RTCs that support alarms.  The third <b><a href="../man2/ioctl.2.html">ioctl</a></b>(2) argument
              is ignored.

       <b>RTC_UIE_ON</b>
       <b>RTC_UIE_OFF</b>
              Enable or disable the interrupt on every clock update, for RTCs that support this  once-per-second
              interrupt.  The third <b><a href="../man2/ioctl.2.html">ioctl</a></b>(2) argument is ignored.

       <b>RTC_PIE_ON</b>
       <b>RTC_PIE_OFF</b>
              Enable  or  disable  the periodic interrupt, for RTCs that support these periodic interrupts.  The
              third  <b><a href="../man2/ioctl.2.html">ioctl</a></b>(2)  argument  is  ignored.   Only  a  privileged  process  (i.e.,  one   having   the
              <b>CAP_SYS_RESOURCE</b>  capability)  can enable the periodic interrupt if the frequency is currently set
              above the value specified in <u>/proc/sys/dev/rtc/max-user-freq</u>.

       <b>RTC_EPOCH_READ</b>
       <b>RTC_EPOCH_SET</b>
              Many RTCs encode the year in an 8-bit register which is either  interpreted  as  an  8-bit  binary
              number or as a BCD number.  In both cases, the number is interpreted relative to this RTC's Epoch.
              The  RTC's  Epoch  is  initialized  to 1900 on most systems but on Alpha and MIPS it might also be
              initialized to 1952, 1980, or 2000, depending on the value of an RTC register for the year.   With
              some  RTCs,  these  operations  can  be used to read or to set the RTC's Epoch, respectively.  The
              third <b><a href="../man2/ioctl.2.html">ioctl</a></b>(2) argument is an <u>unsigned</u> <u>long</u> <u>*</u> or an <u>unsigned</u> <u>long</u>,  respectively,  and  the  value
              returned (or assigned) is the Epoch.  To set the RTC's Epoch the process must be privileged (i.e.,
              have the <b>CAP_SYS_TIME</b> capability).

       <b>RTC_WKALM_RD</b>
       <b>RTC_WKALM_SET</b>
              Some  RTCs  support a more powerful alarm interface, using these ioctls to read or write the RTC's
              alarm time (respectively) with this structure:

                  struct rtc_wkalrm {
                      unsigned char enabled;
                      unsigned char pending;
                      struct rtc_time time;
                  };

              The <u>enabled</u> flag is used to enable or disable the alarm interrupt, or to read its current  status;
              when  using  these  calls,  <b>RTC_AIE_ON</b>  and <b>RTC_AIE_OFF</b> are not used.  The <u>pending</u> flag is used by
              <b>RTC_WKALM_RD</b> to report a pending interrupt (so it's mostly useless on Linux, except  when  talking
              to  the RTC managed by EFI firmware).  The <u>time</u> field is as used with <b>RTC_ALM_READ</b> and <b>RTC_ALM_SET</b>
              except that the <u>tm_mday</u>, <u>tm_mon</u>, and <u>tm_year</u> fields are also valid.  A pointer to  this  structure
              should be passed as the third <b><a href="../man2/ioctl.2.html">ioctl</a></b>(2) argument.

</pre><h4><b>FILES</b></h4><pre>
       <u>/dev/rtc</u>
       <u>/dev/rtc0</u>
       <u>/dev/rtc1</u>
       ...    RTC special character device files.

       <u><a href="file:/proc/driver/rtc">/proc/driver/rtc</a></u>
              status of the (first) RTC.

</pre><h4><b>NOTES</b></h4><pre>
       When the kernel's system time is synchronized with an external reference using <b><a href="../man2/adjtimex.2.html">adjtimex</a></b>(2) it will update
       a  designated  RTC  periodically every 11 minutes.  To do so, the kernel has to briefly turn off periodic
       interrupts; this might affect programs using that RTC.

       An RTC's Epoch has nothing to do with the POSIX Epoch which is used only for the system clock.

       If the year according to the RTC's Epoch and the year register is less than 1970 it is assumed to be  100
       years later, that is, between 2000 and 2069.

       Some RTCs support "wildcard" values in alarm fields, to support scenarios like periodic alarms at fifteen
       minutes  after  every hour, or on the first day of each month.  Such usage is nonportable; portable user-
       space code expects only a single alarm interrupt, and will either disable or reinitialize the alarm after
       receiving it.

       Some RTCs support periodic interrupts with periods that are multiples of a second rather  than  fractions
       of  a  second; multiple alarms; programmable output clock signals; nonvolatile memory; and other hardware
       capabilities that are not currently exposed by this API.

</pre><h4><b>SEE</b> <b>ALSO</b></h4><pre>
       <b><a href="../man1/date.1.html">date</a></b>(1), <b><a href="../man2/adjtimex.2.html">adjtimex</a></b>(2), <b><a href="../man2/gettimeofday.2.html">gettimeofday</a></b>(2), <b><a href="../man2/settimeofday.2.html">settimeofday</a></b>(2), <b><a href="../man2/stime.2.html">stime</a></b>(2), <b><a href="../man2/time.2.html">time</a></b>(2), <b><a href="../man3/gmtime.3.html">gmtime</a></b>(3), <b><a href="../man7/time.7.html">time</a></b>(7), <b><a href="../man8/hwclock.8.html">hwclock</a></b>(8)

       <u>Documentation/rtc.txt</u> in the Linux kernel source tree

Linux man-pages 6.9.1                              2024-05-02                                             <u><a href="../man4/rtc.4.html">rtc</a></u>(4)
</pre>
 </div>
</div></section>
</div>
</body>
</html>