---
import BaseLayout from '../../layouts/BaseLayout.astro';
import AdBanner from '../../components/banner/AdBanner';
import Pagination from '../../components/Pagination.astro';
import BottomPagination from '../../components/BottomPagination.astro';
import { getEmojisByCategory, getEmojiCategories } from '../../lib/emojis';

const ITEMS_PER_PAGE = 24;

export async function getStaticPaths() {
  const categories = getEmojiCategories();
  
  return categories
    .filter((category) => category && category.trim() !== '')
    .map((category) => ({
      params: { category: category.toLowerCase().replace(/[^a-z0-9]+/g, '-') },
      props: { category }
    }));
}

const { category: categorySlug } = Astro.params;
// Prefer original category from build-time props to preserve symbols like '&'
const categoryName = (Astro.props?.category as string) || categorySlug!.replace(/-/g, ' ').replace(/\b\w/g, (l) => l.toUpperCase());

// SEO metadata and descriptions for categories
const categorySeo: Record<string, { title: string; description: string; keywords: string[] } > = {
  'Activities': {
    title: 'Activities Emojis - Sports, Events, and Hobbies | Online Free DevTools by Hexmos',
    description: 'Explore activities emojis covering sports, games, celebrations, and hobbies. Copy emoji, view meanings, and find shortcodes instantly.',
    keywords: ['activities emojis', 'sports emojis', 'game emojis', 'hobby emojis', 'celebration emojis']
  },
  'Animals & Nature': {
    title: 'Animals & Nature Emojis - Wildlife, Pets, and Weather',
    description: 'Browse animals and nature emojis including pets, wild animals, plants, and weather. Meanings, names, and quick copy included.',
    keywords: ['animals emojis', 'nature emojis', 'pet emojis', 'plant emojis', 'weather emojis']
  },
  'Flags': {
    title: 'Flags Emojis - Countries, Regions, and Symbols',
    description: 'Find flags emojis for countries, regions, and symbols. Search, copy, and learn names for each flag emoji.',
    keywords: ['flags emojis', 'country flag emojis', 'regional flags', 'flag symbols', 'flag emoji list']
  },
  'Food & Drink': {
    title: 'Food & Drink Emojis - Meals, Fruits, and Beverages',
    description: 'Discover food and drink emojis including fruits, meals, snacks, and beverages. Copy emoji and view common names and meanings.',
    keywords: ['food emojis', 'drink emojis', 'fruit emojis', 'meal emojis', 'beverage emojis']
  },
  'Objects': {
    title: 'Objects Emojis - Tools, Tech, and Everyday Items',
    description: 'See objects emojis for tools, technology, stationery, and everyday items. Quickly copy and understand emoji usage.',
    keywords: ['objects emojis', 'tool emojis', 'tech emojis', 'stationery emojis', 'everyday item emojis']
  },
  'People & Body': {
    title: 'People & Body Emojis - Gestures, Roles, and Appearance',
    description: 'Browse people and body emojis including gestures, professions, families, and appearances. Copy emoji and see shortcodes.',
    keywords: ['people emojis', 'body emojis', 'gesture emojis', 'profession emojis', 'family emojis']
  },
  'Smileys & Emotion': {
    title: 'Smileys & Emotion Emojis - Faces and Feelings',
    description: 'Explore smileys and emotion emojis that express feelings, reactions, and moods. Meanings, names, and quick copy supported.',
    keywords: ['smileys emojis', 'emotion emojis', 'face emojis', 'reaction emojis', 'mood emojis']
  },
  'Symbols': {
    title: 'Symbols Emojis - Shapes, Arrows, and Signs',
    description: 'Browse symbols emojis including shapes, arrows, signs, and punctuation. Copy emoji and check names and meanings.',
    keywords: ['symbols emojis', 'arrow emojis', 'shape emojis', 'sign emojis', 'punctuation emojis']
  },
  'Travel & Places': {
    title: 'Travel & Places Emojis - Transport and Landmarks',
    description: 'Find travel and places emojis for transportation, buildings, maps, and landmarks. Copy emoji with names and usage.',
    keywords: ['travel emojis', 'places emojis', 'transport emojis', 'building emojis', 'landmark emojis']
  }
};

const emojis = getEmojisByCategory(categoryName);

if (emojis.length === 0) {
  return Astro.redirect('/freedevtools/emojis/');
}

const totalEmojis = emojis.length;
const totalPages = Math.ceil(totalEmojis / ITEMS_PER_PAGE);

// Category icons mapping
const categoryIconMap: Record<string, string> = {
  "Smileys & Emotion": "üòÄ",
  "People & Body": "üë§",
  "Animals & Nature": "üê∂",
  "Food & Drink": "üçé",
  "Travel & Places": "‚úàÔ∏è",
  "Activities": "‚öΩ",
  "Objects": "üì±",
  "Symbols": "‚ù§Ô∏è",
  "Flags": "üèÅ",
  "Other": "‚ùì"
};
---

<BaseLayout 
  name="Emojis"
  path="/emojis/"
  title={(categorySeo[categoryName]?.title) || `${categoryName} Emojis | Online Free DevTools by Hexmos`}
  description={(categorySeo[categoryName]?.description) || `Browse ${totalEmojis} ${categoryName.toLowerCase()} emojis with meanings, shortcodes, and copy functionality.`}
  keywords={categorySeo[categoryName]?.keywords || []}
  canonical={`https://hexmos.com/freedevtools/emojis/${categorySlug}/`}
  themeColor="#1e40af"
  showSidebar={false}
  showHeader={true}
>
  <div class="max-w-6xl mx-auto px-2 md:px-6">
    <div class="mb-16 mt-[74px]">
      <AdBanner client:load />
    </div>
    
    <div class="mb-8">
      <nav class="text-sm text-slate-600 dark:text-slate-400 mb-4">
        <a href="/freedevtools/" class="hover:text-blue-600 dark:hover:text-blue-400">Free DevTools</a>
        <span class="mx-2">/</span>
        <a href="/freedevtools/emojis/" class="hover:text-blue-600 dark:hover:text-blue-400">Emojis</a>
        <span class="mx-2">/</span>
        <span>{categoryName}</span>
      </nav>
      
      <div class="flex items-center mb-6">
        <div class="w-12 h-12 bg-gradient-to-br from-blue-500 to-blue-600 dark:from-blue-600 dark:to-blue-700 rounded-lg flex items-center justify-center mr-4 border border-slate-200 dark:border-slate-700 shadow-sm">
          <span class="text-3xl">
            {categoryIconMap[categoryName] || "‚ùì"}
          </span>
        </div>
        <div>
          <h1 class="text-3xl font-bold text-slate-900 dark:text-slate-100">
            {categoryName} Emojis
          </h1>
          <p class="text-lg text-slate-600 dark:text-slate-400">
            {categorySeo[categoryName]?.description || `${totalEmojis} emojis available`}
          </p>
          <p class="text-sm text-slate-500 dark:text-slate-500 m-0">
            {totalEmojis} emojis available in this category
          </p>
        </div>
      </div>
      
      <!-- Pagination -->
      <Pagination 
        totalItems={totalEmojis}
        itemsPerPage={ITEMS_PER_PAGE}
        currentPage={1}
        totalPages={totalPages}
        itemsLabel="emojis"
      />
    </div>

    <div id="emojis-grid" class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-6 gap-4 mb-8">
      <!-- Emojis will be loaded dynamically -->
    </div>
    
    <!-- Bottom Pagination -->
    <BottomPagination 
      totalItems={totalEmojis}
      currentPage={1}
      totalPages={totalPages}
      itemsLabel="emojis"
    />
    
    <!-- Navigation -->
    <div class="mt-10 pt-6 mb-8 border-t border-slate-200 dark:border-slate-700">
      <div class="flex flex-wrap gap-4">
        <a 
          href="/freedevtools/emojis/" 
          class="inline-flex items-center px-4 py-2 text-sm font-medium text-blue-600 dark:text-blue-400 bg-blue-50 dark:bg-blue-900/20 rounded-lg hover:bg-blue-100 dark:hover:bg-blue-900/30 transition-colors"
        >
          ‚Üê  Back to Emojis
        </a>
      </div>
    </div>
  </div>
</BaseLayout>

<script define:vars={{ emojis, totalEmojis, totalPages, ITEMS_PER_PAGE }}>
  // Pagination state
  let currentPage = 1;
  let itemsPerPage = ITEMS_PER_PAGE;
  
  // Get current page and items per page from URL
  function getCurrentPageFromURL() {
    const urlParams = new URLSearchParams(window.location.search);
    const page = parseInt(urlParams.get('page') || '1', 10);
    const items = parseInt(urlParams.get('items') || ITEMS_PER_PAGE.toString(), 10);
    
    // Update items per page if specified in URL
    if (items !== itemsPerPage) {
      itemsPerPage = items;
      const dropdown = document.getElementById('items-per-page');
      if (dropdown) {
        dropdown.value = items.toString();
      }
    }
    
    return Math.max(1, Math.min(page, Math.ceil(totalEmojis / itemsPerPage)));
  }
  
  // Update URL without page reload
  function updateURL(page, items = null) {
    const url = new URL(window.location);
    if (page === 1) {
      url.searchParams.delete('page');
    } else {
      url.searchParams.set('page', page.toString());
    }
    
    const currentItems = items || itemsPerPage;
    if (currentItems !== ITEMS_PER_PAGE) {
      url.searchParams.set('items', currentItems.toString());
    } else {
      url.searchParams.delete('items');
    }
    
    window.history.pushState({}, '', url);
  }
  
  // Generate page numbers for pagination
  function getPageNumbers(currentPage, totalPages) {
    const pages = [];
    const maxVisible = 5;
    
    if (totalPages <= maxVisible) {
      for (let i = 1; i <= totalPages; i++) {
        pages.push(i);
      }
    } else if (currentPage <= 3) {
      for (let i = 1; i <= maxVisible; i++) {
        pages.push(i);
      }
    } else if (currentPage >= totalPages - 2) {
      for (let i = totalPages - maxVisible + 1; i <= totalPages; i++) {
        pages.push(i);
      }
    } else {
      for (let i = currentPage - 2; i <= currentPage + 2; i++) {
        pages.push(i);
      }
    }
    
    return pages;
  }
  
  // Render emoji card
  function renderEmojiCard(emoji) {
    const emojiTitle = emoji.title || emoji.fluentui_metadata?.cldr || emoji.slug || 'Unknown';
    return `
      <a 
        href="/freedevtools/emojis/${emoji.slug}"
        class="bg-white dark:bg-slate-900 border border-slate-200 dark:border-slate-700 rounded-xl p-4 transition-all duration-300 ease-in-out shadow-sm hover:-translate-y-1 hover:shadow-xl hover:border-blue-300 dark:hover:border-blue-600 group"
      >
        <div class="text-center">
          <div class="text-4xl mb-3 group-hover:scale-110 transition-transform duration-200">
            ${emoji.code || emoji.glyph}
          </div>
          <h3 class="text-sm font-medium text-slate-900 dark:text-slate-100 mb-1 line-clamp-2 group-hover:text-blue-600 dark:group-hover:text-blue-400">
            ${emojiTitle}
          </h3>
          ${emoji.alsoKnownAs && emoji.alsoKnownAs.length > 0 ? `<p class="text-xs text-slate-500 dark:text-slate-400 line-clamp-1">${emoji.alsoKnownAs[0]}</p>` : ''}
        </div>
      </a>
    `;
  }
  
  // Render pagination
  function renderPagination() {
    const totalPages = Math.ceil(totalEmojis / itemsPerPage);
    const startIndex = (currentPage - 1) * itemsPerPage;
    const endIndex = startIndex + itemsPerPage;
    const paginatedEmojis = emojis.slice(startIndex, endIndex);
    
    // Update pagination info (defensive)
    const paginationInfo = document.getElementById('pagination-info');
    if (paginationInfo) {
      paginationInfo.textContent = `Showing ${paginatedEmojis.length} of ${totalEmojis} items (Page ${currentPage} of ${totalPages})`;
    }
    const pageInfo = document.getElementById('page-info');
    if (pageInfo) {
      pageInfo.textContent = `${currentPage} / ${totalPages}`;
    }
    const bottomPageInfo = document.getElementById('bottom-page-info');
    if (bottomPageInfo) {
      bottomPageInfo.textContent = `Page ${currentPage} of ${totalPages} ‚Ä¢ ${totalEmojis} total items`;
    }
    
    // Update button states
    const prevBtn = document.getElementById('prev-btn');
    const nextBtn = document.getElementById('next-btn');
    const bottomPrevBtn = document.getElementById('bottom-prev-btn');
    const bottomNextBtn = document.getElementById('bottom-next-btn');
    
    const hasPrev = currentPage > 1;
    const hasNext = currentPage < totalPages;
    
    [prevBtn, bottomPrevBtn].forEach(btn => {
      if (btn) {
        btn.disabled = !hasPrev;
      }
    });
    
    [nextBtn, bottomNextBtn].forEach(btn => {
      if (btn) {
        btn.disabled = !hasNext;
      }
    });
    
    // Render emojis
    const emojisGrid = document.getElementById('emojis-grid');
    if (emojisGrid) {
      emojisGrid.innerHTML = paginatedEmojis.map(emoji => 
        renderEmojiCard(emoji)
      ).join('');
    }
    
    // Render page numbers
    const pageNumbers = getPageNumbers(currentPage, totalPages);
    const pageNumbersContainer = document.getElementById('page-numbers');
    if (pageNumbersContainer) {
      pageNumbersContainer.innerHTML = pageNumbers.map(pageNum => {
        const isCurrentPage = pageNum === currentPage;
        const buttonClass = isCurrentPage 
          ? 'bg-blue-600 text-white' 
          : 'text-slate-700 dark:text-slate-300 bg-white dark:bg-slate-700 border border-slate-300 dark:border-slate-600 hover:bg-slate-50 dark:hover:bg-slate-600';
        
        return `<button data-page="${pageNum}" class="page-number-btn inline-flex items-center px-3 py-2 text-sm font-medium rounded-md transition-colors ${buttonClass}">${pageNum}</button>`;
      }).join('');
    }
    
    // Show bottom pagination if there are multiple pages
    const bottomPagination = document.getElementById('bottom-pagination');
    if (bottomPagination) {
      bottomPagination.style.display = totalPages > 1 ? 'flex' : 'none';
    }
  }
  
  // Navigate to page
  function goToPage(page) {
    const totalPages = Math.ceil(totalEmojis / itemsPerPage);
    if (page < 1 || page > totalPages || page === currentPage) {
      return;
    }
    
    currentPage = page;
    updateURL(page);
    renderPagination();
    
    // Scroll to head-title element
    const headTitle = document.getElementById('head-title');
    if (headTitle) {
      headTitle.scrollIntoView({ behavior: 'smooth', block: 'start' });
    } else {
      // Fallback to top of page if head-title not found
      window.scrollTo({ top: 0, behavior: 'smooth' });
    }
  }
  
  // Handle items per page change
  function handleItemsPerPageChange(newItemsPerPage) {
    const newTotalPages = Math.ceil(totalEmojis / newItemsPerPage);
    const newCurrentPage = Math.min(currentPage, newTotalPages);
    
    itemsPerPage = newItemsPerPage;
    currentPage = newCurrentPage;
    
    updateURL(currentPage, itemsPerPage);
    renderPagination();
    
    // Scroll to head-title element
    const headTitle = document.getElementById('head-title');
    if (headTitle) {
      headTitle.scrollIntoView({ behavior: 'smooth', block: 'start' });
    } else {
      // Fallback to top of page if head-title not found
      window.scrollTo({ top: 0, behavior: 'smooth' });
    }
  }
  
  // Event listeners - use event delegation to avoid re-attaching listeners
  function setupEventListeners() {
    // Use event delegation on the document to handle all clicks
    document.addEventListener('click', (e) => {
      // Handle previous buttons
      if (e.target.id === 'prev-btn' || e.target.id === 'bottom-prev-btn') {
        e.preventDefault();
        goToPage(currentPage - 1);
        return;
      }
      
      // Handle next buttons
      if (e.target.id === 'next-btn' || e.target.id === 'bottom-next-btn') {
        e.preventDefault();
        goToPage(currentPage + 1);
        return;
      }
      
      // Handle page number buttons
      if (e.target.classList.contains('page-number-btn')) {
        e.preventDefault();
        const page = parseInt(e.target.dataset.page, 10);
        goToPage(page);
        return;
      }
    });
    
    // Handle items per page dropdown change
    document.addEventListener('change', (e) => {
      if (e.target.id === 'items-per-page') {
        const newItemsPerPage = parseInt(e.target.value, 10);
        handleItemsPerPageChange(newItemsPerPage);
      }
    });
  }
  
  // Handle browser back/forward (only add once)
  if (!window.paginationInitialized) {
    window.addEventListener('popstate', () => {
      currentPage = getCurrentPageFromURL();
      renderPagination();
    });
    window.paginationInitialized = true;
  }
  
  // Initialize pagination
  function init() {
    currentPage = getCurrentPageFromURL();
    renderPagination();
  }
  
  // Set up event listeners only once
  if (!window.paginationEventListenersSet) {
    setupEventListeners();
    window.paginationEventListenersSet = true;
  }
  
  // Start when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    // Small delay to ensure DOM is fully ready
    setTimeout(init, 100);
  }
</script>
