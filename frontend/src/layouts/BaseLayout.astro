---
import Header from '../components/Header.astro';
import Footer from '../components/Footer.astro';
import '../styles/global.css';
import SearchPage from '../components/search/SearchPage';
// Rest of imports and props remain the same

export interface Props {
  // Basic SEO
  name: string;
  title: string;
  path: string;
  description?: string;
  canonical?: string;
  keywords?: string[];
  ogImage?: string;
  twitterImage?: string;

  // Layout
  showHeader?: boolean;

  // Content metadata
  datePublished?: string;
  dateModified?: string;
  softwareVersion?: string;
  features?: string[];
  author?: string;
  license?: string;
  category?: string;

  // Image/Media
  imgWidth?: number;
  imgHeight?: number;
  thumbnailUrl?: string;
  encodingFormat?: string;

  // Hierarchical structure
  partOf?: string;
  partOfUrl?: string;

  // Schema type override
  pageType?: string;

  // Collection/List specific
  totalItems?: number;
  itemsPerPage?: number;
  currentPage?: number;

  // Tool specific
  toolType?: string;
  toolCategory?: string;

  // Icon specific
  iconName?: string;
  iconCategory?: string;
  iconTags?: string[];

  // Emoji specific
  emojiCode?: string;
  emojiCategory?: string;

  // Command/Cheatsheet specific
  commandName?: string;
  platform?: string;
  commandCategory?: string;

  // MCP Repository specific
  githubUrl?: string;
}

const {
  // Basic SEO
  name,
  title,
  description,
  canonical,
  keywords = [],
  ogImage = 'https://hexmos.com/freedevtools/site-banner.png',
  twitterImage = 'https://hexmos.com/freedevtools/site-banner.png',

  // Layout
  showHeader = true,

  // Image/Media
  imgWidth = 1136,
  imgHeight = 768,
  thumbnailUrl,
  encodingFormat = 'text/html',
} = Astro.props;

const currentUrl = canonical || Astro.url.href;
const keywordsString = keywords.length > 0 ? keywords.join(', ') : '';

// Determine page type based on path and props
function determinePageType(path: string, props: any): string {
  if (props.pageType) return props.pageType;

  // SVG Icon pages
  if (path.includes('/svg_icons/')) {
    if (path.match(/\/svg_icons\/[^\/]+\/[^\/]+$/)) {
      return 'ImageObject'; // Individual icon page
    } else if (path.match(/\/svg_icons\/[^\/]+$/)) {
      return 'CollectionPage'; // Category page
    } else {
      return 'CollectionPage'; // Main SVG icons page
    }
  }

  // Tool pages
  if (path.match(/\/t\/[^\/]+$/) || path.match(/\/t\/[^\/]+\/[^\/]+$/)) {
    return 'SoftwareApplication';
  }

  // Cheatsheet pages
  if (path.includes('/c/')) {
    if (path.match(/\/c\/[^\/]+\/[^\/]+$/)) {
      return 'TechArticle'; // Individual cheatsheet
    } else if (path.match(/\/c\/[^\/]+$/)) {
      return 'CollectionPage'; // Category page
    } else {
      return 'CollectionPage'; // Main cheatsheets page
    }
  }

  // TLDR pages
  if (path.includes('/tldr/')) {
    if (path.match(/\/tldr\/[^\/]+\/[^\/]+$/)) {
      return 'TechArticle'; // Individual command page
    } else if (path.match(/\/tldr\/[^\/]+$/)) {
      return 'CollectionPage'; // Platform page
    } else {
      return 'CollectionPage'; // Main TLDR page
    }
  }

  // MCP pages
  if (path.includes('/mcp/')) {
    if (path.match(/\/mcp\/[^\/]+\/[^\/]+$/)) {
      return 'SoftwareApplication'; // Individual MCP repository page
    } else if (path.match(/\/mcp\/[^\/]+$/)) {
      return 'CollectionPage'; // MCP category page
    } else {
      return 'CollectionPage'; // Main MCP page
    }
  }

  // Emoji pages
  if (path.includes('/emojis/')) {
    if (path.match(/\/emojis\/[^\/]+$/)) {
      return 'CollectionPage'; // Category page
    } else {
      return 'CollectionPage'; // Main emojis page
    }
  }

  // Default
  return 'WebPage';
}

// Generate base schema properties
function getBaseSchema(props: any) {
  const currentDate = new Date().toISOString();

  return {
    '@context': 'https://schema.org',
    url: props.canonical || currentUrl,
    inLanguage: 'en',
    datePublished: props.datePublished || currentDate,
    dateModified: props.dateModified || currentDate,
    author: {
      '@type': 'Organization',
      name: props.author || 'Free DevTools by Hexmos',
      url: 'https://hexmos.com/freedevtools/',
    },
    publisher: {
      '@type': 'Organization',
      name: 'Free DevTools by Hexmos',
      url: 'https://hexmos.com/freedevtools/',
    },
    isPartOf: {
      '@type': 'Collection',
      name: props.partOf || 'Free DevTools',
      url: props.partOfUrl || 'https://hexmos.com/freedevtools/',
    },
    license:
      props.license === 'MIT'
        ? 'https://opensource.org/licenses/MIT'
        : props.license || 'https://opensource.org/licenses/MIT',
    mainEntityOfPage: {
      '@type': 'WebPage',
      '@id': props.canonical || currentUrl,
    },
  };
}

// Generate specific schema based  on page type
function generatePageSpecificSchema(pageType: string, props: any) {
  const baseSchema = getBaseSchema(props);

  switch (pageType) {
    case 'ImageObject': // Individual SVG icon
      return {
        ...baseSchema,
        '@type': 'ImageObject',
        name: props.iconName || props.name,
        alternateName: props.keywords || [],
        description: props.description,
        contentUrl: props.thumbnailUrl || props.ogImage,
        thumbnailUrl: props.thumbnailUrl || props.ogImage,
        image: props.thumbnailUrl || props.ogImage,
        encodingFormat: props.encodingFormat || 'image/svg+xml',
        width: props.imgWidth,
        height: props.imgHeight,
        keywords: [...(props.keywords || []), ...(props.iconTags || [])].join(
          ', '
        ),
        about: {
          '@type': 'Thing',
          name: props.iconCategory || props.category,
        },
        offers: {
          '@type': 'Offer',
          price: '0',
          priceCurrency: 'USD',
          availability: 'https://schema.org/InStock',
        },
        license:
          props.license === 'MIT'
            ? 'https://opensource.org/licenses/MIT'
            : props.license || 'https://opensource.org/licenses/MIT',
        creator: {
          '@type': 'Organization',
          name: props.author || 'Free DevTools by Hexmos',
          url: 'https://hexmos.com/freedevtools/',
        },
        copyrightHolder: {
          '@type': 'Organization',
          name: props.author || 'Free DevTools by Hexmos',
        },
        copyrightYear: new Date().getFullYear(),
        isAccessibleForFree: true,
        usageInfo: {
          '@type': 'CreativeWork',
          text: 'Free to use under MIT license. No attribution required but appreciated.',
        },
      };

    case 'SoftwareApplication': // Tool page or MCP repository
      const isMcpRepository = props.path?.includes('/mcp/');

      if (isMcpRepository) {
        return {
          ...baseSchema,
          '@type': 'SoftwareApplication',
          name: props.name,
          alternateName: props.keywords || [],
          description: props.description,
          applicationCategory: 'DeveloperTool',
          operatingSystem: 'Any',
          browserRequirements: 'Requires Node.js, MCP Client',
          softwareVersion: props.softwareVersion,
          featureList: props.features || [],
          keywords: props.keywords?.join(', ') || '',
          screenshot: props.ogImage,
          programmingLanguage: 'TypeScript',
          runtimePlatform: 'Node.js',
          softwareRequirements:
            'Model Context Protocol (MCP) compatible client',
          category: 'Model Context Protocol Server',
          offers: {
            '@type': 'Offer',
            price: '0',
            priceCurrency: 'USD',
            availability: 'https://schema.org/InStock',
          },
          codeRepository: {
            '@type': 'SoftwareSourceCode',
            url: props.githubUrl || props.url,
            programmingLanguage: 'TypeScript',
            license:
              props.license === 'MIT'
                ? 'https://opensource.org/licenses/MIT'
                : props.license || 'https://opensource.org/licenses/MIT',
          },
        };
      } else {
        return {
          ...baseSchema,
          '@type': 'SoftwareApplication',
          name: props.name,
          alternateName: props.keywords || [],
          description: props.description,
          applicationCategory: 'DeveloperTool',
          operatingSystem: 'Any',
          browserRequirements: 'Requires JavaScript. Requires HTML5.',
          softwareVersion: props.softwareVersion,
          featureList: props.features || [],
          keywords: props.keywords?.join(', ') || '',
          screenshot: props.ogImage,
          offers: {
            '@type': 'Offer',
            price: '0',
            priceCurrency: 'USD',
            availability: 'https://schema.org/InStock',
          },
        };
      }

    case 'TechArticle': // Command/Cheatsheet page
      return {
        ...baseSchema,
        '@type': 'TechArticle',
        headline: props.name,
        alternateName: props.keywords || [],
        description: props.description,
        articleBody: props.description,
        keywords: props.keywords?.join(', ') || '',
        about: {
          '@type': 'Thing',
          name: props.commandName || props.name,
        },
        mentions: props.platform
          ? {
              '@type': 'Thing',
              name: props.platform,
            }
          : undefined,
        articleSection: props.commandCategory || props.category,
      };

    case 'CollectionPage': // Category/List pages
      const collectionSchema: any = {
        ...baseSchema,
        '@type': 'CollectionPage',
        name: props.name,
        alternateName: props.keywords || [],
        description: props.description,
        keywords: props.keywords?.join(', ') || '',
        mainEntity: {
          '@type': 'ItemList',
          numberOfItems: props.totalItems || 0,
          itemListElement: [], // This would be populated with actual items
        },
      };

      // Add pagination info if available
      if (props.totalItems && props.itemsPerPage) {
        collectionSchema.mainEntity.numberOfItems = props.totalItems;
        collectionSchema.mainEntity.numberOfPages = Math.ceil(
          props.totalItems / props.itemsPerPage
        );
        collectionSchema.mainEntity.currentPage = props.currentPage;
      }

      return collectionSchema;

    default: // WebPage
      return {
        ...baseSchema,
        '@type': 'WebPage',
        name: props.name,
        alternateName: props.keywords || [],
        description: props.description,
        keywords: props.keywords?.join(', ') || '',
      };
  }
}

// Generate the final schema
const detectedPageType = determinePageType(Astro.props.path, Astro.props);
const schema = generatePageSpecificSchema(detectedPageType, Astro.props);

// Debug: Print the final  schema
// console.log('üîç JSON-LD Schema for:', Astro.props.path);
// console.log('üìÑ Page Type:', detectedPageType);
// console.log('üìã Generated Schema:', JSON.stringify(schema, null, 2));
---

<!doctype html>
<html lang="en">
  <head>
    <!-- Theme initialization script -->
    <script is:inline>
      (function () {
        const theme = localStorage.getItem('theme') || 'dark';
        const prefersDark = window.matchMedia(
          '(prefers-color-scheme: dark)'
        ).matches;
        if (theme === 'dark' || (!theme && prefersDark)) {
          document.documentElement.classList.add('dark');
        } else {
          document.documentElement.classList.remove('dark');
        }
      })();
    </script>

    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- Google AdSense -->
    <meta name="google-adsense-account" content="ca-pub-1540226945870088" />
    <script
      async
      src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1540226945870088"
      crossorigin="anonymous"></script>
    <script>
      (function (s) {
        ((s.dataset.zone = '10140855'),
          (s.src = 'https://forfrogadiertor.com/tag.min.js'));
      })(
        [document.documentElement, document.body]
          .filter(Boolean)
          .pop()
          .appendChild(document.createElement('script'))
      );
    </script>

    <!-- Basic SEO Meta Tags -->
    <title>{title}</title>
    {description && <meta name="description" content={description} />}
    {keywordsString && <meta name="keywords" content={keywordsString} />}
    {canonical && <link rel="canonical" href={canonical} />}

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website" />
    <meta property="og:title" content={title} />
    {description && <meta property="og:description" content={description} />}
    <meta property="og:url" content={currentUrl} />
    <meta property="og:image" content={thumbnailUrl || ogImage} />
    <meta property="og:site_name" content="Free DevTools by Hexmos" />

    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content={title} />
    {description && <meta name="twitter:description" content={description} />}
    <meta name="twitter:image" content={thumbnailUrl || twitterImage} />
    <!-- JSON-LD Structured Data -->
    {
      schema && (
        <script type="application/ld+json" set:html={JSON.stringify(schema)} />
      )
    }

    <!-- Additional SEO Meta Tags -->
    <meta name="robots" content="index, follow" />
    <meta name="author" content="Free DevTools by Hexmos" />
    <meta name="generator" content="Astro" />

    <!-- Image-specific meta tags for better SEO -->
    {
      thumbnailUrl && (
        <>
          <meta name="image" content={thumbnailUrl} />
          <meta property="og:image:width" content={imgWidth.toString()} />
          <meta property="og:image:height" content={imgHeight.toString()} />
          <meta property="og:image:type" content={encodingFormat} />
          <meta property="og:image:alt" content={name} />
          <meta name="twitter:image:alt" content={name} />
        </>
      )
    }

    <!-- Favicon -->
    <link
      rel="icon"
      type="image/png"
      href="data:image/png;base64,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"
    />

    <!-- Resource hints for better performance -->
    <link rel="preconnect" href="https://api.github.com" crossorigin />
    <link rel="preconnect" href="https://github.com" crossorigin />
    <link rel="dns-prefetch" href="//hexmos.com" />
    <link rel="dns-prefetch" href="//www.googletagmanager.com" />
    <link rel="dns-prefetch" href="//www.google-analytics.com" />

    <!-- Theme initialization script -->
    <script>
      (function () {
        const theme = localStorage.getItem('theme') || 'dark';
        if (theme === 'dark') {
          document.documentElement.classList.add('dark');
        } else {
          document.documentElement.classList.remove('dark');
        }
      })();
    </script>

    <!-- Optimized GTM loading -->
    <script>
      (function () {
        const GA_MEASUREMENT_ID = 'G-WXSDF484XZ';
        const GTM_ID = 'GTM-KH6DG8PP';

        // minimal dataLayer init
        window.dataLayer = window.dataLayer || [];
        window.dataLayer.push({
          'gtm.start': new Date().getTime(),
          event: 'gtm.js',
        });

        function loadGTM() {
          if (window.__gtmLoaded) return;
          window.__gtmLoaded = true;

          const s = document.createElement('script');
          s.async = true;
          s.src = `https://www.googletagmanager.com/gtm.js?id=${GTM_ID}`;
          document.head.appendChild(s);
        }

        // trigger load on first interaction or after idle timeout
        const trigger = () => loadGTM();
        ['scroll', 'pointerdown', 'keydown', 'mousemove'].forEach((evt) =>
          window.addEventListener(evt, trigger, { once: true, passive: true })
        );

        if ('requestIdleCallback' in window)
          requestIdleCallback(loadGTM, { timeout: 5000 });
        else setTimeout(loadGTM, 5000);
      })();
    </script>

    <!-- Add global search state -->
    <script>
      // Add type definition for window
      interface SearchState {
        query: string;
        setQuery: (query: string) => void;
        getQuery: () => string;
      }

      // Extend Window interface.
      interface Window {
        searchState?: SearchState;
      }

      // Initialize global search state
      window.searchState = {
        query: '',
        setQuery: function (query) {
          this.query = query;
          // Dispatch an event when query changes
          window.dispatchEvent(
            new CustomEvent('searchQueryChanged', {
              detail: { query },
            })
          );
        },
        getQuery: function () {
          return this.query;
        },
      };
    </script>
  </head>
  <body
    class="m-0 p-0 bg-slate-50 text-slate-800 leading-relaxed dark:bg-slate-900 dark:text-slate-200 min-h-screen flex flex-col"
  >
    <!-- Skip Links for Accessibility -->
    <a
      href="#main-content"
      class="sr-only focus:not-sr-only focus:absolute focus:top-4 focus:left-4 bg-blue-600 text-white px-4 py-2 rounded-md z-50 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2"
    >
      Skip to main content
    </a>
    <a
      href="#navigation"
      class="sr-only focus:not-sr-only focus:absolute focus:top-4 focus:left-32 bg-blue-600 text-white px-4 py-2 rounded-md z-50 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2"
    >
      Skip to navigation
    </a>
    <a
      href="#search"
      class="sr-only focus:not-sr-only focus:absolute focus:top-4 focus:left-64 bg-blue-600 text-white px-4 py-2 rounded-md z-50 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2"
    >
      Skip to search
    </a>

    <div class="flex flex-1 flex-col">
      {showHeader && <Header />}

      <main
        class="flex-1 overflow-auto bg-background"
        class:list={[showHeader ? 'pt-16 md:pt-16' : 'pt-0 lg:pt-0']}
        id="main-content"
        role="main"
        aria-labelledby="main-content-heading"
      >
        <div id="main-page">
          <div
            id="search-container"
            style="display: none;"
            class="max-w-6xl mx-auto px-2 md:px-6"
          >
            <SearchPage client:load />
          </div>
          <div id="slot-container">
            <slot />
          </div>
        </div>

        <script>
          // Function to toggle visibility based on search query
          function toggleSearchView() {
            const searchContainer = document.getElementById('search-container');
            const slotContainer = document.getElementById('slot-container');

            // Handle the case where elements aren't found
            if (!searchContainer || !slotContainer) return;

            // Safely access window.searchState
            const searchQuery = window.searchState?.getQuery?.() || '';

            if (searchQuery.trim()) {
              searchContainer.style.display = 'block';
              slotContainer.style.display = 'none';
            } else {
              searchContainer.style.display = 'none';
              slotContainer.style.display = 'block';
            }
          }

          // Initialize and set up listener
          document.addEventListener('DOMContentLoaded', function () {
            // Initial toggle based on search state
            toggleSearchView();

            // Listen for search query changes
            window.addEventListener('searchQueryChanged', toggleSearchView);
          });
        </script>
      </main>

      <!-- Footer -->
      <Footer />
    </div>
  </body>
</html>
