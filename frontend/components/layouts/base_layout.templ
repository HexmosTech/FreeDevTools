package layouts

import (
	"fmt"
	"strings"
	"fdt-templ/assets"
	"fdt-templ/components/common"
	"fdt-templ/components/common/banner"
	"fdt-templ/internal/chunks"
	"fdt-templ/internal/config"
)

templ BaseLayout(props BaseLayoutProps) {
	<!DOCTYPE html>
	<html lang="en">
		<head>
			<meta charset="utf-8"/>
			<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
			
			<!-- Resource hints for better performance - early in head -->
			<link rel="preconnect" href="https://hexmos.com"/>

			<link rel="preconnect" href="https://www.googletagmanager.com">
			<link rel="preconnect" href="https://pagead2.googlesyndication.com" crossorigin>
			<link rel="preconnect" href="https://googleads.g.doubleclick.net" crossorigin>
 
			<!-- Critical CSS - loaded early and render-blocking -->
			<!-- Inline Critical CSS -->
			@templ.Raw("<style>" + assets.CriticalCSS + "</style>")
			<!-- Sidebar collapsed state - prevent CLS on nav (class applied by sync script before paint) -->
			<style>
				/* Hide pro-gated ad slots before paint (prevents CLS) */
				html[data-pro="1"] [data-hide-when-pro="true"] { display: none !important; }

				/* Desktop: sidebar is fixed, so reserve space for main content */
				@media (min-width:1024px){
					#layout-main{margin-left:16rem}
					#sidebar.sidebar-collapsed + #layout-main{margin-left:5rem}
				}
				@media (max-width:1023px){
					#layout-main{margin-left:0!important}
					#sidebar{display:none!important}
					#sidebar.sidebar-open{display:flex!important}
				}

				@media (min-width:1024px){
					#sidebar{transition:width .2s ease}
					#sidebar.sidebar-collapsed{width:5rem!important}
					#sidebar.sidebar-collapsed #sidebar-logo-text-container,
					#sidebar.sidebar-collapsed .nav-link-text span,
					#sidebar.sidebar-collapsed #sidebar-theme-switcher-section,
					#sidebar.sidebar-collapsed #sidebar-search-section #searchbar-container{display:none!important}
					#sidebar.sidebar-collapsed #sidebar-search-icon-wrap{display:flex!important}
					#sidebar.sidebar-collapsed .nav-link-text{justify-content:center;padding-left:.5rem;padding-right:.5rem}
					#sidebar.sidebar-collapsed #sidebar-nav-group-top,
					#sidebar.sidebar-collapsed #sidebar-nav-group-1,
					#sidebar.sidebar-collapsed #sidebar-nav-group-2,
					#sidebar.sidebar-collapsed #sidebar-nav-group-3{padding-left:.5rem!important;padding-right:.5rem!important}
					#sidebar.sidebar-collapsed #sidebar-logo-section{justify-content:center;gap:0}
					#sidebar.sidebar-collapsed #sidebar-collapse-toggle{display:none!important}
					#sidebar.sidebar-collapsed #sidebar-collapsed-expand-hint{display:none}
					#sidebar.sidebar-collapsed #sidebar-logo-section:hover #sidebar-logo-img{display:none!important}
					#sidebar.sidebar-collapsed #sidebar-logo-section:hover #sidebar-collapsed-expand-hint{display:block!important;padding-top:.375rem;padding-bottom:.375rem;box-sizing:content-box}
					#sidebar.sidebar-collapsed #sidebar-logo-link{justify-content:center;min-height:2rem}
					#sidebar:not(.sidebar-collapsed) #sidebar-collapse-toggle{display:flex!important}
				}
			</style>
			<!-- Main CSS (render-blocking to prevent CLS from late style application) -->
			<link rel="stylesheet" href="/freedevtools/static/css/output.css"/>
			
			<!-- Theme initialization script -->
			<script>
				(function () {
					function getTheme() {
						const urlParams = new URLSearchParams(window.location.search);
						const urlTheme = urlParams.get('theme');
						if (urlTheme) return urlTheme;
						
						const savedTheme = localStorage.getItem('theme');
						if (savedTheme) return savedTheme;

						return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
					}

					function applyTheme(theme) {
						if (theme === 'dark') {
							document.documentElement.classList.add('dark');
						} else {
							document.documentElement.classList.remove('dark');
						}
						// Only save to localStorage if it's not from URL (optional, but good for persistence)
                        // Actually, let's strictly save it so it persists.
						localStorage.setItem('theme', theme);
					}

					// Initial application
					applyTheme(getTheme());

					// Listen for messages (e.g. from VS Code extension)
					window.addEventListener('message', (event) => {
						const message = event.data;
						if (message && message.command === 'setTheme' && message.theme) {
							applyTheme(message.theme);
						}
					});
				})();
			</script>
			
			<!-- Global pro status cookie management -->
			<script>
				// Define globally accessible function for pro status cookie
				window.getProStatusCookie = function() {
					const cookies = document.cookie.split('; ');
					for (const cookie of cookies) {
						const [name, value] = cookie.split('=');
						if (name.trim() === 'hexmos-one-fdt-p-status') {
							return value === 'true';
						}
					}
					return false;
				};

				// Set a pre-paint flag for CSS gating (prevents CLS from late hide/show)
				(function () {
					function setProFlag(isPro) {
						document.documentElement.setAttribute('data-pro', isPro ? '1' : '0');
					}
					setProFlag(window.getProStatusCookie());
					window.addEventListener('pro-status-changed', function (e) {
						if (e && e.detail && typeof e.detail.isPro === 'boolean') {
							setProFlag(e.detail.isPro);
						} else {
							setProFlag(window.getProStatusCookie());
						}
					});
				})();
				
				// Check cookie immediately and prevent Google AdSense loading
				(function() {
					function removeGoogleAdSense() {
						const cookieStatus = window.getProStatusCookie();
						console.log('GA Read Cookie Status:', cookieStatus);
						
						if (cookieStatus) {
							// Remove Google AdSense meta tag and script if they exist
							const metaTag = document.querySelector('meta[name="google-adsense-account"]');
							if (metaTag) {
								metaTag.remove();
							}
							const adScript = document.querySelector('script[src*="adsbygoogle.js"]');
							if (adScript) {
								adScript.remove();
							}
						}
					}
					
					// Check on initial load
					if (document.readyState === 'loading') {
						document.addEventListener('DOMContentLoaded', removeGoogleAdSense);
					} else {
						removeGoogleAdSense();
					}
					
					// Listen for pro status changes
					window.addEventListener('pro-status-changed', removeGoogleAdSense);
				})();
			</script>
			
			<!-- Google AdSense -->
			if config.GetAdsEnabled() && config.GetEnabledAdTypes(GetAdPageTypeFromPath(props.Canonical))["google"] {
				<script>
					// Only load if pro status cookie is not set
					(function() {
						let adScriptLoaded = false;
						
						function loadGoogleAdSense() {
							const cookieStatus = window.getProStatusCookie();
							if (!cookieStatus && !adScriptLoaded) {
								adScriptLoaded = true;
								
								// Add meta tag
								const meta = document.createElement('meta');
								meta.name = 'google-adsense-account';
								meta.content = 'ca-pub-1540226945870088';
								document.head.appendChild(meta);
								
								// Add script
								const script = document.createElement('script');
								script.async = true;
								script.src = 'https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-1540226945870088';
								script.crossOrigin = 'anonymous';
								document.head.appendChild(script);
							} else if (cookieStatus && adScriptLoaded) {
								// Remove Google AdSense if user becomes pro
								const metaTag = document.querySelector('meta[name="google-adsense-account"]');
								if (metaTag) {
									metaTag.remove();
								}
								const adScript = document.querySelector('script[src*="adsbygoogle.js"]');
								if (adScript) {
									adScript.remove();
								}
								adScriptLoaded = false;
							}
						}
						
						// Check on initial load
						if (document.readyState === 'loading') {
							document.addEventListener('DOMContentLoaded', loadGoogleAdSense);
						} else {
							loadGoogleAdSense();
						}
						
						// Listen for pro status changes
						window.addEventListener('pro-status-changed', loadGoogleAdSense);
					})();
				</script>
			}
			<!-- Basic SEO Meta Tags -->
			<title>{ props.Title }</title>
			if props.Description != "" {
				<meta name="description" content={ props.Description }/>
			}
			if len(props.Keywords) > 0 {
				<meta name="keywords" content={ strings.Join(props.Keywords, ", ") }/>
			}
			if props.Canonical != "" {
				<link rel="canonical" href={ props.Canonical }/>
			}

			<!-- Open Graph / Facebook -->
			<meta property="og:type" content="website"/>
			<meta property="og:title" content={ props.Title }/>
			if props.Description != "" {
				<meta property="og:description" content={ props.Description }/>
			}
			if props.Canonical != "" {
				<meta property="og:url" content={ props.Canonical }/>
			}
			if props.ThumbnailUrl != "" {
				<meta property="og:image" content={ props.ThumbnailUrl }/>
			} else if props.OgImage != "" {
				<meta property="og:image" content={ props.OgImage }/>
			}
			<meta property="og:site_name" content="Free DevTools by Hexmos"/>

			<!-- Twitter Card -->
			<meta name="twitter:card" content="summary_large_image"/>
			<meta name="twitter:title" content={ props.Title }/>
			if props.Description != "" {
				<meta name="twitter:description" content={ props.Description }/>
			}
			if props.ThumbnailUrl != "" {
				<meta name="twitter:image" content={ props.ThumbnailUrl }/>
			} else if props.TwitterImage != "" {
				<meta name="twitter:image" content={ props.TwitterImage }/>
			}

			<!-- JSON-LD Structured Data -->
			if schemaJSON := GenerateSchemaJSON(props); schemaJSON != "" {
				@templ.Raw(`<script type="application/ld+json">` + schemaJSON + `</script>`)
			}

			<!-- Additional SEO Meta Tags -->
			<meta name="robots" content="index, follow"/>
			<meta name="author" content="Free DevTools by Hexmos"/>
			<meta name="generator" content="Templ"/>

			<!-- Image-specific meta tags for better SEO -->
			if props.ThumbnailUrl != "" {
				<meta name="image" content={ props.ThumbnailUrl }/>
				if props.ImgWidth > 0 {
					<meta property="og:image:width" content={ fmt.Sprintf("%d", props.ImgWidth) }/>
				}
				if props.ImgHeight > 0 {
					<meta property="og:image:height" content={ fmt.Sprintf("%d", props.ImgHeight) }/>
				}
				if props.EncodingFormat != "" {
					<meta property="og:image:type" content={ props.EncodingFormat }/>
				}
				if props.Name != "" {
					<meta property="og:image:alt" content={ props.Name }/>
					<meta name="twitter:image:alt" content={ props.Name }/>
				}
			} else if props.OgImage != "" {
				<meta name="image" content={ props.OgImage }/>
			}

			<!-- Add global search state -->
			<script>
				// Initialize global search state
				window.searchState = {
					query: '',
					setQuery: function (query) {
						this.query = query;
						// Dispatch an event when query changes
						window.dispatchEvent(
							new CustomEvent('searchQueryChanged', {
								detail: { query },
							})
						);
					},
					getQuery: function () {
						return this.query;
					},
				};
			</script>

			<!-- Preload React chunks and index.js in parallel to avoid sequential loading chain -->
			<!-- Static modulepreload links generated at build time -->
			{{
				// Preload index.js itself
				var links strings.Builder
				links.WriteString(`<link rel="modulepreload" href="/freedevtools/static/js/index.js"/>`)
				links.WriteString("\n\t\t\t")
				
				// Preload all React chunks
				reactChunks := chunks.GetReactChunks()
				for _, chunk := range reactChunks {
					links.WriteString(fmt.Sprintf(`<link rel="modulepreload" href="/freedevtools/static/js/chunks/%s"/>`, chunk))
					links.WriteString("\n\t\t\t")
				}
			}}
			@templ.Raw(links.String())

			<!-- Favicon -->
			<link rel="icon" type="image/x-icon" href="/freedevtools/public/favicon.png"/>

			<!-- Optimized GTM loading -->
			<script>
				(function () {
					const GA_MEASUREMENT_ID = 'G-WXSDF484XZ';
					const GTM_ID = 'GTM-KH6DG8PP';

					// minimal dataLayer init
					window.dataLayer = window.dataLayer || [];
					window.dataLayer.push({
						'gtm.start': new Date().getTime(),
						event: 'gtm.js',
					});

			function loadGTM() {
				if (window.__gtmLoaded) return;
				window.__gtmLoaded = true;

				const s = document.createElement('script');
				s.async = true;
				s.src = `https://www.googletagmanager.com/gtm.js?id=${GTM_ID}`;
				document.head.appendChild(s);
			}

			// Load GTM when window is fully loaded
			window.addEventListener('load', loadGTM);
				})();
			</script>
		</head>
		<body class="m-0 p-0 bg-slate-50 text-slate-800 leading-relaxed dark:bg-slate-900 dark:text-slate-200 min-h-screen flex flex-col" aria-hidden="false">
			if props.ShowHeader {
				@common.Header()
			}
			<div id="layout-container" class="flex flex-1" style="min-height: 100vh;">
				@common.Sidebar()
				<div id="layout-main" class="flex flex-1 flex-col" style="height: auto !important;">
					<main class="flex-1 overflow-auto bg-background" id="main-content" role="main" aria-labelledby="main-content-heading">
					<div id="main-page" class="p-2 max-w-6xl mx-auto">
					<div id="search-container" style="display: none; max-w-6xl mx-auto"> </div>
					<div id="pro-banner-container" style="display: none;"> </div>
						<div id="slot-container" style="display: block; min-height: 100vh;">
							if !props.HideBanner {
								@banner.AdBanner()
							}
							{ children... }
						</div>
					</div>

					<script>
						let jsModuleLoaded = false;
						let jsModuleLoading = false;
						
						async function loadSearchModule() {
							if (jsModuleLoaded) return Promise.resolve();
							if (jsModuleLoading) {
								// Wait for the ongoing load to complete
								return new Promise((resolve) => {
									const checkInterval = setInterval(() => {
										if (jsModuleLoaded) {
											clearInterval(checkInterval);
											resolve(undefined);
										}
									}, 50);
								});
							}
							jsModuleLoading = true;
							try {
								// Chunks are already preloaded via static modulepreload links in head
								await import('/freedevtools/static/js/index.js');
								jsModuleLoaded = true;
							} finally {
								jsModuleLoading = false;
							}
						}
						
						function toggleSearchView() {
							const searchContainer = document.getElementById('search-container');
							const slotContainer = document.getElementById('slot-container');

							if (!searchContainer || !slotContainer) return;

							const searchQuery = window.searchState?.getQuery?.() || '';
							const isSearchHash = window.location.hash.startsWith('#search');

							// Show search page if there's a query OR if hash is #search?q= (empty search state)
							if (searchQuery.trim() || (isSearchHash && window.location.hash === '#search?q=')) {
								searchContainer.style.display = 'block';
								slotContainer.style.opacity = '0.3';
								slotContainer.style.pointerEvents = 'none';
								
								// Only mount if not already mounted
								if (!window.searchMounted) {
									// Load the module (may already be preloaded)
									loadSearchModule().then(() => {
										if (window.renderTool && !window.searchMounted) {
											window.renderTool('search-page', 'search-container');
											window.searchMounted = true;
										}
									});
								}
							} else {
								searchContainer.style.display = 'none';
								slotContainer.style.opacity = '1';
								slotContainer.style.pointerEvents = 'auto';
							}
						}

						let proBannerMounted = false;
						
						async function loadProBannerModule() {
							if (proBannerMounted) return Promise.resolve();
							try {
								await loadSearchModule(); // Reuse the same module loader
								if (window.renderTool && !proBannerMounted) {
									const container = document.getElementById('pro-banner-container');
									if (container) {
										window.renderTool('pro-banner', 'pro-banner-container');
										proBannerMounted = true;
									}
								}
							} catch (error) {
								console.error('Failed to load ProBanner module:', error);
							}
						}
						
						function trackPageVisit() {
							// Exclude search and pro pages from visit counting
							const hash = window.location.hash;
							const pathname = window.location.pathname;
							
							if (hash.startsWith('#search') || pathname.includes('/pro/')) {
								return 0; // Don't count these pages
							}
							
							const storageKey = 'fdt_pro_banner_visits';
							const lastPageKey = 'fdt_pro_banner_last_page';
							const today = new Date().toISOString().split('T')[0]; // YYYY-MM-DD format
							
							try {
								// Get current page (pathname only, ignore hash)
								const currentPage = pathname;
								
								// Get last visited page
								const lastPage = localStorage.getItem(lastPageKey);
								
								// Only count if this is a different page (not just hash change)
								if (lastPage === currentPage) {
									// Same page, just return current count without incrementing
									const stored = localStorage.getItem(storageKey);
									if (stored) {
										try {
											const visitData = JSON.parse(stored);
											if (visitData.date === today) {
												return visitData.count;
											}
										} catch (e) {
											// Invalid data
										}
									}
									return 0;
								}
								
								// Store current page for next check
								localStorage.setItem(lastPageKey, currentPage);
								
								const stored = localStorage.getItem(storageKey);
								let visitData = { date: today, count: 0 };
								
								if (stored) {
									try {
										visitData = JSON.parse(stored);
										// Reset if date doesn't match today
										if (visitData.date !== today) {
											visitData = { date: today, count: 0 };
											// Also reset last page on date change
											localStorage.removeItem(lastPageKey);
										}
									} catch (e) {
										// Invalid data, reset
										visitData = { date: today, count: 0 };
										localStorage.removeItem(lastPageKey);
									}
								}
								
								// Increment visit count (new page visited)
								visitData.count += 1;
								
								// Store updated count
								localStorage.setItem(storageKey, JSON.stringify(visitData));
								
								return visitData.count;
							} catch (e) {
								// localStorage not available or error, return 0
								return 0;
							}
						}
						
						function toggleProBanner() {
							const proBannerContainer = document.getElementById('pro-banner-container');
							if (!proBannerContainer) return;

							const urlParams = new URLSearchParams(window.location.search);
							const buyParam = urlParams.get('buy');
							const hash = window.location.hash;
							
							// Manual trigger (query param or hash) takes priority
							const manualTrigger = buyParam === 'pro' || hash === '#pro-banner';
							
							let shouldShow = false;
							if (manualTrigger) {
								// Manual trigger - show immediately, don't track visit
								shouldShow = true;
							} else {
								// Auto-show logic: every 3rd visit (3, 6, 9, 12) up to 12 visits
								// Only track visits when not manually triggered
								const visitCount = trackPageVisit();
								if (visitCount > 0 && visitCount <= 12 && visitCount % 3 === 0) {
									// Check if we've already shown the banner for this count
									const lastShownKey = 'fdt_pro_banner_last_shown';
									const lastShownDateKey = 'fdt_pro_banner_last_shown_date';
									const today = new Date().toISOString().split('T')[0];
									
									// Reset if date changed
									const lastShownDate = localStorage.getItem(lastShownDateKey);
									if (!lastShownDate || lastShownDate !== today) {
										localStorage.removeItem(lastShownKey);
										localStorage.setItem(lastShownDateKey, today);
									}
									
									const lastShown = localStorage.getItem(lastShownKey);
									
									// Only show if this is a new count (not a page refresh)
									if (lastShown !== visitCount.toString()) {
										shouldShow = true;
										// Remember we showed it for this count
										localStorage.setItem(lastShownKey, visitCount.toString());
									}
								}
							}

							// Don't show if user is in pro plan
							if (shouldShow && window.getProStatusCookie()) {
								shouldShow = false;
							}

							if (shouldShow) {
								proBannerContainer.style.display = 'block';
								if (!proBannerMounted) {
									loadProBannerModule();
								}
							} else {
								proBannerContainer.style.display = 'none';
							}
						}

						document.addEventListener('DOMContentLoaded', function () {
							toggleSearchView();
							toggleProBanner();
							window.addEventListener('searchQueryChanged', toggleSearchView);
							window.addEventListener('hashchange', function() {
								toggleSearchView();
								toggleProBanner();
							});
							window.addEventListener('popstate', function() {
								toggleProBanner();
							});
							
							// Check for initial hash param for search
							if (window.location.hash.startsWith('#search')) {
								const params = new URLSearchParams(window.location.hash.substring(1)); // remove #
                                // search?q=... -> we need to parse properly.
                                // The hash is like #search?q=foo or #search?q=
                                const hash = window.location.hash;
                                const qIndex = hash.indexOf('q=');
                                if (qIndex !== -1) {
                                    const q = decodeURIComponent(hash.substring(qIndex + 2));
                                    // Set query even if empty (for empty search state)
                                    window.searchState.setQuery(q || '');
                                } else if (hash === '#search?q=') {
									// Empty search state
									window.searchState.setQuery('');
								}
							}
						});
						
						// Preload SearchPage chunk after window load, in idle time - avoids CLS/FCP impact
						window.addEventListener('load', function () {
							var schedulePreload = function () {
								loadSearchModule().then(function () {
									if (window.preloadSearchPage) {
										window.preloadSearchPage().catch(function () {});
									}
								}).catch(function () {});
							};
							if ('requestIdleCallback' in window) {
								requestIdleCallback(schedulePreload, { timeout: 3000 });
							} else {
								setTimeout(schedulePreload, 1500);
							}
						});
					</script>
					</main>

					@common.Footer()
				</div>
			</div>
		</body>
	</html>
}
