console.log("FDT: IconButtonsScript loaded via static file"), window.showToast = function (e, t = "success") { let n = document.getElementById("vanilla-toast"); n || ((n = document.createElement("div")).id = "vanilla-toast", n.className = "fixed bottom-4 right-4 px-6 py-3 rounded shadow-lg z-50 transition-opacity duration-300 opacity-0 transform translate-y-2", document.body.appendChild(n)), "error" === t ? n.className = "fixed bottom-4 right-4 px-6 py-3 rounded shadow-lg z-50 transition-opacity duration-300 text-white bg-red-600" : n.className = "fixed bottom-4 right-4 px-6 py-3 rounded shadow-lg z-50 transition-opacity duration-300 text-white bg-green-600", n.textContent = e, requestAnimationFrame(() => n.classList.remove("opacity-0", "translate-y-2")), setTimeout(() => n.classList.add("opacity-0", "translate-y-2"), 3e3) }; async function fetchSvgContent(e) { try { const t = await fetch(e); if (!t.ok) throw new Error("Fetch failed"); return await t.text() } catch (e) { return console.error(e), window.showToast("Failed to load Icon", "error"), null } } function renderSvgToCanvas(e, t) { return new Promise((n, o) => { const a = new Image; e.includes("xmlns=") || (e = e.replace("<svg", '<svg xmlns="http://www.w3.org/2000/svg"')); const i = new Blob([e], { type: "image/svg+xml;charset=utf-8" }), r = URL.createObjectURL(i); a.onload = () => { const e = document.createElement("canvas"); e.width = t, e.height = t; const o = e.getContext("2d"), i = a.width / a.height; let c, s; i > 1 ? (c = .8 * t, s = c / i) : (s = .8 * t, c = s * i); const d = (t - c) / 2, l = (t - s) / 2; o.drawImage(a, d, l, c, s), URL.revokeObjectURL(r), n(e) }, a.onerror = e => { URL.revokeObjectURL(r), o(e) }, a.src = r }) } window.downloadSvg = async function (e, t) { const n = await fetchSvgContent(e); if (n) { const e = new Blob([n], { type: "image/svg+xml" }), o = URL.createObjectURL(e), a = document.createElement("a"); a.href = o, a.download = t, document.body.appendChild(a), a.click(), document.body.removeChild(a), URL.revokeObjectURL(o) } }, window.copySvg = async function (e) { const t = await fetchSvgContent(e); t && (async function (e) { try { await navigator.clipboard.writeText(e), window.showToast("SVG copied to clipboard!") } catch (e) { window.showToast("Failed to copy", "error") } }(t)) }, window.downloadPng = async function (e, t, n) { const o = document.getElementById(n); if (o) { const n = parseInt(o.value || "512"), a = await fetchSvgContent(e); if (a) try { const e = await renderSvgToCanvas(a, n), o = e.toDataURL("image/png"), i = document.createElement("a"); i.href = o, i.download = t + "-" + n + "px.png", document.body.appendChild(i), i.click(), document.body.removeChild(i) } catch (e) { console.error(e), window.showToast("Failed to generate PNG", "error") } } else console.error("Size selector not found:", n) }, window.copyPng = async function (e) { const t = await fetchSvgContent(e); t && async function (e) { try { const t = await renderSvgToCanvas(e, 512); t.toBlob(async e => { if (e) try { const t = new ClipboardItem({ "image/png": e }); await navigator.clipboard.write([t]), window.showToast("PNG copied to clipboard!") } catch (e) { console.error(e), window.showToast("Clipboard key check failed (HTTPS required?)", "error") } else window.showToast("PNG blob creation failed", "error") }) } catch (e) { console.error(e), window.showToast("Failed to process PNG", "error") } }(t) };
