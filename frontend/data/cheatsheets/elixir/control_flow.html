<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elixir Control Flow - Understand and Master Conditional Logic</title>
    <meta name="description" content="Master Elixir control flow with comprehensive guides on if/unless, case, cond, try/catch, and with statements. Learn to write efficient and readable Elixir code.">
    <meta name="keywords" content="Elixir control flow, Elixir if, Elixir unless, Elixir case, Elixir cond, Elixir try catch, Elixir with, Elixir conditional logic, Elixir programming, Elixir tutorials">
    <link rel="canonical" href="https://example.com/elixir/control_flow.html">
    <meta name="robots" content="index, follow">
    <meta property="og:title" content="Elixir Control Flow - Understand and Master Conditional Logic">
    <meta property="og:description" content="Master Elixir control flow with comprehensive guides on if/unless, case, cond, try/catch, and with statements. Learn to write efficient and readable Elixir code.">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://example.com/elixir/control_flow.html">
    <meta property="og:image" content="https://example.com/images/elixir-control-flow-og.png">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Elixir Control Flow - Understand and Master Conditional Logic">
    <meta name="twitter:description" content="Master Elixir control flow with comprehensive guides on if/unless, case, cond, try/catch, and with statements. Learn to write efficient and readable Elixir code.">
    <meta name="twitter:image" content="https://example.com/images/elixir-control-flow-twitter.png">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f8f9fa;
        }
        .container {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        .header {
            background: #2c3e50;
            color: white;
            padding: 20px;
            border-bottom: 1px solid #34495e;
        }
        .header h1 {
            margin: 0;
            font-size: 1.5em;
        }
        .content {
            padding: 20px;
        }
        pre {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 16px;
            overflow-x: auto;
            margin: 0;
        }
        code {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 14px;
        }
        .markdown-content {
            line-height: 1.7;
        }
        .markdown-content h1, .markdown-content h2, .markdown-content h3 {
            color: #2c3e50;
            border-bottom: 1px solid #e9ecef;
            padding-bottom: 8px;
        }
        .markdown-content pre {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 16px;
            overflow-x: auto;
        }
        .markdown-content code {
            background: #f1f3f4;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 0.9em;
        }
        .markdown-content pre code {
            background: none;
            padding: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Elixir Control Flow Structures</h1>
        </div>
        <div class="content">
            <div class="markdown-content">
                <h2>Understanding Elixir Control Flow</h2>
                <p>Control flow structures are fundamental to programming, allowing developers to dictate the order in which code is executed. Elixir, a dynamic, functional language designed for building scalable and maintainable applications, offers several powerful constructs for managing control flow. Mastering these is crucial for writing efficient and readable Elixir code.</p>

                <h2>Elixir's Conditional Logic: if/unless</h2>
                <p>The <code>if</code> and <code>unless</code> constructs in Elixir provide basic conditional execution. <code>if</code> executes a block of code if a given expression evaluates to a truthy value (anything other than <code>false</code> or <code>nil</code>). Conversely, <code>unless</code> executes a block if the expression evaluates to a falsy value.</p>
                <pre class="codehilite"><code class="language-elixir">if :something_truthy do
  IO.puts &quot;something truthy happened&quot;
else
  IO.puts &quot;false or nil happened&quot;
end

unless :something_truthy do
  IO.puts &quot;nil or false happened&quot;
else
 IO.puts &quot;something truthy happened&quot;
end
</code></pre>

                <h2>Pattern Matching with case</h2>
                <p>The <code>case</code> statement is a cornerstone of Elixir's expressive power, enabling sophisticated pattern matching. It allows you to match a value against a series of patterns and execute the code associated with the first matching pattern. If no patterns match, a <code>MatchError</code> is raised, which can be handled using a wildcard pattern (<code>_</code>).</p>
                <pre class="codehilite"><code class="language-elixir">case 137 do
  &quot;137&quot; -&gt; IO.puts &quot;I require 137 the number.&quot;
  137   -&gt; IO.puts &quot;Ahh much better.&quot;
  138   -&gt;
    IO.puts &quot;Blocks can start on the next line as well.&quot;
end
</code></pre>

                <p>The wildcard pattern <code>_</code> is essential for ensuring that all possible outcomes are handled, preventing unexpected errors:</p>
                <pre class="codehilite"><code class="language-elixir">case {:ok, &quot;everything went to plan&quot;} do
  {:ok, message}    -&gt; IO.puts message
  {:error, message} -&gt; IO.puts &quot;ERROR!: #{message}&quot;
# ⇣catchall, otherwise you'll get an error if nothing matches
  _                 -&gt; IO.puts &quot;I match everything else!&quot;
end
</code></pre>

                <p><code>case</code> statements can also incorporate guards for more refined pattern matching:</p>
                <pre class="codehilite"><code class="language-elixir">case 1_349 do
  n when is_integer n -&gt; IO.puts &quot;you gave me an integer&quot;
  n when is_binary n  -&gt; IO.puts &quot;you gave me a binary&quot;
  _                   -&gt; IO.puts &quot;you gave me neither an integer nor binary&quot;
end
</code></pre>

                <h2>Sequential Conditionals with cond</h2>
                <p>The <code>cond</code> construct is ideal for situations where you have multiple conditions to check sequentially, similar to an <code>if-elseif-else</code> chain in other languages. It evaluates conditions in order and executes the block associated with the first condition that evaluates to true. If no conditions are met, it raises a <code>MatchError</code>.</p>
                <pre class="codehilite"><code class="language-elixir">cond do
  false -&gt; IO.puts &quot;I will never run&quot;
  true  -&gt; IO.puts &quot;I will always run&quot;
  1235  -&gt; IO.puts &quot;I would run if that dang true wasn't on top of me.&quot;
end
</code></pre>

                <p>Using <code>true</code> as the last condition in a <code>cond</code> statement provides a convenient way to implement a default or catch-all behavior:</p>
                <pre class="codehilite"><code class="language-elixir">guess = 12
cond do
  guess == 10 -&gt; IO.puts &quot;You guessed 10!&quot;
  guess == 46 -&gt; IO.puts &quot;You guessed 46!&quot;
  true        -&gt; 
    IO.puts &quot;I give up.&quot;
end
</code></pre>

                <h2>Exception Handling with try/catch/after</h2>
                <p>Elixir's <code>try</code>, <code>catch</code>, and <code>after</code> blocks offer a robust mechanism for handling exceptions and side effects. You can <code>throw</code> any data type within a <code>try</code> block, which can then be caught and pattern-matched in the <code>catch</code> block. The <code>after</code> block guarantees execution regardless of whether a throw occurred.</p>
                <pre class="codehilite"><code class="language-elixir">try do
  IO.puts &quot;Inside a try block&quot;
  throw [:hey, &quot;Reggie&quot;]
  IO.puts &quot;if there is a throw before me, I'll never run.&quot;
catch
  x when is_number(x) -&gt; IO.puts &quot;!!A number was thrown.&quot;
  [:hey, name] -&gt; IO.puts &quot;!!Hey was thrown to #{name}.&quot;
  _ -&gt; IO.puts &quot;Something else was thrown.&quot;
after
  IO.puts &quot;I run regardless of a throw.&quot;
end
</code></pre>

                <h2>Chaining Operations with with</h2>
                <p>The <code>with</code> statement is a powerful construct for chaining multiple operations that are expected to succeed. It executes a series of pattern matches sequentially. If all matches succeed, the <code>do</code> block is executed. If any match fails, the non-matching value is returned, and the <code>with</code> block is exited. An optional <code>else</code> block can be provided to handle failures gracefully, functioning similarly to a <code>case</code> statement for the failed match.</p>
                <pre class="codehilite"><code class="language-elixir">  nums = [8,13,44]
#                 ┌left arrow           ┌comma
#     match left  |     match right     |
#      ┌───┴────┐ ⇣  ┌───────┴─────────┐⇣
  with {:ok, num} &lt;- Enum.fetch(nums, 2),
       &quot;44&quot;       &lt;- Integer.to_string(num),
  do: &quot;it was 44&quot;

# Paterns can take guards
with a when is_nil(a) &lt;- nil,
do: &quot;Accepts guards&quot;
else
  _ -&gt; &quot;Does not accept guards&quot;

# From the docs
opts = %{width: 10, height: 15}
with {:ok, width} &lt;- Map.fetch(opts, :width),
     {:ok, height} &lt;- Map.fetch(opts, :height),
do: {:ok, width * height}
# returns {:ok, 150}

opts = %{width: 10}
with {:ok, width} &lt;- Map.fetch(opts, :width),
     {:ok, height} &lt;- Map.fetch(opts, :height),
do: {:ok, width * height}
# returns :error as that's what Map.fetch returns when a key is not present.
# ┌─ Or you can catch the error in an else block
else
  :error -&gt; &quot;A key wasn't found!&quot;
</code></pre>

                <p>For more information on Elixir's control flow and functional programming paradigms, refer to the official <a href="https://elixir-lang.org/docs/v1.15/elixir/Kernel.html#section-control-flow" target="_blank" rel="noopener noreferrer">Elixir documentation</a> and resources like <a href="https://exercism.org/tracks/elixir" target="_blank" rel="noopener noreferrer">Exercism Elixir track</a> for practice exercises.</p>
            </div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>
        hljs.highlightAll();
    </script>
</body>
</html>