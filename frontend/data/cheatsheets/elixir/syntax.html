<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elixir Syntax Guide - Understand Variables, Operators, and Pattern Matching</title>
    <meta name="description" content="Master Elixir syntax with this comprehensive guide. Learn about variable declaration, operators, pattern matching, comments, and reserved words for efficient Elixir programming.">
    <meta name="keywords" content="Elixir syntax, Elixir variables, Elixir operators, Elixir pattern matching, Elixir comments, Elixir reserved words, Elixir programming, Elixir guide, Elixir tutorial">
    <link rel="canonical" href="https://yourdomain.com/elixir/syntax.html">
    <meta name="robots" content="index, follow">
    <meta property="og:title" content="Elixir Syntax Guide - Understand Variables, Operators, and Pattern Matching">
    <meta property="og:description" content="Master Elixir syntax with this comprehensive guide. Learn about variable declaration, operators, pattern matching, comments, and reserved words for efficient Elixir programming.">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://yourdomain.com/elixir/syntax.html">
    <meta property="og:image" content="https://yourdomain.com/images/elixir-syntax-og.jpg">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Elixir Syntax Guide - Understand Variables, Operators, and Pattern Matching">
    <meta name="twitter:description" content="Master Elixir syntax with this comprehensive guide. Learn about variable declaration, operators, pattern matching, comments, and reserved words for efficient Elixir programming.">
    <meta name="twitter:image" content="https://yourdomain.com/images/elixir-syntax-twitter.jpg">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f8f9fa;
        }
        .container {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        .header {
            background: #2c3e50;
            color: white;
            padding: 20px;
            border-bottom: 1px solid #34495e;
        }
        .header h1 {
            margin: 0;
            font-size: 1.5em;
        }
        .content {
            padding: 20px;
        }
        pre {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 16px;
            overflow-x: auto;
            margin: 0;
        }
        code {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 14px;
        }
        .markdown-content {
            line-height: 1.7;
        }
        .markdown-content h1, .markdown-content h2, .markdown-content h3 {
            color: #2c3e50;
            border-bottom: 1px solid #e9ecef;
            padding-bottom: 8px;
        }
        .markdown-content pre {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 16px;
            overflow-x: auto;
        }
        .markdown-content code {
            background: #f1f3f4;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 0.9em;
        }
        .markdown-content pre code {
            background: none;
            padding: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Elixir Syntax Fundamentals</h1>
        </div>
        <div class="content">
            <div class="markdown-content">
                <h2>Understanding Elixir Syntax</h2>
                <p>This guide covers the fundamental syntax elements of the Elixir programming language, essential for any developer looking to build robust and scalable applications.</p>

                <h3>Variables in Elixir</h3>
                <p>Variables in Elixir are declared and initialized upon their first use. They follow a specific naming convention: starting with a lowercase letter, followed by zero or more letters, numbers, or underscores, and optionally ending with an exclamation mark or a question mark.</p>
                <p>Elixir variables are immutable by default, but they can be reassigned. They can hold any data structure.</p>
                <pre><code class="language-elixir">&gt; something = :anything
&gt; something = ["a", "list", "of", "strings"]
&gt; _yeeHaw1234! = %{:a => :b}
</code></pre>

                <h3>Operators in Elixir</h3>
                <p>Elixir supports a variety of operators for different purposes:</p>
                <h4>Standard Infix Operators</h4>
                <ul>
                    <li>Equality: <code>==</code>, <code>!=</code></li>
                    <li>Strict Equality: <code>===</code>, <code>!==</code> (do not coerce Floats to Integers, e.g., <code>1 === 1.0 #false</code>)</li>
                    <li>Comparison: <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code></li>
                    <li>Logic (short-circuiting): <code>&amp;&amp;</code> and <code>||</code></li>
                    <li>Boolean-only Logic (short-circuiting): <code>and</code> and <code>or</code> (only the left side must be boolean)</li>
                    <li>Arithmetic: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code></li>
                </ul>
                <h4>Standard Prefix Operators</h4>
                <ul>
                    <li>Negation (any type): <code>!</code> (e.g., <code>!1 == false</code>)</li>
                    <li>Negation (boolean only): <code>not</code> (e.g., <code>not is_atom(5) == true</code>)</li>
                </ul>
                <h4>Match Operator <code>=</code></h4>
                <p>The <code>=</code> operator performs a <a href="#pattern-matching">Pattern Match</a>. It attempts to match the structure on the left with the data structure on the right.</p>
                <h4>Pin Operator <code>^</code></h4>
                <p>The <code>^</code> operator is used to pin the value of a variable on the left side of a <a href="#pattern-matching">Pattern Match</a>, ensuring its value is not changed during the match.</p>
                <pre><code class="language-elixir">a = "thirty hams"
{b, ^a} = {:i_need, "thirty hams"}            # `b` is set to `:i_need`
{^a, {^a}} = {"thirty hams", {"thirty hams"}} # nothing is set, but the match succeeds
</code></pre>

                <h4>Pipe Operator <code>|&gt;</code></h4>
                <p>The <code>|&gt;</code> operator takes the result of a statement on its left and passes it as the first argument to the function on its right. The statement on the left can span multiple lines.</p>
                <pre><code class="language-elixir">&gt; [1,2,3] |&gt; hd |&gt; Integer.to_string |&gt; IO.inspect # "1"
# ⇣ doesn't work in iex
hd([1,2,3])
|&gt; Integer.to_string
|&gt; IO.inspect  # "1"
</code></pre>

                <h4>String Match Operator <code>=~</code></h4>
                <p>The <code>=~</code> operator checks if a string on the left contains a substring or matches a regular expression on the right.</p>
                <pre><code class="language-elixir">&gt; "abcd" =~ ~r/c(d)/ # true
&gt; "abcd" =~ ~r/e/    # false
&gt; "abcd" =~ "bc"     # true
&gt; "abcd" =~ "ad"     # false
</code></pre>

                <h4>Codepoint Operator <code>?</code></h4>
                <p>The <code>?</code> operator returns the UTF-8 codepoint of the character immediately to its right. It accepts single characters and <a href="#escape-sequences">Escape Sequences</a>.</p>
                <pre><code class="language-elixir">&gt; ?a   # 97
&gt; ?♫   # 9835
&gt; ?\s  # 32
&gt; ??   # 63
&gt; [?♀, ?!] == '♀!'  # true
</code></pre>

                <h4>Capture Operator <code>&amp;</code></h4>
                <p>TODO: Add explanation for the capture operator.</p>

                <h4>Ternary Operator (Simulated)</h4>
                <p>Elixir does not have a built-in ternary operator. The same functionality can be achieved using the <code>if</code> macro.</p>
                <pre><code class="language-elixir">&gt; a = if true, do: "True!", else: "False!"
&gt; a == "True!"  # true
</code></pre>

                <h4><code>in</code> Operator</h4>
                <p>The <code>in</code> operator checks if an enumerable on the right contains the data structure on the left. The right-hand side must implement the Enumerable Protocol.</p>
                <pre><code class="language-elixir">&gt; :b in [:a, :b, :c] # true
&gt; [:c] in [1,3,[:c]] # true
&gt; :ok in {:ok} # ERROR: protocol Enumerable not implemented for {:ok}
</code></pre>

                <h3>Comments</h3>
                <p>Comments in Elixir start with a hash symbol (<code>#</code>) and continue to the end of the line.</p>

                <h3>Semicolons</h3>
                <p>Semicolons can be used to terminate statements but are rarely used in practice. Their primary use is to place multiple statements on the same line (e.g., <code>a = 1; b = 2</code>), which is considered poor style. Prefer placing statements on separate lines.</p>

                <h3><code>do</code> and <code>end</code> Blocks</h3>
                <p>Blocks of code passed to macros typically start with <code>do</code> and end with <code>end</code>.</p>
                <pre><code class="language-elixir">if true do
  "True!"
end

if true do "True!" end

# inside a module
def somefunc() do
  IO.puts "multi line"
end

if true do
  "True!"
else
  "False!"
end
</code></pre>
                <p>You can use syntactic sugar for single-line blocks:</p>
                <pre><code class="language-elixir">#      ⇣   ⇣         ⇣ no end keyword
if true, do: "True!"
#      ⇣   ⇣       ⇣     ⇣          ⇣ no end keyword
if true, do: "True", else: "False!"
# inside a module
#             ⇣   ⇣                              ⇣ no end keyword
def someFunc(), do: IO.puts "look ma, one line!"
</code></pre>
                <p>This is syntactic sugar for:</p>
                <pre><code class="language-elixir">if(true, [{:do, "True!"}, {:else, "False!"}])
def(someFunc(), [{:do, IO.puts "look ma, one line!"}])
</code></pre>

                <h3>Pattern Matching</h3>
                <p>Pattern matching is a core feature in Elixir, allowing you to destructure data and bind variables based on the structure of the data.</p>
                <pre><code class="language-elixir">#     ┌Left       ┌Right
# ┌───┴───┐   ┌───┴──────┐
  {:one, x} = {:one, :two}
#        ┌Right
#    ┌───┴──────┐  
case {:one, :two} do
#     ┌Left
# ┌───┴───┐
  {:one, x} -> IO.puts x
# ┌Left
  _         -> IO.puts "no other match"
end
</code></pre>
                <p>The <strong>right</strong> side is a <strong>data structure</strong>. The <strong>left</strong> side attempts to <strong>match</strong> itself to the <strong>data structure</strong> on the right and <strong>bind</strong> any <strong>variables</strong> to <strong>substructures</strong>.</p>
                <p>A simple match with a lone variable on the left will match anything:</p>
                <pre><code class="language-elixir"># in these examples `x` will be set to whatever is on the right
x = 1
x = [1,2,3,4]
x = {:any, "structure", %{:whatso => :ever}}
</code></pre>
                <p>You can place variables inside a structure to capture substructures:</p>
                <pre><code class="language-elixir"># `x` gets set to only the `substructure` it matches
{:one, x} = {:one, :two} # `x` is set to `:two` 
[1,2,n,4] = [1,2,3,4]    # `n` is set to `3`
[:one, p] = [:one, {:apple, :orange}] # `p` is set to `{:apple, :orange}`
</code></pre>
                <p>The special <code>_</code> variable matches anything but discards the value, indicating you don't care about it.</p>
                <pre><code class="language-elixir"># in all of these examples, `x` gets set to `:two`
{_, x} = {:one, :two}
{_, x} = {:three, :two}
[_,_,x,_] = [1,{2},:two,3]
</code></pre>
                <p>If you place a variable on the right, its value is used in the match:</p>
                <pre><code class="language-elixir">#                          ┌Same as writing {"twenty hams"}
a = {"twenty hams"}        ⇣
{:i_have, {b}} = {:i_have, a} # `b` is set to "twenty hams"
</code></pre>
                <p>The <code>^</code> operator allows you to use the value of a variable in the left side of a pattern match.</p>
                <pre><code class="language-elixir">a = "thirty hams"
{b, ^a} = {:i_need, "thirty hams"}            # `b` is set to `:i_need`
{^a, {^a}} = {"thirty hams", {"thirty hams"}} # nothing is set, but the match succeeds
</code></pre>

                <h4>Maps Pattern Matching</h4>
                <p>Individual keys can be matched in Maps:</p>
                <pre><code class="language-elixir">nola = %{ name: "New Orleans", founded: 1718 }
%{name: city_name} = nola # city_name now equals "New Orleans"
%{name: _, founded: city_founded} = nola # Map must have both a name and a founded key
</code></pre>
                <p>You can use the pin operator (<code>^</code>) to match on variables:</p>
                <pre><code class="language-elixir">field = "founded"
%{^field: city_founded} = nola # city_founded now equals 1718
</code></pre>

                <h4>Binaries Pattern Matching</h4>
                <p>Binaries can be deconstructed using size, unit, and type specifiers.</p>
                <pre><code class="language-elixir">&lt;&lt; size::8, rest::binary&gt;&gt; = &lt;&lt;3,0,25,1,1,2,1,6,4,3&gt;&gt;
&lt;&lt; data::size(size)-unit(16)-binary, rest::binary&gt;&gt; = rest
# TODO: Add more examples for binary matching.
</code></pre>

                <h4>Ranges Pattern Matching</h4>
                <p>Ranges can be pattern matched if both their values are integers.</p>
                <pre><code class="language-elixir">min..max = 20..5000
min == 20    # true
max == 5000  # true
min..max == 1..10.0 # This would result in an Argument Error
</code></pre>

                <h3>Reserved Words</h3>
                <p>The following words are reserved in Elixir and cannot be used as identifiers for variables, modules, or function names:</p>
                <p><code>nil</code>, <code>true</code>, <code>false</code>, <code>__MODULE__</code>,<code>__FILE__</code>,<code>__DIR__</code>,<code>__ENV__</code>,<code>__CALLER__</code></p>

                <p>For more in-depth information on Elixir's syntax and features, refer to the official <a href="https://elixir-lang.org/docs/stable/elixir/Kernel.html" target="_blank" rel="noopener noreferrer">Elixir documentation</a>.</p>
            </div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>
        hljs.highlightAll();
    </script>
</body>
</html>
