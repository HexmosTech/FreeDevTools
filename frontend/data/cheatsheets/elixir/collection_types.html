<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elixir Collection Types Explained | Hexmos DevTools</title>
    <meta name="description" content="Explore Elixir's collection types: Lists, CharLists, Tuples, Keyword Lists, Maps, Structs, Ranges, and Streams. Understand their syntax, usage, and performance characteristics.">
    <meta name="keywords" content="Elixir, collection types, list, charlist, tuple, keyword list, map, struct, range, stream, Elixir programming, data structures, programming tutorial">
    <link rel="canonical" href="https://www.hexmos.com/elixir/collection_types.html">
    <meta name="robots" content="index, follow">
    <meta property="og:title" content="Elixir Collection Types Explained | Hexmos DevTools">
    <meta property="og:description" content="Explore Elixir's collection types: Lists, CharLists, Tuples, Keyword Lists, Maps, Structs, Ranges, and Streams. Understand their syntax, usage, and performance characteristics.">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://www.hexmos.com/elixir/collection_types.html">
    <meta property="og:image" content="https://www.hexmos.com/images/elixir-collection-types-og.png">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Elixir Collection Types Explained | Hexmos DevTools">
    <meta name="twitter:description" content="Explore Elixir's collection types: Lists, CharLists, Tuples, Keyword Lists, Maps, Structs, Ranges, and Streams. Understand their syntax, usage, and performance characteristics.">
    <meta name="twitter:image" content="https://www.hexmos.com/images/elixir-collection-types-twitter.png">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f8f9fa;
        }
        .container {
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        .header {
            background: #2c3e50;
            color: white;
            padding: 20px;
            border-bottom: 1px solid #34495e;
        }
        .header h1 {
            margin: 0;
            font-size: 1.5em;
        }
        .content {
            padding: 20px;
        }
        pre {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 16px;
            overflow-x: auto;
            margin: 0;
        }
        code {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 14px;
        }
        .markdown-content {
            line-height: 1.7;
        }
        .markdown-content h1, .markdown-content h2, .markdown-content h3 {
            color: #2c3e50;
            border-bottom: 1px solid #e9ecef;
            padding-bottom: 8px;
        }
        .markdown-content pre {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 16px;
            overflow-x: auto;
        }
        .markdown-content code {
            background: #f1f3f4;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 0.9em;
        }
        .markdown-content pre code {
            background: none;
            padding: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Elixir Collection Types</h1>
        </div>
        <div class="content">
            <div class="markdown-content">
                <h2>Understanding Elixir Collection Types</h2>
                <p>Elixir provides a rich set of collection types to manage data efficiently. Each type has its own strengths and is suited for different use cases. This guide explores the fundamental collection types in Elixir, detailing their syntax, common operations, and performance characteristics.</p>

                <h3>List</h3>
                <p>Lists are fundamental in Elixir, implemented as singly linked lists. They can hold elements of any type and are enclosed in square brackets <code>[]</code> with elements separated by commas. Lists are efficient for sequential access, especially when adding or removing elements from the head. For operations involving the tail, it's often more performant to add to the head and then reverse the list. Lists implement the <code>Enumerable</code> protocol, allowing for extensive manipulation via the <code>Enum</code> module.</p>
                <p>Key operations include concatenation with <code>++</code>, subtraction with <code>--</code>, and construction using the cons operator <code>|</code>. Functions like <code>hd</code> (head) and <code>tl</code> (tail) provide access to the first element and the rest of the list, respectively.</p>
                <pre class="codehilite"><code class="language-elixir">&gt; [1, 2, 3.4, &quot;a&quot;, &quot;b&quot;, :c, [:d]]
&gt; [ 1 | [2 | [3]]] == [1, 2, 3]   # true
&gt; [1, 2, 3.4] ++ [&quot;a&quot;, &quot;b&quot;, :c]   # [1, 2, 3.4, &quot;a&quot;, &quot;b&quot;, :c]
&gt; [1, 2, 3.4, &quot;a&quot;, &quot;b&quot;, :c, [:d]] -- [2, &quot;a&quot;, &quot;c&quot;]  # [1, 3.4, &quot;b&quot;, :c, [:d]]
&gt; hd [1, 2, 3]               # 1
&gt; tl [1, 2, 3]               # [2, 3]
&gt; length [:a, :b, :c, :d]    # 4
&gt; Enum.reverse [:a, :b, :c]  # [:c, :b, :a]
&gt; Enum.member? [:a, :b], :b  # true
&gt; Enum.join [:a, :b], &quot;_&quot;    # &quot;a_b&quot;
&gt; Enum.at [:a, :b, :c], 1    # :b
</code></pre>

                <h3>Charlist</h3>
                <p>A Charlist is essentially a List of UTF-8 codepoints. Syntactically, they are distinguished by single quotes <code>'</code>. Despite the different syntax, CharLists are identical to Lists in their underlying structure and behavior. They support multi-line definitions and utilize the same <a href="#escape-sequences">Escape Sequences</a> as Strings.</p>
                <pre class="codehilite"><code class="language-elixir">&gt; 'char list'
&gt; [108, 105, 115, 116] == 'list'  # true
&gt; 'turbo' ++ 'pogo'               # 'turbopogo'
&gt; 'char list' -- 'a l'            # 'christ'
&gt; hd 'such list' == ?s            # true
&gt; String.to_char_list &quot;tacosalad&quot; # 'tacosalad'
&gt; List.to_string 'frijoles'       # &quot;frijoles&quot;
&gt; [?Y, ?e, ?a, ?h] == 'Yeah'      # true
</code></pre>

                <h3>Tuple</h3>
                <p>Tuples are fixed-size collections that can store elements of any type. Their elements are stored contiguously in memory, making them efficient for index-based access. Tuples are defined using curly braces <code>{}</code> with comma-separated elements. While fast for direct element retrieval by index using <code>elem/2</code>, they are less efficient for operations involving a large number of elements compared to Lists.</p>
                <pre class="codehilite"><code class="language-elixir">&gt; { :a, 1, {:b}, [2]}
&gt; put_elem({:a}, 0, :b) # {:b}
&gt; elem({:a, :b, :c}, 1) # b
&gt; Tuple.delete_at({:a, :b, :c}, 1) # {:a, :c}
&gt; Tuple.insert_at({:a, :c}, 1, :b) # {:a, :b, :c}
&gt; Tuple.to_list({:a, :b, :c})      # [:a, :b, :c]
</code></pre>

                <h3>Keyword List</h3>
                <p>A Keyword List is a specialized List containing 2-element Tuples, where the first element of each Tuple is an Atom (the keyword or key). They offer a concise syntax, omitting the Tuple brackets and placing the key's colon on the right (e.g., <code>[key: value]</code>). Like Lists, Keyword Lists are ordered, can contain duplicate keys, and are efficient for head-based access. They support concatenation with <code>++</code> and subtraction with <code>--</code>. Elements can be accessed using <code>[:key]</code> notation, returning the first matching element. Equality comparison requires elements to be identical and in the same order.</p>
                <pre class="codehilite"><code class="language-elixir"># Full Syntax
&gt; [{:a, &quot;one&quot;}, {:b, 2}]
# Concice Syntax
&gt; [a: &quot;one&quot;, b: 2]
&gt; [a: 1] ++ [a: 2, b: 3] == [a: 1, a: 2, b: 3] # true
&gt; [a: 1, b: 2] == [b: 2, a: 1]         # false! elements are in different order
&gt; [a: 1, a: 2][:a] == 1                # true
&gt; Keyword.keys([a: 1, b: 2])           # [:a, :b]
&gt; Keyword.get_values([a: 1, a: 2], :a) # [1, 2]
&gt; Keyword.keyword?([{:a,1}, {:b,2}])   # true
&gt; Keyword.keyword?([{:a,1}, {&quot;b&quot;,2}])  # false! &quot;b&quot; is not an Atom
&gt; Keyword.delete([a: 1, b: 2], :a)     # [b: 2]
</code></pre>

                <h3>Map</h3>
                <p>Maps are key-value stores where keys and values can be of any type. Unlike Keyword Lists, Maps do not allow duplicate keys and are unordered. They are defined using <code>%{ }</code> with key-value pairs separated by <code>=></code>. If all keys are Atoms, a shorthand syntax is available where the <code>=></code> is omitted and the Atom's colon is on the right (e.g., <code>%{atom: value}</code>). Values are accessed using <code>[key]</code> notation, and if the key is an Atom, dot notation (<code>.key</code>) can also be used. Maps are highly efficient for key-based lookups.</p>
                <pre class="codehilite"><code class="language-elixir">&gt; %{:a =&gt; 1, 1 =&gt; [&quot;list&quot;], [2,3,4] =&gt; {&quot;a&quot;, &quot;b&quot;}}
&gt; %{:a =&gt; 1, :b =&gt; 2} == %{a: 1, b: 2}              # true
&gt; %{a: &quot;one&quot;, b: &quot;two&quot;, a: 1} == %{a: 1, b: &quot;two&quot;}  # true
&gt; %{a: &quot;one&quot;, b: &quot;two&quot;} == %{b: &quot;two&quot;, a: &quot;one&quot;}    # true
&gt; %{a: &quot;one&quot;, b: &quot;two&quot;}[:b]                         # &quot;two&quot;
&gt; %{a: &quot;one&quot;, b: &quot;two&quot;}.b                           # &quot;two&quot;
&gt; %{a: &quot;one&quot;, a: 1} == %{a: 1}                      # true
&gt; %{:a =&gt; &quot;one&quot;, &quot;a&quot; =&gt; &quot;two&quot;}.&quot;a&quot; == &quot;two&quot;         # false! watchout
&gt; Map.keys( %{a: 1, b: 2} ) == [:a, :b]             # true
&gt; %{ %{a: 1, b: 2, c: 3} | :a =&gt; 4, b: 5 }          # %{a: 4, b: 5, c: 3}
&gt; Map.merge( %{a: 1, b: 2}, %{a: 4, c: 3} )         # %{a: 4, b: 2, c: 3}
&gt; Map.put( %{a: 1}, :b, 2 ) == %{a: 1, b: 2}        # true
&gt; Kernel.get_in # TODO
&gt; Kernel.put_in # TODO
</code></pre>

                <h3>Struct</h3>
                <p>Structs are essentially Maps with predefined keys, default values, and Atom keys. They are defined within a Module and take the Module's name. Structs do not implement the <code>Access</code> or <code>Enumerable</code> protocols, behaving like bare Maps. A special field, <code>__struct__</code>, holds the name of the struct.</p>
                <pre class="codehilite"><code class="language-elixir">defmodule City do
  defstruct name: &quot;New Orleans&quot;, founded: 1718
end
nola = %City{}
chi =  %City{name: &quot;Chicago&quot;, founded: 1833}
nola.name   # &quot;New Orleans&quot;
chi.founded # 1833
nola.__struct__ # City
</code></pre>

                <h3>Range</h3>
                <p>Ranges represent a sequence of numbers or other ordered elements, defined by a first and last element. They are a type of Struct with <code>first</code> and <code>last</code> fields. Ranges can be created using the special <code>..</code> syntax or by explicitly constructing a <code>Range</code> struct. They are enumerable and can be iterated over using functions from the <code>Enum</code> module.</p>
                <pre class="codehilite"><code class="language-elixir">&gt; a = 5..10
&gt; b = Range.new(5, 10)
&gt; c = %Range{first: 5, last: 10}
&gt; Range.range?(c)   # true
&gt; Enum.each(5..10, fn(n) -&gt; n*n end) # prints all the squares of 5..10
&gt; Map.keys(5..10)   # [:__struct__, :first, :last]
&gt; (5..10).first     # 5
</code></pre>

                <h3>Streams</h3>
                <p>Streams are lazy enumerables, meaning their elements are not computed until explicitly requested by an <code>Enum</code> module function. They are created using functions within the <code>Stream</code> module. This lazy evaluation is particularly useful for handling potentially infinite sequences or large datasets, as it avoids unnecessary computation and memory usage.</p>
                <p>The <code>Stream.unfold/2</code> function is a powerful tool for creating custom streams, allowing for arbitrary stream generation based on an initial state and a function that produces the next element and the next state.</p>
                <pre class="codehilite"><code class="language-elixir">&gt; a = Stream.cycle 'abc'
#Function&lt;47.29647706/2 in Stream.unfold/2&gt; # Infinate Stream created
&gt; Enum.take a, 10                           # Enum.take computes the 10 elements
'abcabcabca'
</code></pre>

                <p>With <a href="http://elixir-lang.org/docs/stable/elixir/Stream.html#unfold/2">Stream.unfold/2</a> you can create an arbitrary stream.</p>
                <pre class="codehilite"><code class="language-elixir">&gt; s = Stream.unfold( 5, 
  fn 0 -&gt; nil            # returning nil halts the stream
     n -&gt; {n, n-1}       # return format {next-val, rest}
  end)
&gt; Enum.to_list(s)
[5, 4, 3, 2, 1]
</code></pre>
            </div>
        </div>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>
        hljs.highlightAll();
    </script>
</body>
</html>